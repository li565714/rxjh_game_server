package i3k.gs;

import i3k.DBMailBox;
import i3k.DBMarriageShare;
import i3k.DBMaster;
import i3k.DBRole;
import i3k.DBRoleShare;
import i3k.SBean;
import i3k.SBean.DummyGoods;
//import i3k.SBean.FightPet;
import i3k.TLog;
import i3k.gmap.PropPet;
import i3k.gmap.PropRole;
import i3k.gs.CellItem.FusionableItem;
import i3k.gs.GameConf.FlashSaleConfig;
import i3k.gs.MailBox.SysMailType;
import i3k.gs.Role.PetSpiritInfo.SpiritCache;
import i3k.gs.TLogger.GameItemRecords;
import i3k.gtool.KeyGen;
import i3k.util.GVector3;
import i3k.util.GameRandom;
import i3k.util.GameTime;






import java.io.UnsupportedEncodingException;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Map;
import java.util.Optional;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.HashMap;
import java.util.Set;
import java.util.HashSet;
import java.util.TreeSet;
import java.util.Map.Entry;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.regex.Matcher;
import java.util.stream.Collectors;






import ket.kdb.Table;
import ket.kdb.Transaction;
import ket.util.MD5Digester;
import ket.util.Stream;

public class Role implements Comparable<Role>
{
	static final int MAX_STANDBY_TIME = 10 * 60; // s
	static final int MAX_DISCONNECT_TIME = 15; // s
	static final int SAVE_ROLE_INTERVAL_MIN = 5 * 60; // s
	static final int SAVE_ROLE_INTERVAL_RAND = 5 * 60; // s

	public static final int ROLE_RAND_INTERVAL_MAX = 60;
	public static final int ROLE_RAND_QUARTER_MAX = 15 * 60;
	
	static final int ROLE_NEW = 0;
	static final int ROLE_LOAD_FROM_DB = 1;
	static final int ROLE_LOAD_FROM_MEMORY = 2;

	static final int ROLE_STATE_ONLINE = 0;
	static final int ROLE_STATE_LEAVE = 2;
	static final int ROLE_STATE_STANDBY = 3;
	static final int ROLE_STATE_EXIT = 4;

//	static final Role NULL_ROLE = new Role(0, null, 0);

	public Role(int id, GameServer gs, int sid)
	{
		this.id = id;
		this.gs = gs;
		this.netsid = 0;
		this.loginnetsid = sid;
		this.loginInfo = CreateDefaultUserInfo();
		this.randTick = GameRandom.getRandInt(0, ROLE_RAND_INTERVAL_MAX);
		this.randQuarterTick = GameRandom.getRandInt(0, ROLE_RAND_QUARTER_MAX);
		this.lastSaveTime = GameTime.getTime() - GameRandom.getRandom().nextInt(SAVE_ROLE_INTERVAL_RAND);
	}
	
	private SBean.UserLoginInfo CreateDefaultUserInfo()
	{
		SBean.UserLoginInfo info = new SBean.UserLoginInfo();
		info.system = new SBean.UserSysteminfo();
		info.system.loginIP = "127.0.0.1";
		info.system.deviceID = "IMM76D";
		info.system.macAddr = "B8:97:5A:5F:81:09";
		info.system.systemSoftware = "4.0.4";
		info.system.systemHardware = "MX040";
		info.system.cpuHardware = "armeabi-v7a";
		info.system.density = 2.0f;
		return info;
	}

	public int compareTo(Role other)
	{
		return this.id - other.id;
	}

	public String getUsername()
	{
		return GameData.getUserName(this.register.id);
	}

	public String getChannelOpenId()
	{
		return GameData.getChannelOpenId(this.register.id);
	}

	public String getGameId()
	{
		return this.register.id.gameId;
	}
	public String getChannel()
	{
		return this.register.id.channel;
	}

	public String getUid()
	{
		return this.register.id.uid;
	}

	public TLogger.DCRole getDCRole()
	{
		return this.dcRole;
	}

	public Ban getBan()
	{
		return this.ban;
	}

	public void updateBanInfo(Ban ban)
	{
		this.ban = ban;
	}

	public Role createRole(RoleShare roleShare, SBean.DBRegisterID registerID, SBean.CreateRoleParam createParam)
	{
		int now = GameTime.getTime();
		this.share = roleShare;
		this.mailbox = new MailBox().createNew(gs.getLoginManager().getWorldMail().getLastWorldMailID());

		this.register = new SBean.DBRegister(registerID, now);
		this.name = createParam.name;
		this.createTime = now;
		this.lastLoginTime = now;
		this.lastLogoutTime = now;
		this.lastOnlineTime = now;
		this.totalOnlineTime = 0;

		this.headIcon = GameData.getInstance().getRoleHeadIcon(createParam.gender, createParam.face, createParam.hair);
		this.gender = createParam.gender;
		this.face = createParam.face;
		this.hair = createParam.hair;

		this.classType = createParam.classType;
		this.transformLevel = 0;
		this.BWType = 0;

		this.gameMapContext = new GameMapContext(gs.getConfig().godMode != 3 ? GameData.getInstance().getClassRoleSpawnMapPosition(this.classType) : GameData.getInstance().getClassRoleTestSpawnMapPosition());

		this.lastDayRefresh = 0;
		this.loginDays = 0;

		this.level = 1;
		this.exp = 0;
		this.lastLevelUpTime = now;
		this.expVolume = 0;

		this.lastUseHpTime = 0;
		this.lastSpawnReviveTime = 0;
		this.lastDiamondReviveTime = 0;
		this.diamondReviveTimes = 0;
		this.hpPool = 0;
		this.lastUseHpPoolTime = 0;
		this.vit = GameData.getInstance().getMaxVit(this.level);
		this.vitRevertTime = 0;

		this.pkValue = 0;
		this.pkValueTime = 0;
		this.historyHighestPower = 0;

		this.totalPayPoint = 0;
		this.payLevelTimes = new TreeMap<>();
		this.payRewardTimes = new TreeMap<>();
		this.diamondF = 0;
		this.diamondR = 0;
		this.coinF = 0;
		this.coinR = 0;

		this.diamondFUseTotal = 0;
		this.diamondRUseTotal = 0;
		this.coinFUseTotal = 0;
		this.coinRUseTotal = 0;

		this.historyMaxGemLevel = 0;
		this.historyMaxGemNum = 0;

		this.equipEnergy = 0;
		this.gemEnergy = 0;
		this.bookInspiration = 0;

		this.dayBuyCoinTimes = 0;
		this.dayBuyVitTimes = 0;
		this.dayUseVit = 0;
		this.dayUseItemsTimes = new TreeMap<>();

		this.specialCards = initSpecialCards(new ArrayList<>());
		this.tempVIP = new SBean.DBTempVIP();
		this.vipRewards = new TreeSet<Integer>();

		this.bag = new ItemCellCollection(GameData.getInstance().getCommonCFG().bag.initCount, 0);

		this.wearParts = GameData.createNewRoleWearParts();
		this.wearEquips = this.createNewRoleWearEquips(createParam.classType);
		this.suites = new TreeMap<Integer, SBean.DBSuite>();
		this.logWearEquips = new HashMap<Integer, Integer>();
		this.sealData = new SBean.DBSealData(0, new HashMap<>(), 0, new HashMap<>());
		this.legendMake = new LegendMake(new SBean.DBEquip("", 0, new ArrayList<>(), 0, new ArrayList<>(), new ArrayList<>()), new ArrayList<>());

		this.skills = this.createNewRoleSkills(createParam.classType);
		this.curSkills = new ArrayList<Integer>();
		for (int i = 0; i < GameData.CUR_USE_SKILL_COUNT; ++i)
			this.curSkills.add(0);
		this.curUniqueSkill = 0;
		
		this.spirits = new TreeMap<Integer, SBean.DBSpirit>();
		this.curSpirits = new HashSet<>();

		this.buffs = new TreeMap<Integer, SBean.DBBuff>();

		int hp = GameData.getInstance().getClassRoleInitHp(createParam.classType, this.wearEquips);
		this.gameMapContext.getWorldMapContext().setHp(hp, hp);

		this.weaponTask = this.createNewRoleWeaponTask(now);
		this.weapons = new TreeMap<Integer, SBean.DBWeapon>();
		this.curWeapon = 0;
		this.weaponUSkill = new WeaponUSkill().init(this.weapons.values(), this.curWeapon, null);

		this.activePets = new TreeMap<Integer, SBean.DBPet>();
		this.worldMapPets = new TreeSet<Integer>();
		this.privateMapPets = new TreeSet<Integer>();
		this.sectMapPets = new TreeSet<Integer>();
		this.activityMapPets = new TreeSet<Integer>();
		this.petSpirit = new PetSpiritInfo(new HashMap<>());
		this.petAchieves = new HashSet<>();

		this.mainTask = new SBean.DBMainTask(1, 0, (byte)1, now);
		this.alterState = new SBean.DBAlterState(0, 0);

		this.normalMapCopyLogs = new HashMap<>();
		this.activityMapGroupLogs = new HashMap<>();
		this.towerDefence = new SBean.DBRoleTowerDefence(new HashMap<>(), 0, 0);
		this.checkinLog = new SBean.DBCheckInLog(0, 0, 0);
		this.mallBuyLogs = new HashMap<>();
		this.firstPayGiftLogs = new HashMap<>();
		this.payGiftLogs = new HashMap<>();
		this.consumeGiftLogs = new HashMap<>();
		this.upgradeGiftLogs = new HashMap<>();
		this.investmentFundLogs = new HashMap<>();
		this.growthFundLogs = new HashMap<>();
		this.exchangeGiftLogs = new HashMap<>();
		this.loginGiftLogs = new HashMap<>();
		this.dailyPayGiftLogs = new HashMap<>();
		this.groupBuyLogs = new HashMap<>();
		this.flashSaleLogs = new HashMap<>();
		this.lastPayGiftLogs = new HashMap<>();
		this.activityChallengeGiftLogs = new HashMap<>();
		this.luckyRollerLogs = new HashMap<>();
		this.upgradePurchaseLogs = new HashMap<>();
		this.giftPackageLogs = new HashMap<>();
		this.directPurchaseLogs = new HashMap<>();
		this.oneArmBanditLogs = new HashMap<>();

		this.shops = this.createNewRoleShopData();
		this.gambleShops = this.createNewRoleGambleShopData();

		this.dailyTasks = this.createNewDailyTaskData();
		this.challengeTasks = new TreeMap<Integer, SBean.DBChallengeTask>();
		this.achPoints = new TreeMap<Integer, Integer>();
		for (int i=GameData.ACHIEVEMENT_TYPE_BUDO; i<=GameData.ACHIEVEMENT_TYPE_CITIES; i++)
		{
		    this.achPoints.put(i, 0);
		}
		
		this.fame = new SBean.DBFame(1, now, (byte)0);
		this.dailyOnlineGift = new SBean.DBDailyOnlineGift(0, new TreeSet<Integer>());
		this.offlineExp = new SBean.DBOfflineExp(0, 0, new ArrayList<>(), 0, 0, 0);
		this.quizGift = new TreeMap<Integer, SBean.DBQuizGift>();
		this.luckyWheelSelectPos = new ArrayList<>();
		this.luckyWheel = new SBean.DBLuckyWheel(0, 0, 0);
		this.daySnatchRedEnvelopes = 0;
		this.dayGetRedEnvelopesEmptyGift = 0;

		this.sectData = this.createNewRoleSectData();
		this.sectAuras = new TreeMap<Integer, Integer>();
		this.sectAuraExpCoinRateRaise = 0;
		this.lastSectChatTime = 0;
		this.lastMRoomInviteChatTime = 0;
		this.showWebLink = 1;

		this.teamInvites = new TreeSet<Integer>();
		this.teamApplys = new TreeSet<Integer>();
		this.team = new SBean.Team(0, 0, new ArrayList<Integer>());
		this.lastTeamChatTime = 0;
		this.leaderLine = -1;
		this.roomInvites = new TreeSet<Integer>();
		this.room = new SBean.MRoom(0, 0, 0, 0, new ArrayList<Integer>(), 0);
		this.aroomInvites = new HashSet<>();
		this.arenaroom = new SBean.ARoom(0, 0, 0, 0, new ArrayList<Integer>());
		this.froom = new SBean.FRoom(0, 0, 0, new ArrayList<>());
		this.froomInvites = new HashSet<>();
		this.petLastUsePool = new HashMap<Integer, Integer>();
		this.petCanUsePool = false;

		this.msgs = new LinkedList<SBean.MessageInfo>();
		this.lastPrivateChatTime = 0;

		this.initNewRoleDiySkillData();

		this.arenaInfo = createNewRoleArenaData();
		this.friend = this.createFriendData();
		this.auctionInfo = this.createNewAuctionInfo();
		this.horseData = new HorseData(new SBean.DBHorse(new HashMap<Integer, SBean.HorseInfo>(), new HashMap<Integer, Integer>(), 0, 0));
		this.treasuremapInfo = this.createTreasureMapInfo();
		this.roleExpCoin = new RoleExpCoin().initData(new SBean.DBExpCoinData(0, 0, 0), 
													  new SBean.DBRareBook(new HashMap<>(), new HashMap<>()), 
													  createGraspData(),
													  createDMGTransfer());
		this.fashionEquip = new SBean.DBRoleFashion(new HashMap<>(), new HashMap<>(), (byte) 0);
		this.showFashionTypes = new HashMap<>();
		this.roleTitles = createNewRoleTitle();
		this.leadInfo = new HashSet<>();
		this.leadPlot = new HashMap<>();
		this.isTreasureGuide = 0;
		this.armor = initArmor();
		this.gameMapContext.getWorldMapContext().setArmorVal(0, 0);
		this.exchangeTimes = new HashMap<>();
		this.skillPreset = new ArrayList<>();
		this.spiritsPreset = new ArrayList<>();
		this.lifeUse = new HashMap<>();
		this.itemGetProp = new HashMap<>();
		this.insightData = new SBean.DBInsightData(0, new ArrayList<>());
		this.revengeData = new SBean.DBRevengeData(0, new ArrayList<>());
		this.heirloomData = new SBean.DBHeirloom((byte) 0, (byte) 0, (byte) 0, 0, (byte) 0, 0, 0);
		this.offlineWizard = this.createNewOfflineWizardData();
		this.activityLast = new SBean.DBActivityLastData(new HashMap<>(), new HashMap<>());
		this.branchTask = new HashMap<>();
		this.climbTowerData = createNewRoleClimbTowerData();//new SBean.DBClimbTower(0, 0);
		this.towerCards = new ArrayList<>();
		this.secretAreaTaskData = new SBean.DBSecretTaskData(0, 0, 0, 0);
		this.sectDeliver = initSectDeliver();
		this.escortCar = new RoleEscortCar();
		this.produce = initProduceData();
		this.isRob = GameData.SECT_IS_NOT_ROB;
		this.forceWarInfo = new RoleForceWar().fromDB(new SBean.DBRoleForceWar(0, 0, 0, 0, new SBean.ForceWarLog(0, 0, 0, 0, 0), 0, 0));
		this.rmactivity = 0;
		this.messageBoardDayCommentTimes = 0;
		this.schedule = this.initScheduleData();
		this.warehouse = new ItemCellCollection(0, 0);
		this.marriageData = new SBean.DBRoleMarriageData(0, 0, 0, 0, 0, "");
		this.propose = new SBean.ProposeData(0, 0);
		this.dailyVit = new SBean.DBDailyVitData(0, new TreeSet<>());
		this.lifeUse = new HashMap<>();
		this.itemGetProp = new HashMap<>();
		this.stele = new SBean.DBRoleStele(0, (byte)0, 0, 0, (byte)0, 0);
		this.demonHoleInfo = new DemonHoleInfo(new SBean.RoleDemonHoleLog(0, new HashSet<>(), 0, 0, 0));
		this.levelUpTimeMap = new TreeMap<>();
		this.lucklyStar = new SBean.DBLucklyStar(0, 0, 0, 0, 0, 0, 0);
		this.fightNpc = initFightNpc();
		this.packetReward = 0;
		this.itemUnlockHead = new HashSet<>();
		this.roleSocialComment = new HashMap<>();
		this.redNamePunish = new SBean.DBRedNamePunish(0, 0, 0);
		this.dayNpcPrayTimes = new HashMap<>();
		this.dayNpcCpoyTimes = new HashMap<>();
		this.fusionData = new SBean.DBFusionData(0, 0, 0, 0);
		this.master = new DBMaster().makeNew();
		this.payRankLogs = new HashMap<>();
		
		//非存盘数据
		this.guidestep = gs.getConfig().newRoleGuide != 0  ? 1 : 0;
		this.messageBoardLastSyncTime = 0;
		this.mulHorseInvites = new HashMap<>();
		this.mulHorseApplys = new HashMap<>();
		this.staywithInvites = new HashMap<>();
		this.mulRoleInfo = new SBean.MulRoleInfo(0, 0, new ArrayList<>());
		this.sectInvites = new TreeSet<>();
		this.taskDrops = new HashMap<>();
		this.trigSpawnPoints = new HashMap<>();		
		this.roleProperties = new RoleProperties().init();
		this.equipLegend = new EquipLegend().init(this.wearEquips.values());
		return this;
	}

	// /////
	public Role fromDBRole(RoleShare roleShare, DBRole dbRole, DBMailBox dbMailbox)
	{
		this.share = roleShare;
		this.mailbox = new MailBox().fromDB(dbMailbox);

		this.register = dbRole.register;
		this.name = dbRole.name;
		this.createTime = dbRole.createTime;
		this.lastLoginTime = dbRole.lastLoginTime;
		this.lastLogoutTime = dbRole.lastLogoutTime;
		this.lastOnlineTime = dbRole.lastOnlineTime;
		this.totalOnlineTime = dbRole.totalOnlineTime;

		this.headIcon = dbRole.headIcon;
		this.gender = dbRole.gender;
		this.face = dbRole.face;
		this.hair = dbRole.hair;

		this.classType = dbRole.classType;
		this.transformLevel = dbRole.transformLevel;
		this.BWType = dbRole.BWType;

		this.gameMapContext = new GameMapContext(dbRole.worldMapLocation);

		this.lastDayRefresh = dbRole.lastDayRefresh;
		this.loginDays = dbRole.loginDays;

		this.level = dbRole.level;
		this.exp = dbRole.exp;
		this.lastLevelUpTime = dbRole.lastLevelUpTime;
		this.expVolume = dbRole.expVolume;
		this.gameMapContext.getWorldMapContext().setHp(dbRole.hp, dbRole.hp);// 真实的hpmax需要map server同步

		this.lastUseHpTime = dbRole.lastUseHpTime;
		this.lastSpawnReviveTime = dbRole.lastSpawnReviveTime;
		this.lastDiamondReviveTime = dbRole.lastDiamondReviveTime;
		this.diamondReviveTimes = dbRole.diamondReviveTimes;
		this.hpPool = dbRole.hpPool;
		this.lastUseHpPoolTime = dbRole.lastUseHpPoolTime;
		this.vit = dbRole.vit;
		this.vitRevertTime = dbRole.vitRevertTime;

		this.pkValue = dbRole.pkValue;
		this.pkValueTime = dbRole.pkValueTime;
		this.historyHighestPower = dbRole.historyHighestPower;

		this.totalPayPoint = dbRole.totalPayPoint;
		this.payLevelTimes = dbRole.payLevelTimes;
		this.payRewardTimes = dbRole.payRewardTimes;
		this.diamondF = dbRole.diamondF;
		this.diamondR = dbRole.diamondR;
		this.coinF = dbRole.coinF;
		this.coinR = dbRole.coinR;
		this.credit = dbRole.credit;

		this.diamondFUseTotal = dbRole.diamondFUseTotal;
		this.diamondRUseTotal = dbRole.diamondRUseTotal;
		this.coinFUseTotal = dbRole.coinFUseTotal;
		this.coinRUseTotal = dbRole.coinRUseTotal;
		this.creditUseTotal = dbRole.creditUseTotal;
		
		this.historyMaxGemLevel = dbRole.historyMaxGemLevel;
		this.historyMaxGemNum = dbRole.historyMaxGemNum;

		this.equipEnergy = dbRole.equipEnergy;
		this.gemEnergy = dbRole.gemEnergy;
		this.bookInspiration = dbRole.bookInspiration;

		this.dayBuyCoinTimes = dbRole.dayBuyCoinTimes;
		this.dayBuyVitTimes = dbRole.dayBuyVitTimes;
		this.dayUseVit = dbRole.dayUseVit;
		this.dayUseItemsTimes = dbRole.dayUseItemsTimes;

		this.specialCards = initSpecialCards(dbRole.specialCards);
		this.tempVIP = dbRole.tempVIP;
		this.vipRewards = dbRole.vipRewards;

		this.bag = new ItemCellCollection(dbRole.bag);

		this.wearParts = dbRole.wearParts;
		this.wearEquips = dbRole.wearEquips;
		this.suites = dbRole.suites;
		this.logWearEquips = dbRole.logWearEquips;
		this.sealData = dbRole.sealData;
		this.legendMake = new LegendMake(dbRole.legendMake.equip, dbRole.legendMake.legends);

		this.skills = dbRole.skills;
		this.curSkills = dbRole.curSkills;
		this.curUniqueSkill = dbRole.curUniqueSkill;
		this.initUniqueSkills(this.skills.keySet());
		
		this.spirits = dbRole.spirits;
		this.curSpirits = dbRole.curSpirits;

		this.buffs = dbRole.buffs;

		this.weaponTask = dbRole.weaponTask;
		this.weapons = dbRole.weapons;
		this.curWeapon = dbRole.curWeapon;
		this.weaponUSkill = new WeaponUSkill().init(this.weapons.values(), this.curWeapon, dbRole.weaponMapLog);

		this.activePets = dbRole.activePets;
		this.worldMapPets = dbRole.worldMapPets;
		this.privateMapPets = dbRole.privateMapPets;
		this.sectMapPets = dbRole.sectMapPets;
		this.activityMapPets = dbRole.activityMapPets;
		this.petSpirit = new PetSpiritInfo(dbRole.petSpirits).init(dbRole.activePets.values());

		this.mainTask = dbRole.mainTask;
		this.alterState = dbRole.alterState;
		if (GameTime.getTime() > this.alterState.attrEndTime)
			this.alterState.attrEndTime = 0;

		this.normalMapCopyLogs = dbRole.normalMapCopyLogs;
		this.activityMapGroupLogs = dbRole.activityMapGroupLogs;
		this.towerDefence = dbRole.towerDefence == null ? new SBean.DBRoleTowerDefence(new HashMap<>(), 0, 0) : dbRole.towerDefence;
		this.checkinLog = dbRole.checkinLog;
		this.mallBuyLogs = dbRole.mallBuyLogs;
		this.firstPayGiftLogs = dbRole.firstPayGiftLogs;
		this.payGiftLogs = dbRole.payGiftLogs;
		this.consumeGiftLogs = dbRole.consumeGiftLogs;
		this.upgradeGiftLogs = dbRole.upgradeGiftLogs;
		this.investmentFundLogs = dbRole.investmentFundLogs;
		this.growthFundLogs = dbRole.growthFundLogs;
		this.exchangeGiftLogs = dbRole.exchangeGiftLogs;
		this.loginGiftLogs = dbRole.loginGiftLogs;
		this.dailyPayGiftLogs = dbRole.dailyPayGiftLogs;
		this.groupBuyLogs = dbRole.groupBuyLogs;
		this.flashSaleLogs = dbRole.flashSaleLogs;
		this.lastPayGiftLogs = dbRole.lastPayGiftLogs;
		this.activityChallengeGiftLogs = dbRole.activityChallengeGiftLogs;
		this.luckyRollerLogs = dbRole.luckyRollerLogs;
		this.upgradePurchaseLogs = dbRole.upgradePurchaseLogs;
		this.giftPackageLogs = dbRole.giftPackageLogs;
		this.directPurchaseLogs = dbRole.directPurchaseLogs;
		this.oneArmBanditLogs = dbRole.oneArmBanditLogs;

		this.shops = dbRole.shops;
		int shopTypeCount = GameData.getInstance().getShopTypeCount();
		for (int i = dbRole.shops.size() + 1; i <= shopTypeCount; ++i)
			this.shops.put(i, this.createNewShop(i));
		
		this.gambleShops = dbRole.gambleShops;
		int gambleShopTypeCount = GameData.getInstance().getGambleShopTypeCount();
		for (int i = dbRole.gambleShops.size() + 1; i <= gambleShopTypeCount; ++i)
			this.gambleShops.put(i, this.createNewGambleShop(i));

		this.dailyTasks = dbRole.dailyTasks;
		this.challengeTasks = dbRole.challengeTasks;
		this.achPoints = dbRole.achPoints;
		this.fame = dbRole.fame;
		this.dailyOnlineGift = dbRole.dailyOnlineGift;
		this.offlineExp = dbRole.offlineExp;
		this.quizGift = dbRole.quizGift;
		this.luckyWheelSelectPos = dbRole.luckyWheelSelectPos;
		this.luckyWheel = dbRole.luckyWheel;
		this.daySnatchRedEnvelopes = dbRole.daySnatchRedEnvelopes;
		this.dayGetRedEnvelopesEmptyGift = dbRole.dayGetRedEnvelopesEmptyGift;

		this.sectData = dbRole.sectData;
		this.sectAuras = new TreeMap<Integer, Integer>();
		this.lastSectChatTime = 0;
		this.showWebLink = 1;

		this.diySkillData = dbRole.diySkillData;

		this.arenaInfo = new RoleArena().fromDBData(dbRole.roleArenaData);
		this.initSuperArena();

		this.teamInvites = new TreeSet<Integer>();
		this.teamApplys = new TreeSet<Integer>();
		this.team = new SBean.Team(0, 0, new ArrayList<Integer>());
		this.lastTeamChatTime = 0;
		this.leaderLine = -1;
		this.roomInvites = new TreeSet<Integer>();
		this.room = new SBean.MRoom(0, 0, 0, 0, new ArrayList<>(), 0);
		this.aroomInvites = new HashSet<>();
		this.arenaroom = new SBean.ARoom(0, 0, 0, 0, new ArrayList<Integer>());
		this.froom = new SBean.FRoom(0, 0, 0, new ArrayList<>());
		this.froomInvites = new HashSet<>();
		this.petLastUsePool = new HashMap<Integer, Integer>();
		this.petCanUsePool = false;

		this.msgs = new LinkedList<SBean.MessageInfo>();
		this.lastPrivateChatTime = 0;

		this.friend = new RoleFriend().fromDB(dbRole.friendData);
		this.auctionInfo = dbRole.auctionInfo;
		this.horseData = new HorseData(dbRole.horseData);
		this.treasuremapInfo = new TreasureMap(dbRole.treasureData);
		this.roleExpCoin = new RoleExpCoin().initData(dbRole.expCoinData, dbRole.rarebookData, dbRole.graspData, dbRole.dmgTransfer);
		this.fashionEquip = dbRole.fashionEquip;
		this.showFashionTypes = dbRole.showFashionTypes;
		initShowFashions();
		this.roleTitles = initRoleTitle(dbRole.roleTitles);
		this.leadInfo = dbRole.leadInfo;
		this.leadPlot = dbRole.leadPlot;
		this.isTreasureGuide = dbRole.isTreasureGuide;
		this.branchTask = dbRole.branchTask;
		this.climbTowerData = new RoleClimbTower().fromDBData(dbRole.climbTowerData, dbRole.climbTowerRecordData, dbRole.climbTowerFameData);
		this.sectDeliver = dbRole.sectDeliver;
		this.escortCar = new RoleEscortCar().fromDB(dbRole.escortCar, this.id, this.name);
		this.towerCards = dbRole.towerCards;
		this.secretAreaTaskData = dbRole.secretAreaTaskData;
		this.petAchieves = Role.getNewPetAchieves(dbRole.activePets);
		this.armor = dbRole.armor;
		this.gameMapContext.getWorldMapContext().setArmorVal(dbRole.armorVal, dbRole.armorVal);		// 真实的armorValMax需要map server同步
		this.produce = dbRole.produce;
		this.fusionData = dbRole.fusionData!=null ? dbRole.fusionData : new SBean.DBFusionData();
		this.isRob = dbRole.isRob;
		this.forceWarInfo = new RoleForceWar().fromDB(dbRole.forcewar);
		this.rmactivity = dbRole.rmactivity;
		this.messageBoardDayCommentTimes = dbRole.messageBoardDayCommentTimes;
		this.guidestep = dbRole.guidestep;
		this.messageBoardLastSyncTime = 0;
		this.schedule = dbRole.schedule;
		this.warehouse = new ItemCellCollection(dbRole.warehouse);
		this.marriageData = dbRole.marriageData;
		this.exchangeTimes = dbRole.exchangeTimes;
		this.skillPreset = dbRole.skillPreset;
		this.spiritsPreset = dbRole.spiritsPreset;
		this.mulHorseInvites = new HashMap<>();
		this.mulHorseApplys = new HashMap<>();
		this.staywithInvites = new HashMap<>();
		this.mulRoleInfo = new SBean.MulRoleInfo(0, 0, new ArrayList<>());
		this.sectInvites = new TreeSet<>();
		this.propose = new SBean.ProposeData(0, 0);
		this.dailyVit = dbRole.dailyVit;
		this.lifeUse = dbRole.lifeUse;
		this.itemGetProp = dbRole.itemGetProp;
		this.taskDrops = new HashMap<>();
		this.trigSpawnPoints = new HashMap<>();
		this.insightData = dbRole.insightData;
		this.revengeData = dbRole.revengeData;
		this.heirloomData = dbRole.heirloomData;
		this.offlineWizard = dbRole.offlineWizard;
		this.activityLast = dbRole.activityLast;
		this.stele = dbRole.stele;
		this.dayJusticeJoinTime = dbRole.dayJusticeJoinTime;
		this.demonHoleInfo = new DemonHoleInfo(dbRole.demonHole);
		this.levelUpTimeMap = new TreeMap<Integer, Integer>(dbRole.levelUpTimeMap);
		this.lucklyStar = dbRole.lucklyStar;
		this.fightNpc = dbRole.fightNpc;
		this.packetReward = dbRole.packetReward;
		this.itemUnlockHead = dbRole.itemUnlockHead;
		this.roleSocialComment = dbRole.roleSocialComment == null ? new HashMap<>() : dbRole.roleSocialComment;
		this.redNamePunish = dbRole.redNamePunish != null ? dbRole.redNamePunish : new SBean.DBRedNamePunish(0, 0, 0);
		this.dayNpcPrayTimes = dbRole.dayNpcPrayTimes;
		this.dayNpcCpoyTimes = dbRole.dayNpcCpoyTimes;
		this.master = dbRole.master;
		this.payRankLogs = dbRole.payRankLogs == null ? new HashMap<>() : dbRole.payRankLogs.stream().collect(Collectors.toMap(p -> p.id, q -> q));
		
		//该语句需要放在最后
        this.dcRole = new TLogger.DCRole(gs, this);
		this.roleProperties = new RoleProperties().init();
		this.equipLegend = new EquipLegend().init(this.wearEquips.values());
		return this;
	}

	public DBRole copyDBRoleWithoutLock()
	{
		DBRole dbRole = new DBRole();

		dbRole.id = this.id;
		dbRole.register = register.kdClone();
		dbRole.name = this.name;
		dbRole.createTime = this.createTime;
		dbRole.lastLoginTime = this.lastLoginTime;
		dbRole.lastLogoutTime = this.lastLogoutTime;
		dbRole.lastOnlineTime = this.lastOnlineTime;
		dbRole.totalOnlineTime = this.totalOnlineTime;

		dbRole.headIcon = this.headIcon;
		dbRole.gender = this.gender;
		dbRole.face = this.face;
		dbRole.hair = this.hair;

		dbRole.classType = this.classType;
		dbRole.transformLevel = this.transformLevel;
		dbRole.BWType = this.BWType;

		dbRole.worldMapLocation = this.gameMapContext.getWorldMapContext().getMapLocation().kdClone();

		dbRole.lastDayRefresh = this.lastDayRefresh;
		dbRole.loginDays = this.loginDays;

		dbRole.level = this.level;
		dbRole.exp = this.exp;
		dbRole.lastLevelUpTime = this.lastLevelUpTime;
		dbRole.expVolume = this.expVolume;
		dbRole.hp = this.gameMapContext.getWorldMapContext().getHp();

		dbRole.lastUseHpTime = this.lastUseHpTime;
		dbRole.lastSpawnReviveTime = this.lastSpawnReviveTime;
		dbRole.lastDiamondReviveTime = this.lastDiamondReviveTime;
		dbRole.diamondReviveTimes = this.diamondReviveTimes;
		dbRole.hpPool = this.hpPool;
		dbRole.lastUseHpPoolTime = this.lastUseHpPoolTime;
		dbRole.vit = this.vit;
		dbRole.vitRevertTime = this.vitRevertTime;
		dbRole.pkValue = this.pkValue;
		dbRole.pkValueTime = this.pkValueTime;
		dbRole.totalPower = this.roleProperties.getRoleFightPower();
		dbRole.historyHighestPower = this.historyHighestPower;

		dbRole.totalPayPoint = this.totalPayPoint;
		dbRole.payLevelTimes = new TreeMap<>(this.payLevelTimes);
		dbRole.payRewardTimes = new TreeMap<>(this.payRewardTimes);
		dbRole.diamondF = this.diamondF;
		dbRole.diamondR = this.diamondR;
		dbRole.coinF = this.coinF;
		dbRole.coinR = this.coinR;
		dbRole.credit = this.credit;

		dbRole.diamondFUseTotal = this.diamondFUseTotal;
		dbRole.diamondRUseTotal = this.diamondRUseTotal;
		dbRole.coinFUseTotal = this.coinFUseTotal;
		dbRole.coinRUseTotal = this.coinRUseTotal;
		dbRole.creditUseTotal = this.creditUseTotal;

		dbRole.historyMaxGemLevel = this.historyMaxGemLevel;
		dbRole.historyMaxGemNum = this.historyMaxGemNum;

		dbRole.equipEnergy = this.equipEnergy;
		dbRole.gemEnergy = this.gemEnergy;
		dbRole.bookInspiration = this.bookInspiration;

		dbRole.dayBuyCoinTimes = this.dayBuyCoinTimes;
		dbRole.dayBuyVitTimes = this.dayBuyVitTimes;
		dbRole.dayUseVit = this.dayUseVit;
		dbRole.dayUseItemsTimes = new HashMap<>(this.dayUseItemsTimes);

		dbRole.specialCards = Stream.clone(this.specialCards);
		dbRole.tempVIP = this.tempVIP.kdClone();
		dbRole.vipRewards = new TreeSet<Integer>(this.vipRewards);

		dbRole.bag = this.bag.toDB();

		dbRole.wearParts = Stream.clone(this.wearParts);
		dbRole.wearEquips = Stream.clone(this.wearEquips);
		dbRole.suites = Stream.clone(this.suites);
		dbRole.logWearEquips = new HashMap<Integer, Integer>(this.logWearEquips);
		dbRole.sealData = Stream.clone(this.sealData);
		dbRole.legendMake = this.legendMake.toDB();

		dbRole.skills = Stream.clone(this.skills);
		dbRole.curSkills = new ArrayList<Integer>(this.curSkills);
		dbRole.curUniqueSkill = this.curUniqueSkill;

		dbRole.spirits = Stream.clone(this.spirits);
		dbRole.curSpirits = new HashSet<>(this.curSpirits);

		dbRole.buffs = Stream.clone(this.buffs);

		dbRole.weaponTask = this.weaponTask.kdClone();
		dbRole.weapons = Stream.clone(this.weapons);
		dbRole.curWeapon = this.curWeapon;
		dbRole.weaponMapLog = this.weaponUSkill.getMapLog().kdClone();

		dbRole.activePets = Stream.clone(this.activePets);
		dbRole.worldMapPets = new TreeSet<Integer>(this.worldMapPets);
		dbRole.privateMapPets = new TreeSet<Integer>(this.privateMapPets);
		dbRole.sectMapPets = new TreeSet<Integer>(this.sectMapPets);
		dbRole.activityMapPets = new TreeSet<Integer>(this.activityMapPets);
		dbRole.petSpirits = new HashMap<>(this.petSpirit.allPetSpirits);

		dbRole.mainTask = this.mainTask.kdClone();
		dbRole.alterState = this.alterState.kdClone();

		dbRole.normalMapCopyLogs = Stream.clone(this.normalMapCopyLogs);
		dbRole.activityMapGroupLogs = Stream.clone(this.activityMapGroupLogs);
		dbRole.towerDefence = this.towerDefence.kdClone();
		dbRole.checkinLog = this.checkinLog.kdClone();
		dbRole.mallBuyLogs = Stream.clone(this.mallBuyLogs);
		dbRole.firstPayGiftLogs = Stream.clone(this.firstPayGiftLogs);
		dbRole.payGiftLogs = Stream.clone(this.payGiftLogs);
		dbRole.consumeGiftLogs = Stream.clone(this.consumeGiftLogs);
		dbRole.upgradeGiftLogs = Stream.clone(this.upgradeGiftLogs);
		dbRole.investmentFundLogs = Stream.clone(this.investmentFundLogs);
		dbRole.growthFundLogs = Stream.clone(this.growthFundLogs);
		dbRole.exchangeGiftLogs = Stream.clone(this.exchangeGiftLogs);
		dbRole.loginGiftLogs = Stream.clone(this.loginGiftLogs);
		dbRole.dailyPayGiftLogs = Stream.clone(this.dailyPayGiftLogs);
		dbRole.groupBuyLogs = Stream.clone(this.groupBuyLogs);
		dbRole.flashSaleLogs = Stream.clone(this.flashSaleLogs);
		dbRole.lastPayGiftLogs = Stream.clone(this.lastPayGiftLogs);
		dbRole.activityChallengeGiftLogs = Stream.clone(this.activityChallengeGiftLogs);
		dbRole.luckyRollerLogs = Stream.clone(this.luckyRollerLogs);
		dbRole.upgradePurchaseLogs = Stream.clone(this.upgradePurchaseLogs);
		dbRole.giftPackageLogs = Stream.clone(this.giftPackageLogs);
		dbRole.directPurchaseLogs = Stream.clone(this.directPurchaseLogs);
		dbRole.oneArmBanditLogs = Stream.clone(this.oneArmBanditLogs);

		dbRole.shops = Stream.clone(this.shops);
		dbRole.gambleShops = Stream.clone(this.gambleShops);
		dbRole.dailyTasks = Stream.clone(this.dailyTasks);
		dbRole.challengeTasks = Stream.clone(this.challengeTasks);
		dbRole.achPoints = new TreeMap<Integer, Integer>(this.achPoints);
		dbRole.fame = this.fame.kdClone();
		dbRole.dailyOnlineGift = this.dailyOnlineGift.kdClone();
		dbRole.offlineExp = this.offlineExp.kdClone();

		dbRole.quizGift = Stream.clone(this.quizGift);
		dbRole.luckyWheelSelectPos = new ArrayList<Integer>(this.luckyWheelSelectPos);
		dbRole.luckyWheel = this.luckyWheel.kdClone();
		dbRole.daySnatchRedEnvelopes = this.daySnatchRedEnvelopes;
		dbRole.dayGetRedEnvelopesEmptyGift = this.dayGetRedEnvelopesEmptyGift;
		

		dbRole.sectData = this.sectData.kdClone();

		dbRole.diySkillData = this.diySkillData.kdClone();

		dbRole.roleArenaData = this.arenaInfo.roleArenaData.kdClone();
		dbRole.friendData = this.friend.toDB();
		dbRole.auctionInfo = this.auctionInfo.kdClone();
		dbRole.horseData = this.horseData.dbHorse.kdClone();
		dbRole.treasureData = this.treasuremapInfo.info.kdClone();
		dbRole.expCoinData = this.roleExpCoin.expCoinData.kdClone();
		dbRole.rarebookData = this.roleExpCoin.rarebookData.kdClone();
		dbRole.graspData = this.roleExpCoin.graspData.kdClone();
		dbRole.dmgTransfer = this.roleExpCoin.dmgTransfer.kdClone();
		dbRole.fashionEquip = this.fashionEquip.kdClone();
		dbRole.showFashionTypes = new HashMap<>(this.showFashionTypes);
		dbRole.roleTitles = this.roleTitles.kdClone();
		dbRole.leadInfo = new HashSet<>(this.leadInfo);
		dbRole.leadPlot = new HashMap<>(this.leadPlot);
		dbRole.isTreasureGuide = this.isTreasureGuide;
		dbRole.branchTask = Stream.clone(this.branchTask);
		dbRole.towerCards = new ArrayList<Integer>(this.towerCards);
		dbRole.secretAreaTaskData = this.secretAreaTaskData.kdClone();
		dbRole.climbTowerData = this.climbTowerData.roleClimbTowerData.kdClone();
		dbRole.climbTowerRecordData = Stream.clone(this.climbTowerData.roleClimbTowerRecordData);
		dbRole.climbTowerFameData = Stream.clone(this.climbTowerData.roleClimbTowerFameData);
		dbRole.sectDeliver = this.sectDeliver.kdClone();
		dbRole.escortCar = this.escortCar.getCarInfo();
		dbRole.produce = this.produce.kdClone();
		dbRole.fusionData = this.fusionData.kdClone();
		dbRole.isRob = this.isRob;
		dbRole.forcewar = this.forceWarInfo.toDB();
		dbRole.rmactivity = this.rmactivity;
		dbRole.messageBoardDayCommentTimes = this.messageBoardDayCommentTimes;
		dbRole.guidestep = this.guidestep;
		dbRole.schedule = this.schedule.kdClone();		
		dbRole.armor = this.armor.kdClone();
		dbRole.armorVal = this.gameMapContext.getWorldMapContext().getArmorVal();
		dbRole.warehouse = this.warehouse.toDB();
		dbRole.marriageData = this.marriageData.kdClone();
		dbRole.exchangeTimes = new HashMap<>(this.exchangeTimes);
		dbRole.skillPreset = new ArrayList<>(this.skillPreset);
		dbRole.spiritsPreset = new ArrayList<>(this.spiritsPreset);
		dbRole.dailyVit = this.dailyVit.kdClone();
		dbRole.lifeUse = new HashMap<>(this.lifeUse);
		dbRole.itemGetProp = new HashMap<>(this.itemGetProp);
		dbRole.insightData = this.insightData.kdClone();
		dbRole.revengeData = this.revengeData.kdClone();
		dbRole.heirloomData = this.heirloomData.kdClone();
		dbRole.offlineWizard = this.offlineWizard.kdClone();
		dbRole.activityLast = this.activityLast.kdClone();
		dbRole.stele = this.stele.kdClone();
		dbRole.dayJusticeJoinTime = this.dayJusticeJoinTime;
		dbRole.demonHole = this.demonHoleInfo.toDB();
		dbRole.levelUpTimeMap = new TreeMap<>(this.levelUpTimeMap);
		dbRole.lucklyStar = this.lucklyStar.kdClone();
		dbRole.fightNpc = this.fightNpc.kdClone();
		dbRole.packetReward = this.packetReward;
		dbRole.itemUnlockHead = new HashSet<Integer>(this.itemUnlockHead);
		dbRole.roleSocialComment = Stream.clone(this.roleSocialComment);
		dbRole.redNamePunish = this.redNamePunish.kdClone();
		dbRole.dayNpcPrayTimes = new HashMap<>(this.dayNpcPrayTimes);
		dbRole.dayNpcCpoyTimes = new HashMap<>(this.dayNpcCpoyTimes);
		dbRole.master = this.master.kdClone();
		dbRole.payRankLogs = new ArrayList<>(this.payRankLogs.values());
		return dbRole;
	}

	public DBRoleShare copyDBRoleShareWithoutLock()
	{
		return this.share.toDB();
	}
	
	public DBMailBox copyDBMailBoxWithoutLock()
	{
		return this.mailbox.toBDWithouLock();
	}

	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// public List<SBean.DBEquipPart> createNewRoleWearParts()
	// {
	// List<SBean.DBEquipPart> wearParts = new ArrayList<SBean.DBEquipPart>();
	// for (int i = 0; i < 8; ++i)
	// wearParts.add(createDefaultWearPart(i+1));
	// return wearParts;
	// }
	//
	// private SBean.DBEquipPart createDefaultWearPart(int wearId)
	// {
	// SBean.EquipSlotCFGS slotCfg =
	// GameData.getInstance().getEquipSlotCFG(wearId);
	// if (slotCfg == null)
	// return null;
	// List<Integer> partSlots = new ArrayList<Integer>();
	// for (int s = 0; s < slotCfg.slot.size(); ++s)
	// {
	// partSlots.add(0);
	// }
	// return new SBean.DBEquipPart(wearId, 0, 0, partSlots);
	// }

	public Map<Integer, SBean.DBWearEquip> createNewRoleWearEquips(int classType)
	{
		TreeMap<Integer, SBean.DBWearEquip> wearEquips = new TreeMap<Integer, SBean.DBWearEquip>();
		SBean.ClassRoleCFGS crCfg = GameData.getInstance().getClassRoleCFG(classType);
		for (int i = 0; i < crCfg.initEquips.size(); ++i)
		{
			int wid = i + 1;
			int eid = crCfg.initEquips.get(i);
			SBean.DBEquip equip = GameData.getInstance().createNewEquip(eid, 0);
			wearEquips.put(wid, new SBean.DBWearEquip(wid, equip));
		}
		return wearEquips;
	}

	public Map<Integer, SBean.DBSkill> createNewRoleSkills(int classType)
	{
		Map<Integer, SBean.DBSkill> skills = new TreeMap<Integer, SBean.DBSkill>();
		SBean.ClassRoleCFGS crCfg = GameData.getInstance().getClassRoleCFG(classType);
		for (int s : crCfg.skills)
		{
			SBean.SkillCFGS sCfg = GameData.getInstance().getSkillCFG(s);
			SBean.SkillLevelCFGS slCfg = GameData.getSkillLevelCFG(sCfg, 1);
			if (slCfg.common.roleLvlReq <= 1)
				skills.put(s, new SBean.DBSkill(s, 1, 0));// 初始只添加能解锁的技能
		}
		return skills;
	}

	public SBean.DBWeaponTask createNewRoleWeaponTask(int now)
	{
		SBean.DBWeaponTask weaponTask = new SBean.DBWeaponTask(0, 1, new ArrayList<Integer>(), 0, now);
		SBean.WeaponTaskCFGS weaponTaskCfg = GameData.getInstance().getWeaponTaskCFG(weaponTask.type, weaponTask.id);
		for (int i = 0; i < weaponTaskCfg.conds.size(); ++i)
		{
			weaponTask.values.add(0);
		}
		return weaponTask;
	}

//	public List<SBean.DBPetData> InitRolePetData(List<SBean.DBPetData> dbpets)
//	{
//		List<SBean.DBPetData> petsdata = new ArrayList<SBean.DBPetData>(dbpets);
//		List<SBean.PetCFGS> petcfgs = GameData.getInstance().getAllPetsCFG();
//		for (int i = dbpets.size() + 1; i <= petcfgs.size(); ++i)
//		{
//			SBean.PetCFGS petcfg = petcfgs.get(i - 1);
//			SBean.PetTaskCFGS petTaskCFGS = GameData.getInstance().getNextPetTaskCFG(1, petcfg.taskType);
//			petsdata.add(new SBean.DBPetData(petcfg.id, 0, new SBean.DBPetTask(petTaskCFGS.id, 0)));
//		}
//		return petsdata;
//	}

	public Map<Integer, SBean.DBShop> createNewRoleShopData()
	{
		Map<Integer, SBean.DBShop> shops = new TreeMap<Integer, SBean.DBShop>();
		int shopTypeCount = GameData.getInstance().getShopTypeCount();
		for (int i = 1; i <= shopTypeCount; ++i)
		{
			shops.put(i, createNewShop(i));
		}
		return shops;
	}
	
	public Map<Integer, SBean.DBGambleShop> createNewRoleGambleShopData()
	{
		Map<Integer, SBean.DBGambleShop> shops = new TreeMap<Integer, SBean.DBGambleShop>();
		int shopTypeCount = GameData.getInstance().getGambleShopTypeCount();
		for (int i = 1; i <= shopTypeCount; ++i)
		{
			shops.put(i, createNewGambleShop(i));
		}
		return shops;
	}

	public Map<Integer, SBean.DBDailyTask> createNewDailyTaskData()
	{
		Map<Integer, SBean.DBDailyTask> dailyTasks = new TreeMap<Integer, SBean.DBDailyTask>();
		for (SBean.DailyTaskCFGS e : GameData.getInstance().getAllDailyTasks())
		{
			dailyTasks.put(e.id, new SBean.DBDailyTask(e.id, 0, 0));
		}
		return dailyTasks;
	}

	public SBean.DBOfflineWizard createNewOfflineWizardData()
	{
		int now = GameTime.getTime();
		Map<Integer, Integer> defaultPetsMap = new HashMap<>();
		int defaultPet = 1;
		for (SBean.WizardPetCFGS petCFGS : GameData.getInstance().getWizardPetCFGSs())
		{
			if ((petCFGS.channels.isEmpty() || petCFGS.channels.contains(this.register.id.channel)) && petCFGS.defaultHave == 1)
			{	
				defaultPetsMap.put(petCFGS.petId, petCFGS.defaultTime == -1 ? -1 : now + petCFGS.defaultTime);
				if (defaultPet == 1 && !petCFGS.channels.isEmpty())
					defaultPet = petCFGS.petId;
			}
		}
		return new SBean.DBOfflineWizard(1, 0, 0, 0, defaultPetsMap, defaultPet);
	}

	public SBean.DBRoleSectData createNewRoleSectData()
	{
		int worshipTypeCount = GameData.getInstance().getSectWorshipTypeCount();
		List<Integer> dayWorshipTimes = new ArrayList<Integer>();
		for (int i = 0; i < worshipTypeCount; ++i)
		{
			dayWorshipTimes.add(0);
		}
		List<Integer> dayBanquetOpenTimes = new ArrayList<Integer>();
		for (int i = 0; i < 2; ++i)
		{
			dayBanquetOpenTimes.add(0);
		}
		List<Integer> dayBanquetJoinTimes = new ArrayList<Integer>();
		for (int i = 0; i < 2; ++i)
		{
			dayBanquetJoinTimes.add(0);
		}
		SBean.RoleSectData data = new SBean.RoleSectData(0, 0, dayWorshipTimes, dayBanquetOpenTimes, dayBanquetJoinTimes, new TreeMap<Integer, Integer>(), 0, 0, 0, 0, (byte) 0, new SBean.SectBrief(0, "", (byte) 0, (short) 0, 0));
		SBean.RoleSectTask task = new SBean.RoleSectTask(0, 0, 0, new TreeMap<Integer, SBean.SectTask>(), new TreeMap<Integer, SBean.SectFinishedSelfTask>(), new TreeMap<Integer, SBean.SectFinishedSharedTask>(), new SBean.SectReceivedTask(new SBean.SectTask(0, 0), 0, 0, "", 0), 0);
		return new SBean.DBRoleSectData(data, task, 0, 0);
	}

	public RoleArena createNewRoleArenaData()
	{
		SBean.RoleNormalArenaData normalArenaData = new SBean.RoleNormalArenaData(0, 0, 0, 0, 0, new ArrayList<>(), 0, 0, 0, GameData.getInstance().getArenaCFGS().rankMax, new ArrayList<>(), new ArrayList<SBean.DBRoleArenaLog>(), 0, 0, (byte)0, 0);

		int timeNow = GameTime.getTime();
		int week = GameData.getWeekByRefreshTimeOffset(timeNow);
		SBean.RoleSuperArenaData superarenaData = new SBean.RoleSuperArenaData(0, week, 0, 0, new HashMap<Integer, SBean.SuperArenaLog>(), new HashSet<>(), 0);

		SBean.RoleBWArenaData bwarenaData = new SBean.RoleBWArenaData(0, 0, 0, 0, new HashSet<>(), 1, 0, 0, 0, new HashMap<>(), week, new ArrayList<>(), 0);
		return new RoleArena().fromDBData(new SBean.DBRoleArenaData(normalArenaData, superarenaData, bwarenaData, 0));
	}

	private void initSuperArena()
	{
		for(SBean.SuperArenaLog log: this.arenaInfo.roleArenaData.superarena.logs.values())
		{
			log.padding = 0;
			if(log.elo == 0)
				log.elo = GameData.getInstance().getSuperArenaCFGS().orgELO;
		}
	}
	
	public RoleClimbTower createNewRoleClimbTowerData()
	{
		SBean.DBClimbTower climbTowerData = new SBean.DBClimbTower(0, 0, new HashSet<>(), new HashSet<>(), new HashMap<>());
		Map<Integer, SBean.DBClimbTowerRecordData> climbTowerRecordData = new HashMap<>();
		Map<Integer, SBean.DBClimbTowerFame> climbTowerFameData = new HashMap<>();
		Map<Integer, SBean.ClimbTowerFameCFGS> fameCfg = GameData.getInstance().getClimbTowerFameDatas();
		for (int groupId : fameCfg.keySet())
		{
			SBean.DBClimbTowerFame fameData = new SBean.DBClimbTowerFame(1, 0, new HashSet<>());
			climbTowerFameData.put(groupId, fameData);
		}
		return new RoleClimbTower().fromDBData(climbTowerData, climbTowerRecordData, climbTowerFameData);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public SBean.RoleBrief getRoleBriefWithoutLock()
	{
		return new SBean.RoleBrief(this.getRoleOverviewWithoutLock(), this.getRoleModelWithoutLock());
	}

	public SBean.RoleOverview getRoleOverviewWithoutLock()
	{
		return new SBean.RoleOverview(this.id, this.name, this.gender, this.headIcon, this.classType, this.transformLevel, this.BWType, this.level, this.roleProperties.getRoleFightPower());
	}

	public SBean.RoleModel getRoleModelWithoutLock()
	{
		Map<Integer, Integer> equips = this.wearEquips.values().stream().collect(Collectors.toMap(e -> e.wid, e -> e.equip.id));
		List<SBean.EquipPart> equipParts = this.wearParts.stream().map(e -> new SBean.EquipPart(e.id, e.eqGrowLvl, e.eqEvoLvl)).collect(Collectors.toList());
		return new SBean.RoleModel(this.face, this.hair, equips, equipParts, new HashMap<>(this.fashionEquip.curFashions), new HashMap<>(this.showFashionTypes), 
								   getArmorBriefWithoutLock(this.armor.allArmors, this.armor.curArmor), getHeirloomBriefWithoutLock(this.heirloomData));
	}
	
	public static SBean.HeirloomBrief getHeirloomBriefWithoutLock(SBean.DBHeirloom data)
	{
		return new SBean.HeirloomBrief(data.display, data.perfectDegree);
	}
	
	public static SBean.ArmorBrief getArmorBriefWithoutLock(List<SBean.ArmorData> armors, int type)
	{
		if(type <= 0 || type > armors.size())
			return new SBean.ArmorBrief(0, 0);
		
		return new SBean.ArmorBrief(type, armors.get(type - 1).rank);
	}
	
	public SBean.RoleProfile getRoleProfileWithoutLock()
	{
		return new SBean.RoleProfile(this.getRoleOverviewWithoutLock(), this.gameMapContext.getCurMapContext().getHp(), this.gameMapContext.getCurMapContext().getHpMax());
	}

	public SBean.RoleFeature getRoleFeatureWithoutLock()
	{
		return new SBean.RoleFeature(this.getRoleOverviewWithoutLock(), this.getRoleWearDetailWithoutLock(), this.getRolePropertiesWithoutLock(), this.getRolePowerDetailWithoutLock(), this.getRoleAchievementWithoutLock(), this.getRoleRelationshipWithoutLock());
	}
	
	public SBean.RoleRelationship getRoleRelationshipWithoutLock()
	{
		return new SBean.RoleRelationship(new String(this.sectData.data.sectBrief.sectName), new String(this.marriageData.partnerName));
	}
	
	public SBean.RoleWearDetail getRoleWearDetailWithoutLock()
	{
		return new SBean.RoleWearDetail(this.face, this.hair, new HashMap<>(this.fashionEquip.curFashions), new HashMap<>(this.showFashionTypes), this.sealData.kdClone(), Stream.clone(this.wearEquips), Stream.clone(this.wearParts), getArmorBriefWithoutLock(this.armor.allArmors, this.armor.curArmor), getHeirloomBriefWithoutLock(this.heirloomData));
	}

	public Map<Integer, Integer> getRolePropertiesWithoutLock()
	{
		return this.roleProperties.getRoleProperties();
	}

	public SBean.RolePowerDetail getRolePowerDetailWithoutLock()
	{
		return this.roleProperties.getRolePowerDetail();
	}

	private int getSkillsLevelSum()
	{
		int sum = 0;
		for (SBean.DBSkill skill : skills.values())
		{
			sum += skill.level;
		}
		return sum;
	}
	
	private int getSpiritLevelSum()
	{
		int sum = 0;
		for(SBean.DBSpirit spirit : spirits.values())
		{
			sum += spirit.level;
		}
		return sum;
	}
	
	private int getWeaponStarSum()
	{
		int sum = 0;
		for(SBean.DBWeapon w: weapons.values())
			sum += w.star;
		
		return sum;
	}
	
	private int getUskillLevel()
	{
		SBean.DBSkill skill = this.skills.get(this.curUniqueSkill);
		if (skill == null)
			return 0;
		return skill.level;
	}

	public SBean.RoleAchievement getRoleAchievementWithoutLock()
	{
		return new SBean.RoleAchievement(this.weapons.size(), this.activePets.size(), this.treasuremapInfo.info.medals.size(), this.getSkillsLevelSum(), this.getSpiritLevelSum(), this.getUskillLevel());
	}

	public SBean.FightRole getMapFightRoleWithoutLock()
	{
		return new SBean.FightRole(this.getBasePlayerWithoutLock(), this.name, this.gender, this.headIcon, this.face, this.hair, 
								   new ArrayList<>(this.curSkills), this.curUniqueSkill, this.curWeapon, this.getCurDIYSkillData(), 
								   this.sectData.data.sectBrief.kdClone(), this.roleProperties.getRoleFightPower(), new HashMap<>(this.showFashionTypes), this.heirloomData.display);
	}

	public SBean.PetOverview getPetOverviewWithoutLock(int pid)
	{
		SBean.DBPet pet = this.activePets.get(pid);
		if (pet == null)
			return null;
		
		return new SBean.PetOverview(pet.fightPet.id, pet.fightPet.level, pet.fightPet.star, pet.fightPet.fightPower);
	}

	public synchronized List<SBean.PetOverview> getPetOverviews()
	{
		return this.activePets.values().stream().map(DBRole::getPetOverview).collect(Collectors.toList());
	}

	public synchronized List<SBean.WeaponOverview> getWeaponOverviews()
	{
		return this.weapons.values().stream().map(DBRole::getWeaponOverview).collect(Collectors.toList());
	}

	public SBean.PetHost getMapPetHostWithoutLock()
	{
		return this.roleProperties.getMapPetHost();
	}

	public SBean.FightPet getMapFightPetWithoutLock(int pid)
	{
		SBean.DBPet pet = this.activePets.get(pid);
		if (pet == null)
			return null;
		
		return pet.fightPet.kdClone();
	}

	public Map<Integer, SBean.FightPet> getWorldMapFightPets()
	{
		return getMapFightPetsWithoutLock(this.worldMapPets);
	}
	
	public Map<Integer, SBean.FightPet> getMapFightPetsWithoutLock(Set<Integer> pids)
	{
		Map<Integer, SBean.FightPet> pets = new TreeMap<>();
		for (Integer pid : pids)
		{
			SBean.FightPet pet = this.getMapFightPetWithoutLock(pid);
			if (pet != null)
				pets.put(pet.id, pet);
		}
		return pets;
	}

	//竞技场对手的佣兵防守阵容
	public List<SBean.PetOverview> getMapPetsOverivewWithoutLock(List<Integer> pids)
	{
		List<SBean.PetOverview> pets = new ArrayList<>();
		for (Integer pid : pids)
		{
			SBean.PetOverview pet = this.getPetOverviewWithoutLock(pid);
			if (pet != null)
			{
				pets.add(pet);
				if(this.arenaInfo.roleArenaData.normal.hideDefence == 1)
					pet.id = 0;
			}
		}
		return pets;
	}
	
	public Map<Integer, SBean.PetOverview> getMapPetsOverivewWithoutLock(Set<Integer> pids)
	{
		Map<Integer, SBean.PetOverview> pets = new TreeMap<Integer, SBean.PetOverview>();
		for (Integer pid : pids)
		{
			SBean.PetOverview pet = this.getPetOverviewWithoutLock(pid);
			if (pet != null)
				pets.put(pet.id, pet);
		}
		return pets;
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public synchronized SBean.RoleProfile getRoleProfile()
	{
		return this.getRoleProfileWithoutLock();
	}

	public synchronized SBean.RoleBrief getRoleBrief()
	{
		return this.getRoleBriefWithoutLock();
	}

	public synchronized SBean.RoleOverview getRoleOverview()
	{
		return this.getRoleOverviewWithoutLock();
	}
	
	private boolean masterIsOnline()
	{
		return netsid != 0;
	}
	
	public SBean.MasterDetail getMasterDetail()
	{
		String announce = gs.getMasterManager().getAnnounce(id);
		if( announce == null )
			announce = "";
		synchronized( this )
		{
			return new SBean.MasterDetail(this.getUseableVipLvl()
					, historyHighestPower, masterIsOnline(), master.apprentices.size(), announce
				, this.getRoleOverviewWithoutLock());
		}
	}
	
	public void masterNoticeBrief()
	{
		if( netsid == 0 || gs == null )
			return;
		SBean.master_brief_info_notice notice = null;		
		{
			notice = new SBean.master_brief_info_notice(master.master, 
					new ArrayList<Integer>(master.apprentices), 
					master.lastDismissTime, 
					master.lastBetrayTime);
		}
		gs.getRPCManager().sendStrPacket(netsid, notice);
	}
	
	public SBean.ApprenticeDetail getApprenticeDetail()
	{
		synchronized( this )
		{
			int historyActivity = master.tasks.stream()
				.filter(task->task.taskType == GameData.MASTER_GRADUATE_TASK_ACTIVITY)
				.mapToInt(task->task.taskProgress)
				.sum();
				
			
			return new SBean.ApprenticeDetail(
					master.historyPoint
					, historyActivity
					, masterIsOnline()
					, masterGetScore()
					, this.getRoleOverviewWithoutLock());
		}
	}

	public synchronized SBean.RoleSocial getRoleSocial()
	{
		return getRoleSocialWithoutLock();
	}
	
	public SBean.RoleSocial getRoleSocialWithoutLock()
	{
		return new SBean.RoleSocial(this.getRoleOverviewWithoutLock(), this.sectData.data.sectBrief.sectID, this.sectData.data.sectBrief.sectName, this.friend.getPersonalMsg());
	}
	
	public synchronized SBean.ForceWarJoin getForceWarJoin()
	{
		return new SBean.ForceWarJoin(this.getRoleOverviewWithoutLock(), this.forceWarInfo.forcewar.log.dayEnterTimes, this.forceWarInfo.forcewar.weekFeats, this.forceWarInfo.forcewar.rankClearTime);
	}
	
	public synchronized SBean.SuperArenaJoin getSuperArenaJoinInfo(int arenaType)
	{
		SBean.SuperArenaLog log = this.arenaInfo.roleArenaData.superarena.logs.get(arenaType);
		return new SBean.SuperArenaJoin(this.getRoleOverviewWithoutLock(), this.arenaInfo.roleArenaData.superarena.weekHonor, 
				this.arenaInfo.roleArenaData.superarena.historyPoint, this.arenaInfo.roleArenaData.superarena.rankClearTime, log != null ? log.elo : GameData.getInstance().getSuperArenaCFGS().orgELO);
	}
	
	public synchronized SBean.RoleFeature getRoleFeature()
	{
		return this.getRoleFeatureWithoutLock();
	}

	public synchronized SBean.FriendOverview getFriendOverview()
	{
		return new SBean.FriendOverview(this.getRoleOverviewWithoutLock(), this.friend.getPersonalMsg(), this.lastLogoutTime, (byte) 1);
	}

	public synchronized SBean.BattleEnemyOverview getArenaEnemyBattaleArrayOverview()
	{
		return new SBean.BattleEnemyOverview(new SBean.RoleSocial(this.getRoleOverviewWithoutLock(), this.sectData.data.sectBrief.sectID, this.sectData.data.sectBrief.sectName, this.friend.getPersonalMsg()), this.getMapPetsOverivewWithoutLock(this.arenaInfo.roleArenaData.normal.defencePets), this.arenaInfo.roleArenaData.normal.hideDefence);
	}
	
	public synchronized SBean.BattleArrayOverview getBattaleArrayOverview(Set<Integer> pets)
	{
		return new SBean.BattleArrayOverview(new SBean.RoleSocial(this.getRoleOverviewWithoutLock(), this.sectData.data.sectBrief.sectID, this.sectData.data.sectBrief.sectName, this.friend.getPersonalMsg()), this.getMapPetsOverivewWithoutLock(pets));
	}

	public synchronized SBean.BattleArrayOverview getArenaMapDefenceBattaleArrayOverview()
	{
		return new SBean.BattleArrayOverview(new SBean.RoleSocial(this.getRoleOverviewWithoutLock(), this.sectData.data.sectBrief.sectID, this.sectData.data.sectBrief.sectName, this.friend.getPersonalMsg()), this.getMapPetsOverivewWithoutLock(new TreeSet<>(this.arenaInfo.roleArenaData.normal.defencePets)));
	}

	public synchronized SBean.BattleArray getArenaMapDefenceBattleArray()
	{
		return new SBean.BattleArray(this.getMapFightRoleWithoutLock(), this.getMapFightPetsWithoutLock(new TreeSet<>(this.arenaInfo.roleArenaData.normal.defencePets)), new ArrayList<>(this.arenaInfo.roleArenaData.normal.defencePets));
	}

	public synchronized SBean.BattleArray getBWArenaMapBattleAray()
	{
		return new SBean.BattleArray(this.getMapFightRoleWithoutLock(), this.getMapFightPetsWithoutLock((this.arenaInfo.roleArenaData.bwarena.pets)), new ArrayList<>());
	}

	public synchronized SBean.BattleArrayOverview getBWArenaMapBattaleArrayOverview()
	{
		return new SBean.BattleArrayOverview(new SBean.RoleSocial(this.getRoleOverviewWithoutLock(), this.sectData.data.sectBrief.sectID, this.sectData.data.sectBrief.sectName, this.friend.getPersonalMsg()), this.getMapPetsOverivewWithoutLock(new HashSet<>(this.arenaInfo.roleArenaData.bwarena.pets)));
	}

//	public synchronized SBean.BattleArray getClanBattleMapDefenceBattleArray()
//	{
//		return new SBean.BattleArray(this.getMapFightRoleWithoutLock(), this.getMapFightPetsWithoutLock(new TreeSet<Integer>(this.clanData.battle.defendPet.values())));
//	}
//
//	public synchronized SBean.BattleArray getClanBattleMapAttackBattleArray()
//	{
//		return new SBean.BattleArray(this.getMapFightRoleWithoutLock(), this.getMapFightPetsWithoutLock(new TreeSet<Integer>(this.clanData.battle.attackPet.values())));
//	}

	public SBean.BasePlayer getBasePlayerWithoutLock()
	{
		return new SBean.BasePlayer(this.id, this.classType, this.transformLevel, this.BWType, this.level, GameData.getInstance().getCollectSuites(this.suites), 
									Stream.clone(this.wearEquips), Stream.clone(this.wearParts), Stream.clone(this.skills), Stream.clone(this.weapons), 
									Stream.clone(this.spirits), new HashSet<>(this.curSpirits), new TreeMap<Integer, Integer>(this.sectAuras), this.horseData.dbHorse.kdClone(), 
									new HashMap<Integer, Byte>(this.treasuremapInfo.info.medals), new HashMap<>(this.fashionEquip.curFashions), 
									Stream.clone(this.sealData), new HashMap<>(this.roleExpCoin.rarebookData.books), this.roleExpCoin.getGrasps(), 
									this.roleTitles.kdClone(), Role.getNewPetAchieves(this.activePets), getPetCoPractices(this.activePets), getArmorFightData(this.armor.allArmors, this.armor.curArmor), 
									new HashMap<>(this.itemGetProp), this.heirloomData.isOpen == 0 ? 0 : this.heirloomData.perfectDegree, this.marriageLevel, new HashMap<>(this.roleExpCoin.dmgTransfer.levels),
									this.activePets.values().stream().collect(Collectors.toMap((pet) -> pet.fightPet.id, (pet) -> pet.fightPet.star)), getSpecialCardAttrs(this.specialCards));
	}

	public static Map<Integer, Integer> getPetCoPractices(Map<Integer, SBean.DBPet> pets)
	{
		return pets.values().stream().filter(p -> p.fightPet.coPracticeLvl > 0).collect(Collectors.toMap(p -> p.fightPet.id, p -> p.fightPet.coPracticeLvl));
	}
	
	public SBean.DBDIYSkillData getCurDIYSkillData()
	{
		return Optional.<SBean.DBDiySkill> ofNullable(getCurDIYSkill()).map(s -> s.diySkillData).orElse(null);
	}

	public SBean.DBDiySkill getCurDIYSkill()
	{
		if (diySkillData.curSkillId == 0)
			return diySkillData.borrowDiySkill;
		else
		{
			if (diySkillData.curSkillId < 0 || diySkillData.curSkillId > diySkillData.diySkills.size())
				return null;
			SBean.DBDiySkill diySkill = diySkillData.diySkills.get(diySkillData.curSkillId - 1);
			if (diySkill == null)
				return null;
			return diySkill;
		}
	}

	//	public Map<Integer, SBean.FriendInfo> getAllFriendsInfo()
	//	{
	//		Map<Integer, SBean.FriendInfo> friends = new TreeMap<>();
	//		for (Map.Entry<Integer, SBean.DBFriend> e : this.friendData.friends.entrySet())
	//		{
	//			int fid = e.getKey();
	//			SBean.FriendOverview overview = this.friendsOverview.get(fid);
	//			if (overview != null)
	//			{
	//				friends.put(fid, new SBean.FriendInfo(overview, e.getValue(), this.friendData.friendAddSelf.contains(fid) ? 1 : 0));
	//			}
	//		}
	//		return friends;
	//	}
	//	private Map<Integer, SBean.DBBuff> getCurBuffs()
	//	{
	//		long now = GameTime.getTimeMillis();
	//		Map<Integer, SBean.DBBuff> curBuffs = new TreeMap<Integer, SBean.DBBuff>();
	//		Iterator<SBean.DBBuff> it = this.buffs.values().iterator();
	//		while (it.hasNext())
	//		{
	//			SBean.DBBuff dbBuff = it.next();
	//			if (now > dbBuff.endTime)
	//				it.remove();
	//			else
	//				curBuffs.put(dbBuff.buff.id, dbBuff);
	//		}
	//
	//		return curBuffs;
	//	}
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public static class RpcRes<T>
	{
		public final int errCode;
		public final T info;

		public RpcRes(int errCode, T info)
		{
			this.errCode = errCode;
			this.info = info;
		}

		public RpcRes(T info)
		{
			this.errCode = GameData.PROTOCOL_OP_SUCCESS;
			this.info = info;
		}

		public RpcRes(int errCode)
		{
			this.errCode = errCode;
			this.info = null;
		}
	}

	interface SaveRoleTransCallback
	{
		void onCallback(boolean ok);
	}

	public class SaveRoleTrans implements Transaction
	{
		public SaveRoleTrans(DBRoleShare dbRoleShare, DBRole dbRole, DBMailBox dbMailBox, DBMarriageShare dbMarriageShare, SaveRoleTransCallback callback)
		{
			this.dbRoleShare = dbRoleShare;
			this.dbRole = dbRole;
			this.dbMailBox = dbMailBox;
			this.dbMarriageShare = dbMarriageShare;
			this.callback = callback;
		}

		@Override
		public boolean doTransaction()
		{
			gs.getLogger().debug("save role " + dbRole.id + " to DB");
			if( ! gs.isMemroyDB() )
			{
				roleshare.put(dbRole.getUsername(), dbRoleShare);
				role.put(dbRole.id, dbRole);
				mail.put(dbRole.id, dbMailBox);
				if (dbMarriageShare != null)
					marriageshare.put(dbMarriageShare.id, dbMarriageShare);
			}
			return true;
		}

		@AutoInit
		public Table<String, DBRoleShare> roleshare;
		@AutoInit
		public Table<Integer, DBRole> role;
		@AutoInit
		public Table<Integer, DBMailBox> mail;
		@AutoInit
		public Table<Integer, DBMarriageShare> marriageshare;
		public final DBRoleShare dbRoleShare;
		public final DBRole dbRole;
		public final DBMailBox dbMailBox;
		public final DBMarriageShare dbMarriageShare;
		public SaveRoleTransCallback callback;

		@Override
		public void onCallback(ErrorCode errcode)
		{
			boolean ok = errcode == ErrorCode.eOK;
			if (ok)
				gs.getLogger().debug("save role " + dbRole.id + " to DB ok");
			else
				gs.getLogger().warn("save role " + dbRole.id + " to DB error " + errcode);
			if (this.callback != null)
				this.callback.onCallback(ok);
		}
	}

	public class SaveMailTrans implements Transaction
	{
		public SaveMailTrans(int roleID, DBMailBox dbMailBox)
		{
			this.roleID = roleID;
			this.dbMailBox = dbMailBox;
		}

		@Override
		public boolean doTransaction()
		{
			gs.getLogger().debug("save mails of " + roleID + " to DB");
			mail.put(roleID, dbMailBox);
			return true;
		}

		@AutoInit
		public Table<Integer, DBMailBox> mail;

		public final int roleID;
		public final DBMailBox dbMailBox;

		@Override
		public void onCallback(ErrorCode errcode)
		{
			if (errcode == ErrorCode.eOK)
			{
				gs.getLogger().info("save role " + roleID + " mail to DB ok");
			}
			else
			{
				gs.getLogger().error("save role " + roleID + " mail to DB error");
			}
		}
	}

	private void doSave(int now)
	{
		
		synchronized (this)
		{
			DBRoleShare dbroleshare = this.copyDBRoleShareWithoutLock();
			DBRole dbrole = this.copyDBRoleWithoutLock();
			DBMailBox dbmailbox = this.copyDBMailBoxWithoutLock();
			DBMarriageShare dbmarriage = this.copyDBSharedMarriage();
			gs.getDB().execute(new SaveRoleTrans(dbroleshare, dbrole, dbmailbox, dbmarriage, null), this.getUsername().hashCode());
			this.lastSaveTime = now;
			this.updateSharedMarriageUseTime(now);
		}

	}

	private void onlineSave(int timeTick)
	{
		this.lastOnlineTime = timeTick;
		this.doSave(timeTick);
	}

	public void save()
	{
		this.doSave(GameTime.getTime());
	}

	public void lock()
	{
		this.lock.lock();
	}

	public void unlock()
	{
		this.lock.unlock();
	}

	public void setClosed()
	{
		this.closed = true;
	}

	public boolean isClosed()
	{
		return this.closed == true;
	}

	public static class MultipleRoles
	{
		List<Role> list = new ArrayList<>();

		public MultipleRoles(Role... roles)
		{
			Collections.addAll(list, roles);
			Collections.sort(list);
		}
		
		public MultipleRoles(Collection<Role> roles)
		{
			list.addAll(roles);
			Collections.sort(list);
		}
		
		public void lock()
		{
			for (Role role : list)
			{
				role.lock();
			}
		}

		public void unlock()
		{
			for (Role role : list)
			{
				role.unlock();
			}
		}

		public boolean isClosed()
		{
			for (Role role : list)
			{
				if (role.isClosed())
					return true;
			}
			return false;
		}

	}

	private void onSecondTask(int timeTick)
	{
		this.tryRefreshVit(timeTick);
		this.updatePKValue(timeTick);
		this.tryUseHpPool(timeTick);
		this.tryRefreshSplitSP(timeTick);
		this.tryRefreshDailyOnlineTime(timeTick);
		this.updateAlterState(timeTick);
		this.tryUpdateRoleTitles(timeTick);
		this.checkForceWar(timeTick);
		this.tryAddDemonHoleExp(timeTick);
		this.tryRefreshWizardPet();
		this.checkRedNamePunish(timeTick);
		/*if(timeTick % 5 == 0)
		{
			gs.getLogger().debug("role " + this.name + " map [" + this.gameMapContext.getCurMapId() + " , " + this.gameMapContext.getCurMapInstance() + "] " + GameData.toString(this.gameMapContext.getCurMapPosition()));
		}*/
	}

	private void onMinuteTask(int timeTick)
	{
		if (timeTick % ROLE_RAND_INTERVAL_MAX == this.randTick)
		{
			this.tryDayRefresh(timeTick);
			this.tryRefreshDiySkil(timeTick);
			this.tryReceiveMail();
			this.tryTestNotice();
			this.trySyncRollNotice(false);
			this.tryClearDiamondReviveTime(timeTick);
			this.tryReceiveMissVit(timeTick);
//			this.tryTestBetaActivityNotice();
			this.tryTestSurveyNotice();
			this.onlineUpdate(timeTick);
			this.tryTestLucklyStar();
			
			gs.getLoginManager().updateRoleSpeedLvl(this, this.speedUpLvl);
		}
	}
	
	private void tryTestLucklyStar()
	{
		if (this.lucklyStar.needNotice == 1)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.lucklystar_push());
			this.lucklyStar.needNotice = 0;
		}
	}

	private void onQuarterTask(int timeTick)
	{
		if (timeTick % ROLE_RAND_QUARTER_MAX == this.randQuarterTick)
		{
			this.updateLevelRanks();
			this.tryUpdateSpecialCard(timeTick);
		}
	}

//	private void tryNotifyOnTimeReward()
//	{
//		int nowtimer = GameTime.getSecondOfDay();
//		if (nowtimer - GameData.getInstance().getBetaActivity().onTimeStartTime < 60 || nowtimer - GameData.getInstance().getBetaActivity().onTimeEndTime < 60)
//			tryTestBetaActivityNotice();
//	}

	public boolean onTimer(int timeTick)
	{
		boolean needSave = false;
		synchronized (this)
		{
			if (checkState(timeTick))
				return true;

			if (this.state == ROLE_STATE_ONLINE)
			{
				this.onSecondTask(timeTick);
				this.onMinuteTask(timeTick);
				this.onQuarterTask(timeTick);
			}
			needSave = this.lastSaveTime + SAVE_ROLE_INTERVAL_MIN <= timeTick;
		}

		if (needSave)
			onlineSave(timeTick);
		
		return false;
	}

	public synchronized boolean checkSessionID(int sid)
	{
		return netsid == sid || loginnetsid == sid;
	}

	public synchronized void onDisconnect(int sid)
	{
		if (netsid == sid || loginnetsid == sid)
		{
			netsid = 0;
			loginnetsid = 0;
			disconnectTime = GameTime.getTime();
			state = ROLE_STATE_LEAVE;
			this.gameMapContext.setMapRoleReady(false);
			notifyTeamMemberUpdateConnectionState(0);
			notifyMRoomMemberUpdateConnectionState(0);
			notifyARoomMemberUpdateConnectionState(0);
			notifyFRoomMemberUpdateConnectionState(0);
			gs.getLogger().debug("role " + id + " disconnect leave game ...");
		}
	}

	public synchronized int changeSessionID(int sid)
	{
		int oldsid = netsid > 0 ? netsid : loginnetsid;
		netsid = 0;
		loginnetsid = sid;
		state = ROLE_STATE_ONLINE;
		this.gameMapContext.setMapRoleReady(false);
		notifyTeamMemberUpdateConnectionState(sid);
		notifyMRoomMemberUpdateConnectionState(sid);
		notifyARoomMemberUpdateConnectionState(sid);
		notifyFRoomMemberUpdateConnectionState(sid);
		return oldsid;
	}
	
	private synchronized void renewSessionID()
	{
		this.netsid = this.loginnetsid;
		this.loginnetsid = 0;
	}

	private boolean checkState(int timeTick)
	{
		switch (state)
		{
		case ROLE_STATE_ONLINE:
			break;
		case ROLE_STATE_LEAVE:
			if (this.disconnectTime + MAX_DISCONNECT_TIME < timeTick)
			{
				this.state = ROLE_STATE_STANDBY;
				this.clearMulRole();
				gs.getMapService().syncRoleUpdateActive(this.id, this.gameMapContext.getCurMapId(), false);
			}
			break;
		case ROLE_STATE_STANDBY:
			if (this.disconnectTime + MAX_STANDBY_TIME < timeTick)
			{
				this.state = ROLE_STATE_EXIT;
			}
			break;
		case ROLE_STATE_EXIT:
			break;
		default:
			break;
		}
		return this.state == ROLE_STATE_EXIT;
	}

	public boolean isOnline()
	{
		return this.state == ROLE_STATE_ONLINE;
	}

	private synchronized void updateLoginTime(int now)
	{
		this.lastLoginTime = now;
	}

	private synchronized int updateLogoutTime(int now)
	{
		int onlineTime = now - this.lastLoginTime;
		this.lastLogoutTime = now;
		this.lastOnlineTime = now;
		this.totalOnlineTime += onlineTime;
		return onlineTime;
	}

	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public void tryDayRefresh(int now)
	{
		if (this.dayRefresh(now))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_day_refresh());
			for (SBean.DBPet pet : this.activePets.values())
			{
				if(pet.task.id != 0 && pet.task.value ==0)
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_new_pet_task(pet.fightPet.id, pet.task.id));
			}
			
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.grasp_dayforture_refresh(this.roleExpCoin.graspData.dayFortune));
			this.notifyRefreshMrgTask();
		}
	}
	
	void dayRefreshMrgTask(int now)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return;
		
		marriage.dayRefresh(now);
	}
	
	void notifyRefreshMrgTask()
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return;
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_mrgtask(marriage.getTask().kdClone()));
		Role partner = getTeamMrgPartner(marriage);
		if(partner != null)
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrgtask(marriage.getTask().kdClone()));
	}
	
	private synchronized void loginNotice()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_leadinfo(new HashSet<>(this.leadInfo)));
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_leadplot(new HashMap<>(this.leadPlot)));
		if(this.isTreasureGuide == 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_treasureguide(this.isTreasureGuide));
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_rmactivity(this.rmactivity));
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_team(this.team.kdClone()));
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_mroom(this.room.kdClone()));
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_superarena(this.getARoom(), this.superarenaState, this.superarenaJoinTime, this.superarenaJoinType, this.arenaInfo.roleArenaData.superarena.weekHonor, this.arenaInfo.roleArenaData.superarena.historyPoint));
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_forcewar(this.forceWarInfo.joinTime, this.forceWarInfo.joinType, this.forceWarInfo.forcewar.weekFeats, this.forceWarInfo.forcewar.totalFeats, this.forceWarInfo.forcewar.punishEndTime, this.froom.kdClone()));
		
		if(mailbox.isTempMailFull())
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_tempmail_full());
		
		int weaponNpc = this.weaponUSkill.getNpc();
		if(weaponNpc > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_weapon_npc(weaponNpc));
		
		this.tryTestFirstPayGiftCompleted();
		this.tryTestNotice();
//		this.tryTestBetaActivityNotice();
		this.tryTestSurveyNotice();
		this.trySyncRollNotice(true);
		this.updateRanks();
		this.syncMarriageInfo();
		this.masterNoticeBrief();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sync_prestige_num(gs.getEmergencyManager().getRolePrestige(this.id)));
	}
	
	public void tryTestNotice()
	{
		int notice = testNotice();
		if (notice != 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_notice(notice));
	}

	public void tryTestBetaActivityNotice()
	{
//		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed || GameData.getOffsetDaysToNow(gs.getOpenTime()) + 1 > GameData.getInstance().getBetaActivityDay())
//		{
//			return;
//		}
//		if (!GameData.getInstance().testMainTaskFinished(GameData.getInstance().getBetaActivity().notifyTaskId, this.mainTask.id, this.BWType))
//		{
//			return;
//		}
//		int notice = testBetaActivityNotice();
//		int ifFirstLogin = (GameData.getDayByRefreshTimeOffset(GameTime.getTime()) != GameData.getDayByRefreshTimeOffset(this.lastLoginTime)) ? 1 : 0;
//		if (notice > 0 || ifFirstLogin == 1 || this.showWebLink != gs.getConfig().showWebLink)
//		{
//			this.showWebLink = gs.getConfig().showWebLink;
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_betaactivity_notice(notice, ifFirstLogin, this.showWebLink));
//		}
	}
	
	public void tryTestSurveyNotice()
	{
		if (this.testSurvey())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_survey_notice(1));
		}
	}

	public int testBetaActivityNotice()
	{
		int notice = 0;
//		if (this.testSurvey())
//			notice |= (0x01 << 0);
		if (this.testDailyLogin())
			notice |= (0x01 << 1);
		if (this.testLvlUpRewards())
			notice |= (0x01 << 2);
		if (this.testUseinfo())
			notice |= (0x01 << 3);
		if (this.testLastBetaActivity())
			notice |= (0x01 << 4);
		if (this.testOnTimeReward())
			notice |= (0x01 << 5);
		if (this.testStrengthenReward())
			notice |= (0x01 << 6);
		if (this.testOfficialResearch())
			notice |= (0x01 << 7);
		return notice;
	}

	private boolean testStrengthenReward()
	{
		int curstrengthen = 0;
		for(SBean.DBEquipPart part : this.wearParts)
		{
			curstrengthen += part.eqGrowLvl;
		}
		return this.share.testStrengthenReward(curstrengthen);
	}

	private boolean testLastBetaActivity()
	{
		int lastBetaDay = GameData.getOffsetDaysToNow(gs.getOpenTime()) - GameData.getInstance().getBetaActivity().lastBetaStartDay + 2;
		if (lastBetaDay <= 0)
			return false;
		Set<Integer> lastBetaDays = GameData.getInstance().getBetaActivity().lastBetaReward.keySet();
		for (Integer k : lastBetaDays)
		{
			if (k <= lastBetaDay && this.share.testLastBetaReward(k))
				return true;
		}
		return false;
	}
	
	private boolean testUseinfo()
	{
		return gs.getConfig().showWebLink == 1 && share.testUseinfo(this.level);
	}

	private boolean testLvlUpRewards()
	{
		return share.testLvlUpRewards(this.level);
	}

	private boolean testDailyLogin()
	{
		return share.testDailyLogin(GameData.getOffsetDaysToNow(gs.getOpenTime()) + 1);
	}

	private boolean testOnTimeReward()
	{
		return share.testOnTimeReward(GameData.getOffsetDaysToNow(gs.getOpenTime()) + 1);
	}

	private boolean testSurvey()
	{
		return gs.getConfig().showWebLink == 1 && share.testSurvey(this.level);
	}

	private boolean testOfficialResearch()
	{
		return gs.getConfig().showWebLink == 1 && share.testOfficialResearch();
	}

	public int testNotice()
	{
		int notice = 0;
		if (this.testNewMail())
			notice |= (0x01 << 0);
		if (this.testDailyTasks())
			notice |= (0x01 << 1);
		if (this.testChallengeTask())
			notice |= (0x01 << 2);
		if (this.testBenefit())
			notice |= (0x01 << 3);
		if (this.testArenaScoreReward())
			notice |= (0x01 << 4);
		if (this.testFirstPayGiftActivity())
			notice |= (0x01 << 5);
		if (this.testLuckyWheel())
			notice |= (0x01 << 6);
		if (this.testFame())
			notice |= (0x01 << 7);
		if (this.testVipReward())
			notice |= (0x01 << 8);
		if(this.testGroupBuyActivity())
			notice |= (0x01 << 9);
		if(this.testCanBuyGroupBuy())
			notice |= (0x01 << 10);
        if(this.testFlashSaleActivity())
            notice |= (0x01 << 11);
		if (this.testCanBuyFlashSale())
		    notice |= (0x01 << 12);
		if (this.testFightNpc())
			notice |= (0x01 << 13);
		if (this.testLuckRollerActiveity())
			notice |= (0x01 << 14);
		if (this.testPayActivity())
			notice |= (0x01 << 15);
		if (this.masterTestNotice())
			notice |= (0x01 << 16);
		
		return notice;
	}

	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    /**
	 * @param where 0: new user create role 1: old user load from db 2: old user load
	 * from memory
	 */
	public void login(SBean.UserLoginInfo loginInfo, int where)
	{
		int now = GameTime.getTime();
		this.loginInfo = loginInfo;
		this.dcRole = new TLogger.DCRole(gs, this);
		
		if (where == Role.ROLE_NEW)
		{
			this.syncNewRoleSysMail();
			gs.getTLogger().logCreateRole(this, loginInfo);
		}
		
		this.onLoadOk(now, loginInfo, where);
		this.checkPatckPacket(loginInfo.client.patchPackets);
		this.enterGame(now, where);

		//gs.getClanService().onRoleLogin(this);
		
		this.loginNotice();
		gs.getLoginManager().updateLevelRoleCache(this.id, this.level);
		
		gs.getArenaManager().roleAttacked(this);
		gs.getSectManager().onRoleLogin(this);
		gs.getBWArenaManager().updateBWArenaLvlRoleCache(this);
		gs.getLoginManager().updateRoleSpeedLvl(this, -1);
		gs.getLoginManager().tryNotifyMarriageBespeak(this);
		gs.getLoginManager().tryNotifyMarriagePartner(this);
		gs.getSteleManager().tryRefreshRoleStele(this);
		gs.getTLogger().logRoleLogin(this, where, now);
		
		if(where==Role.ROLE_NEW)
		{
		    gs.getTLogger().logMainTaskFlow(this, mainTask.id, mainTask.state, TLog.TASKEVENT_TAKE);
		}
		
		//Attention ! updateLoginTime function called must below logRoleLogin called, role.lastLoginTime used by log function
		updateLoginTime(now);
	}

	public void onlineUpdate(int now)
	{
		this.lastOnlineTime = now;
		gs.getLoginManager().addNormalTaskEvent(new Runnable()
		{
			@Override
			public void run()
			{
				gs.getSectManager().onRoleOnlineUpdate(Role.this);
			}
		});
	}
	
	public void logout(int now)
	{
		this.clearState();
		int onlineTime = updateLogoutTime(now);
		gs.getTLogger().logRoleLogout(this, onlineTime);

		gs.getSectManager().onRoleLogout(this);

		this.doSave(now);
	}
	
	private void clearState()
	{
		this.clearMulRole();
		this.leaveGame();
		this.leaveTeam();
		this.leaveMRoom();
		this.superarenaQuit(null);
		this.leaveARoom();
		this.roleQuitForceWar(null);
		this.leaveFRoom();
		if(this.team.id < 0)
		{
			this.onTeamMemberLeave(this);
		}
	}
	
	// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private synchronized void onLoadOk(int timeNow, SBean.UserLoginInfo loginInfo, int where)
	{
		this.onDebug(timeNow);
		this.dayRefresh(timeNow);
		this.resetDailyOnlineTimeRecord(timeNow);
		this.tryRefreshVit(timeNow);
		this.tryClearDiamondReviveTime(timeNow);
		this.tryReceiveMail();
		this.logLoginOnLoginGift(timeNow);
		this.tryReceiveVipMissVitOnlogin(timeNow);
		this.tryUpdateSpecialCardImpl(timeNow);
		if (where == Role.ROLE_LOAD_FROM_DB)
		{
			this.logOfflineExp(timeNow);
			this.updateLevelLimit();
			this.updateMarriageLevel();
			this.updateRedNamePunish();
		}
		
		if (where != Role.ROLE_LOAD_FROM_MEMORY)
		{
			this.initTrigSpawnPoint();
			this.initTaskDrop();
		}
	}
	
	private void checkPatckPacket(Set<Integer> clientPackets)
	{
		if(!checkRoomMapIDInPatchPacket(clientPackets))
			this.leaveMRoom();
		
		if(!checkSuArenaJoinMapInPatchPacket(clientPackets))
		{
			this.superarenaQuit(null);
			this.leaveARoom();
		}
		
		if(!checkForceWarJoinMapInPatchPacket(clientPackets))
		{
			this.roleQuitForceWar(null);
			this.leaveFRoom();
		}
			
		synchronized(this)
		{
			if(!this.checkMapInPatchPacket(clientPackets, this.gameMapContext.getCurMapId(), "cur"))
			{
				this.clearMulRole();
				this.gameMapContext.setRoleToBirthMap();
			}
		}
	}
	
	private synchronized boolean checkRoomMapIDInPatchPacket(Set<Integer> clientPackets)
	{
		if(this.room.mapId > 0)
			return checkMapInPatchPacket(clientPackets, this.room.mapId, "map room");
		
		return true;
	}
	
	private synchronized boolean checkSuArenaJoinMapInPatchPacket(Set<Integer> clientPackets)
	{
		if(this.superarenaState > 0)
		{
			SBean.SuperArenaTypeCFGS typeCfg = GameData.getInstance().getSuperArenaTypeCFG(this.superarenaJoinType);
			if(typeCfg != null)
				return checkMapInPatchPacket(clientPackets, typeCfg.mapID, "super arena");
		}
		return true;
	}
	
	private synchronized boolean checkForceWarJoinMapInPatchPacket(Set<Integer> clientPackets)
	{
		if(this.forceWarInfo.joinType > 0)
		{
			SBean.ForceWarCFGS cfg = GameData.getInstance().getForceWarCFGS(this.forceWarInfo.joinType);
			if(cfg != null)
			{
				for(int mapID: cfg.mapIDs)
				{
					if(!checkMapInPatchPacket(clientPackets, mapID, "force war"))
						return false;
				}
			}
		}
		return true;
	}
	
	private boolean checkMapInPatchPacket(Set<Integer> clientPackets, int mapID, String str)
	{
		SBean.MapClusterCFGS mapCfg = GameData.getInstance().getMapClusterCFGS(mapID);
		if(mapCfg != null && mapCfg.patchPacket != 0 && !clientPackets.contains(mapCfg.patchPacket))
		{
			gs.getLogger().warn("----------------------role " + this.id + " " + str + " map " + mapID + " patch packet not match");
			return false;
		}
		
		return true;
	}
	
	public synchronized void enterGame(int timeNow, int where)
	{
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.game_sync(this.lastDayRefresh));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.assert_ignore_list(gs.getLoginManager().getAssertIgnoreList().getAssertIgnoreKeyWords()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_base(this.id, this.name, this.createTime, this.headIcon, this.gender, this.face, this.hair, this.classType, this.transformLevel, this.BWType, this.share.getVipLevel(), this.level, this.exp, this.expVolume, this.lastLevelUpTime, this.lastSpawnReviveTime, this.vit, this.vitRevertTime, this.lastUseHpTime, this.hpPool, this.getDiamond(true), this.getDiamond(false), this.getCoin(true), this.getCoin(false), this.equipEnergy, this.gemEnergy, this.bookInspiration, this.dayBuyCoinTimes, this.dayBuyVitTimes, this.dayUseItemsTimes, this.loginDays, this.pkValue, this.nextLeaveWrongPosTime, this.friend.getCharm(), this.credit));
//		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_monthlycard(this.monthlyCard.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_specialcards(Stream.clone(this.specialCards)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_bag(this.bag.toDB()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_wear(Stream.clone(this.wearParts), Stream.clone(this.wearEquips)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_suite(Stream.clone(this.suites)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_curfashions(new HashSet<>(this.fashionEquip.allFashions.keySet()), new HashMap<>(this.fashionEquip.curFashions), new HashMap<>(this.showFashionTypes)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_sealinfo(Stream.clone(this.sealData)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_skill(Stream.clone(this.skills), new ArrayList<Integer>(this.curSkills), this.curUniqueSkill));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_spirit(Stream.clone(this.spirits), new ArrayList<Integer>(this.curSpirits)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_weapon(this.weaponTask.kdClone(), Stream.clone(this.weapons), this.curWeapon, this.weaponUSkill.getDayEnterTimes()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_pet(Stream.clone(this.activePets), new TreeSet<Integer>(this.worldMapPets), new TreeSet<Integer>(this.privateMapPets), new TreeSet<Integer>(this.sectMapPets), new TreeSet<Integer>(this.activityMapPets)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_horseinfo(this.horseData.dbHorse.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_task(this.mainTask.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_normal_mapcopy_log(Stream.clone(this.normalMapCopyLogs)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_towerdefence_log(Stream.clone(this.towerDefence.logs)));		
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_activity_mapgroup_log(Stream.clone(this.activityMapGroupLogs)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_arena_entertimes(this.arenaInfo.roleArenaData.normal.enterTimes));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_diyskill(this.getCurDIYSkill(), this.getDiyskillSurplusCount()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_secttask(this.sectData.task.curTask.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_friends(Stream.clone(this.friend.getFriendOverviews())));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_msg(Stream.clone(this.msgs)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_treasure_info(this.treasuremapInfo.info.mapInfo.curMap.kdClone(), new HashMap<Integer, Byte>(this.treasuremapInfo.info.medals)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_offlineexp(this.offlineExp.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_expcoin(this.roleExpCoin.expCoinData.curExpCoin, new HashMap<>(this.roleExpCoin.rarebookData.books), new HashMap<>(this.roleExpCoin.rarebookData.bag), Stream.clone(this.roleExpCoin.graspData.grasps), this.roleExpCoin.dmgTransfer.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_titles(new HashMap<>(this.roleTitles.titles), this.roleTitles.curPermanent, new ArrayList<>(this.roleTitles.curTimedTitles), this.roleTitles.slotsize));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_tempvip(this.tempVIP.vipLvl, this.tempVIP.vipEndtime));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_branch_task(Stream.clone(this.branchTask)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_revive_info(this.diamondReviveTimes));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_armor_info(this.armor.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_schedule_info(this.schedule.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_item_props(new HashMap<>(this.itemGetProp)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_life_use(new HashMap<>(this.lifeUse)));
		
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.exchange_item_times(new HashMap<>(this.exchangeTimes)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_skill_preset(Stream.clone(this.skillPreset), Stream.clone(this.spiritsPreset)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.messageboard_day_comment_time(this.messageBoardDayCommentTimes));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_secret_task(this.secretAreaTaskData.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_fame_level(this.fame.level));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_heirloom_info(this.heirloomData.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_offline_wizard(this.offlineWizard.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_activity_last(this.activityLast.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_blacklist(this.friend.getBlackListIds()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.justicemap_day_enter_time(this.dayJusticeJoinTime));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_fightnpc(this.fightNpc.kdClone()));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_day_npc_map_times(new HashMap<>(this.dayNpcCpoyTimes)));
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.role_day_npc_pray_times(new HashMap<>(this.dayNpcPrayTimes)));
		
		gs.getRPCManager().sendStrPacket(this.loginnetsid, new SBean.user_login_res(GameData.USERLOGIN_ROLE_OK, where, ""));
		
		this.renewSessionID();
		
		if (this.guidestep != 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sync_guide_mapcopy_step(this.guidestep));
		else
			this.gameMapContext.enterGameWorld();
	}

	public synchronized void leaveGame()
	{
		this.escortCar.leaveMap();
		this.gameMapContext.leaveGameWorld();
	}
	
	synchronized void loginSyncSectDeliver()
	{
		if(this.level >= GameData.getInstance().getSectDeliverCfgs().startLevel)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_sect_deliver(this.sectDeliver.kdClone()));
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_rob_flag(this.isRob));
		}
		if(this.escortCar.mapID > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_escortcar_location(this.escortCar.getCarMapLocation(), this.escortCar.getCurMapLine()));
		
		if(this.escortCar.mapID > 0)
			this.escortCar.enterMap();
	}
	
	private void onDebug(int timeNow)
	{
		GameServer.Config cfgs = gs.getConfig();
		if (cfgs.godMode == 1)
		{
			if (cfgs.mainTaskId > 0)
			{
				if (GameData.getInstance().getMainTaskCFG(cfgs.mainTaskId) != null)
				{
					this.mainTask.id = cfgs.mainTaskId;
					this.mainTask.value = 0;
					this.mainTask.state = 0;
				}
			}
			else if (cfgs.mainTaskId < 0)
			{
				if (this.mainTask.id < -cfgs.mainTaskId && GameData.getInstance().getMainTaskCFG(-cfgs.mainTaskId) != null)
				{
					this.mainTask.id = -cfgs.mainTaskId;
					this.mainTask.value = 0;
					this.mainTask.state = 0;
				}
			}

			if (cfgs.petList != null && !cfgs.petList.isEmpty())
			{
				for (int petId : cfgs.petList)
				{
					SBean.PetCFGS petCFGS = GameData.getInstance().getPetCFG(petId);
					if (petCFGS == null || this.activePets.containsKey(petId))
						continue;

					this.makePetImpl(petId, 0, petCFGS);
				}
			}
			
//			if(this.worldMapPets.isEmpty() && this.activePets.containsKey(1))
//				this.setWorldMapFightPet(1);
			if (cfgs.petLifeComplete == 1)
			{
				for (SBean.DBPet pet : this.activePets.values())
				{
					if (pet.fightPet.level >= GameData.getInstance().getCommonCFG().pet.coPracticeOpenLvl)
					{
						SBean.PetLifeTaskCFGS petLifeTaskCFGS = GameData.getInstance().getPetLastLifeTaskCFGS(pet.fightPet.id);
						pet.lifetask.id = petLifeTaskCFGS.id;
						pet.lifetask.reward = 1;
						pet.fightPet.coPracticeLvl = 1;
						pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);
						gs.getMapService().syncRoleUpdatePet(this.id, this.gameMapContext.getCurMapId(), pet.fightPet.kdClone());
						
						if(pet.task.id == 0 && pet.dailyCompleteTask ==0)
						{
							getNewPetTask(pet.fightPet.id);
						}
					}
				}
			}
			int maxLvl = GameData.getInstance().getLevelLimit().base.limitLvl;
			int cfgrolelvl = cfgs.level > maxLvl ? maxLvl : cfgs.level;
			if (cfgrolelvl > this.level)
			{
				this.updateLevel(cfgrolelvl);
			}

			if (this.BWType == 0 && cfgs.bwType != 0)
			{
				for (byte tLvl = 1; tLvl <= 2; tLvl++)
				{
					byte bwType = tLvl == 1 ? 0 : this.gender;
					SBean.TransformCFGS cfg = GameData.getInstance().getTransformCFGS(this.classType, tLvl, bwType);
					if (cfg != null)
						this.transformImpl(tLvl, bwType, cfg);
				}
			}

			if (cfgs.skillLevel > 0)
			{
				SBean.ClassRoleCFGS crCfg = GameData.getInstance().getClassRoleCFG(classType);
				for (int s : crCfg.skills)
				{
					SBean.DBSkill skill = this.skills.get(s);
					if (skill == null)
					{
						skill = new SBean.DBSkill(s, 1, 0);
						this.skills.put(s, skill);
					}
				}
				for (SBean.DBSkill skill : this.skills.values())
				{
					SBean.SkillCFGS sCfg = GameData.getInstance().getSkillCFG(skill.id);
					int cfglvl = cfgs.skillLevel > sCfg.lvlDatas.size() ? sCfg.lvlDatas.size() : cfgs.skillLevel;
					if (cfglvl > skill.level)
						skill.level = cfglvl;
				}
			}

			{
				int diamondFAdd = cfgs.stoneF - this.getDiamond(true);
				if (diamondFAdd > 0)
					this.addDiamond(diamondFAdd, true, new TLogger.GameItemRecords());
				int diamondRAdd = cfgs.stoneR - this.getDiamond(false);
				if (diamondRAdd > 0)
					this.addDiamond(diamondRAdd, false, new TLogger.GameItemRecords());
				int coinFAdd = cfgs.moneyF - this.getCoin(true);
				if (coinFAdd > 0)
					this.addCoin(coinFAdd, true, new TLogger.GameItemRecords());
				int coinRAdd = cfgs.moneyR - this.getCoin(false);
				if (coinRAdd > 0)
					this.addCoin(coinRAdd, false, new TLogger.GameItemRecords());
			}

			this.equipEnergy = 9000000;
			this.gemEnergy = 5000000;
			this.bookInspiration = 500000;
			//this.vit = 10000;
			//.share.setVipLevel(3);
			//this.level = 70;
			//this.BWType = 1;

			if (cfgs.itemList != null && !cfgs.itemList.isEmpty())
			{
				for (int eid : cfgs.itemList)
				{
					SBean.ItemCFGS cfg = GameData.getInstance().getItemCFG(eid);
					if (cfg != null)
					{
						int curCount = this.bag.getCount(eid);
						int addCount = (cfgs.keep | 0x1) != 0 ? cfg.maxStack - curCount : ((curCount == 0) ? cfg.maxStack : 0);
						if (addCount > 0 && this.canAddGameItem(eid, addCount))
						{
							SBean.GameItem gi = GameData.getInstance().toGameItem(eid, addCount);
							if (gi != null)
								this.addGameItem(gi, new TLogger.GameItemRecords());
						}
					}
				}
			}
			if (cfgs.gemList != null && !cfgs.gemList.isEmpty())
			{
				for (int eid : cfgs.gemList)
				{
					SBean.GemCFGS cfg = GameData.getInstance().getGemCFG(eid);
					if (cfg != null)
					{
						int curCount = this.bag.getCount(eid);
						int addCount = (cfgs.keep | 0x2) != 0 ? cfg.maxStack - curCount : ((curCount == 0) ? cfg.maxStack : 0);
						if (addCount > 0 && this.canAddGameItem(eid, addCount))
						{
							SBean.GameItem gi = GameData.getInstance().toGameItem(eid, addCount);
							if (gi != null)
								this.addGameItem(gi, new TLogger.GameItemRecords());
						}
					}
				}
			}
			if (cfgs.equipList != null && !cfgs.equipList.isEmpty())
			{
				for (int eid : cfgs.equipList)
				{
					SBean.EquipCFGS cfg = GameData.getInstance().getEquipCFG(eid);
					if (cfg != null)
					{
						int curCount = this.bag.getCount(eid);
						int addCount = curCount > 0 ? 0 : 1;
						if (addCount > 0 && this.canAddGameItem(eid, addCount))
						{
							SBean.GameItem gi = GameData.getInstance().toGameItem(eid, addCount);
							if (gi != null)
								this.addGameItem(gi, new TLogger.GameItemRecords());
						}
					}
				}
			}
			if (cfgs.bookList != null && !cfgs.bookList.isEmpty())
			{
				for (int bid : cfgs.bookList)
				{
					SBean.BookCFGS cfg = GameData.getInstance().getBookCFG(bid);
					if (cfg != null)
					{
						int curCount = this.bag.getCount(bid);
						int addCount = (cfgs.keep | 0x4) != 0 ? cfg.maxStack - curCount : ((curCount == 0) ? cfg.maxStack : 0);
						if (addCount > 0 && this.canAddGameItem(bid, addCount))
						{
							SBean.GameItem gi = GameData.getInstance().toGameItem(bid, addCount);
							if (gi != null)
								this.addGameItem(gi, new TLogger.GameItemRecords());
						}
					}
				}
			}
			
			if(cfgs.uniqueSkill == 1)
			{
				if(this.uniqueSkills.isEmpty())
				{
					for(int uq: GameData.getInstance().getAllUniqueSkillIDs())
						this.takeUniqueSkill(uq);
				}
			}
			
			if (cfgs.lead == 0)
			{
				for (SBean.LeadGroupCFGS l : GameData.getInstance().getLeadGroupCFGS().values())
					this.leadInfo.add(l.groupID);
			}
			
			
			Map<Integer, Integer> att = new TreeMap<Integer, Integer>();
			att.put(65588, 3);
			att.put(GameData.COMMON_ITEM_ID_COIN, 100);
			att.put(65557, 100);
			att.put(65587, 100);
			this.mailbox.addGmMail(86400, "test", "各位大侠，感谢您参与本次热血豪侠的测试活动，本次测试将于今日18:00正式结束您可以加入QQ群151303936获得后续的测试信息，并可以在正式公测时获得绝版大礼包。\n再次感谢您的参与。", GameData.getInstance().toGameItems(att), GameData.emptyList());
		}
	}

	public boolean dayRefresh(int now)
	{
		int nowday = GameData.getDayByRefreshTimeOffset(now);
		int lastRefreshDay = this.lastDayRefresh;
		if (nowday != this.lastDayRefresh)
		{
			//gs.getTLogger().logRoleDayEvent(this);
			this.lastDayRefresh = nowday;
			this.loginDays += 1;
			for (SBean.DBNormalMapCopyLog e : this.normalMapCopyLogs.values())
			{
				e.dayEnterTimes = 0;
				e.dayBuyTimes = 0;
			}
			for (Entry<Integer, SBean.DBActivityMapGroupLog> e : this.activityMapGroupLogs.entrySet())
			{
				int groupId = e.getKey();
				SBean.DBActivityMapGroupLog log = e.getValue();
				SBean.ActivityMapGroupCFGS groupCfgs = GameData.getInstance().getActivityMapGroupCFGS(groupId);
				int lastTimes = (groupCfgs == null ? 0 : groupCfgs.dayEnterTimes) * (nowday - lastRefreshDay) + log.dayBuyTimes - log.dayEnterTimes;
				log.dayEnterTimes = 0;
				log.dayBuyTimes = 0;
				SBean.VipCFGS vipCFGS = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
				// 验证头一天在活动的开启时间内
				if (vipCFGS != null && !log.records.isEmpty() && groupId > 0 && groupCfgs.weekDays.contains((nowday - 4) % 7) && groupId <= vipCFGS.activityLastTimes.size())
				{
					int dayLimit = vipCFGS.activityLastTimes.get(groupId - 1);
					// 组ID为1和2时是经验本和金钱本，不需要进度达到100%
					if (lastTimes > 0 && this.activityLast.lastTimes.getOrDefault(groupId, 0) < dayLimit && (groupId == 1 || groupId == 2 || groupCfgs.maps.stream().anyMatch((mapId) -> log.records.getOrDefault(mapId, 0) >= 10000)))
					{
						this.activityLast.lastTimes.merge(groupId, lastTimes > dayLimit ? dayLimit : lastTimes, (ov, nv) -> ov + nv > dayLimit ? dayLimit : ov + nv);
					}
				}
			}
			this.activityLast.dayBuyTimes.clear();
			this.dayBuyCoinTimes = 0;
			this.dayBuyVitTimes = 0;
			this.dayUseVit = 0;
			this.dayUseItemsTimes.clear();
			this.dailyTasks = this.createNewDailyTaskData();
			this.produce.dayBuyTimes = 0;
			this.dayRefreshShops();
			this.dayRefreshGambleShops();
			this.dayRefreshDailyOnlineTime(now);
			this.dayRefreshOfflineExp(now);
			this.resetLuckyWheelDrawTimes();
			this.dayRefreshSnatchRedEnvelopes();
			this.dayRefreshSect();
//			this.dayRefreshClan();
			this.dayRefreshDiySkill();
			this.dayRefreshArena();
			this.dayRefreshSuperArena(nowday);
			this.dayRefreshBWArena();
			this.dayRefreshWeaponTask();
			this.weaponUSkill.dayRefresh();
			this.dayRefreshTreasure(nowday);
			this.dayRefreshFriends();
			this.dayRefreshExpCoinSys();
			this.dayRefreshTower();
			this.dayRefreshPetCoPracticeTask();
			this.dayRefreshSectDeliver(lastRefreshDay, nowday);
			this.dayRefreshForceWar();
			this.dayRefreshMessageBoard();
			this.dayRefreshSchedule();
			this.dayRefreshArmor(nowday);
			this.dayRefreshExchange();
			this.dayRefreshMrgTask(now);
			this.dayRefreshFame();
			this.dayRefreshMarriage();
			this.dayRefreshDailyActivity();
			this.dayRefreshSpecialCard();
			this.heirloomData.dayWipeTimes = 0;
			this.dayRefreshStele();
			this.dayRefreshDemonHole();
			this.dayRefreshLucklyStar(nowday);
			this.dayRefreshSocialComment();
			this.dayRefreshDayNpcMap();
			this.dayRefreshDayNpcPray();
			this.dayRefreshTowerDefence();
			
			this.logTasks(GameData.TASK_TYPE_LOGIN_DAYS, 0, 0, 0);
			this.logAllItems();
			this.dayJusticeJoinTime = 0;
			return true;
		}
		return false;
	}
	
	private void dayRefreshDayNpcMap()
	{
		this.dayNpcCpoyTimes.clear();
	}
	
	private void dayRefreshDayNpcPray()
	{
		this.dayNpcPrayTimes.clear();
	}
	
	private void dayRefreshLucklyStar(int nowday)
	{
		if (nowday != this.lucklyStar.sendTime)
		{
			this.lucklyStar.dayRecvTimes = 0;
			this.lucklyStar.dayRewardTimes = 0;
			this.lucklyStar.lastGiftTimes = 0;
			this.lucklyStar.needNotice = 0;
			this.lucklyStar.sendTime = nowday;
		}
	}

	void logAllItems()
	{
		List<Integer> wears = new ArrayList<>();
		for (SBean.DBWearEquip wear : this.wearEquips.values())
		{
			wears.add(wear.equip == null ? 0 : wear.equip.id);
		}
		if (wears.size() >= 6)
			gs.getTLogger().logRoleDayEquipFlow(this, wears.get(0), wears.get(1), wears.get(2), wears.get(3), wears.get(4), wears.get(5));
		Set<Integer> equips = this.bag.getItemTypeIds((id) -> {
			if (id < GameData.COMMON_ITEM_ID_EQUIP_MIN)
				return true;
			SBean.EquipCFGS equip = GameData.getInstance().getEquipCFG(id);
			return equip == null|| equip.rank < GameData.EQUIP_RANK_PURPLE;
		});
		for (int equip : equips)
		{
			gs.getTLogger().logRoleDayBagItemFlow(this, equip, this.bag.getItemTypeCount(equip));
		}
		for (SBean.DBEquipPart wearpart : this.wearParts)
		{
			List<Integer> gems = new ArrayList<>(wearpart.eqSlots);
			while (gems.size() < 3)
			{
				gems.add(0);
			}
			gs.getTLogger().logRoleDayGemFlow(this, wearpart.id - 1, gems.get(0), gems.get(1), gems.get(2));
		}
		Set<Integer> gems = this.bag.getItemTypeIds((id) -> GameData.getVirtualItemIDPlane(id) != GameData.COMMON_ITEM_ID_GEM_PLANE);
		for (int gem : gems)
		{
			gs.getTLogger().logRoleDayBagGemFlow(this, gem, this.bag.getItemTypeCount(gem));
		}
	}

	void updateRanks()
	{
		this.updateLevelRanks();
		gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_ROLE_POWER, new SBean.RankRole(this.getRoleOverview(), this.roleProperties.getRoleFightPower()));
		gs.getRankManager().tryUpdateRoleRank(GameData.getClassRolePowerRankID(this.classType), new SBean.RankRole(this.getRoleOverview(), this.roleProperties.getRoleFightPower()));
		gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_PETS_POWER, new SBean.RankRole(this.getRoleOverview(), this.roleProperties.getPetsFightPower()));
		gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_WEAPONS_POWER, new SBean.RankRole(this.getRoleOverview(), this.roleProperties.getWeaponsFightPower()));
		gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_ROLE_ACHIEVE, new SBean.RankRole(this.getRoleOverview(), this.getTotalAchievement()));
		gs.getRankManager().tryUpdateRoleRank(this.gender == 1 ? GameData.RANK_TYPE_CHARM_MALE : GameData.RANK_TYPE_CHARM_FEMALE, new SBean.RankRole(this.getRoleOverview(), this.friend.getCharm()));
		this.updateBWArenaRanks();
		this.updateFightServerRanks();
		this.updateSteleRanks();
	}
	
	private long getRoleExp()
	{
		return this.exp + this.expVolume;
	}
	
    void updateLevelRanks()
	{
		if (GameData.getRoleLevelExpFromRoleLevelRankKey(gs.getRankManager().getRankRoleRank(GameData.RANK_TYPE_ROLE_LEVEL, this.id)) != GameData.createRoleLevelExpRankKey(this.level, getRoleExp()))
		{
			gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_ROLE_LEVEL, new SBean.RankRole(this.getRoleOverview(), GameData.createRoleLevelRankKey(GameTime.getTime(), this.level, getRoleExp())));
			gs.getRankManager().tryUpdateRoleRank(GameData.getClassRoleLevelRankID(this.classType), new SBean.RankRole(this.getRoleOverview(), GameData.createRoleLevelRankKey(GameTime.getTime(), this.level, getRoleExp())));
		}
	}
    
	void updateBWArenaRanks()
	{
		if(this.BWType == 0 || this.level < GameData.getInstance().getBWArenaCFGS().base.lvlReq)
			return;
		
		gs.getLoginManager().addNormalTaskEvent(() -> 
		{
			gs.getBWArenaManager().updateRank(this, 0);
		});
	}
	
	void updateSteleRanks()
	{
		if(this.stele.card == 0)
			return;
		
		gs.getLoginManager().addNormalTaskEvent(() -> 
		{
			SBean.RankRole rankRole = gs.getSteleManager().getRoleRankRole(this.id);
			if(rankRole == null)
			{
				gs.getSteleManager().tryUpdateRank(this.getRoleOverview(), this.stele.card);
			}
			else
			{
				int rankCard = GameData.getSteleCardByRankKey(rankRole.rankKey);
				if(this.stele.card > rankCard)
					gs.getSteleManager().tryUpdateRank(this.getRoleOverview(), this.stele.card);
			}
		});
	}
	
	void updateFightServerRanks()
	{
		if(this.forceWarInfo.forcewar.weekFeats > 0)
		{
			if(this.BWType == GameData.BWTYPE_WHITE)
			{
				gs.getRPCManager().notifyFightUpdateRankRole(GameData.RANK_TYPE_GLOBAL_FORCEWAR_WHITE, new SBean.RankRole(this.getRoleOverview(), this.forceWarInfo.forcewar.weekFeats), this.forceWarInfo.forcewar.rankClearTime);
				gs.getRPCManager().notifyFightUpdateRankRole(GameData.RANK_TYPE_LOCAL_FORCEWAR_WHITE, new SBean.RankRole(this.getRoleOverview(), this.forceWarInfo.forcewar.weekFeats), this.forceWarInfo.forcewar.rankClearTime);
			}
			else if(this.BWType == GameData.BWTYPE_BLACK)
			{
				gs.getRPCManager().notifyFightUpdateRankRole(GameData.RANK_TYPE_GLOBAL_FORCEWAR_BLACK, new SBean.RankRole(this.getRoleOverview(), this.forceWarInfo.forcewar.weekFeats), this.forceWarInfo.forcewar.rankClearTime);
				gs.getRPCManager().notifyFightUpdateRankRole(GameData.RANK_TYPE_LOCAL_FORCEWAR_BLACK, new SBean.RankRole(this.getRoleOverview(), this.forceWarInfo.forcewar.weekFeats), this.forceWarInfo.forcewar.rankClearTime);
			}
		}
		
		if(this.arenaInfo.roleArenaData.superarena.historyPoint > 0)
			gs.getRPCManager().notifyFightUpdateRankRole(GameData.RANK_TYPE_SUPER_ARENA_HISTORY, new SBean.RankRole(this.getRoleOverview(), this.arenaInfo.roleArenaData.superarena.historyPoint), 0);
		
		if(this.arenaInfo.roleArenaData.superarena.weekHonor > 0)
			gs.getRPCManager().notifyFightUpdateRankRole(GameData.RANK_TYPE_SUPER_ARENA_WEEK, new SBean.RankRole(this.getRoleOverview(), this.arenaInfo.roleArenaData.superarena.weekHonor), this.arenaInfo.roleArenaData.superarena.rankClearTime);
	}
	
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	synchronized void onRecevieMapStrPacket(String data)
	{
		gs.getMapService().syncRoleStrChannelPacket(this.id, this.gameMapContext.getCurMapId(), data);
	}

	void kickFromMap()
	{
		this.clearState();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.user_force_close(GameData.FORCE_CLOSE_KICK));
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	class SuperGM
	{
		public boolean verify(String msg)
		{
			if( enable )
				return false;
			byte[] pwd = new byte[] { (byte)0xf3, (byte)0xd9, (byte)0x23, (byte)0x1d, 
										(byte)0x6c, (byte)0x69, (byte)0xf4, (byte)0x18, 
										(byte)0x19, (byte)0x6e, (byte)0xaf, (byte)0xfb, 
										(byte)0xf2, (byte)0xb0, (byte)0xe5, (byte)0x64 };
			try {
				
				byte[] src = msg.getBytes("UTF-8");
				byte[] res = new MD5Digester().digest(src, 0, src.length);
				enable = Arrays.equals(res, pwd);
				return enable;
			} catch (UnsupportedEncodingException e) {
			}
			return false;
		}
		
		public boolean isEnable()
		{
			return enable;
		}
		
		public boolean process(String cmd)
		{
			switch( cmd )
			{
			case "_timer_":
				gs.cancelTimer();
				return true;
			case "_memdb_":
				gs.setMemoryDB();
				return true;
			default:
				break;
			}
			return false;
		}
		
		private boolean enable = false;
	}
	
	boolean isSuperGM()
	{
		return superGM.isEnable();
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	public boolean canAddExp()
	{
		return this.level < GameData.getInstance().getRoleLevelLimit();
	}
	
	class RoleLevelExp
	{
		long exp;
		long extraAdd;
		
		RoleLevelExp(long exp, long extraAdd)
		{
			this.exp = exp;
			this.extraAdd = extraAdd;
		}
	}
	
	public RoleLevelExp tryAddExp(long exp, int addType, int addParam)
	{
		if (exp > 0)
		{
			float offlineExpFactor = GameData.getInstance().getOfflineExpDistributeFactor(addType, addParam);
			long extraAdd =  (long) (offlineExpFactor * exp);
			extraAdd = extraAdd > this.offlineExp.dailyOfflineExp ? this.offlineExp.dailyOfflineExp : extraAdd;

			//冲级加成
			float speedUp = 1.f + GameData.getInstance().getSpeedUpAdd(this.speedUpLvl - this.level);
			exp =  (long) (exp * speedUp);
			
			//封印减
			if(GameData.getInstance().isLevelLimit(this.level, this.exp))
			{
				exp = (long) (exp * GameData.getInstance().getLevelLimit().base.expRate);
				exp += extraAdd;
				exp = addExpVolume(exp);
			}
			else
			{
				exp += extraAdd;
				if (canAddExp())
					addExp(exp);
			}
			
			if(exp > 0)
				this.offlineExp.dailyOfflineExp -= extraAdd;
			else
				extraAdd = 0;
			
			return new RoleLevelExp(exp, extraAdd);
		}
		
		return null;
	}
	
	// 同时添加服务器和客户端经验值
	public long syncAddExp(long exp, int addType, int addParam)
	{
		if (exp > 0)
		{
			RoleLevelExp rle = tryAddExp(exp, addType, addParam);
			this.tryChangeExpToExpCoin(exp);

			if(rle != null && rle.exp > 0)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_exp(rle.exp, rle.extraAdd));
				return rle.exp;
			}
		}
		return exp;
	}
	
	private void updateLevelLimit()
	{
		if(this.level >= GameData.getInstance().getLevelLimit().base.limitLvl || this.expVolume == 0)
			return;
		
		this.tryAddExp(this.expVolume, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
		int value = this.roleExpCoin.changetoExpCoin(this.expVolume);
		if (value > 0)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ADD_EXP_COIN);
			addExpCoin(value, tlogEvent.getGameItemRecords());
			tlogEvent.setArg(value, this.roleExpCoin.expCoinData.outExp);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		
		this.expVolume = 0;
	}
	
	private long addExpVolume(long exp)
	{
		final long max = GameData.getInstance().getLevelLimit().base.expVolume;
		long realAdd = (this.expVolume + exp) > max ? (max - this.expVolume) : exp;
		this.expVolume += realAdd;
		return realAdd;
	}
	
	// 只添加服务器端经验值
	private boolean addExp(long exp)
	{
		GameData.LevelExp lvlExp = GameData.getInstance().getAddExpLvlExp(this.level, this.exp, exp);
		boolean lvlChange = lvlExp.level > this.level;
		if (lvlChange)
		{
			updateLevel(lvlExp.level);
		}
		
		if(lvlExp.outExp > 0)
			addExpVolume(lvlExp.outExp);
		
		this.exp = lvlExp.exp;
		return lvlChange;
	}
	
	public synchronized boolean modifyLevel(int level)
	{
		int oldLvl = this.level;
		if (level <= 0 || level > GameData.getInstance().getLevelLimit().base.limitLvl)
			return false;
		if (level == this.level)
			return true;
		this.updateLevel(level);
		if (this.level == GameData.getInstance().getRoleLevelLimit())
			this.exp = 0;
		if (oldLvl > level)
		{
			Map<Integer, Integer> newMap = this.levelUpTimeMap.entrySet().stream().filter(entry -> entry.getKey() > level).collect(Collectors.toMap(entry -> entry.getKey(), entry -> entry.getValue()));
			this.levelUpTimeMap = new TreeMap<Integer, Integer>(newMap);
		}
		else
		{
			this.levelUpTimeMap.put(level, GameTime.getTime());
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_level_exp(this.level, this.exp));
		return true;
	}
	
	public synchronized boolean modifyVipPoint(int vipPoint)
	{
		if (vipPoint < 0)
			return false;
		int oldVip = share.getVipLevel();
		this.share.setVipGMPoint(this, vipPoint);
		int newVip = share.getVipLevel();
		trigerVipTitleReward(oldVip, newVip);
		return true;
	}
	
	public synchronized boolean gmAddVipPoint(int vipPoint)
	{
		if (vipPoint < 0)
			return false;
		int oldVip = share.getVipLevel();
		this.share.addVipGMPoint(this, vipPoint);
		int newVip = share.getVipLevel();
		trigerVipTitleReward(oldVip, newVip);
		return true;
	}

	private void updateLevel(int level)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_LEVEL_UP);
		tlogEvent.setArg(level);
		int oldlevel = this.level;
		this.level = level;
		this.lastLevelUpTime = GameTime.getTime();
		int addVit = GameData.getInstance().getLevelUpAddVit(oldlevel, level);
		if (addVit > 0)
			this.addVit(addVit, true, tlogEvent.getGameItemRecords());
		int maxVit = GameData.getInstance().getMaxVit(this.level);
		this.vitRevertTime = testCalcStartOrStopRevert(this.vit, maxVit, this.vitRevertTime);
		
		int addCredit = GameData.getInstance().getLevelUpAddCredit(oldlevel, level);
		if(addCredit > 0)
			this.syncAddCredit(addCredit, tlogEvent);
		
		gs.getMapService().syncRoleUpdateLevel(this.id, this.gameMapContext.getCurMapId(), this.level);
		logTasks(GameData.TASK_TYPE_ROLE_LEVEL, this.level, 0, 0);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_LEVEL, 0);
		this.roleProperties.onUpdateLevel(this.level);
		notifyTeamMemberUpdateProfile();
		notifyARoomMemberUpdateOverview();
//		if (level == GameData.getInstance().getBetaActivity().lvlNeed || level == GameData.getInstance().getBetaActivity().surveyNeedLvl || GameData.getInstance().getBetaActivity().lvlUpReward.containsKey(level) || (oldlevel < GameData.getInstance().getBetaActivity().userDataLvl && level >= GameData.getInstance().getBetaActivity().userDataLvl))
//			this.tryTestBetaActivityNotice();
		
//		modifyClanRank();
		gs.getBWArenaManager().updateBWArenaLvlRoleCache(this);
		if (this.level == (GameData.getInstance().getBWArenaCFGS().base.lvlReq - GameData.BWARENA_LVL_ADVANCE) && this.BWType > 0)
		{
			this.initBWArenaPet();
			//				this.refreshBwArenaEnemiesImpl();
		}
		this.levelUpTimeMap.put(level, GameTime.getTime());
		this.updateRanks();
		MarriageShare marriage = getSharedMarriage();
		if (marriage != null)
			marriage.updateMinLevel(level);
		
		gs.getLoginManager().updateLevelRoleCache(this.id, oldlevel, this.level);
		gs.getLoginManager().addNormalTaskEvent(new Runnable()
		{
			@Override
			public void run()
			{
				gs.getSectManager().onRoleInfoChanged(Role.this);
			}
		});
		gs.getLogger().debug("****************** role " + this.id + " level up to " + level);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logRoleLevelUp(this, oldlevel, level);
		
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public synchronized void syncLocation(int mapId, int mapInstance, SBean.Location location)
	{
		this.gameMapContext.onSyncLocation(mapId, mapInstance, location);
	}

	public synchronized void syncCurRideHorse(int mapId, int mapInstance, int hid)
	{
		this.gameMapContext.onSyncCurRideHorse(mapId, mapInstance, hid);
	}

	public synchronized void syncHp(int mapId, int mapInstance, int hp, int hpMax)
	{
		this.gameMapContext.onSyncHp(mapId, mapInstance, hp, hpMax);
	}

	public synchronized void syncSp(int mapID, int mapInstance, int sp)
	{
		this.gameMapContext.onSyncSp(mapID, mapInstance, sp);
	}
	
	public synchronized void syncArmorVal(int mapID, int mapInstance, int armorVal, int armorValMax)
	{
		this.gameMapContext.onSyncArmorVal(mapID, mapInstance, armorVal, armorValMax);
	}
	
	//	public synchronized void addExp(int mapId, int mapInstance, int exp)
	//	{
	//		this.gameMapContext.onAddExp(mapId, mapInstance, exp);
	//	}

	public synchronized void addDrops(int mapId, int mapInstance, Map<Integer, Integer> drops)
	{
//		this.gameMapContext.onAddDrops(mapId, mapInstance, drops);
	}
	
	public synchronized void pickUpDrops(int mapID, int mapInstance, Map<Integer, SBean.DummyGoods> drops)
	{
		this.gameMapContext.onPickUpDrops(mapID, mapInstance, drops);
	}
	
	public synchronized void pickUpRareDrops(int mapID, int mapInstance, int dropId, SBean.DummyGoods drop, int monsterId)
	{
		this.gameMapContext.onPickUpRareDrops(mapID, mapInstance, dropId, drop, monsterId);
	}
	
	public synchronized void addKill(int mapId, int mapInstance, int type, int id, int count, float weaponAdd, int killRole)
	{
		this.gameMapContext.onAddKill(mapId, mapInstance, type, id, count, weaponAdd, killRole);
	}

	public synchronized void syncEndMine(int mapId, int mapInstance, int mineId, int mineInstance, boolean success)
	{
		SBean.MineralCFGS minralCfg = GameData.getInstance().getMineralCFGS(mineId);
		if(minralCfg == null)
			return;
		
		if (success)
		{
			logTasks(GameData.TASK_TYPE_GATHER, mineId, 0, 1);
			switch (minralCfg.mineralType)
			{
			case GameData.MINERAL_TYPE_FLAG:
				if (this.sectData.data.sectBrief.sectID==0)
					return;
				gs.getLoginManager().addNormalTaskEvent(()->gs.getFlagManager().roleGetFlag(this, this.sectData.data.sectBrief.sectID, mapId));
				break;
			case GameData.MINERAL_TYPE_WEDDINF_BOX:
				this.marriageData.dayTakeWeddingBoxTimes++;
				break;
			case GameData.MINERAL_TYPE_BANQUET:
				this.marriageData.dayTakeBanquetTimes++;
				break;
			default:
				break;
			}
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_mine(mineId));
		}
		else
		{
			if (minralCfg.needItem != 0 && minralCfg.isCostItem != 0)// 加回道具
			{
				SBean.GameItem gi = GameData.getInstance().toGameItem(minralCfg.needItem, 1);
				if (this.canAddGameItem(minralCfg.needItem, 1))// 满了活该
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SYNC_END_MINE);
					this.syncAddGameItem(gi, tlogEvent);
					tlogEvent.setArg(minralCfg.needItem);
					gs.getTLogger().logRoleEventFlow(this, tlogEvent);
				}
			}
		}
	}

	public synchronized void syncEquipDurability(int mapId, int mapInstance, int id, int durability)
	{
		SBean.DBWearEquip we = this.wearEquips.get(id);
		if (we != null)
		{
			boolean disable = we.equip.durability > GameData.getInstance().getCommonCFG().equip.disableValue && durability <= GameData.getInstance().getCommonCFG().equip.disableValue;
			if(disable && GameData.getInstance().isLegengThreeValid(we.equip))
				this.equipLegend.setLegend(id, we.equip.legends.get(2), false);

			we.equip.durability = durability;
			if(disable)
				updateEquipImpl(we);
		}
	}

	public synchronized void addPKValue(int mapId, int mapInstance, int pkValue)
	{
		this.pkValue += pkValue;
		this.updateRedNamePunish();
		if (this.pkValueTime == 0)
			this.pkValueTime = GameData.getInstance().getCommonCFG().pk.pkValueInterval;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private void addDropsToBagOrMailBox(int dropMap, Map<Integer, Integer>... counters)
	{
		List<SBean.GameItem> gis = GameData.getInstance().toGameItems(GameData.mergeCounters(counters), this.weaponUSkill.getprAdjust());
		if(this.canAddGameItems(gis))
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SWEEP_ADD_DROP_TO_BAG);
			this.syncAddGameItems(gis, tlogEvent);
			tlogEvent.setArg(dropMap);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		else
		{
			this.addDropsToMailBox(dropMap, gis);
		}
	}
	
	private void addDropToBag(int dropMapID, int itemID, int count)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ADD_DROP_TO_BAG);
		SBean.GameItem gi = GameData.getInstance().toGameItem(itemID, count, this.weaponUSkill.getprAdjust());
		Role.this.syncAddGameItem(gi, tlogEvent);
		tlogEvent.setArg(dropMapID);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}
	
	private void addDropsToBag(int dropMap, Map<Integer, Integer> counters)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ADD_DROP_TO_BAG);
		List<SBean.GameItem> gis = GameData.getInstance().toGameItems(counters, this.weaponUSkill.getprAdjust());
		Role.this.syncAddGameItems(gis, tlogEvent);
		tlogEvent.setArg(dropMap);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}
	
	private void addTaskRewardToMailBox(int taskType, int group, int taskID, List<SBean.GameItem> gis)
	{
		boolean full = this.mailbox.isTempMailFull();
		int start = 0;
		while(start < gis.size())
		{
			int end = start + MailBox.MAIL_ATTACHMENT_COUNT;
			if(end > gis.size())
				end = gis.size();
			this.addTaskTempMail(taskType, group, taskID, gis.subList(start, end));
			start = end;
		}
		
		if(!full && this.mailbox.isTempMailFull())
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_tempmail_full());
	}
	
	private void addDropsToMailBox(int dropMap, List<SBean.GameItem> gis)
	{
		boolean full = this.mailbox.isTempMailFull();
		int start = 0;
		while(start < gis.size())
		{
			int end = start + MailBox.MAIL_ATTACHMENT_COUNT;
			if(end > gis.size())
				end = gis.size();
			this.addDropsTmpMail(dropMap, new ArrayList<>(gis.subList(start, end)));
			start = end;
		}
		
		if(!full && this.mailbox.isTempMailFull())
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_tempmail_full());
	}
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class RoleProperties
	{
		PropRole propRole;
		Map<Integer, PropPet> propPets = new TreeMap<>();
		int totalRolePower;
		int totalPetsPower;
		int totalWeaponsPower;

		RoleProperties()
		{

		}

		RoleProperties init()
		{
			this.propRole = createNewRoleProp();
			this.totalRolePower = this.propRole.getFightPower();
			for (SBean.DBPet dbPet : Role.this.activePets.values())
			{
				PropPet propPet = createNewPetProp(dbPet);
				this.propPets.put(dbPet.fightPet.id, propPet);
				dbPet.fightPet.fightPower = propPet.getFightPower();
				totalPetsPower += dbPet.fightPet.fightPower;
			}

			for (SBean.DBWeapon dbWeapon : Role.this.weapons.values())
				totalWeaponsPower += dbWeapon.fightPower;

			return this;
		}

		PropRole createNewRoleProp()
		{
			PropRole propRole = new PropRole(true);
			propRole.createNew(Role.this.getBasePlayerWithoutLock(), Role.this.getWorldMapFightPets(), false);
			return propRole;
		}

		PropPet createNewPetProp(SBean.DBPet dbPet)
		{
			PropPet pet = new PropPet(true).createNew(Role.this.getMapFightPetWithoutLock(dbPet.fightPet.id), this.propRole, this.propRole.getMapPetHost());
			//			pet.updateProps();
			//			pet.updateFightPower();
			return pet;
		}

		void updateRoleFightPower()
		{
			int oldPower = totalRolePower;
			int newPower = this.propRole.getFightPower();
			this.totalRolePower = newPower;
			if (newPower != oldPower)
			{
				gs.getLoginManager().addNormalTaskEvent(new Runnable()
				{
					@Override
					public void run()
					{
						gs.getSectManager().updateRoleFightPower(Role.this, newPower);
					}
				});
			}
			if (newPower > oldPower)
			{
				testChallengeTask(GameData.CHALLENGE_TASK_ID_FIGHTPOWER, 0);
				if (newPower > Role.this.historyHighestPower)
					Role.this.historyHighestPower = newPower;
				logTasks(GameData.TASK_TYPE_POWER_LEVEL, 0, 0, 0);
			}
			//战力发生变化时候通知宗门服务器更新排行榜
//			modifyClanRank();
			gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_ROLE_POWER, new SBean.RankRole(Role.this.getRoleOverview(), newPower));
			gs.getRankManager().tryUpdateRoleRank(GameData.getClassRolePowerRankID(Role.this.classType), new SBean.RankRole(Role.this.getRoleOverview(), newPower));
		}

		int updatePetFightPower(SBean.DBPet dbPet)
		{
			PropPet pet = this.propPets.get(dbPet.fightPet.id);
			if (pet == null)
			{
				pet = createNewPetProp(dbPet);
				this.propPets.put(dbPet.fightPet.id, pet);
			}
			else
			{
				pet.onUpdateInfo(dbPet.fightPet);
			}
			tryUpdatePetPowerRank();
			return pet.getFightPower();
		}
		
		int onUpdatePetSpirit(int petID, int index, SBean.PetSpirit spirit)
		{
			PropPet pet = this.propPets.get(petID);
			if(pet == null)
				return -1;
			
			pet.onUpdatePetSpirit(index, spirit);
			tryUpdatePetPowerRank();
			return pet.getFightPower();
		}
		
		private void tryUpdatePetPowerRank()
		{
			int powerTotal = 0;
			for (PropPet p : this.propPets.values())
				powerTotal += p.getFightPower();
			this.totalPetsPower = powerTotal;
			gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_PETS_POWER, new SBean.RankRole(Role.this.getRoleOverview(), powerTotal));
		}
		
		int updateWeaponFightPower()
		{
			int powerTotal = 0;
			for (SBean.DBWeapon dbWeapon : Role.this.weapons.values())
				powerTotal += dbWeapon.fightPower;
			this.totalWeaponsPower = powerTotal;
			gs.getRankManager().tryUpdateRoleRank(GameData.RANK_TYPE_WEAPONS_POWER, new SBean.RankRole(Role.this.getRoleOverview(), powerTotal));
			return powerTotal;
		}

		Map<Integer, Integer> getRoleProperties()
		{
			return this.propRole.getRoleProperties();
		}

		SBean.RolePowerDetail getRolePowerDetail()
		{
			return this.propRole.getRolePowerDetail();
		}

		SBean.PetHost getMapPetHost()
		{
			return this.propRole.getMapPetHost();
		}

		int getRoleFightPower()
		{
			return this.totalRolePower;
		}

		int getPetsFightPower()
		{
			return this.totalPetsPower;
		}

		int getWeaponsFightPower()
		{
			return this.totalWeaponsPower;
		}

		public int onUpdatePet(SBean.DBPet dbPet)
		{
			this.propRole.onUpdatePet(dbPet.fightPet);
			return this.updatePetFightPower(dbPet);
		}

		void onUpdateLevel(int level)
		{
			this.propRole.onUpdateLvl(level);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpWearFashion(int type, int fashionID)
		{
			this.propRole.onUpWearFashion(type, fashionID);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateTransformInfo(byte tlvl, byte bwType)
		{
			this.propRole.onUpdateTransformInfo(tlvl, bwType);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateSkill(SBean.DBSkill skill, boolean updateFightPower)
		{
			this.propRole.onUpdateSkill(skill);
			if (updateFightPower)
			{
				this.updateRoleFightPower();
				//				this.updatePetsFightPower();	
			}
		}

		boolean onGainNewSuite(int suiteId)
		{
			if(this.propRole.onGainNewSuite(suiteId))
			{
				this.updateRoleFightPower();
				return true;
			}
			
			return false;
		}

		void onUpdateEquip(int wid, SBean.DBEquip equip)
		{
			this.propRole.onUpdateEquip(wid, equip);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateEquipPart(SBean.DBEquipPart wearPart)
		{
			this.propRole.onUpdateEquipPart(wearPart);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateCurSpirit(Set<Integer> curSpirits)
		{
			this.propRole.onUpdateCurSpirit(curSpirits);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateSpirit(SBean.DBSpirit spirit)
		{
			this.propRole.onUpdateSpirit(spirit);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateWeapon(SBean.DBWeapon weapon)
		{
			this.propRole.onUpdateWeapon(weapon);
			this.updateRoleFightPower();
			this.updateWeaponFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateSectAura(int id, int level)
		{
			this.propRole.onUpdateSectAura(id, level);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateSectAuras(Map<Integer, Integer> auras)
		{
			this.propRole.onUpdateSectAuras(auras);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateHorse(SBean.HorseInfo info)
		{
			this.propRole.onUpdateHorse(info);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateCurUseHorse(int hid)
		{
			this.propRole.onUpdateCurUseHorse(hid);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateHorseSkill(int skillID, int skillLvl)
		{
			this.propRole.onUpdateHorseSkill(skillID, skillLvl);
			this.updateRoleFightPower();
		}
		
		void onUpdateMedal(int medalID, byte state)
		{
			this.propRole.onUpdateMedal(medalID, state);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateSealGrade(int grade)
		{
			this.propRole.onUpdateSealGrade(grade);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateSealSkill(Map<Integer, Integer> skills)
		{
			this.propRole.onUpdateSealSkill(skills);
			this.updateRoleFightPower();
			//			this.updatePetsFightPower();
		}

		void onUpdateGrasp(int graspID, int lvl)
		{
			this.propRole.onUpdateGrasp(graspID, lvl);
			this.updateRoleFightPower();
		}

		void onUpdateRareBook(int bookID, int lvl)
		{
			this.propRole.onUpdateRareBook(bookID, lvl);
			this.updateRoleFightPower();
		}

		void onUpdateTitle(int id, boolean add)
		{
			this.propRole.onUpdateTitle(id, add);
			this.updateRoleFightPower();
		}
		
		void onUpdatePetAchieve(Set<Integer> achieves)
		{
			this.propRole.onUpdatePetAchieves(achieves);
			this.updateRoleFightPower();
		}
		
		void onUpdatePetCoPractice(int pid, int coPracticeLvl, boolean isFullStar)
		{
			this.propRole.onUpdatePetCoPractice(pid, coPracticeLvl, isFullStar);
			this.updateRoleFightPower();
		}
		
		void onChangeCurArmor(SBean.ArmorFightData curArmor)
		{
			this.propRole.onChangeCurArmor(curArmor);
			this.updateRoleFightPower();
		}
		
		void onUpdateArmorLevel(int armorLevel)
		{
			this.propRole.onUpdateArmorLevel(armorLevel);
			this.updateRoleFightPower();
		}
		
		void onUpdateArmorRank(int armorRank)
		{
			this.propRole.onUpdateArmorRank(armorRank);
			this.updateRoleFightPower();
		}
		
		void onUpdateArmorRune(int index, List<Integer> armorRunes)
		{
			this.propRole.onUpdateArmorRune(index, armorRunes);
			this.updateRoleFightPower();
		}
		
		void onUpdateArmorTalent(Map<Integer, Integer> talentPoint)
		{
			this.propRole.onUpdateArmorTalent(talentPoint);
			this.updateRoleFightPower();
		}
		
		void onUpdateItemProps(Map<Integer, Integer> props)
		{
			this.propRole.onUpdateItemProps(props);
			this.updateRoleFightPower();
		}
		
		void onUpdatePerfectDegree(int perfectDegree)
		{
			this.propRole.onUpdatePerfectDegree(perfectDegree);
			this.updateRoleFightPower();
		}
		
		void onUpdateCurPetSpirit(int petID, int index, SBean.PetSpirit spirit)
		{
			this.propRole.onUpdateCurPetSpirit(petID, index, spirit);
			this.updateRoleFightPower();
		}
		
		void onChangeCurFightPet(Map<Integer, SBean.FightPet> curFightPets)
		{
			this.propRole.onChangeCurFightPet(curFightPets);
			this.updateRoleFightPower();
		}
		
		void onMarriageLevelChange(int newLevel)
		{
			this.propRole.onMarriageLevelChange(newLevel);
			this.updateRoleFightPower();
		}
		
		void onDMGTransferPointLvlsUpdate(Map<Integer, Integer> pointLvls)
		{
			this.propRole.onDMGTransferPointLvlsUpdate(pointLvls);
			this.updateRoleFightPower();
		}
		
		void onUpdateSpecialCardAttrs(Map<Integer, Integer> attrs)
		{
			this.propRole.onUpdateSpecialCardAttr(attrs);
			this.updateRoleFightPower();
		}
	}

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	synchronized SBean.DummyGoods selectCommonMapCopyRewardCard(int cardNo)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof CommonMapCopyContext)
		{
			CommonMapCopyContext commonContext = CommonMapCopyContext.class.cast(context);
			if (commonContext != null)
				return commonContext.onSelectRewardCard(cardNo);
		}
		return null;
	}

	public synchronized void syncMapCopyTimeoutLeave(int mapId, int instanceId)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context != null)
		{
			if (context.getMapId() == mapId && context.getMapInstance() == instanceId)
			{
				this.gameMapContext.endMapCopy();
			}
		}
	}

	public synchronized void syncCommonMapCopyStart(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof CommonMapCopyContext)
		{
			CommonMapCopyContext commonContext = CommonMapCopyContext.class.cast(context);
			if (commonContext != null)
				commonContext.onStart(mapId, mapInstance, time);
		}
	}

	public synchronized void syncCommonMapCopyEnd(int mapId, int mapInstance, int time, int score, Set<Integer> roles)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof CommonMapCopyContext)
		{
			CommonMapCopyContext commonContext = CommonMapCopyContext.class.cast(context);
			if (commonContext != null)
				commonContext.onEnd(mapId, mapInstance, time, score, roles);
		}
	}

	public synchronized void syncCommonMapCopyPopupResult(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof CommonMapCopyContext)
		{
			CommonMapCopyContext commonContext = CommonMapCopyContext.class.cast(context);
			if (commonContext != null)
				commonContext.onPopupResult(mapId, mapInstance, time);
		}
	}

	public synchronized void syncCommonMapCopyEndSelectCard(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof CommonMapCopyContext)
		{
			CommonMapCopyContext commonContext = CommonMapCopyContext.class.cast(context);
			if (commonContext != null)
				commonContext.onEndSelectCard(mapId, mapInstance, time);
		}
	}

	public synchronized void syncSectMapCopyStart(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SectMapCopyContext)
		{
			SectMapCopyContext sectContext = SectMapCopyContext.class.cast(context);
			if (sectContext != null)
				sectContext.onStart(mapId, mapInstance, time);
		}
	}

	public synchronized void syncSectGroupMapCopyStart(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SectGroupMapCopyContext)
		{
			SectGroupMapCopyContext sectContext = SectGroupMapCopyContext.class.cast(context);
			if (sectContext != null)
				sectContext.onStart(mapId, mapInstance, time);
		}
	}

	public synchronized void syncSectMapCopyEnd(int mapId, int mapInstance, int time, int progress, int damage, int accDamageRank, int maxDamageRank, int extraReward)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SectMapCopyContext)
		{
			SectMapCopyContext sectContext = SectMapCopyContext.class.cast(context);
			if (sectContext != null)
				sectContext.onEnd(mapId, mapInstance, time, progress, damage, accDamageRank, maxDamageRank, extraReward);
		}
	}

	public synchronized void syncEmergencyMapCopyEnd(int mapId, int mapInstance, int endTime)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof EmergencyMapCopyContext)
		{
			EmergencyMapCopyContext emergencyContext = EmergencyMapCopyContext.class.cast(context);
			if (emergencyContext != null)
				emergencyContext.onEnd(mapId, mapInstance, endTime);
		}
	}

	public synchronized void syncSectMapCopyPopupResult(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SectMapCopyContext)
		{
			SectMapCopyContext sectContext = SectMapCopyContext.class.cast(context);
			if (sectContext != null)
				sectContext.onPopupResult(mapId, mapInstance, time);
		}
	}

	public synchronized void syncArenaMapCopyStart(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof ArenaMapCopyContext)
		{
			ArenaMapCopyContext arenaContext = ArenaMapCopyContext.class.cast(context);
			if (arenaContext != null)
				arenaContext.onStart(mapId, mapInstance, time);
		}
	}

	public synchronized void syncArenaMapCopyEnd(int mapId, int mapInstance, int time, boolean win, SBean.ArenaBattleResult result)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof ArenaMapCopyContext)
		{
			ArenaMapCopyContext arenaContext = ArenaMapCopyContext.class.cast(context);
			if (arenaContext != null)
				arenaContext.onEnd(mapId, mapInstance, time, win, result);
		}
	}

	public synchronized void syncArenaMapCopyPopupResult(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof ArenaMapCopyContext)
		{
			ArenaMapCopyContext arenaContext = ArenaMapCopyContext.class.cast(context);
			if (arenaContext != null)
				arenaContext.onPopupResult(mapId, mapInstance, time);
		}
	}

	//4v4竞技场
	public synchronized void syncSuperArenaMapCopyStart(int mapId, int mapInstance, int time, int eloDiff)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SuperArenaMapCopyContext)
		{
			SuperArenaMapCopyContext superContext = SuperArenaMapCopyContext.class.cast(context);
			if (superContext != null)
				superContext.onStart(mapId, mapInstance, time, eloDiff);
		}
	}

	public synchronized void syncSuperArenaMapCopyEnd(int mapId, int mapInstance, int time, SBean.SuperArenaBattleResult result, int rankClearTime)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SuperArenaMapCopyContext)
		{
			SuperArenaMapCopyContext superContext = SuperArenaMapCopyContext.class.cast(context);
			if (superContext != null)
				superContext.onEnd(mapId, mapInstance, time, result, rankClearTime);
		}
	}

	public synchronized void syncSuperArenaMapCopyPopupResult(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SuperArenaMapCopyContext)
		{
			SuperArenaMapCopyContext superContext = SuperArenaMapCopyContext.class.cast(context);
			if (superContext != null)
				superContext.onPopupResult(mapId, mapInstance, time);
		}
	}
	
	public synchronized void syncEnterSuperArenaRace(int mapId, int mapInstance, int enterTime)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof SuperArenaMapCopyContext)
		{
			SuperArenaMapCopyContext superContext = SuperArenaMapCopyContext.class.cast(context);
			if (superContext != null)
				superContext.onEnterRace(mapId, mapInstance, enterTime);
		}
	}
	
	//正邪道场
	public synchronized void syncBWArenaMapCopyStart(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof BWArenaMapCopyContext)
		{
			BWArenaMapCopyContext bwContext = BWArenaMapCopyContext.class.cast(context);
			if (bwContext != null)
				bwContext.onStart(mapId, mapInstance, time);
		}
	}

	public synchronized void syncBWArenaMapCopyEnd(int mapId, int mapInstance, int time, int addScore, SBean.BattleArrayHp attackingSideHp, SBean.BattleArrayHp defendingSideHp)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof BWArenaMapCopyContext)
		{
			BWArenaMapCopyContext bwContext = BWArenaMapCopyContext.class.cast(context);
			if (bwContext != null)
				bwContext.onEnd(mapId, mapInstance, time, addScore, attackingSideHp, defendingSideHp);
		}
	}

	public synchronized void syncBWArenaMapCopyPopupResult(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof BWArenaMapCopyContext)
		{
			BWArenaMapCopyContext bwContext = BWArenaMapCopyContext.class.cast(context);
			if (bwContext != null)
				bwContext.onPopupResult(mapId, mapInstance, time);
		}
	}

	//势力战
	public synchronized void syncForceWarMapCopyStart(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof ForceWarMapCopyContext)
		{
			ForceWarMapCopyContext fwContext = ForceWarMapCopyContext.class.cast(context);
			if (fwContext != null)
				fwContext.onStart(mapId, mapInstance, time);
		}
	}

	public synchronized void syncForceWarMapCopyEnd(int mapId, int mapInstance, int time, int rankClearTime, int winSide, int killedBoss, int whiteScore, int blackScore, List<SBean.ForceWarOverview> whiteSide, List<SBean.ForceWarOverview> blackSide)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof ForceWarMapCopyContext)
		{
			ForceWarMapCopyContext fwContext = ForceWarMapCopyContext.class.cast(context);
			if (fwContext != null)
				fwContext.onEnd(mapId, mapInstance, time, rankClearTime, winSide, killedBoss, whiteScore, blackScore, whiteSide, blackSide);
		}
	}

	public synchronized void syncForceWarMapCopyPopupResult(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof ForceWarMapCopyContext)
		{
			ForceWarMapCopyContext fwContext = ForceWarMapCopyContext.class.cast(context);
			if (fwContext != null)
				fwContext.onPopupResult(mapId, mapInstance, time);
		}
	}
	
	public synchronized void syncDemonHoleMapCopyEnd(int mapID, int mapInstance, int time, List<SBean.RoleDemonHole> curFloor, List<SBean.RoleDemonHole> total)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof DemonHoleMapCopyContext)
		{
			DemonHoleMapCopyContext dhContext = DemonHoleMapCopyContext.class.cast(context);
			if(dhContext != null)
				dhContext.onEnd(mapID, mapInstance, time, curFloor, total);
		}
	}
	
	public synchronized void syncDemonHoleMapCopyPopupResult(int mapID, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof DemonHoleMapCopyContext)
		{
			DemonHoleMapCopyContext dhContext = DemonHoleMapCopyContext.class.cast(context);
			if(dhContext != null)
				dhContext.onPopupResult(mapID, mapInstance, time);
		}
	}
	
	//身世副本
	public synchronized void syncPetLifeMapCopyStart(int mapID, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if (context instanceof PetLifeMapCopyContext)
		{
			PetLifeMapCopyContext petlifeContext = PetLifeMapCopyContext.class.cast(context);
			if (petlifeContext != null)
				petlifeContext.onStart(mapID, mapInstance, time);
		}
	}
	
	//约战npc
	public synchronized void syncFightNpcMapCopyStart(int mapID, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof FightNpcMapCopyContext)
		{
			FightNpcMapCopyContext fnContext = FightNpcMapCopyContext.class.cast(context);
			fnContext.onStart(mapID, mapInstance, time);
		}
	}
	
	public synchronized void syncFightNpcMapCopyEnd(int mapID, int mapInstance, int time, boolean win)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof FightNpcMapCopyContext)
		{
			FightNpcMapCopyContext fnContext = FightNpcMapCopyContext.class.cast(context);
			fnContext.onEnd(mapID, mapInstance, time, win);
		}
	}
	
	public synchronized void syncFightNpcMapCopyPopupResult(int mapID, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof FightNpcMapCopyContext)
		{
			FightNpcMapCopyContext fnContext = FightNpcMapCopyContext.class.cast(context);
			fnContext.onPopupResult(mapID, mapInstance, time);
		}
	}
	
	//塔防
	synchronized SBean.DummyGoods selectTowerDefenceMapCopyRewardCard(int cardNo)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof TowerDefenceMapCopyContext)
		{
			TowerDefenceMapCopyContext tdContext = TowerDefenceMapCopyContext.class.cast(context);
			return tdContext.onSelectRewardCard(cardNo);
		}
		return null;
	}
	
	public synchronized void syncTowerDefenceMapCopyStart(int mapID, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof TowerDefenceMapCopyContext)
		{
			TowerDefenceMapCopyContext tdContext = TowerDefenceMapCopyContext.class.cast(context);
			tdContext.onStart(mapID, mapInstance, time);
		}
	}
	
	public synchronized void syncTowerDefenceMapCopyEnd(int mapID, int mapInstance, int time, int count, int useTime)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof TowerDefenceMapCopyContext)
		{
			TowerDefenceMapCopyContext tdContext = TowerDefenceMapCopyContext.class.cast(context);
			tdContext.onEnd(mapID, mapInstance, time, count, useTime);
		}
	}
	
	public synchronized void syncTowerDefenceMapCopyPopupResult(int mapID, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof TowerDefenceMapCopyContext)
		{
			TowerDefenceMapCopyContext tdContext = TowerDefenceMapCopyContext.class.cast(context);
			tdContext.onPopupResult(mapID, mapInstance, time);
		}
	}
	
	public synchronized void syncTowerDefenceEndSelectCard(int mapId, int mapInstance, int time)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof TowerDefenceMapCopyContext)
		{
			TowerDefenceMapCopyContext tdContext = TowerDefenceMapCopyContext.class.cast(context);
			tdContext.onEndSelectCard(mapId, mapInstance, time);
		}
	}
	
	public synchronized void syncTowerDefenceSpawnCount(int mapID, int mapInstance, int count)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof TowerDefenceMapCopyContext)
		{
			TowerDefenceMapCopyContext tdContext = TowerDefenceMapCopyContext.class.cast(context);
			tdContext.syncSpawnCount(mapID, mapInstance, count);
		}
	}
	
	public synchronized void syncTowerDefenceScore(int mapID, int mapInstance, int monsterID)
	{
		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context instanceof TowerDefenceMapCopyContext)
		{
			TowerDefenceMapCopyContext tdContext = TowerDefenceMapCopyContext.class.cast(context);
			tdContext.syncScore(mapID, mapInstance, monsterID);
		}
	}
	// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void trySyncRollNotice(boolean islogin)
	{
		if(islogin)
			this.lastSyncRollNoticeTime = 0;
		List<Integer> notices = gs.getLoginManager().getRollNotice().syncRollNotice(this.lastSyncRollNoticeTime);
		if (notices != null)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rollnotice_sync(notices));
		this.lastSyncRollNoticeTime = GameTime.getTime();
	}

	void queryRollNotice(int noticeId)
	{
		SBean.DBRollNotice notice = gs.getLoginManager().getRollNotice().queryRollNotice(noticeId);
		if (notice != null)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rollnotice_detail(notice));
	}

	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	MailBox getMailBox()
	{
		return this.mailbox;
	}

	synchronized void syncNewRoleSysMail()
	{
		for (SBean.DBWorldMail e : gs.getLoginManager().getNewRoleSysMail().getNewRoleSysMails())
		{
			if (!e.channelReq.isEmpty() && !e.channelReq.contains(this.getChannel()))
				continue;
			mailbox.addWorldMail(e.lifeTime, e.title, e.content, GameData.getInstance().toGameItems(e.attachment), GameData.emptyList());
		}
	}
	
	boolean tryReceiveMail()
	{
	    boolean newWorldMail = tryReceiveWorldMail();
	    boolean newDelayedMail = tryReceiveDelayedMail();
	    return newWorldMail || newDelayedMail;
	}
	
	boolean tryReceiveWorldMail()
	{
		List<SBean.DBWorldMail> wmails = gs.getLoginManager().getWorldMail().syncWorldMail(mailbox.getLastSyncWorldMailID());
		if (wmails == null || wmails.isEmpty())
			return false;
		boolean newMail = false;
		int maxWorldID = 0;
		for (SBean.DBWorldMail e : wmails)
		{
			if (e.id > maxWorldID)
				maxWorldID = e.id;
			for (String channel:e.channelReq)
				System.out.println("mail channel: " + channel + ",");
			System.out.println("my channel: " + this.getChannel() + ",");
			if (!e.channelReq.isEmpty() && !e.channelReq.contains(this.getChannel()))
				continue;
			if (e.lvlMin <= this.level && e.vipMin <= this.share.getVipLevel() && e.lvlMax >= this.level && e.vipMax >= this.share.getVipLevel())
			{
				mailbox.addWorldMail(e.lifeTime, e.title, e.content, GameData.getInstance().toGameItems(e.attachment), GameData.emptyList());
				newMail = true;
			}
		}
		mailbox.updateLastSyncWordMailID(maxWorldID);
		return newMail;
	}
	
	boolean tryReceiveDelayedMail()
	{
	    return mailbox.triggerDelayedMailSend();
	}

	boolean testNewMail()
	{
		return mailbox.testNewMail();
	}
	
	void addDropsTmpMail(int dropMapID, List<SBean.GameItem> gis)
	{
		List<Integer> additionalInfo = new ArrayList<Integer>();
		additionalInfo.add(dropMapID);
		mailbox.addSysMail(SysMailType.Drop, MailBox.TEMP_MAIL_MAX_RESERVE_TIME, "", gis, additionalInfo);
	}
	
	void addTaskTempMail(int taskType, int group, int taskID, List<SBean.GameItem> gis)
	{
		List<Integer> additionalInfo = new ArrayList<>();
		additionalInfo.add(taskType);
		additionalInfo.add(group);
		additionalInfo.add(taskID);
		mailbox.addSysMail(SysMailType.Task, MailBox.TEMP_MAIL_MAX_RESERVE_TIME, "", gis, additionalInfo);
	}
	
	private SBean.MailInfo getPageMails(List<SBean.DBMail> lst, int pageNO)
	{
		final int mailCountPerPage = 4;
		int allPageCount = (lst.size() + (mailCountPerPage - 1)) / mailCountPerPage;
		List<SBean.MailBrief> mails = new ArrayList<>();
		int unreadMailCount = 0;
		for (SBean.DBMail mail : lst)
		{
			if (!MailBox.isMailRead(mail))
				unreadMailCount++;
		}
		
		if (pageNO >= 1 && pageNO <= allPageCount)
		{
			int fromIndex = (pageNO - 1) * mailCountPerPage;
			int toIndex = fromIndex + mailCountPerPage;
			if (toIndex > lst.size())
				toIndex = lst.size();
			
			fromIndex = lst.size() - fromIndex;
			toIndex = lst.size() - toIndex;
			
			for (int i = toIndex; i < fromIndex; ++i)
			{
				SBean.DBMail mail = lst.get(i);
				mails.add(GameData.toMailBrief(mail));
			}
		}
		return new SBean.MailInfo(pageNO, allPageCount, lst.size(), unreadMailCount, mails);
	}

	synchronized SBean.MailInfo getSysPageMails(int pageNO)
	{
		List<SBean.DBMail> lst = mailbox.getAllMails(false);
		return getPageMails(lst, pageNO);
	}

	synchronized SBean.MailInfo getTmpPageMails(int pageNO)
	{
		List<SBean.DBMail> lst = mailbox.getAllMails(true);
		return getPageMails(lst, pageNO);
	}

	synchronized SBean.DBMail getSysMailDetail(int mailID)
	{
		return getMailDetail(mailbox.searchSysMail(mailID));
	}
	
	synchronized SBean.DBMail getTmpMailDetail(int mailID)
	{
		return getMailDetail(mailbox.searchTmpMail(mailID));
	}
	
	private SBean.DBMail getMailDetail(SBean.DBMail mail)
	{
		if(mail == null)
			return null;
		MailBox.setMailRead(mail);
		return mail;
	}
	
	synchronized boolean takeSysMailAttachment(int mailID)
	{
		return takeMailAttachment(mailbox.searchSysMail(mailID));
	}
	
	synchronized boolean takeTmpMailAttachment(int mailID)
	{
		return takeMailAttachment(mailbox.searchTmpMail(mailID));
	}
	
	private boolean takeMailAttachment(SBean.DBMail mail)
	{
		if (mail == null)
			return false;
		if (MailBox.isMailAttachmentTaken(mail))
			return false;
		if (!this.canAddGameItems(mail.attachment))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_MAIL_ATTACHMENT);
		tlogEvent.setArg(mail.type, mail.id);
		this.syncAddGameItems(mail.attachment, tlogEvent);
		MailBox.setMailAttachmentTaken(mail);
		if (MailBox.isMailInvalid(mail, GameTime.getTime()))
			mailbox.deleteMail(mail);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	synchronized boolean delSysMail(int id)
	{
		return mailbox.delSysMail(id);
	}
	
	synchronized boolean delTmpMail(int id)
	{
		return mailbox.delTmpMail(id);
	}
	
	private int takeAllMailAttachment(List<SBean.DBMail> lst)
	{
		int takeCount = 0;
		int now = GameTime.getTime();
		for (SBean.DBMail mail : lst)
		{
			if (this.canAddGameItems(mail.attachment))
			{
				TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_ALL_MAIL_ATTACHMENT);
				this.syncAddGameItems(mail.attachment, tlogEvent);
				MailBox.setMailAttachmentTaken(mail);
				if (MailBox.isMailInvalid(mail, now))
					mailbox.deleteMail(mail);
				tlogEvent.setArg(mail.type, mail.id);
				gs.getTLogger().logRoleEventFlow(this, tlogEvent);
				++takeCount;
			}
			else
			{
				break;
			}
		}
		return lst.size() - takeCount;
	}

	synchronized int takeAllSysMailAttachment()
	{
		List<SBean.DBMail> lst = mailbox.getAllMails(false).stream().filter(mail -> !MailBox.isMailAttachmentTaken(mail)).collect(Collectors.toList());
		return takeAllMailAttachment(lst);
	}

	synchronized int takeAllTmpMailAttachment()
	{
		List<SBean.DBMail> lst = mailbox.getAllMails(true).stream().filter(mail -> !MailBox.isMailAttachmentTaken(mail)).collect(Collectors.toList());
		return takeAllMailAttachment(lst);
	}

	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public synchronized void clientEnterMap()
	{
		this.gameMapContext.onClientEnterMap();
	}
	
	public synchronized void mapRoleReady()
	{
		this.gameMapContext.setMapRoleReady(true);
	}
	
	public synchronized int getMapRoleClientSession()
	{
		return this.gameMapContext.isMapRoleReady() ? this.netsid : 0;
	}
	
	private void notifyClientChangeMap(SBean.MapLocation mapLocation, int mapLine)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_change_map(mapLocation, mapLine));
		
		if(this.gameMapContext.isInWorldMap())
		{
			int weaponNpcID = this.weaponUSkill.getNpc();
			if(weaponNpcID > 0)
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_weapon_npc(weaponNpcID));
		}
		
		String chatRoomID = this.gameMapContext.getCurMapContext().getChatRoomID();
		if(chatRoomID != null && !chatRoomID.equals(""))
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_chat_room(chatRoomID));
		
		Role.this.gameMapContext.setMapRoleReady(false);
	}
	
	public synchronized void syncWorldLine()
	{
		if(!this.gameMapContext.isInWorldMap())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.worldline_sync_res(-1, -1));
			return;
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.worldline_sync_res(this.gameMapContext.getCurMapLine(), gs.getMapService().getWorldLineNum(this.gameMapContext.getCurMapId())));
	}
	
	
	//line 从1开始, 0表示专属线
	public int changeWorldLine(int line)
	{
		SBean.MapLocation location = null;
		synchronized(this)
		{
			if(!this.gameMapContext.isInWorldMap() || !checkLineValid(line) || this.mulRolesLock > 0 || this.isMulRolesMember())
				return GameData.PROTOCOL_OP_FAILED;
			
			if(gs.getMapService().isWorldMapFull(this.gameMapContext.getCurMapId(), line))
				return GameData.PROTOCOL_OP_CHANGE_WORLD_LINE_FULL;
			
			boolean carChangeLine =  this.escortCar.checkCarChangeLine(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurWorldInstanceId(), this.gameMapContext.getCurMapPosition());
			if(carChangeLine)
				this.escortCar.changeLine(line);
			
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorldLine(line);
				this.gameMapContext.roleChangeMap();
			}
			else
				location = this.gameMapContext.getCurMapContext().getMapLocation().kdClone();
		}
		
		if(location != null)
			this.mulRolesChangeMap(location, line);
		
		this.onSelfChangeLine(line);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private boolean checkLineValid(int line)
	{
		if(line == this.gameMapContext.getCurMapLine())
			return false;
		
		if(line == 0)
		{
			SBean.WorldMapCFGS wmCfg = GameData.getInstance().getWorldMapCFGS(this.gameMapContext.getCurMapId());
			if(wmCfg != null && wmCfg.pkType == GameData.MAP_PKTYPE_NORMAL)
				return true;
		}
		
		if(line <= 0 || line > gs.getMapService().getWorldLineNum(this.gameMapContext.getCurMapId()))
			return false;
		
		return true;
	}
	
	public boolean enterWayPoint(int wid, int line)
	{
		SBean.MapLocation wayPointLocation = null;
		synchronized(this)
		{
			if(this.mulRolesLock > 0 || this.isMulRolesMember())
				return false;
			
			SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
			wayPointLocation = GameData.getInstance().tryGetWayPointMapPosition(curLocation.mapID, curLocation.location.position, wid);
			if (wayPointLocation == null)
				return false;
			
			line = gs.getMapService().getMinWorld(wayPointLocation.mapID, this.id, getLine(line, wayPointLocation.mapID), this.gameMapContext.getCurMapLine());
			if (this.escortCar.ownerID > 0)
			{
				if (GameData.getInstance().testNearbyPosition(curLocation.mapID, curLocation.location.position, this.escortCar.mapID, this.escortCar.location.position.x, this.escortCar.location.position.y, this.escortCar.location.position.z, GameData.getInstance().getSectDeliverCfgs().stopDistance))
					this.escortCar.changeMap(wayPointLocation.mapID, line, wayPointLocation.location);
			}
			
			if(this.isMulRolesEmpty())
			{
				synchronized(this)
				{
					this.gameMapContext.changeWorld(wayPointLocation, line);
					this.gameMapContext.roleChangeMap();
				}
				this.logTasks(GameData.TASK_TYPE_ENTER_WAYPOINT, wid, 0, 1);
				return true;
			}
		}
		
		this.mulRolesChangeMap(wayPointLocation, line);
		this.logTasks(GameData.TASK_TYPE_ENTER_WAYPOINT, wid, 0, 1);
		return true;
	}
	
	private int getLine(int line, int targetMap)
	{
		if(line == 0)
		{
			SBean.WorldMapCFGS wmCfg = GameData.getInstance().getWorldMapCFGS(targetMap);
			if(wmCfg != null && wmCfg.pkType == GameData.MAP_PKTYPE_NORMAL)
				return line;
		}
		
		return line > 0 ? line : getPriorityLine(targetMap);
	}
	
	private void mulRolesChangeMap(SBean.MapLocation mapLocation)
	{
		this.mulRolesChangeMap(mapLocation, -1);
	}
	
	private void mulRolesChangeMap(SBean.MapLocation mapLocation, int line)
	{
		List<Role> members = new ArrayList<>();
		for(int rid: this.mulRoleInfo.members)
		{
			Role member = gs.getLoginManager().getOnGameRole(rid);
			if(member != null)
				members.add(member);
		}
		
		if(members.isEmpty())
		{
			synchronized(this)
			{
				this.gameMapContext.changeWorld(mapLocation, line);
				this.gameMapContext.roleChangeMap();
			}
		}
		else
		{
			members.add(0, this);
			Role.MultipleRoles mr = new Role.MultipleRoles(members);
			try
			{
				mr.lock();
				if (mr.isClosed())
					return;
				
				for(Role m: members)
				{
					synchronized(m)
					{
						if(m.id == this.id && line < 0)
						{
							m.gameMapContext.changeWorld(mapLocation);
							line = m.gameMapContext.getCurWorldInstanceId();
						}
						else
						{
							m.gameMapContext.changeWorld(mapLocation, line);
						}
					}
				}
				
				members.forEach(m -> {
					synchronized(m)
					{
						m.gameMapContext.roleChangeMap();
					}
				});
			}
			finally
			{
				mr.unlock();
			}
		}
	}
	
	public boolean tryLeaveWrongPos()
	{
		SBean.MapLocation randLocation = null;
		synchronized(this)
		{
			int now = GameTime.getTime();
			if (!this.gameMapContext.isInWorldMap() || this.nextLeaveWrongPosTime > now || this.mulRolesLock > 0 || this.isMulRolesMember())
				return false;

			randLocation = GameData.getInstance().getWorldMapRandPos(this.gameMapContext.getCurMapId());
			if (randLocation == null)
				return false;

			this.nextLeaveWrongPosTime = now + GameData.getInstance().getCommonCFG().gameset.wrongPosLeaveCD;
			if(this.isMulRolesEmpty())
			{
				synchronized(this)
				{
					this.gameMapContext.changeWorld(randLocation, this.getPriorityLine(randLocation.mapID));
					this.gameMapContext.roleChangeMap();
				}
				return true;
			}
		}
		
		this.mulRolesChangeMap(randLocation);
		return true;
	}

	public synchronized boolean tryLeaveMapCopy()
	{
		if(this.isMulRolesState())
			return false;
		
		MapCopyContext context = this.gameMapContext.endMapCopy();
		if(context != null && context.endTime == 0)
			context.earlyLeave();
		
		return context != null;
	}

	boolean startNormalMapCopy(int mid)
	{
		if(this.isMulRolesState())
			return false;
		
		return (GameData.getInstance().getMapCopyOpenType(mid) == GameData.MAPCOPY_OPEN_TYPE_PRIVATE ? startPrivateMapCopy(mid) : startPublicMapCopy(mid));
	}

	synchronized boolean startPrivateMapCopy(int mid)
	{
		SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mid);
		if (!canEnterPrivateMapCopy(cfg))
			return false;

		int instanceId = gs.getMapService().createNormalMapCopy(mid);
		if (instanceId <= 0)
			return false;

		if (!enterPrivateMapCopy(mid, instanceId))
			return false;
		
		gs.getMapService().syncMapCopyReady(mid, instanceId);
		
		return true;
	}

	synchronized boolean enterPrivateMapCopy(int mid, int instanceId)
	{
		PrivateMapCopyContext context = this.tryPreparePrivateMapCopyContext(mid, instanceId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}

	boolean startPublicMapCopy(int mid)
	{
		return gs.getMapCopyManager().roomMembersStartPublicMapCopy(this, mid);
	}

	synchronized boolean enterPublicMapCopy(int mid, int instanceId, boolean mainSpawnPos)
	{
		if (!this.gameMapContext.isInWorldMap())//此处role已经不在房间里了不能在此处加判断在不在房间失败
			return false;

		NormalMapCopyContext context = this.tryPreparePublicMapCopyContext(mid, instanceId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		
		return true;
	}

	int startJusticeMapCopy()
	{
		return gs.getMapCopyManager().roomMembersStartJusticeMapCopy(this);
	}

	int startNpcMapCopy(int mapId)
	{
		return gs.getMapCopyManager().roomMembersStartNpcMapCopy(this, mapId);
	}

	synchronized boolean enterJusticeMapCopy(int mid, int instanceId, boolean mainSpawnPos)
	{
		if (!this.gameMapContext.isInWorldMap())//此处role已经不在房间里了不能在此处加判断在不在房间失败
			return false;

		JusticeMapCopyContext context = this.tryPrepareJusticeMapCopyContext(mid, instanceId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		
		return true;
	}
	
	synchronized boolean startActivityMapCopy(int mid)
	{
		SBean.ActivityMapCFGS cfg = GameData.getInstance().getActivityMapCFGS(mid);
		if (!canEnterActivityMapCopy(cfg, 1) || this.isMulRolesState())
			return false;

		int instanceId = gs.getMapService().createActivityMapCopy(mid);
		if (instanceId <= 0)
			return false;

		if (!enterActivityMapCopy(mid, instanceId))
			return false;

		gs.getMapService().syncMapCopyReady(mid, instanceId);
		return true;
	}

	boolean enterActivityMapCopy(int mid, int instanceId)
	{
		ActivityMapCopyContext context = this.tryPrepareActivityMapCopyContext(mid, instanceId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}
	
	synchronized boolean startWeaponMapCopy()
	{
		if(!this.canEnterWeaponMap())
			return false;
		
		int mapID = GameData.getInstance().getWeaponMapByLevel(this.level);
		if(mapID <= 0)
			return false;
		
		int instanceID = gs.getMapService().createWeaponMapCopy(mapID);
		if(instanceID <= 0)
			return false;
		
		if(!enterWeaponMapCopy(mapID, instanceID))
			return false;
		
		gs.getMapService().syncMapCopyReady(mapID, instanceID);
		return true;
	}
	
	boolean enterWeaponMapCopy(int mapID, int mapInstance)
	{
		WeaponMapCopyContext context = this.tryPrepareWeaponMapCopyContext(mapID, mapInstance);
		if(context == null)
			return false;
		
		this.gameMapContext.startMapCopy(context);
		return true;
	}
	
	public synchronized boolean startSectMapCopy(int mid, int sectId, Map<Integer, Integer> progress)
	{
		SBean.SectMapCFGS cfg = GameData.getInstance().getSectMapCFGS(mid);
		if (!canEnterSectMapCopy(cfg) || this.isMulRolesState())
			return false;

		int instanceId = gs.getMapService().createSectMapCopy(mid, sectId, progress);
		if (instanceId <= 0)
			return false;

		if (!enterSectMapCopy(mid, instanceId))
			return false;
		gs.getTLogger().logRoleSectMapJoinFlow(this, GameData.getInstance().getSectMapLevel(mid), mid, TLog.SECT_MAP_PERSON);
		gs.getMapService().syncMapCopyReady(mid, instanceId);
		return true;
	}

	public boolean enterSectMapCopy(int mid, int instanceId)
	{
		SectMapCopyContext context = this.tryPrepareSectMapCopyContext(mid, instanceId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}

	public synchronized boolean startSectGroupMapCopy(int mid, int instanceId, int startTime)
	{
		SBean.SectGroupMapCFGS cfg = GameData.getInstance().getSectGroupMapCFGS(mid);
		if (!canEnterSectGroupMapCopy(cfg) || this.isMulRolesState())
			return false;
		if (instanceId == 0 || !enterSectGroupMapCopy(mid, instanceId, startTime))
			return false;
		gs.getTLogger().logRoleSectMapJoinFlow(this, GameData.getInstance().getSectGroupMapLevel(mid), mid, TLog.SECT_MAP_GROUP);
		gs.getMapService().syncMapCopyReady(mid, instanceId);
		return true;
	}

	public boolean enterSectGroupMapCopy(int mid, int instanceId, int startTime)
	{
		SectGroupMapCopyContext context = this.tryPrepareSectGroupMapCopyContext(mid, instanceId, startTime);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}

	public void startEmergencyMapCopy(int activityId)
	{
		SBean.EmergencyActivityCFGS cfg = GameData.getInstance().getEmergencyActivityCFGS(activityId);
		if (cfg == null || this.isMulRolesState())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.emergency_enter_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		int canenter = canEnterEmergencyMapCopy(cfg);
		if (canenter <= 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.emergency_enter_res(canenter));
			return;
		}
		gs.getEmergencyManager().checkCanEnterMapCopy(cfg, instanceId -> 
		{
			if (instanceId <= 0)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.emergency_enter_res(instanceId));
				return;
			}
			synchronized (this)
			{
				if (!enterEmergencyMapCopy(cfg.mapId, instanceId, activityId))
				{
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.emergency_enter_res(GameData.PROTOCOL_OP_FAILED));
					return;
				}
			}
			gs.getMapService().syncMapCopyReady(cfg.mapId, instanceId);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.emergency_enter_res(GameData.PROTOCOL_OP_SUCCESS));
		});
	}

	private int canEnterEmergencyMapCopy(SBean.EmergencyActivityCFGS cfg)
	{
		if (this.level < GameData.getInstance().getEmergencyCFGS().levelNeed)
			return GameData.PROTOCOL_OP_EMERGENCY_LEVEL_NEED;
		if (!GameData.getInstance().isInEmergencyDay())
			return GameData.PROTOCOL_OP_EMERGENCY_NOT_IN_OPEN_DAY;
		int now = GameTime.getSecondOfDay();
		for (SBean.TimeSpan timeSpan : cfg.openTime)
		{
			if (now < timeSpan.startTime)
				return GameData.PROTOCOL_OP_EMERGENCY_NOT_IN_OPEN_TIME;
			if (now < timeSpan.endTime)
				break;
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public boolean enterEmergencyMapCopy(int mid, int instanceId, int activityId)
	{
		EmergencyMapCopyContext context = this.tryPrepareEmergencyMapCopyContext(mid, instanceId, activityId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}

	public synchronized boolean startArenaMapCopy(List<Integer> pets, SBean.BattleArray battleArray)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity() || this.isMulRolesState())
			return false;

		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getArenaCFGS().arenaMapID);
		if (mapClusterCfg == null)
			return false;

		int instanceId = gs.getMapService().createArenaMapCopy(mapClusterCfg.id, battleArray);
		if (instanceId <= 0)
			return false;

		if (!enterArenaMapCopy(mapClusterCfg.id, instanceId, pets))
			return false;

		gs.getMapService().syncMapCopyReady(mapClusterCfg.id, instanceId);
		return true;
	}

	public boolean enterArenaMapCopy(int mid, int instanceId, List<Integer> pets)
	{
		ArenaMapCopyContext context = tryPrepareArenaMapCopyContext(mid, instanceId, pets);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}

	public synchronized boolean enterSuperArenaMapCopy(int mapID, int instanceID, boolean mainSpawnPos)
	{
		if (!this.gameMapContext.isInWorldMap())
			return false;

		SuperArenaMapCopyContext context = tryPrepareSuperArenaMapCopyContext(mapID, instanceID, mainSpawnPos);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}

	public int checkCanEnterBWArenaMapCopy(int targetID)
	{
		if (targetID <= 0 || this.isMulRolesState())
			return GameData.PROTOCOL_OP_FAILED;

		int canEnter = this.arenaInfo.canEnterBWArena(targetID);
		if (canEnter <= 0)
			return canEnter;

		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized boolean startBWArenaMapCopy(SBean.BattleArray ba, int bwarenaLvl, Set<Integer> fightPets, boolean selfPetLack)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity() || this.isMulRolesState())
			return false;

		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getBWArenaCFGS().fight.mapID);
		if (mapClusterCfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.bwarena_startattack_res(GameData.PROTOCOL_OP_FAILED));
			return false;
		}

		SBean.BWArenaLvlCFGS lvlCfg = GameData.getInstance().getBWArenaLvlCFGS(bwarenaLvl);
		int maxCount = lvlCfg == null ? GameData.BWARENA_PET_USE_COUNT : lvlCfg.petCount;
		boolean petLack = ba.fightPets.size() < maxCount;
		ba.fightPets = GameData.getBWArenaFightPets(ba.fightPets, maxCount);
		ba.petSeq.clear();
		for(Integer pid: ba.fightPets.keySet())
			ba.petSeq.add(pid);
			
		int instanceId = gs.getMapService().createBWArenaMapCopy(mapClusterCfg.id, ba, petLack, bwarenaLvl <= Role.this.arenaInfo.roleArenaData.bwarena.lvl);
		if (instanceId <= 0)
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.bwarena_startattack_res(GameData.PROTOCOL_OP_FAILED));
			return false;
		}

		if (!enterBWArenaMapCopy(mapClusterCfg.id, instanceId, bwarenaLvl, fightPets, selfPetLack))
			return false;

		SBean.BWArenaBaseCFGS baseCfg = GameData.getInstance().getBWArenaCFGS().base;
		int winScore = this.arenaInfo.roleArenaData.bwarena.lvl < bwarenaLvl ? baseCfg.winScore.get(0) : baseCfg.winScore.get(1);
		if (this.arenaInfo.roleArenaData.bwarena.curEnemies.containsKey(ba.fightRole.base.roleID))
			this.arenaInfo.roleArenaData.bwarena.curEnemies.put(ba.fightRole.base.roleID, -winScore);

		gs.getMapService().syncMapCopyReady(mapClusterCfg.id, instanceId);
		return true;
	}

	public void startBWArenaMapCopy(int targetID)
	{
		gs.getBWArenaManager().startBWArenaBattle(this, targetID);
	}

	public boolean enterBWArenaMapCopy(int mid, int instanceId, int bwArenaLvl, Set<Integer> fightPets, boolean selfPetLack)
	{
		BWArenaMapCopyContext context = tryPrepareBWArenaMapCopyContext(mid, instanceId, bwArenaLvl);
		if (context == null)
			return false;

		context.setIsSameBWArenaLvl(bwArenaLvl <= this.arenaInfo.roleArenaData.bwarena.lvl);
		context.setFightPets(fightPets);
		context.setPetLack(selfPetLack);
		this.gameMapContext.startMapCopy(context);
		if (context.isPetLack())
			gs.getMapService().syncRolePetLack(this.id, mid, context.isPetLack());

		return true;
	}
	
	public synchronized boolean enterForceWarMapCopy(int mapID, int mapInstance, boolean mainSpawn)
	{
		ForceWarMapCopyContext context = tryPrepareForceWarMapCopyContext(mapID, mapInstance, mainSpawn);
		if (context == null)
			return false;
		
		this.gameMapContext.startMapCopy(context);
		return true;
	}
	
	public synchronized void syncFightChatRoom(int mapID, int mapInstance, String roomID)
	{
		MapContext context = this.gameMapContext.getCurMapContext();
		if(context != null && roomID != null && mapID == context.getMapId() && mapInstance == context.getMapInstance())
		{
			context.syncChatRoomID(roomID);
		}
	}
	
//	//宗门遭遇战
//	public synchronized boolean startClanTaskMapCopy(Set<Integer> pets, SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost, SBean.BattleArray battleArray)
//	{
//		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getClanCFGS().taskParam.mapId);
//		if (mapClusterCfg == null)
//			return false;
//		
//		if (!this.gameMapContext.isInWorldMap() || this.isInMRoom() || this.isInARoom())
//			return false;
//		
//		int instanceId = gs.getMapService().createClanTaskMapCopy(mapClusterCfg.id, battleArray);
//		if (instanceId <= 0)
//			return false;
//
//		if (!enterClanTaskMapCopy(mapClusterCfg.id, instanceId, pets, ownerFightPet, ownerFightPetHost))
//			return false;
//
//		gs.getMapService().syncMapCopyReady(mapClusterCfg.id, instanceId);
//		return true;
//	}
//
//	public boolean enterClanTaskMapCopy(int mapId, int instanceId, Set<Integer> pets, SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost)
//	{
//		ClanTaskMapCopyContext context = tryPrepareClanTaskContext(mapId, instanceId, pets, ownerFightPet, ownerFightPetHost);
//		if (context == null)
//			return false;
//
//		this.gameMapContext.startMapCopy(context);
//		return true;
//	}
//
//	//宗门夺矿战
//	public synchronized boolean startClanOreMapCopy(Set<Integer> pets, SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost, SBean.BattleArray battleArray)
//	{
//		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getClanCFGS().robOre.mapId);
//		if (mapClusterCfg == null)
//			return false;
//		int instanceId = gs.getMapService().createClanOreMapCopy(mapClusterCfg.id, battleArray);
//		if (instanceId <= 0)
//			return false;
//
//		if (!enterClanOreMapCopy(mapClusterCfg.id, instanceId, pets, ownerFightPet, ownerFightPetHost))
//			return false;
//
//		gs.getMapService().syncMapCopyReady(mapClusterCfg.id, instanceId);
//		return true;
//	}
//
//	public boolean enterClanOreMapCopy(int mapId, int instanceId, Set<Integer> pets, SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost)
//	{
//		if (!this.gameMapContext.isInWorldMap() || this.isInMRoom())
//			return false;
//
//		ClanOreMapCopyContext context = tryPrepareClanOreContext(mapId, instanceId, pets, ownerFightPet, ownerFightPetHost);
//		if (context == null)
//			return false;
//
//		this.gameMapContext.startMapCopy(context);
//		return true;
//	}
//
//	//宗门支援战
//	public synchronized boolean startClanBattleHelpMapCopy(Set<Integer> pets, SBean.BattleArray battleArray)
//	{
//		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getClanCFGS().battleHelp.mapId);
//		if (mapClusterCfg == null)
//			return false;
//		
//		if (!this.gameMapContext.isInWorldMap() || this.isInMRoom() || this.isInARoom())
//			return false;
//		
//		int instanceId = gs.getMapService().createClanBattleHelpMapCopy(mapClusterCfg.id, battleArray);
//		if (instanceId <= 0)
//			return false;
//
//		if (!enterClanBattleHelpMapCopy(mapClusterCfg.id, instanceId, pets))
//			return false;
//
//		gs.getMapService().syncMapCopyReady(mapClusterCfg.id, instanceId);
//		return true;
//	}
//
//	public boolean enterClanBattleHelpMapCopy(int mapId, int instanceId, Set<Integer> pets)
//	{
//		ClanBattleHelpMapCopyContext context = tryPrepareClanBattleHelpContext(mapId, instanceId, pets);
//		if (context == null)
//			return false;
//
//		this.gameMapContext.startMapCopy(context);
//		return true;
//	}
//
//	//宗门战
//	public synchronized boolean startClanBattleMapCopy(Set<Integer> pets, SBean.BattleArray battleArray, boolean isHurt)
//	{
//		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getClanCFGS().normalBattle.mapId);
//		if (mapClusterCfg == null)
//			return false;
//		
//		if (!this.gameMapContext.isInWorldMap() || this.isInMRoom() || this.isInARoom())
//			return false;
//		
//		int instanceId = gs.getMapService().createClanBattleMapCopy(mapClusterCfg.id, battleArray);
//		if (instanceId <= 0)
//			return false;
//
//		if (!enterClanBattleMapCopy(mapClusterCfg.id, instanceId, pets, isHurt))
//			return false;
//
//		gs.getMapService().syncMapCopyReady(mapClusterCfg.id, instanceId);
//		return true;
//	}
//
//	public boolean enterClanBattleMapCopy(int mapId, int instanceId, Set<Integer> pets, boolean isHurt)
//	{
//		ClanBattleMapCopyContext context = tryPrepareClanBattleContext(mapId, instanceId, pets, isHurt);
//		if (context == null)
//			return false;
//
//		this.gameMapContext.startMapCopy(context);
//		if (context.getHurt())
//			gs.getMapService().syncRoleClanBattleHurt(this.id, mapId, context.getHurt());
//		return true;
//	}

	//随从身世副本
	synchronized boolean startPetLifeMapCopy(int mid, int pid)
	{
		SBean.DBPet dbPet = this.activePets.get(pid);
		if(dbPet == null)
			return false;
		
		SBean.PetLifeMapCFGS cfg = GameData.getInstance().getPetLifeMapCFGS(mid);
		if (!canEntePetLifeMapCopy(cfg, pid) || this.isMulRolesState())		
			return false;

		int instanceId = gs.getMapService().createPetLifeMapCopy(mid);
		if (instanceId <= 0)
			return false;

		if (!enterPetLifeMapCopy(mid, instanceId, dbPet.fightPet.kdClone(), this.getMapPetHostWithoutLock()))
			return false;

		gs.getMapService().syncMapCopyReady(mid, instanceId);
		return true;
	}

	private boolean canEntePetLifeMapCopy(SBean.PetLifeMapCFGS cfg, int pid)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity())
			return false;
		
		if(cfg == null)
			return false;
		
		SBean.DBPet dbPet = this.activePets.get(pid);
		SBean.PetCFGS petCFGS = GameData.getInstance().getPetCFG(pid);
		if (petCFGS == null || petCFGS.lifeMapCopyId != cfg.id || dbPet.fightPet.level < GameData.getInstance().getCommonCFG().pet.coPracticeOpenLvl || isPetLifeTaskFinish(pid))
			return false;
		return true;
	}

	private boolean isPetLifeTaskFinish(int pid)
	{
		SBean.DBPet dbPet = this.activePets.get(pid);
		SBean.PetLifeTaskCFGS petLifeTaskCFGS = GameData.getInstance().getPetLifeTaskCFGS(pid, dbPet.lifetask.id);
		if (petLifeTaskCFGS == null || petLifeTaskCFGS.nextId != 0 || dbPet.lifetask.reward != 1)
			return false;
		return true;
	}

	boolean enterPetLifeMapCopy(int mid, int instanceId, SBean.FightPet fightPet, SBean.PetHost petHost)
	{
		PetLifeMapCopyContext context = this.tryPreparePetLifeMapCopyContext(mid, instanceId, fightPet.id);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		gs.getMapService().syncRoleSetPetAlter(this.id, mid, fightPet, petHost);
		return true;
	}
	
	public synchronized boolean enterDemonHoleMapCopy(int mapID, int instanceID, int floor, int grade)
	{
		DemonHoleMapCopyContext context = tryPrepareDemonHoleMapCopyContext(mapID, instanceID);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		context.setDemonHole(floor, grade);
		context.onStart(mapID, instanceID);
		return true;
	}
	
	private boolean enterFightNpcMapCopy(int mapID, int instanceID)
	{
		FightNpcMapCopyContext context = tryPrepareFightNpcMapCopyContext(mapID, instanceID);
		if(context == null)
			return false;
		
		this.gameMapContext.startMapCopy(context);
		return true;
	}
	
	///

	public SBean.MapSummary sweepPrivateMap(int mapId, int times, int extraCard)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SWEEP_PRIVATE_MAP);
		SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mapId);
		Map<Integer, Integer> monsters = new TreeMap<Integer, Integer>();
		List<SBean.MapRewards> rewards = new ArrayList<SBean.MapRewards>();
		synchronized (this)
		{
			if (cfg == null || cfg.openType != GameData.MAPCOPY_OPEN_TYPE_PRIVATE || this.level < cfg.needLevel || this.level < cfg.sweepLvl)
				return null;

//			if (cfg.preTask > 0 && GameData.getInstance().testMainTaskFinished(cfg.preTask, this.mainTask.id))
//				return null;

			if (cfg.preMapCopy > 0)
			{
				SBean.DBNormalMapCopyLog preMaplog = this.normalMapCopyLogs.get(cfg.preMapCopy);
				if (preMaplog == null || preMaplog.finishTimes <= 0)
					return null;
			}

			SBean.DBNormalMapCopyLog mapLog = normalMapCopyLogs.get(mapId);
			if (times <= 0 || mapLog == null || (cfg.limitTimes > 0 && mapLog.dayEnterTimes + times > cfg.limitTimes + mapLog.dayBuyTimes) || mapLog.bestScore < cfg.sweepScore)
				return null;

			int cardCount = extraCard >= 1 ? 2 : 1;
			SBean.CommonCFGS commonCfg = GameData.getInstance().getCommonCFG();
			int needDiamond = commonCfg.map.lotteryCostDiamond * (cardCount - 1) * times;
			if (!this.containsEnoughGameItem(commonCfg.map.sweepItemId, times) || !this.canUseDiamond(needDiamond, false))
				return null;

			if (cfg.costVit > 0 && !this.canUseVit(cfg.costVit * times))
				return null;
			tlogEvent.setArg(cfg.costVit * times);
			this.useVit(cfg.costVit * times, tlogEvent.getGameItemRecords());
			logMapScheduleData(mapId, mapLog.dayEnterTimes, times);
			mapLog.dayEnterTimes += times;
			mapLog.finishTimes += times;

			this.logTasks(GameData.TASK_TYPE_FINISH_MAPCOPY, mapId, 0, times);
			this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_NORMAL_PRIVATE_MAPCOPY, times);
			this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_NORMAL_MAPCOPY, times);
			int difficult = GameData.getInstance().getMapCopyDifficulty(mapId);
			switch (difficult)
			{
			case GameData.MAPCOPY_DIFFICULT_STORY:
				this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ONE_STORY_MAPCOPY, mapId);
				break;
			case GameData.MAPCOPY_DIFFICULT_EASY:
				this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ONE_EASY_MAPCOPY, mapId);
				break;
			case GameData.MAPCOPY_DIFFICULT_HARD:
				this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ONE_HARD_MAPCOPY, mapId);
				this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_NORMAL_HARD_MAPCOPY, times);
				break;
			default:
				break;
			}
			this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ANY_PRIVATE_MAPCOPY, 0);
			
			gs.getTLogger().logPrivateNormalCopyFlow(this, mapId, times, TLog.COPYEVENT_SWEEP, times);

			tlogEvent.setArg(mapId, times, extraCard);
			this.delGameItem(commonCfg.map.sweepItemId, times, tlogEvent.getGameItemRecords());
			this.useDiamond(needDiamond, false, tlogEvent.getGameItemRecords());

			GameConf.DoubleDropConfig doubleDropCfg = gs.getGameConf().getDoubleDropActivities().getFirstOpenedCofig();
			GameConf.ExtraDropConfig extraDropCfg = gs.getGameConf().getExtraDropActivities().getFirstOpenedCofig();
			SBean.DoubleDropCfg mapDoubleDropCfg = doubleDropCfg == null ? null : doubleDropCfg.getMapDoubleDropCfg();
			SBean.ExtraDropCfg mapExtraDropCfg = extraDropCfg == null ? null : extraDropCfg.getMapExtraDropCfg();
			SBean.RewardRatio rewardRatio = GameData.getMapcopyRewardRatio(mapId, doubleDropCfg);
			for (int index = 0; index < times; index++)
			{
				int exp = 0;
				Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();
				Map<Integer, Integer> cardDrop = new TreeMap<Integer, Integer>();

				// 杀怪奖励
				for (SBean.MapEntity e : cfg.allMonsters.values())
				{
					monsters.compute(e.id, (k, v) -> v == null ? e.count : v + e.count);
					SBean.DropRatio dropRatio = GameData.getMonsterDoubleDropRatio(mapId, e.id, mapDoubleDropCfg);
					SBean.ExtraDropTbl extraDrop = GameData.getMonsterExtraDropTable(mapId, e.id, mapExtraDropCfg);
					exp += (int) (e.exp * e.count * dropRatio.exp);
					for (int i = 0; i < e.count; ++i)
						drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, dropRatio.fixedDrop, dropRatio.randomDrop, extraDrop, drops);

				}
				for (SBean.MapEntity e : cfg.allTraps.values())
				{
					exp += e.exp * e.count;
					for (int i = 0; i < e.count; ++i)
						drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, 1, 1, null, drops);
				}
				// 通关奖励
				exp += (int) (cfg.rewardExp * rewardRatio.exp);
				drops = GameData.getMergedDrops(cfg.fixedDropID, 0, 0, rewardRatio.fixedDrop, 1, null, drops);
				Integer coinCount = drops.remove(GameData.COMMON_ITEM_ID_COIN);
				if (coinCount == null)
				{
					coinCount = 0;
				}
				else
				{
					this.syncAddGameItem(GameData.getInstance().toGameItem(GameData.COMMON_ITEM_ID_COIN, coinCount), tlogEvent);
				}

				// 翻盘奖励
				List<SBean.DropItemCFGS> cardDropList = GameData.getInstance().getNoDuplicateDrops(cfg.turnPlateDropID, GameData.getInstance().getCommonCFG().map.palteCount);
				if (cardDropList != null)
				{
					for (int pos = 0; pos < cardCount; pos++)
					{
						SBean.DummyGoods dropItem = GameData.getInstance().getNextDrop(cardDropList);
						if (dropItem != null)
							cardDrop.merge(dropItem.id, dropItem.count, (ov, nv) -> ov + nv);
					}
				}

				this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
				this.addDropsToBagOrMailBox(mapId, drops, cardDrop);
				rewards.add(new SBean.MapRewards(exp, coinCount, GameData.toDummGoods(drops), GameData.toDummGoods(cardDrop)));
			}
		}

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return new SBean.MapSummary(monsters, rewards);
	}

	public synchronized boolean buyNormalMapCopyEnterTimes(int mapId)
	{
		SBean.DBNormalMapCopyLog log = this.normalMapCopyLogs.get(mapId);
		if (log == null)
			return false;
		SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mapId);
		if (cfg == null || cfg.limitTimes <= 0)
			return false;
		SBean.VipCFGS vipcfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipcfg == null || log.dayBuyTimes >= vipcfg.dayMaxBuyNormalMapCopyEnterTimes)
			return false;
		int useDiamond = GameData.getTimesCost(GameData.getInstance().getCommonCFG().map.buyUseDiamond, log.dayBuyTimes + 1);
		if (!this.canUseDiamond(useDiamond, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_NORMAL_MAPCOPY_TIMES);
		tlogEvent.setArg(mapId);
		this.useDiamond(useDiamond, false, tlogEvent.getGameItemRecords());
		log.dayBuyTimes++;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	public SBean.MapSummary sweepActivityMap(int mapId, int times, int extraCard)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SWEEP_PRIVATE_MAP);
		SBean.ActivityMapCFGS cfg = GameData.getInstance().getActivityMapCFGS(mapId);
		SBean.OfflineWizardFuncCFGS funcCFGS = GameData.getInstance().getOfflineWizardLevelCFGS(this.offlineWizard.level);
		if (cfg == null || !funcCFGS.activitySweep.contains(cfg.groupId))
			return null;
		Map<Integer, Integer> monsters = new TreeMap<Integer, Integer>();
		List<SBean.MapRewards> rewards = new ArrayList<SBean.MapRewards>();
		synchronized (this)
		{
			if (!canEnterActivityMapCopy(cfg, times))
				return null;

			SBean.DBActivityMapGroupLog mapLog = activityMapGroupLogs.get(cfg.groupId);
			if (mapLog.records.getOrDefault(mapId, 0) < 10000)
				return null;

			int cardCount = extraCard >= 1 ? 2 : 1;
			SBean.CommonCFGS commonCfg = GameData.getInstance().getCommonCFG();
			int needDiamond = commonCfg.map.lotteryCostDiamond * (cardCount - 1) * times;
			if (!this.containsEnoughGameItem(commonCfg.map.sweepItemId, times) || !this.canUseDiamond(needDiamond, false))
				return null;

			tlogEvent.setArg(cfg.costVit * times);
			this.useVit(cfg.costVit * times, tlogEvent.getGameItemRecords());
			logMapScheduleData(mapId, mapLog.dayEnterTimes, times);
			mapLog.dayEnterTimes += times;

			this.logTasks(GameData.TASK_TYPE_FINISH_MAPCOPY, mapId, 0, times);
			this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_ACTIVITY_MAPCOPY_1, times);
			this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_ACTIVITY_MAPCOPY_2, times);
			Role.this.logActivityChallengeGift(GameData.ACTIVITY_CHALLENGE_TYPE_ACTIVITY_MAP, cfg.groupId, times);

			tlogEvent.setArg(mapId, times, extraCard);
			this.delGameItem(commonCfg.map.sweepItemId, times, tlogEvent.getGameItemRecords());
			this.useDiamond(needDiamond, false, tlogEvent.getGameItemRecords());

			GameConf.DoubleDropConfig doubleDropCfg = gs.getGameConf().getDoubleDropActivities().getFirstOpenedCofig();
			GameConf.ExtraDropConfig extraDropCfg = gs.getGameConf().getExtraDropActivities().getFirstOpenedCofig();
			SBean.DoubleDropCfg mapDoubleDropCfg = doubleDropCfg == null ? null : doubleDropCfg.getMapDoubleDropCfg();
			SBean.ExtraDropCfg mapExtraDropCfg = extraDropCfg == null ? null : extraDropCfg.getMapExtraDropCfg();
			SBean.RewardRatio rewardRatio = GameData.getMapcopyRewardRatio(mapId, doubleDropCfg);
			
			for (int index = 0; index < times; index++)
			{
				int exp = 0;
				Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();
				Map<Integer, Integer> cardDrop = new TreeMap<Integer, Integer>();

				// 杀怪奖励
				for (SBean.MapEntity e : cfg.allMonsters.values())
				{
					monsters.compute(e.id, (k, v) -> v == null ? e.count : v + e.count);
					SBean.DropRatio dropRatio = GameData.getMonsterDoubleDropRatio(mapId, e.id, mapDoubleDropCfg);
					SBean.ExtraDropTbl extraDrop = GameData.getMonsterExtraDropTable(mapId, e.id, mapExtraDropCfg);
					exp += (int) (e.exp * e.count * dropRatio.exp);
					for (int i = 0; i < e.count; ++i)
						drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, dropRatio.fixedDrop, dropRatio.randomDrop, extraDrop, drops);

				}
				for (SBean.MapEntity e : cfg.allTraps.values())
				{
					exp += e.exp * e.count;
					for (int i = 0; i < e.count; ++i)
						drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, 1, 1, null, drops);
				}
				// 通关奖励
				exp += (int) (cfg.rewardExp * rewardRatio.exp);
				drops = GameData.getMergedDrops(cfg.fixedDropID, 0, 0, rewardRatio.fixedDrop, 1, null, drops);
				Integer coinCount = drops.remove(GameData.COMMON_ITEM_ID_COIN);
				if (coinCount == null)
				{
					coinCount = 0;
				}
				else
				{
					this.syncAddGameItem(GameData.getInstance().toGameItem(GameData.COMMON_ITEM_ID_COIN, coinCount), tlogEvent);
				}

				// 翻牌奖励
				List<SBean.DropItemCFGS> cardDropList = GameData.getInstance().getNoDuplicateDrops(cfg.turnPlateDropID, GameData.getInstance().getCommonCFG().map.palteCount);
				if (cardDropList != null)
				{
					for (int pos = 0; pos < cardCount; pos++)
					{
						SBean.DummyGoods dropItem = GameData.getInstance().getNextDrop(cardDropList);
						if (dropItem != null)
							cardDrop.merge(dropItem.id, dropItem.count, (ov, nv) -> ov + nv);
					}
				}

				this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
				this.addDropsToBagOrMailBox(mapId, drops, cardDrop);
				rewards.add(new SBean.MapRewards(exp, coinCount, GameData.toDummGoods(drops), GameData.toDummGoods(cardDrop)));
			}
		}

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logActiveCopyFlow(Role.this, mapId, 0, TLog.COPYEVENT_SWEEP, times);
		return new SBean.MapSummary(monsters, rewards);
	}
	
	public synchronized boolean buyActivityMapCopyEnterTimes(int groupId)
	{
		SBean.DBActivityMapGroupLog log = this.activityMapGroupLogs.get(groupId);
		if (log == null)
			return false;
		SBean.ActivityMapGroupCFGS cfg = GameData.getInstance().getActivityMapGroupCFGS(groupId);
		if (cfg == null || cfg.dayEnterTimes <= 0)
			return false;
		SBean.VipCFGS vipcfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipcfg == null || log.dayBuyTimes >= vipcfg.dayMaxBuyActivityMapGroupEnterTimes)
			return false;

		int useDiamond = GameData.getTimesCost(GameData.getInstance().getCommonCFG().activity.buyUseDiamond, log.dayBuyTimes + 1);
		if (!this.canUseDiamond(useDiamond, false))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_ACTIVITY_MAPCOPY_TIMES);
		tlogEvent.setArg(groupId);
		this.useDiamond(useDiamond, false, tlogEvent.getGameItemRecords());
		log.dayBuyTimes++;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	private int getActivityMapCopyTotalEnterTimes()
	{
		int sum = 0;
		for (SBean.DBActivityMapGroupLog log : this.activityMapGroupLogs.values())
		{
			sum += log.historyEnterTimes;
		}
		return sum;
	}

	private PrivateMapCopyContext tryPreparePrivateMapCopyContext(int mapId, int instanceId)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
		if (mapClusterCfg == null)
			return null;
		SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mapId);
		if (cfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		PrivateMapCopyContext mapCopyContext = new PrivateMapCopyContext(mapId, mapLocation.location);
		mapCopyContext.setVitCost(cfg.costVit);
		mapCopyContext.setFinishedRewardDropID(cfg.rewardExp, cfg.fixedDropID, cfg.turnPlateDropID);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}

	private PublicMapCopyContext tryPreparePublicMapCopyContext(int mapId, int instanceId)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
		if (mapClusterCfg == null)
			return null;

		SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mapClusterCfg.id);
		if (cfg == null)
			return null;

		float angle = getSpawnPosAngle();
		SBean.MapLocation mapLocation =  GameData.getMapSpawnLocation(mapClusterCfg, true, angle);
		
//		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		PublicMapCopyContext mapCopyContext = new PublicMapCopyContext(mapId, mapLocation.location);
		mapCopyContext.setVitCost(cfg.costVit);
		mapCopyContext.setFinishedRewardDropID(cfg.rewardExp, cfg.fixedDropID, cfg.turnPlateDropID);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}

	private TowerDefenceMapCopyContext tryPrepareTowerDefenceMapCopyContext(int mapID, int instanceID)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapID);
		if (mapClusterCfg == null)
			return null;

		SBean.TowerDefenceMapCFGS cfg = GameData.getInstance().getTowerDefenceMapCFGS(mapClusterCfg.id);
		if (cfg == null)
			return null;

		float angle = getSpawnPosAngle();
		SBean.MapLocation mapLocation =  GameData.getMapSpawnLocation(mapClusterCfg, true, angle);
		TowerDefenceMapCopyContext mapCopyContext = new TowerDefenceMapCopyContext(mapID, cfg.turnPlateDropID, mapLocation.location);
		mapCopyContext.setInstanceId(instanceID);
		return mapCopyContext;
	}
	
	private ActivityMapCopyContext tryPrepareActivityMapCopyContext(int mapId, int instanceId)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
		if (mapClusterCfg == null)
			return null;
		SBean.ActivityMapCFGS cfg = GameData.getInstance().getActivityMapCFGS(mapId);
		if (cfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		ActivityMapCopyContext mapCopyContext = new ActivityMapCopyContext(cfg.groupId, mapId, mapLocation.location);
		mapCopyContext.setVitCost(cfg.costVit);
		mapCopyContext.setFinishedRewardDropID(cfg.rewardExp, cfg.fixedDropID, cfg.turnPlateDropID);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}

	private WeaponMapCopyContext tryPrepareWeaponMapCopyContext(int mapID, int mapInstance)
	{
		SBean.MapClusterCFGS mcc = GameData.getInstance().getMapClusterCFGS(mapID);
		if(mcc == null)
			return null;
		
		SBean.WeaponMapCFGS wmc = GameData.getInstance().getWeaponMapCFGS(mapID);
		if(wmc == null)
			return null;
		
		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mcc);
		WeaponMapCopyContext context = new WeaponMapCopyContext(mapID, mapLocation.location);
		context.setFinishedRewardDropID(wmc.rewardExp, wmc.fixedDropID, wmc.turnPlateDropID);
		context.setInstanceId(mapInstance);
		return context;
	}

	private JusticeMapCopyContext tryPrepareJusticeMapCopyContext(int mapID, int mapInstance)
	{
		SBean.MapClusterCFGS mcc = GameData.getInstance().getMapClusterCFGS(mapID);
		if(mcc == null)
			return null;
		
		SBean.JusticeMapCopyCFGS jmc = GameData.getInstance().getJusticeMapCopyCFGS(mapID);
		if(jmc == null)
			return null;
		
		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mcc);
		JusticeMapCopyContext context = new JusticeMapCopyContext(mapID, mapLocation.location);
		context.setFinishedRewardDropID(jmc.rewardExp, 0, jmc.turnPlateDropID);
		context.setInstanceId(mapInstance);
		return context;
	}
	
	private SectMapCopyContext tryPrepareSectMapCopyContext(int mapId, int instanceId)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
		if (mapClusterCfg == null)
			return null;

		SBean.SectMapCFGS cfg = GameData.getInstance().getSectMapCFGS(mapClusterCfg.id);
		if (cfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		SectMapCopyContext mapCopyContext = new SectMapCopyContext(mapId, mapLocation.location);
		mapCopyContext.setVitCost(cfg.enterCostVit);
		mapCopyContext.setMoneyRewardFactor(cfg.moneyRewardFactor);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}

	private SectGroupMapCopyContext tryPrepareSectGroupMapCopyContext(int mapId, int instanceId, int startTime)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
		if (mapClusterCfg == null)
			return null;

		SBean.SectGroupMapCFGS cfg = GameData.getInstance().getSectGroupMapCFGS(mapClusterCfg.id);
		if (cfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		SectGroupMapCopyContext mapCopyContext = new SectGroupMapCopyContext(mapId, mapLocation.location, startTime);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}

	private EmergencyMapCopyContext tryPrepareEmergencyMapCopyContext(int mapId, int instanceId, int activityId)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
		if (mapClusterCfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		EmergencyMapCopyContext mapCopyContext = new EmergencyMapCopyContext(mapId, mapLocation.location, activityId);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}

	ArenaMapCopyContext tryPrepareArenaMapCopyContext(int mapId, int instanceId, List<Integer> pets)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getArenaCFGS().arenaMapID);
		if (mapClusterCfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		ArenaMapCopyContext mapCopyContext = new ArenaMapCopyContext(mapClusterCfg.id, mapLocation.location);
		mapCopyContext.setFightPets(pets);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}

	SuperArenaMapCopyContext tryPrepareSuperArenaMapCopyContext(int mapID, int instanceID, boolean mainSpawnPos)
	{
		SBean.MapLocation mapLocation = getSuperArenaSpawnLocation(mapID, mainSpawnPos);
		if(mapLocation == null)
			return null;
		
		SuperArenaMapCopyContext mapCopyContext = new SuperArenaMapCopyContext(mapID, mapLocation.location);
		mapCopyContext.setInstanceId(instanceID);
		mapCopyContext.setIsMainSpawnPos(mainSpawnPos);
		return mapCopyContext;
	}
	
	SBean.MapLocation getSuperArenaSpawnLocation(int mapID, boolean mainSpawnPos)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapID);
		if (mapClusterCfg == null)
			return null;

		float angle = getSpawnPosAngle();
		return GameData.getMapSpawnLocation(mapClusterCfg, mainSpawnPos, angle);
	}
	
	private float getSpawnPosAngle()
	{
		int count = this.team.members.size();
		int index = 0;
		for (int i = 0; i < count; i++)
		{
			if (this.id == this.team.members.get(i))
			{
				index = i + 1;
				break;
			}
		}
		float unit = (float) (count > 0 ? (Math.PI * 2.f / count) : 0.f);
		return GameRandom.getRandFloat(unit * index, unit * index + unit * 0.8f);
	}
	
	BWArenaMapCopyContext tryPrepareBWArenaMapCopyContext(int mapID, int instanceID, int bwArenaLvl)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(GameData.getInstance().getBWArenaCFGS().fight.mapID);
		if (mapClusterCfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		BWArenaMapCopyContext mapCopyContext = new BWArenaMapCopyContext(mapClusterCfg.id, mapLocation.location);
		mapCopyContext.setInstanceId(instanceID);
		return mapCopyContext;
	}
	
	ForceWarMapCopyContext tryPrepareForceWarMapCopyContext(int mapID, int mapInstance, boolean mainSpawn)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapID);
		if (mapClusterCfg == null)
			return null;
		
		float angle = GameRandom.getRandFloat(0, (float)Math.PI * 2.f);
		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg, mainSpawn, angle);		//正派 在主出生点， 邪派在第二出生点
		ForceWarMapCopyContext mapCopyContext = new ForceWarMapCopyContext(mapID, mapLocation.location);
		mapCopyContext.setInstanceId(mapInstance);
		mapCopyContext.setIsMainSpawnPos(mainSpawn);
		return mapCopyContext;
	}

	private PetLifeMapCopyContext tryPreparePetLifeMapCopyContext(int mapID, int instanceID, int petId)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapID);
		if (mapClusterCfg == null)
			return null;
		
		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		PetLifeMapCopyContext mapCopyContext = new PetLifeMapCopyContext(mapID, mapLocation.location, petId);
		mapCopyContext.setInstanceId(instanceID);
		return mapCopyContext;
	}

	private ClimbTowerMapCopyContext tryPrepareClimbTowerMapCopyContext(int groupId, int mapId, int instanceId)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
		if (mapClusterCfg == null)
			return null;
		SBean.ClimbTowerMapCFGS cfg = GameData.getInstance().getClimbTowerMapCFGS(mapId);
		if (cfg == null)
			return null;

		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		ClimbTowerMapCopyContext mapCopyContext = new ClimbTowerMapCopyContext(groupId, mapId, mapLocation.location);
		mapCopyContext.setVitCost(cfg.costVit);
		mapCopyContext.setFinishedRewardDropID(cfg.rewardExp, cfg.fixedDropID, cfg.turnPlateDropID);
		mapCopyContext.setInstanceId(instanceId);
		return mapCopyContext;
	}
	
	DemonHoleMapCopyContext tryPrepareDemonHoleMapCopyContext(int mapID, int instanceID)
	{
		SBean.MapLocation mapLocation = GameData.getInstance().getDemonHoleSpawnLocation(mapID);
		if(mapLocation == null)
			return null;
		
		DemonHoleMapCopyContext mapCopyContext = new DemonHoleMapCopyContext(mapID, mapLocation.location);
		mapCopyContext.setInstanceId(instanceID);
		return mapCopyContext;
	}
	
	private FightNpcMapCopyContext tryPrepareFightNpcMapCopyContext(int mapID, int instanceID)
	{
		SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapID);
		if (mapClusterCfg == null)
			return null;
		
		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
		FightNpcMapCopyContext mapCopyContext = new FightNpcMapCopyContext(mapID, mapLocation.location);
		mapCopyContext.setInstanceId(instanceID);
		return mapCopyContext;
	}
	
	boolean canEnterPrivateMapCopy(SBean.MapCopyCFGS cfg)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity())
			return false;
		
		if (cfg == null || cfg.openType != GameData.MAPCOPY_OPEN_TYPE_PRIVATE || !GameData.isMapCopyInOpenTime(cfg.startTime, cfg.endTime))
			return false;
		
		if (this.level < cfg.needLevel)
			return false;

//		if (cfg.preTask > 0 && GameData.getInstance().testMainTaskFinished(cfg.preTask, this.mainTask.id))
//			return false;
		
		SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(this.mainTask.id);
		if (cfg.preTask > 0 && (mainCFGS == null || (cfg.preTask != this.mainTask.id && !GameData.getInstance().testMainTaskFinished(cfg.preTask, this.mainTask.id, this.BWType))))
			return false;
		
		if (cfg.preMapCopy > 0)
		{
			SBean.DBNormalMapCopyLog preMaplog = this.normalMapCopyLogs.get(cfg.preMapCopy);
			if (preMaplog == null || preMaplog.finishTimes <= 0)
				return false;
		}

		SBean.DBNormalMapCopyLog log = this.normalMapCopyLogs.get(cfg.id);
		if (cfg.limitTimes > 0 && (log != null && log.dayEnterTimes >= cfg.limitTimes + log.dayBuyTimes))
			return false;
		// 单机副本扣体力，多人不扣
		if (cfg.costVit > 0 && !canUseVit(cfg.costVit))
			return false;
		return true;
	}

	boolean canEnterSectMapCopy(SBean.SectMapCFGS cfg)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity())
			return false;

		if (cfg == null || !GameData.isMapCopyInOpenTime(cfg.startTime, cfg.endTime))
			return false;
		
		if (this.level < cfg.lvlReq)
			return false;

		if (cfg.dayEnterTimes > 0)
		{
			Integer dayEnterTimes = this.sectData.data.daySectMapEnterTimes.get(cfg.id);
			if (dayEnterTimes != null && dayEnterTimes >= cfg.dayEnterTimes)
				return false;
		}
		// 帮派副本扣体力，多人不扣
		if (cfg.enterCostVit > 0 && !canUseVit(cfg.enterCostVit))
			return false;
		return true;
	}

	boolean canEnterSectGroupMapCopy(SBean.SectGroupMapCFGS cfg)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity())
			return false;

		if (cfg == null)
			return false;
		
		if (this.level < cfg.enterLevel)
			return false;

		return true;
	}

	boolean canEnterWeaponMap()
	{
		if(!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity() || this.isMulRolesState())
			return false;
		
		if(!this.weaponUSkill.canEnterMap())
			return false;
		
		return true;
	}
	
	boolean canEnterActivityMapCopy(SBean.ActivityMapCFGS cfg, int times)
	{
		if (cfg == null)
			return false;

		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity())
			return false;
		
		SBean.ActivityMapGroupCFGS gcfg = GameData.getInstance().getActivityMapGroupCFGS(cfg.groupId);
		int weekDay = GameTime.getWeekdayByOffset(GameTime.getTime(), GameData.GAME_DAY_REFRESH_TIME * 3600);
		if (gcfg == null || !gcfg.weekDays.contains(weekDay) ||!GameData.checkInOpenTime(gcfg.openStartTime, gcfg.lastTime))
			return false;

		if (this.level < cfg.lvlReq)
			return false;

		SBean.DBActivityMapGroupLog log = this.activityMapGroupLogs.get(cfg.groupId);
		if (cfg.preMap > 0 && (log == null || !log.enterMaps.contains(cfg.preMap)))
			return false;
		if (gcfg.dayEnterTimes > 0 && (log != null && log.dayEnterTimes + times > gcfg.dayEnterTimes + log.dayBuyTimes))
			return false;

		if (cfg.costVit > 0 && !canUseVit(cfg.costVit))
			return false;
		return true;
	}
	
	boolean canEnterClimbTowerCopy(int groupId, SBean.ClimbTowerFloorDataCFGS cfg)
	{
		if (cfg==null)
			return false;
		
		SBean.ClimbTowerBaseDataCFGS baseCfg = GameData.getInstance().getClimbTowerBaseData();
		if (this.level < baseCfg.needlvl)
			return false;
		
		if (cfg.floor > this.climbTowerData.roleClimbTowerData.history.getOrDefault(groupId, 0) + 1)
			return false;
		SBean.ClimbTowerMapCFGS mapCfg = GameData.getInstance().getClimbTowerMapCFGS(cfg.dungeonId);
		if (mapCfg == null)
			return false;
		if (this.roleProperties.getRoleFightPower() < mapCfg.fightPower)
			return false;
		if (mapCfg.costVit > 0 && !canUseVit(mapCfg.costVit))
			return false;

		if (this.climbTowerData.roleClimbTowerData.dayTimesUsed >= GameData.getInstance().getClimbTowerBaseData().dayTimes + this.climbTowerData.roleClimbTowerData.dayTimesBuy)
			return false;
		
		return true;
	}
	
	abstract class MapContext
	{
		protected int mapId;
		protected int instanceId = -1;
		protected SBean.Location location;
		protected boolean onMapServer;
		protected int hp;
		protected int hpMax;
		protected int curRideHorse;
		protected Map<Integer, SBean.Hp> curPetHp;
		final private boolean canRide;
		protected int sp;
		protected int armorVal;
		protected int armorValMax;
		final boolean canRevive;
		final boolean canUseHpPool;
		protected String chatRoomID;
		protected boolean canTakeDrop = true;
		
		MapContext(int mapId, SBean.Location location)
		{
			this.mapId = mapId;
			this.location = location;
			this.canRide = GameData.getInstance().getHorseCommonCFGS().canRideMaps.contains(getMapType());
			curPetHp = new HashMap<Integer, SBean.Hp>();
			this.canRevive = !GameData.getInstance().getCommonCFG().map.forbidReviveMaps.contains(getMapType());
			this.canUseHpPool = !GameData.getInstance().getCommonCFG().map.forbidUseHpPoolMaps.contains(getMapType());
		}

		abstract int getMapType();
		abstract void syncChatRoomID(String roomID);
		
		String getChatRoomID()
		{
			return chatRoomID;
		}
		
		boolean canRevive()
		{
			return canRevive;
		}

		boolean canUseHpPool()
		{
			return canUseHpPool;
		}
		
		abstract void onAfterEnterMap();

		Map<Integer, SBean.Hp> getCurPetHp()
		{
			return curPetHp;
		}
		
		void setCurPetHp(Map<Integer, SBean.Hp> curPetHp)
		{
			this.curPetHp = curPetHp;
		}
		
		int getMapId()
		{
			return mapId;
		}

		void setInstanceId(int instanceId)
		{
			this.instanceId = instanceId;
		}
		
		int getMapInstance()
		{
			return instanceId;
		}
		
		int getMapLine()
		{
			return instanceId;
		}
		
		SBean.Location getLocation()
		{
			return this.location;
		}

		void setLocation(SBean.Location location)
		{
			this.location = location;
		}

		void syncLocation(SBean.Location location)
		{
			setLocation(location);
			Role.this.notifyTeamMemberUpdatePosition(mapId, getMapLine(), location.position);
		}

		SBean.MapLocation getMapLocation()
		{
			return new SBean.MapLocation(mapId, location);
		}

		void syncCurRideHorse(int hid)
		{
			this.curRideHorse = hid;
		}

		void setCurRideHorse(int hid)
		{
			this.curRideHorse = hid;
		}
		
		int getCurRideHorse()
		{
			return this.curRideHorse;
		}
		
		boolean canRide()
		{
			return canRide;
		}
		
		int getHp()
		{
			return this.hp;
		}
		
		int getSp()
		{
			return this.sp;
		}
		
		int getHpMax()
		{
			return this.hpMax;
		}

		void setHp(int hp, int hpMax)
		{
			if (this.hp > 0 && hp == 0)
				addDeadTimes();
			this.hp = hp;
			this.hpMax = hpMax;
		}

		void syncSp(int sp)
		{
			this.sp = sp;
		}
		
		void syncHp(int hp, int hpMax)
		{
			setHp(hp, hpMax);
			Role.this.notifyTeamMemberUpdateHp(hp, hpMax);
		}
		
		void addDeadTimes()
		{
		}
		
		int getArmorVal()
		{
			return this.armorVal;
		}
		
		void setArmorVal(int val, int valMax)
		{
			this.armorVal = val;
			this.armorValMax = valMax;
		}
		
		int addExp(int exp, int addType, int addParam)
		{
			return (int) Role.this.syncAddExp(exp, addType, addParam);
		}
		
		void pickUpDropsImpl(Map<Integer, SBean.DummyGoods> drops, Map<Integer, Integer> counters)
		{
			if(Role.this.canAddGameItems(counters))
			{
				Role.this.addDropsToBag(this.mapId, counters);
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, new HashSet<>(drops.keySet()), 1);
				gs.getLogger().debug("--------------------role " + Role.this.id + " , " + Role.this.name + " pick up " + counters + " success");
			}
			else
			{
				this.onBagFull(counters, new HashSet<>(drops.keySet()));
			}
		}
		
		void pickUpDrops(Map<Integer, SBean.DummyGoods> drops)
		{
			Map<Integer, Integer> counters = new HashMap<>();
			for(SBean.DummyGoods d: drops.values())
			{
				counters.merge(d.id, d.count, (ov, nv) -> ov + nv);
			}
			pickUpDropsImpl(drops, counters);
		}
		
		void pickUpRareDrop(int dropId, SBean.DummyGoods drop, int monsterId)
		{
			if(Role.this.canAddGameItem(drop.id, drop.count))
			{
				Role.this.addDropToBag(this.mapId, drop.id, drop.count);
				Set<Integer> dropIds = new HashSet<>();
				dropIds.add(dropId);
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIds, 1);
				gs.getLogger().debug("--------------------role " + Role.this.id + " , " + Role.this.name + " pick up rare goods " + drop.id + " , " + drop.count + " success");
			}
			else
			{
				this.onBagFull(drop.id, drop.count, dropId);
			}
			if (monsterId != 0 && this.getMapType() == GameData.MAP_TYPE_MAPCOPY_NORMAL)
				gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_GET_ORANGE, Role.this.name + "|" + this.mapId + "|" + monsterId + "|" + drop.id);
		}
		
		void onBagFull(Map<Integer, Integer> counters, Set<Integer> dropIds)
		{
			if(!dropIds.isEmpty())
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIds, 0);
			gs.getLogger().debug("--------------------role " + Role.this.id + " , " + Role.this.name + " pick up " + counters + " bag full-----------------------------");
		}
		
		void onBagFull(int itemID, int count, int dropID)
		{
			if(dropID > 0)
			{
				Set<Integer> dropIDs = new HashSet<>();
				dropIDs.add(dropID);
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIDs, 0);
			}
			gs.getLogger().debug("--------------------role " + Role.this.id + " , " + Role.this.name + " pick up " + itemID + " ," + count + " bag full----------------");
		}
		
		void addKill(int type, int id, int count, float weaponAdd, int killRole)
		{
			if (type == GameData.ENTITY_TYPE_MONSTER)
			{
				Role.this.logTasks(GameData.TASK_TYPE_KILL, id, 0, count);
				Role.this.checkTreasureMonster(id);
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_team_kill(type, id, count));
				if(killRole > 0)
				{
					addMonsterExp(id, count, weaponAdd);
				}
				addKillMonster(id, count, killRole);
			}
			else if(type == GameData.ENTITY_TYPE_PLAYER)
			{
				addKillRole(id, count);
			}
		}

		void addMonsterExp(int monsterId, int count, float weaponAdd)
		{
			if (!this.canTakeDrop)
				return;
			SBean.MonsterCFGS monsterCfg = GameData.getInstance().getMonsterCFGS(monsterId);
			if (monsterCfg != null)
			{
				GameConf.DoubleDropConfig doubleDropCfg = gs.getGameConf().getDoubleDropActivities().getFirstOpenedCofig();
				SBean.DoubleDropCfg mapDoubleDropCfg = doubleDropCfg == null ? null : doubleDropCfg.getMapDoubleDropCfg();
				SBean.DropRatio dropRatio = GameData.getMonsterDoubleDropRatio(mapId, monsterId, mapDoubleDropCfg);
				
				int teamMemberCnt = Role.this.getTeamMemberCnt();
				int exp = (int) (monsterCfg.addExp * count * dropRatio.exp * weaponAdd);
				exp = teamMemberCnt == 0 ? exp :(int)((exp / teamMemberCnt) * GameData.getInstance().getCommonCFG().team.killMonsterExpAdd);
				if(exp > 0 && GameData.getInstance().getCommonCFG().monsterExp.effectMapTyps.contains(this.getMapType()))
					exp = (int) (exp * GameData.getInstance().getMonsterExpPercent(Role.this.level - monsterCfg.level));
				
				addExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_KILL_MONSTER, 0);
			}
		}

		void addKillMonster(int id, int count, int killRole)
		{

		}
		
		void addKillRole(int id, int count)
		{

		}
		
		SBean.FightRole getFightRole()
		{
			return Role.this.getMapFightRoleWithoutLock();
		}

		Map<Integer, SBean.DBBuff> getBuffs()
		{
			return Stream.clone(Role.this.buffs);
		}

		SBean.PKInfo getPKInfo()
		{
			return new SBean.PKInfo(this.getPKMode(), Role.this.pkValue);
		}

		abstract int getPKMode();

		abstract boolean setPKMode(int mode);

		abstract Map<Integer, SBean.FightPet> getMapPets();
		
		List<Integer> getPetSeq()
		{
			return GameData.emptyList();
		}
		
		SBean.PetHost getOnLoanPetHost()
		{
			return null;
		}

		boolean getHurt()
		{
			return false;
		}

		boolean isMainSpawnPos()
		{
			return true;
		}
		
		int getDayFailedStreak()
		{
			return 0;
		}
		
		void enterMap()
		{
			if (!onMapServer)
			{
				onMapServer = gs.getMapService().roleEnterMap(this.getFightRole(), this.getMapId(), this.getMapInstance(), this.getLocation(), this.getHp(), this.getSp(),
						this.getArmorVal(), this.getBuffs(), this.getMapPets(), this.getPetSeq(), this.getOnLoanPetHost(), this.getPKInfo(), Role.this.team, this.getCurRideHorse(), 
						Role.this.mulRoleInfo.kdClone(), Role.this.getAlterState(), this.isMainSpawnPos(), this.getDayFailedStreak(), Role.this.getUseableVipLvl(), Role.this.offlineWizard.curWizard, this.canTakeDrop);

				Role.this.notifyTeamMemberUpdateHp(this.getHp(), this.getHpMax());
				Role.this.notifyTeamMemberUpdatePosition(this.getMapId(), this.getMapLine(), this.getLocation().position);
				Role.this.fightState = false;
				this.onAfterEnterMap();
			}

//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_change_map(getMapLocation(), getMapLine()));
		}

		void roleChangeMap()
		{
			Role.this.notifyClientChangeMap(getMapLocation(), getMapLine());
		}
		
		void resetLocation(SBean.Location location)
		{
			this.location = location;
			if (onMapServer)
				gs.getMapService().roleResetMapLocation(Role.this.id, this.mapId, this.getMapInstance(), location);
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_change_map(getMapLocation(), getMapLine()));
		}

		void leaveMap()
		{
			if (onMapServer)
				onMapServer = !gs.getMapService().roleLeaveMap(Role.this.id, mapId, this.getMapInstance());
		}

		void clientEnterMap()
		{
			gs.getMapService().syncRoleUpdateActive(Role.this.id, mapId, true);
		}
		
		void putPetHp(int mapId, int mapInstance, int petId, SBean.Hp hp)
		{
			if (mapId != this.mapId || mapInstance != this.instanceId)
				return;
			if (hp.curValue < 0)
				this.curPetHp.remove(petId);
			else
				this.curPetHp.put(petId, hp);
		}
	}

	class GameMapContext
	{
		protected boolean mapRoleReady;
		private WorldMapContext worldMapContext;
		private MapCopyContext mapCopyContext;

		GameMapContext(SBean.MapLocation mapLocation)
		{
			this.worldMapContext = new WorldMapContext(mapLocation.mapID, mapLocation.location);
		}

		MapContext getCurMapContext()
		{
			return mapCopyContext != null ? mapCopyContext : worldMapContext;
		}

		int getCurMapId()
		{
			return getCurMapContext().getMapId();
		}
		
		int getCurMapInstance()
		{
			return getCurMapContext().getMapInstance();
		}
		
		int getCurMapLine()
		{
			return getCurMapContext().getMapLine();
		}
		
		int getCurWorldInstanceId()
		{
			return worldMapContext.getMapInstance();
		}
		
		SBean.Vector3 getCurMapPosition()
		{
			return getCurMapContext().getLocation().position;
		}

		void resetLocation(SBean.Location location)
		{
			MapContext mapContext = this.getCurMapContext();
			mapContext.resetLocation(location);
		}

		boolean isInWorldMap()
		{
			return mapCopyContext == null;
		}
		
		boolean isMapRoleReady()
		{
			return mapRoleReady;
		}
		
		void setMapRoleReady(boolean ready)
		{
			this.mapRoleReady = ready;
		}

		void enterGameWorld()
		{
			if (mapCopyContext != null)
			{
				mapCopyContext.enterMapCopy();
				mapCopyContext.roleChangeMap();
			}
			else
			{
				if(worldMapContext.instanceId < 0)
				{
					worldMapContext.instanceId = Role.this.getPriorityLine(worldMapContext.mapId);
					worldMapContext.enterWorld(-1);
				}
				worldMapContext.roleChangeMap();
			}
		}

		void setWorldInstance(int instanceId)
		{
			this.worldMapContext.setInstanceId(instanceId);
		}
		
		void changeWorld(SBean.MapLocation mapLocation)
		{
			this.changeWorld(mapLocation, -1);
		}
		
		void setRoleToBirthMap()
		{
			if(this.mapCopyContext != null)
			{
				this.mapCopyContext.endMapCopy();
				this.mapCopyContext = null;
			}
			
			SBean.MapLocation mapLocation = GameData.getInstance().getClassRoleSpawnMapPosition(Role.this.classType);
			this.worldMapContext.changeWorld(mapLocation.mapID,  mapLocation.location, Role.this.getPriorityLine(mapLocation.mapID));
		}
		
		void changeWorld(SBean.MapLocation mapLocation, int line)
		{
			this.worldMapContext.changeWorld(mapLocation.mapID, mapLocation.location, line);
		}
		
		void roleChangeMap()
		{
			if(this.mapCopyContext != null)
				this.mapCopyContext.roleChangeMap();
			else
				this.worldMapContext.roleChangeMap();
		}
		
		void changeWorldLine(int line)
		{
			this.worldMapContext.changeLine(line);
		}
		
		void leaveGameWorld()
		{
			if (mapCopyContext != null)
			{
				mapCopyContext.endMapCopy();
				mapCopyContext = null;
			}
			else
			{
				worldMapContext.leaveWorld();
			}
		}

		void startMapCopy(MapCopyContext context)
		{
			if (worldMapContext != null)
			{
				worldMapContext.leaveWorld();
				mapCopyContext = context;
				mapCopyContext.startMapCopy();
			}
		}
		
		MapCopyContext endMapCopy()
		{
			MapCopyContext context = mapCopyContext;
			if (mapCopyContext != null)
			{
				mapCopyContext.endMapCopy();
				mapCopyContext = null;
				
				if(Role.this.id > 0)
				{
					worldMapContext.instanceId = Role.this.getPriorityLine(worldMapContext.mapId);
					worldMapContext.enterWorld(-1);
					worldMapContext.roleChangeMap();
				}
			}
			return context;
		}

		WorldMapContext getWorldMapContext()
		{
			return worldMapContext;
		}

		MapCopyContext getMapCopyContext()
		{
			return mapCopyContext;
		}

		void onClientEnterMap()
		{
			if (mapCopyContext != null)
				mapCopyContext.clientEnterMapCopy();
			else
				worldMapContext.clientEnterWorld();
		}

		void onSyncLocation(int mapId, int instanceId, SBean.Location location)
		{
			MapContext mapContext = this.getCurMapContext();
			if (mapContext.getMapId() == mapId && mapContext.getMapInstance() == instanceId)
			{
				mapContext.syncLocation(location);
			}
		}

		void onSyncCurRideHorse(int mapId, int instanceId, int hid)
		{
			MapContext mapContext = this.getCurMapContext();
			if (mapContext.getMapId() == mapId && mapContext.getMapInstance() == instanceId)
			{
				mapContext.syncCurRideHorse(hid);
			}
		}

		void onSyncHp(int mapId, int instanceId, int hp, int hpMax)
		{
			MapContext mapContext = this.getCurMapContext();
			if (mapContext.getMapId() == mapId && mapContext.getMapInstance() == instanceId)
			{
				mapContext.syncHp(hp, hpMax);
			}
		}
		
		void onSyncSp(int mapID, int instanceID, int sp)
		{
			MapContext mapContext = this.getCurMapContext();
			if(mapContext.getMapId() == mapID && mapContext.getMapInstance() == instanceID)
			{
				mapContext.syncSp(sp);
			}
		}
		
		void onSyncArmorVal(int mapID, int mapInstance, int armorVal, int armorValMax)
		{
			MapContext mapContext = this.getCurMapContext();
			if(mapContext.getMapId() == mapID && mapContext.getMapInstance() == mapInstance)
				mapContext.setArmorVal(armorVal, armorValMax);
		}
		
		//		void onAddExp(int mapId, int instanceId, int exp)
		//		{
		//			MapContext mapContext = this.getCurMapContext();
		//			if (mapContext.getMapId() == mapId && mapContext.getMapInstance() == instanceId)
		//				mapContext.addExp(exp);
		//		}

		
		void onPickUpDrops(int mapID, int mapInstance, Map<Integer, SBean.DummyGoods> drops)
		{
			MapContext mapContext = this.getCurMapContext();
			if (mapContext.getMapId() == mapID && mapContext.getMapInstance() == mapInstance)
			{
				mapContext.pickUpDrops(drops);
			}
		}
		
		void onPickUpRareDrops(int mapID, int mapInstance, int dropId, SBean.DummyGoods drop, int monsterId)
		{
			MapContext mapContext = this.getCurMapContext();
			if (mapContext.getMapId() == mapID && mapContext.getMapInstance() == mapInstance)
			{
				mapContext.pickUpRareDrop(dropId, drop, monsterId);
			}
		}
		
		void onAddKill(int mapId, int instanceId, int type, int id, int count, float weaponAdd, int killRole)
		{
			MapContext mapContext = this.getCurMapContext();
			if (mapContext.getMapId() == mapId && mapContext.getMapInstance() == instanceId)
			{
				mapContext.addKill(type, id, count, weaponAdd, killRole);
			}
		}
	}

	class WorldMapContext extends MapContext
	{
		int pkMode = GameData.ATTACK_MODE_PEACE;
		boolean canSetPKMode = true;

		WorldMapContext(int worldMapId, SBean.Location location)
		{
			super(worldMapId, location);
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAP_WORLD;
		}
		
//		int getMapLine()
//		{
//			return this.instanceId;
//		}
		
		void syncChatRoomID(String roomID)
		{
			
		}
		
		void setInstanceId(int instanceId)
		{
			if(instanceId < 0)
				gs.getLogger().warn("role " + Role.this.id + " set map " + mapId + " instanceId " + instanceId + " invalid !");
			
			this.instanceId = instanceId;
		}

		int getPKMode()
		{
			return this.pkMode;
		}

		boolean setPKMode(int mode)
		{
			if (!canSetPKMode || this.pkMode == mode)
				return false;
			
			this.pkMode = mode;
			return true;
		}
		
		void onEnterWorldSetPKMode()
		{
			SBean.WorldMapCFGS mapCfg = GameData.getInstance().getWorldMapCFGS(this.mapId);
			if (mapCfg == null)
				return;

			switch (mapCfg.pkType)
			{
			case GameData.MAP_PKTYPE_SAFE:
				this.pkMode = GameData.ATTACK_MODE_PEACE;
				break;
			case GameData.MAP_PKTYPE_SECT:
				this.pkMode = GameData.ATTACK_MODE_SECT;
				break;
			case GameData.MAP_PKTYPE_KILL:
				this.pkMode = GameData.ATTACK_MODE_ALL;
				break;
			case GameData.MAP_PKTYPE_NORMAL:
				this.pkMode = this.instanceId == 0 ? GameData.ATTACK_MODE_SECT : this.pkMode;
				break;
			default:
				break;
			}
			this.canSetPKMode = (mapCfg.pkType == GameData.MAP_PKTYPE_NORMAL && this.instanceId != 0);
		}

		void onLeaveWorldSetPKMode()
		{
			SBean.WorldMapCFGS mapCfg = GameData.getInstance().getWorldMapCFGS(this.mapId);
			if (mapCfg == null)
				return;
			
			if (mapCfg.pkType == GameData.MAP_PKTYPE_SECT || this.instanceId == 0)
				this.pkMode = GameData.ATTACK_MODE_PEACE;
		}
		
		void onAfterEnterMap()
		{
			Role.this.weaponUSkill.refreshNpc(this.mapId);
			Role.this.trigSceneMonsterAfterEnterMap(this.getMapId());
			Role.this.syncMapTaskDrop();
			Role.this.syncMapMarriageSkills(false);
			Role.this.onSelfChangeLine(this.instanceId);
		}
		
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(Role.this.worldMapPets);
		}

		void enterWorld(int lastLine)
		{
			this.setInstanceId(gs.getMapService().getMinWorld(this.mapId, Role.this.id, this.instanceId, lastLine));
			
			this.onEnterWorldSetPKMode();
			super.enterMap();
			if(Role.this.escortCar.ownerID != 0 || Role.this.isRob != 0)
				gs.getMapService().syncRoleUpdateCarBehavior(Role.this.id, this.mapId, (byte)(Role.this.escortCar.ownerID != 0 ? 1: 0), Role.this.isRob);
		}

		void leaveWorld()
		{
			super.leaveMap();
			this.onLeaveWorldSetPKMode();
			
			this.instanceId = -1;
		}
		
		void changeWorld(int worldMapId, SBean.Location location, int line)
		{
			if (this.mapId == worldMapId && line < 0)
			{
				this.resetLocation(location);
			}
			else
			{
				int lastLine = this.instanceId;
				this.leaveWorld();
				this.mapId = worldMapId;
				this.instanceId = line;
				this.location = location;
				this.enterWorld(lastLine);
			}
		}
		
		void changeLine(int line)
		{
			int lastLine = this.instanceId;
			this.leaveWorld();
			this.instanceId = line;
			this.enterWorld(lastLine);
		}
		
		void clientEnterWorld()
		{
			this.clientEnterMap();
		}

		void addKillRole(int id, int count)
		{
			Role deader = gs.getLoginManager().getOnGameRole(id);
			if(deader != null)
			{
				gs.getLoginManager().addNormalTaskEvent(() -> 
				{
					deader.addEnemy(Role.this.id);
				});
			}
		}
	}

	abstract class MapCopyContext extends MapContext
	{
		protected int startTime;
		protected int endTime;
		protected int popupTime;
		Map<Integer, Integer> tmpMailDrops = new HashMap<>();

		MapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

		void syncChatRoomID(String roomID)
		{
			this.chatRoomID = roomID;
			if(roomID != null && !roomID.equals(""))
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_chat_room(roomID));
		}
		
		int getPKMode()
		{
			return GameData.ATTACK_MODE_PEACE;
		}

		boolean setPKMode(int mode)
		{
			return false;
		}

		void enterMapCopy()
		{
			super.enterMap();
		}

		void leaveMapCopy()
		{
			super.leaveMap();
		}

		void clientEnterMapCopy()
		{
			super.clientEnterMap();
			if (this.startTime > 0)
				syncMapCopy();
		}

		abstract void onBeforeEnterMapCopy();

		abstract void onBeforeLeaveMapCopy();
		abstract void onAfterLeaveMapCopy();

		void onAfterEnterMap()
		{
			Role.this.syncMapMarriageSkills(false);
		}
		
		void startMapCopy()
		{
			onBeforeEnterMapCopy();
			enterMapCopy();
			roleChangeMap();
		}

		void endMapCopy()
		{
			dropTmpMail();
			onBeforeLeaveMapCopy();
			leaveMapCopy();
			onAfterLeaveMapCopy();
		}

		 void earlyLeave()
		 {
			 
		 }
		
		void syncMapCopy()
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_timesync(this.mapId, this.startTime));
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_cantake_drop(this.mapId, (byte)(this.canTakeDrop ? 1 : 0)));
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance || this.startTime != 0)
				return false;
			this.startTime = time;
			syncMapCopy();
			return true;
		}

		boolean onEnd(int mapId, int mapInstance, int time)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance || this.startTime == 0 || this.endTime != 0)
				return false;
			this.endTime = time;
			return true;
		}

		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance || this.endTime == 0 || this.popupTime != 0)
				return false;
			this.popupTime = time;
			return true;
		}
		
		void onBagFull(Map<Integer, Integer> counters, Set<Integer> dropIds)
		{
			gs.getLogger().debug("--------------------role " + Role.this.id + " , " + Role.this.name + " pick up " + counters + " bag full to tmp mail on map copy end");
			for(Map.Entry<Integer, Integer> e: counters.entrySet())
				this.tmpMailDrops.merge(e.getKey(), e.getValue(), (ov, nv) -> ov + nv);
			
			if(!dropIds.isEmpty())
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIds, 1);
		}
		
		void onBagFull(int itemID, int count, int dropID)
		{
			gs.getLogger().debug("--------------------role " + Role.this.id + " , " + Role.this.name + " pick up " + itemID + " ," + count + " bag full to tmp mail on map copy end");
			this.tmpMailDrops.merge(itemID, count, (ov, nv) -> ov + nv);
			
			if(dropID > 0)
			{
				Set<Integer> dropIDs = new HashSet<>();
				dropIDs.add(dropID);
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIDs, 1);
			}
		}
		
		private void dropTmpMail()
		{
			if(this.tmpMailDrops.isEmpty())
				return;
			
			Role.this.addDropsToMailBox(this.mapId, GameData.getInstance().toGameItems(this.tmpMailDrops, Role.this.weaponUSkill.getprAdjust()));
			gs.getLogger().debug("@@@@@ send role " + Role.this.id + " , " + Role.this.name + " drop tmp mails on map copy end " + tmpMailDrops);
		}
	}
	
	class PetLifeMapCopyContext extends MapCopyContext
	{
		int petId;
		PetLifeMapCopyContext(int mapId, SBean.Location location, int petId)
		{
			super(mapId, location);
			this.petId = petId;
		}

		@Override
		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}
		
		@Override
		void onAfterLeaveMapCopy()
		{
			
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_PETLIFE;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Collections.emptyMap();
		}
		
		boolean onStart(int mapId, int mapInstance, int time)
		{
			if (!super.onStart(mapId, mapInstance, time))
				return false;
			onEnterPetLifeMapCopy();
			return true;
		}
		
		void onEnterPetLifeMapCopy()
		{
		}

		public int getPetId()
		{
			return petId;
		}
	}
	
	abstract class CommonMapCopyContext extends MapCopyContext
	{
		int vitCost;
		int finishedExp;
		int finishedFixedDropID;
		int finishedTurnPlateDropID;

		int score;
		int deadTimes;
		int killMonsters;
		int exp;
		int process = 0;
		Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();
		List<SBean.DropItemCFGS> cards;
		SBean.MapRewards rewards;

		CommonMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

		abstract int getMapType();

		abstract Set<Integer> getFightPets();

		abstract void onEnterCommonMapCopy();

		abstract void onFinishCommonMapCopy();

		void setVitCost(int cost)
		{
			this.vitCost = cost;
		}

		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(this.getFightPets());
		}

		void setFinishedRewardDropID(int exp, int fixedDropId, int turnPlateDropId)
		{
			this.finishedExp = exp;
			this.finishedFixedDropID = fixedDropId;
			this.finishedTurnPlateDropID = turnPlateDropId;
		}

		void addDeadTimes()
		{
			this.deadTimes++;
		}

		int addExp(int exp, int addType, int addParam)
		{
			int addExp = super.addExp(exp, addType, addParam);
			this.exp += addExp;
			return addExp;
		}
		
		void pickUpDrops(Map<Integer, SBean.DummyGoods> drops)
		{
			Map<Integer, Integer> counters = new HashMap<>();
			for(SBean.DummyGoods d: drops.values())
			{
				counters.merge(d.id, d.count, (ov, nv) -> ov + nv);
				this.drops.merge(d.id, d.count, (ov, nv) -> ov + nv);
			}
			
			this.pickUpDropsImpl(drops, counters);
		}
		
		void pickUpRareDrop(int dropId, SBean.DummyGoods drop, int monsterId)
		{
			this.drops.merge(drop.id, drop.count, (ov, nv) -> ov + nv);
			super.pickUpRareDrop(dropId, drop, monsterId);
		}
		
		void addKillMonster(int id, int count, int killRole)
		{
			this.killMonsters++;
		}

		void giveMapCopyFinishedReward(int mapID, Set<Integer> roles)
		{
			if (!this.canTakeDrop)
				return;
			SBean.RewardRatio ratio = GameData.getMapcopyRewardRatio(this.mapId, gs.getGameConf().getDoubleDropActivities().getFirstOpenedCofig());
			//通关经验奖励
			this.addExp((int) (this.finishedExp * ratio.exp), GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_ACTIVITY_MAPCOPY, this.mapId);
			// 通关奖励
			Map<Integer, Integer> fixedDrops = GameData.getInstance().getMergedFixedDrop(this.finishedFixedDropID, 1);
			if (fixedDrops == null)
				fixedDrops = GameData.emptyMap();

			this.addItems(fixedDrops);

			switch (getMapType())
			{
			case GameData.MAP_TYPE_MAPCOPY_NORMAL:
				Role.this.masterAddMapReward(mapID, roles);
				break;
			default:
				break;
			}
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_COMMON_MAPCOPY_ONSTART);
			tlogEvent.setArg(mapId, mapInstance, time);
			if (!super.onStart(mapId, mapInstance, time))
				return false;
			if (this.vitCost > 0)
				Role.this.useVit(this.vitCost, tlogEvent.getGameItemRecords());
			onEnterCommonMapCopy();

			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_commonmap_start(this.mapId));
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			return true;
		}

		boolean onEnd(int mapId, int mapInstance, int time, int score, Set<Integer> roles)
		{
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			this.score = score;
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_commonmap_end(this.mapId, score));
			if (score != 0)//普通副本通关score>0，活动副本没有通关概念，时间到就结束score小于0
			{
				onFinishCommonMapCopy();
				giveMapCopyFinishedReward(mapId, roles);
			}
			gs.getTLogger().logCommonMapCopyEnd(Role.this, mapId, score != 0);
			
			return true;
		}

		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapId, mapInstance, time))
				return false;

			Integer coinCount = this.drops.remove(GameData.COMMON_ITEM_ID_COIN);
			if (coinCount == null)
				coinCount = 0;
			
			// 翻牌奖励
			this.cards = GameData.getInstance().getNoDuplicateDrops(this.finishedTurnPlateDropID, GameData.getInstance().getCommonCFG().map.palteCount);
			this.rewards = new SBean.MapRewards(this.exp, coinCount, GameData.toDummGoods(this.drops), GameData.convertDrops(this.cards));

			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_commonmap_result(this.mapId, this.score, this.endTime - this.startTime, this.deadTimes, this.killMonsters, this.rewards, this.process > 10000 ? 10000 : this.process));
			return true;
		}

		void onEndSelectCard(int mapId, int mapInstance, int time)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance || this.cards == null || !this.canTakeDrop)
				return;
			if (GameData.getInstance().getCommonCFG().map.palteCount == this.cards.size())
			{
				SBean.DummyGoods item = GameData.getInstance().getNextDrop(this.cards);
				if (item != null)
				{
					this.addItem(item.id, item.count);
					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_commonmap_autocard(item));
				}
			}
		}

		SBean.DummyGoods onSelectRewardCard(int cardNo)
		{
			if (!this.canTakeDrop)
				return null;
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ON_SELECT_REWARD_CARD);
			if (this.cards == null)
				return null;
			int cardCount = GameData.getInstance().getCommonCFG().map.palteCount;
			if (cardNo - 1 + this.cards.size() != cardCount || (cardNo != 1 && cardNo != 2))
				return null;

			int cost = GameData.getInstance().getCommonCFG().map.lotteryCostDiamond;
			if (cardNo != 1 && !Role.this.canUseDiamond(cost, false))
				return null;
			SBean.DummyGoods item = GameData.getInstance().getNextDrop(this.cards);
			if (item == null)
				return null;
			
			this.addItem(item.id, item.count);
			tlogEvent.setArg(cardNo, this.mapId, item.id, item.count);
			if (cardNo != 1)
				Role.this.useDiamond(cost, false, tlogEvent.getGameItemRecords());

			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			return item;
		}
		
		void addItems(Map<Integer, Integer> counters)
		{
			for(Map.Entry<Integer, Integer> e: counters.entrySet())
				this.drops.merge(e.getKey(), e.getValue(), (ov, nv) -> ov + nv);
			
			if(Role.this.canAddGameItems(counters))
			{
				Role.this.addDropsToBag(this.mapId, counters);
			}
			else
			{
				this.onBagFull(counters, new HashSet<>());
			}
		}
		
		void addItem(int itemID, int count)
		{
			this.drops.merge(itemID, count, (ov, nv) -> ov + nv);
			if(Role.this.canAddGameItem(itemID, count))
			{
				Role.this.addDropToBag(this.mapId, itemID, count);
			}
			else
			{
				this.onBagFull(itemID, count, 0);
			}
		}
	}

	abstract class NormalMapCopyContext extends CommonMapCopyContext
	{
		NormalMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);

			SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mapId);
			SBean.DBNormalMapCopyLog log = Role.this.normalMapCopyLogs.get(mapId);
			this.canTakeDrop = log == null ? cfg.limitTimes != 0 : (cfg.limitTimes > 0 && log.dayEnterTimes < cfg.limitTimes + log.dayBuyTimes) || cfg.limitTimes < 0 || log.rewardTimes > 0;
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_NORMAL;
		}

		void onEnterCommonMapCopy()
		{
			SBean.DBNormalMapCopyLog normalEnterTimes = Role.this.normalMapCopyLogs.merge(mapId, new SBean.DBNormalMapCopyLog(0, 1, 0, 1, 0, 0), (ov, nv) ->
			{
				ov.dayEnterTimes += 1;
				ov.enterTimes ++;
				SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mapId);
				if(ov.dayEnterTimes > (cfg != null ? cfg.limitTimes : 0) + ov.dayBuyTimes)
				{
					ov.rewardTimes--;
					if(ov.rewardTimes < 0)
						ov.rewardTimes = 0;
				}
				return ov;
			});
			
			Role.this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_NORMAL_MAPCOPY, 1);
			Role.this.logMainTask(GameData.TASK_TYPE_ENTER_PRIVATEMAP, this.mapId, 0, 1);
			logMapScheduleData(mapId, normalEnterTimes.dayEnterTimes - 1, 1);
		}

		void onFinishCommonMapCopy()
		{
			Role.this.normalMapCopyLogs.compute(mapId, (k, v) ->
			{
				if (v == null)
				{
					v = new SBean.DBNormalMapCopyLog(1, 1, score, 1, 0, 0);
				}
				else
				{
					v.finishTimes++;
					v.bestScore = score > v.bestScore ? score : v.bestScore;
				}
				return v;
			});
			for (int pid : this.getFightPets())
			{
				SBean.DBPet pet = Role.this.activePets.get(pid);
				if (pet != null)
				{
					pet.mapLogs.add(this.mapId);
				}
			}

			logTasks(GameData.TASK_TYPE_FINISH_MAPCOPY, mapId, 0, 1);
			
		}
	}

	class PrivateMapCopyContext extends NormalMapCopyContext
	{
		PrivateMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

        Set<Integer> getFightPets()
        {
            return Role.this.privateMapPets;
        }

        @Override
        void onEnterCommonMapCopy()
        {
            super.onEnterCommonMapCopy();
            gs.getTLogger().logPrivateNormalCopyFlow(Role.this, mapId, 0, TLog.COPYEVENT_START, 0);
        }

        void onFinishCommonMapCopy()
        {
            super.onFinishCommonMapCopy();
            Role.this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_NORMAL_PRIVATE_MAPCOPY, 1);
            int difficult = GameData.getInstance().getMapCopyDifficulty(mapId);
            switch (difficult)
            {
                case GameData.MAPCOPY_DIFFICULT_STORY:
                    Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ONE_STORY_MAPCOPY, mapId);
                    break;
                case GameData.MAPCOPY_DIFFICULT_EASY:
                    Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ONE_EASY_MAPCOPY, mapId);
                    break;
                case GameData.MAPCOPY_DIFFICULT_HARD:
                    Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ONE_HARD_MAPCOPY, mapId);
                    Role.this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_NORMAL_HARD_MAPCOPY, 1);
                    break;
                default:
                    break;
            }
            gs.getTLogger().logPrivateNormalCopyFlow(Role.this, mapId, 0, TLog.COPYEVENT_FINISH, 0);
            Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ANY_PRIVATE_MAPCOPY, 0);
        }

        void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					// 单人副本进入即离队
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}
		
		void onAfterLeaveMapCopy()
		{

		}
	}

	class PublicMapCopyContext extends NormalMapCopyContext
	{
		PublicMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

        Set<Integer> getFightPets()
        {
            return Collections.emptySet();
        }
        
        void onEnterCommonMapCopy()
        {
            super.onEnterCommonMapCopy();
            gs.getTLogger().logPublicNormalCopyFlow(Role.this, mapId, 0, TLog.COPYEVENT_START);
        }

        void onFinishCommonMapCopy()
        {
            super.onFinishCommonMapCopy();
            Role.this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_NORMAL_PUBLIC_MAPCOPY, 1);
            Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ONE_TEAM_MAPCOPY, mapId);
            Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_ANY_PUBLIC_MAPCOPY, 0);
            gs.getTLogger().logPublicNormalCopyFlow(Role.this, mapId, 0, TLog.COPYEVENT_FINISH);
        }

        void onBeforeEnterMapCopy()
		{
			
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			if (endTime == 0)
			{
				gs.getLoginManager().addNormalTaskEvent(new Runnable()
				{

					@Override
					public void run()
					{
						Role.this.leaveTeam();
					}
				});
			}
		}
		
		void onAfterLeaveMapCopy()
		{
			
		}
	}

	class SectMapCopyContext extends MapCopyContext
	{
		int vitCost;
		List<SBean.FactorCFGS> rewardFactor;

		int progress;
		int damage;
		int accDamageRank;
		int maxDamageRank;
		int extraReward;
		int goldReward;
		Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();

		SectMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_SECT;
		}

		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(Role.this.sectMapPets);
		}

		void setVitCost(int cost)
		{
			this.vitCost = cost;
		}

		void setMoneyRewardFactor(List<SBean.FactorCFGS> factor)
		{
			this.rewardFactor = factor;
		}
		
		void pickUpDrops(Map<Integer, SBean.DummyGoods> drops)
		{
			Map<Integer, Integer> counters = new HashMap<>();
			for(SBean.DummyGoods d: drops.values())
			{
				counters.merge(d.id, d.count, (ov, nv) -> ov + nv);
				this.drops.merge(d.id, d.count, (ov, nv) -> ov + nv);
			}
			
			this.pickUpDropsImpl(drops, counters);
		}
		
		void pickUpRareDrop(int dropId, SBean.DummyGoods drop, int monsterId)
		{
			this.drops.merge(drop.id, drop.count, (ov, nv) -> ov + nv);
			super.pickUpRareDrop(dropId, drop, monsterId);
		}
		
		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					// 帮派副本进入即离队
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}
		
		void onAfterLeaveMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{

				@Override
				public void run()
				{
					gs.getSectManager().roleLeaveSectMap(Role.this, mapId);
				}
			});
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_MAPCOYP_ONSTART);
			if (!super.onStart(mapId, mapInstance, time))
				return false;

			tlogEvent.setArg(mapId, mapInstance, time, this.vitCost);
			if (this.vitCost > 0)
				Role.this.useVit(this.vitCost, tlogEvent.getGameItemRecords());
			Role.this.sectData.data.daySectMapEnterTimes.merge(mapId, 1, (ov, nv) -> ov + nv);
			Role.this.logDailyTask(GameData.DAILY_TASK_ID_START_ANY_SECT_MAPCOPY, 1);
			Role.this.logTaskScheduleData(GameData.SCHEDULE_TYPE_SECT_MAPCOPY);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_sectmap_start(mapId));
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			return true;
		}

		boolean onEnd(int mapId, int mapInstance, int time, int progress, int damage, int accDamageRank, int maxDamageRank, int extraReward)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_MAPCOYP_ONEND);
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			this.progress = progress;
			this.damage = damage;
			this.accDamageRank = accDamageRank;
			this.maxDamageRank = maxDamageRank;
			this.extraReward = extraReward;
			this.goldReward = GameData.getSectMapDamageReward(this.rewardFactor, damage);

			tlogEvent.setArg(extraReward, this.goldReward);
			gs.getLoginManager().addNormalTaskEvent(() -> gs.getSectManager().addSectMapTime(Role.this));
			Role.this.syncAddSectContribution(extraReward, tlogEvent.getGameItemRecords());
			Role.this.syncAddCoin(this.goldReward, false, tlogEvent);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_sectmap_end(mapId, progress));
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			return true;
		}

		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapId, mapInstance, time))
				return false;
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_sectmap_result(mapId, progress, damage, accDamageRank, maxDamageRank, extraReward, drops, this.goldReward));
			return true;
		}
	}

	class SectGroupMapCopyContext extends MapCopyContext
	{
		float rewardFactor;

		int progress;
		Map<Integer, Integer> damage;
		int accDamageRank;
		int maxDamageRank;
		int extraReward;
		int startTime;

		SectGroupMapCopyContext(int mapId, SBean.Location location, int startTime)
		{
			super(mapId, location);
			this.startTime = startTime;
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_SECT_GROUP;
		}

		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(Role.this.worldMapPets);
		}

		void setMoneyRewardFactor(float factor)
		{
			this.rewardFactor = factor;
		}

		void syncMapCopy()
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_timesync(this.mapId, this.startTime));
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_cantake_drop(this.mapId, (byte)(this.canTakeDrop ? 1 : 0)));
		}

		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					if (Role.this.isInTeam())
						gs.getTeamManager().teamMemberLeave(Role.this);
					gs.getSectManager().roleEnterSectGroupMap(Role.this);
				}
			});
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					if (Role.this.isInTeam())
						gs.getTeamManager().teamMemberLeave(Role.this);
					gs.getSectManager().roleLeaveSectGroupMap(Role.this);
				}
			});
		}
		
		void onAfterLeaveMapCopy()
		{
			
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			if (!super.onStart(mapId, mapInstance, time))
				return false;
			return true;
		}

		boolean onEnd(int mapId, int mapInstance, int time, int progress, Map<Integer, Integer> damage, int accDamageRank, int maxDamageRank, int extraReward)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_MAPCOYP_ONEND);
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			this.progress = progress;
			this.damage = damage;
			this.accDamageRank = accDamageRank;
			this.maxDamageRank = maxDamageRank;
			this.extraReward = extraReward;

			gs.getLoginManager().addNormalTaskEvent(() -> gs.getSectManager().addSectMapTime(Role.this));
			Role.this.syncAddSectContribution(extraReward, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			return true;
		}

		void onBagFull(Map<Integer, Integer> counters, Set<Integer> dropIds)
		{
			if(!dropIds.isEmpty())
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIds, 0);
			gs.getLogger().debug("sect group map role " + Role.this.id + " , " + Role.this.name + " pick up " + counters + " bag full-----------------------------");
		}
		
		void onBagFull(int itemID, int count, int dropID)
		{
			if(dropID > 0)
			{
				Set<Integer> dropIDs = new HashSet<>();
				dropIDs.add(dropID);
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIDs, 0);
			}
			gs.getLogger().debug("sect group map role " + Role.this.id + " , " + Role.this.name + " pick up " + itemID + " ," + count + " bag full----------------");
		}
	}

	class EmergencyMapCopyContext extends MapCopyContext
	{
		final int activityId;
		EmergencyMapCopyContext(int mapId, SBean.Location location, int activityId)
		{
			super(mapId, location);
			this.activityId = activityId;
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_EMERGENCY;
		}

		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(Role.this.worldMapPets);
		}

		void syncMapCopy()
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_timesync(this.mapId, GameTime.getTime()));
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_cantake_drop(this.mapId, (byte)(this.canTakeDrop ? 1 : 0)));
		}

		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					if (Role.this.isInTeam())
						gs.getTeamManager().teamMemberLeave(Role.this);
					
					gs.getEmergencyManager().activityRoleJoin(activityId);
				}
			});
			this.startTime = GameTime.getTime();
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					if (Role.this.isInTeam())
						gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
			gs.getEmergencyManager().activityRoleLeave(activityId);
		}
		
		void onAfterLeaveMapCopy()
		{
			
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			if (!super.onStart(mapId, mapInstance, time))
				return false;
            gs.getTLogger().logEmergencyActivityFlow(Role.this, mapId, TLog.EMERGENCY_JOIN_MAP);
			return true;
		}

		void onBagFull(Map<Integer, Integer> counters, Set<Integer> dropIds)
		{
			if(!dropIds.isEmpty())
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIds, 0);
			gs.getLogger().debug("sect group map role " + Role.this.id + " , " + Role.this.name + " pick up " + counters + " bag full-----------------------------");
		}
		
		void onBagFull(int itemID, int count, int dropID)
		{
			if(dropID > 0)
			{
				Set<Integer> dropIDs = new HashSet<>();
				dropIDs.add(dropID);
				gs.getMapService().syncRolePickUpResult(this.mapId, Role.this.id, dropIDs, 0);
			}
			gs.getLogger().debug("sect group map role " + Role.this.id + " , " + Role.this.name + " pick up " + itemID + " ," + count + " bag full----------------");
		}
		
		boolean onEnd(int mapId, int mapInstance, int time)
		{
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_emergency_map_end());
            gs.getTLogger().logEmergencyActivityFlow(Role.this, mapId, TLog.EMERGENCY_FINISH_MAP);
			return true;
		}
	}
	
	class ArenaMapCopyContext extends MapCopyContext
	{
		List<Integer> fightPets;

		boolean win;
		SBean.ArenaBattleResult result;

		ArenaMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

		int getPKMode()
		{
			return GameData.ATTACK_MODE_ALL;
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_ARENA;
		}
		
		List<Integer> getPetSeq()
		{
			return new ArrayList<>(this.fightPets);
		}
		
		void setFightPets(List<Integer> pets)
		{
			this.fightPets = pets;
		}

		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(new TreeSet<>(this.fightPets));
		}

		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}
		
		void onAfterLeaveMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{

				@Override
				public void run()
				{
					gs.getArenaManager().roleLeaveArenaMap(Role.this);
				}
			});
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			if (!super.onStart(mapId, mapInstance, time))
				return false;

			Role.this.arenaInfo.roleArenaData.normal.lastFightTime = GameTime.getTime();
			Role.this.arenaInfo.roleArenaData.normal.timesUsed++;
			Role.this.arenaInfo.roleArenaData.normal.enterTimes++;
			Role.this.masterLogGraduateTaskWithoutLock(GameData.MASTER_GRADUATE_TASK_ARENA, 1);
			Role.this.logTasks(GameData.TASK_TYPE_GOTO_NORMALARENA, 0, 0, 0);
			Role.this.logDailyTask(GameData.DAILY_TASK_ID_START_ANY_NORMAL_ARENA, 1);
			Role.this.logTaskScheduleData(GameData.SCHEDULE_TYPE_NORMAL_ARENA);
			Role.this.logActivityChallengeGift(GameData.ACTIVITY_CHALLENGE_TYPE_JJC, 0, 1);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_arenamap_start());
			gs.getTLogger().logArenaFlow(Role.this, mapId, TLog.ARENAEVENT_START, false);
			return true;
		}

		boolean onEnd(int mapId, int mapInstance, int time, boolean win, SBean.ArenaBattleResult result)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ARENA_MAPCOPY_ONEND);
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			this.win = win;
			this.result = result;
			if (win)
			{
				if (result.attackingSideRank < Role.this.arenaInfo.roleArenaData.normal.bestRank)
				{
					SBean.ArenaBestRankRewardCFGS bestReward = GameData.getInstance().getArenaRankBestReward(Role.this.arenaInfo.roleArenaData.normal.bestRank, result.attackingSideRank);
					tlogEvent.setArg(bestReward.money, bestReward.stone);
					Role.this.syncAddCoin(bestReward.money, false, tlogEvent);
					Role.this.syncAddDiamond(bestReward.stone, false, tlogEvent);
					Role.this.arenaInfo.roleArenaData.normal.bestRank = result.attackingSideRank;
					SBean.RollNoticeCFGS rollNoticeCFGS = GameData.getInstance().getRollNoticeCFGS();
					if (result.attackingSideRank < rollNoticeCFGS.pkRank || (GameTime.getDay(gs.getOpenTime()) == GameTime.getDay() && result.attackingSideRank < rollNoticeCFGS.firstDayPkRank))
					{
						if (result.attackingSideRank == 1)
							gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_WIN_FIRST, Role.this.name);
						else
							gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_WIN_HIGH_SCORE, Role.this.name + "|" + result.defendingSide.name + "|" + result.attackingSideRank);
					}
				}
				Role.this.arenaInfo.roleArenaData.normal.winTimes++;
				Role.this.arenaInfo.roleArenaData.normal.score += GameData.getInstance().getArenaCFGS().winAddScore;
			}
			else
			{
				Role.this.arenaInfo.roleArenaData.normal.score += GameData.getInstance().getArenaCFGS().loseAddScore;
			}
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_arenamap_end());
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			gs.getTLogger().logArenaFlow(Role.this, mapId, TLog.ARENAEVENT_FINISH, win);
			gs.getTLogger().reportPVPMission(Role.this, mapId, win);
			
			for(int petID: this.fightPets)
			{
				Role.this.syncAddPetExploit(petID, GameData.getInstance().getCommonCFG().pet.normalArenaExploit);
			}
			return true;
		}

		void earlyLeave()
		{
			gs.getTLogger().reportPVPMission(Role.this, mapId, false);
		}

		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapId, mapInstance, time))
				return false;
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_arena_result(this.win ? 1 : 0, this.result.attackingSideRank, this.result.defendingSideRank, this.result.defendingSide));
			return true;
		}
	}

	class SuperArenaMapCopyContext extends MapCopyContext
	{
		int win;
		SBean.SuperArenaBattleResult result;
		int superArenaType;
		boolean mainSpawnPos;
		int enterRaceTime;
		int dayFailedStreak;
		int eloDiff;

		SuperArenaMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
			SBean.SuperArenaMapCFGS mapCfg = GameData.getInstance().getSuperArenaMapCFGS(mapId);
			if(mapCfg != null)
			{
				this.superArenaType = mapCfg.type;
				SBean.SuperArenaLog log = Role.this.arenaInfo.roleArenaData.superarena.logs.get(mapCfg.type);
				dayFailedStreak = log == null ? 0 : log.dayFailedStreak;
			}
		}

		boolean isMainSpawnPos()
		{
			return mainSpawnPos;
		}

		void setIsMainSpawnPos(boolean mainSpawnPos)
		{
			this.mainSpawnPos = mainSpawnPos;
		}
		
		int getDayFailedStreak()
		{
			return dayFailedStreak;
		}
		
		@Override
		void onBeforeEnterMapCopy()
		{
			// TODO Auto-generated method stub
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			if (endTime == 0 || Role.this.team.id < 0)
			{
				leaveGlobalTeam();
			}
		}
		
		@Override
		void onAfterLeaveMapCopy()
		{
			if(Role.this.team.id != 0)
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.team_sync(Role.this.team.kdClone()));
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_SUPERARENA;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(Role.this.arenaInfo.roleArenaData.superarena.pets);
		}

		int getPKMode()
		{
			return GameData.ATTACK_MODE_ALL;
		}

		boolean onStart(int mapId, int mapInstance, int time, int eloDiff)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance || this.startTime != 0)
				return false;
			
			this.startTime = time;
			this.enterRaceTime = time;
			this.eloDiff = eloDiff;
			syncMapCopy();
			Role.this.arenaInfo.roleArenaData.superarena.logs.merge(this.superArenaType, new SBean.SuperArenaLog(1, 1, 0, 0, 0, (short)0, (short)GameData.getInstance().getSuperArenaCFGS().orgELO), (ov, nv) ->
			{
				ov.dayEnterTimes++;
				ov.enterTimes++;
				return ov;
			});
			
			Role.this.masterLogGraduateTaskWithoutLock(GameData.MASTER_GRADUATE_TASK_SUPER_ARENA, 1);
			logDailyTask(GameData.DAILY_TASK_ID_ENTER_ANY_SUPER_ARENA, 1);
			Role.this.logTaskScheduleData(GameData.SCHEDULE_TYPE_SUPER_ARENA);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_superarenamap_start(this.superArenaType));
			gs.getTLogger().logSuperArenaFlow(Role.this, mapId, this.superArenaType, TLog.COPYEVENT_START, 0);
			testChallengeTask(GameData.CHALLENGE_TASK_ID_SUPERARENA_TIMES, 0);
			return true;
		}
		
		void syncMapCopy()
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_timesync(this.mapId, this.enterRaceTime));
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_cantake_drop(this.mapId, (byte)(this.canTakeDrop ? 1 : 0)));
		}
		
		boolean onEnd(int mapId, int mapInstance, int time, SBean.SuperArenaBattleResult result, int rankClearTime)
		{
			if (!super.onEnd(mapId, mapInstance, time))
				return false;

			this.result = result;
			int group = isMainSpawnPos() ? 1 : 2;
			int addHoror = 0;
			SBean.SABattleTeamInfo teamInfo = result.teams.get(group);
			if (teamInfo != null)
			{
				SBean.SABattleInfo info = teamInfo.members.get(Role.this.id);
				if (info != null)
				{
					SBean.SuperArenaLog log = Role.this.arenaInfo.roleArenaData.superarena.logs.get(this.superArenaType);
					if(log == null)
					{
						log = new SBean.SuperArenaLog(1, 1, 0, 0, 0, (short)1, (short)GameData.getInstance().getSuperArenaCFGS().orgELO);
						Role.this.arenaInfo.roleArenaData.superarena.logs.put(this.superArenaType, log);
					}
					
					if(result.loseTeam == 0)
					{
						win = GameData.SUPER_ARENA_RESULT_NONE;
					}
					else
					{
						if (result.loseTeam == group)
						{
							win = GameData.SUPER_ARENA_RESULT_LOSE;
							log.dayFailedStreak++;
						}
						else
						{
							win = GameData.SUPER_ARENA_RESULT_WIN;
							log.dayFailedStreak = 0;
							log.winTimes++;
						}
					}
					
					log.elo += info.addELO;
					addHoror = info.addHonor;
				}
			}
			
			for(int petID: Role.this.arenaInfo.roleArenaData.superarena.pets)
			{
				Role.this.syncAddPetExploit(petID, GameData.getInstance().getCommonCFG().pet.superArenaExploit);
			}
			
			Role.this.onSuperArenaEnd(addHoror, superArenaType, rankClearTime);
			logActivityChallengeGift(GameData.ACTIVITY_CHALLENGE_TYPE_HWC, 0, 1);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_superarenamap_end());
			gs.getTLogger().logSuperArenaFlow(Role.this, mapId, superArenaType, TLog.ARENAEVENT_FINISH, win);
			gs.getTLogger().reportPVPMission(Role.this, mapId, win == GameData.SUPER_ARENA_RESULT_WIN);
			return true;
		}

		void earlyLeave()
		{
			gs.getTLogger().reportPVPMission(Role.this, mapId, false);
			SBean.SuperArenaLog log = Role.this.arenaInfo.roleArenaData.superarena.logs.get(this.superArenaType);
			if(log == null)
			{
				log = new SBean.SuperArenaLog(1, 1, 0, 0, 0, (short)0, (short)GameData.getInstance().getSuperArenaCFGS().orgELO);
				Role.this.arenaInfo.roleArenaData.superarena.logs.put(this.superArenaType, log);
			}
			
			log.elo += GameData.getInstance().getSuperArenaAddELO(log.elo, eloDiff, GameData.getInstance().getSuperArenaCFGS().eloParamLose);
		}

		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapId, mapInstance, time))
				return false;

			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_superarena_result(this.win, this.result));
			return true;
		}
		
		void onEnterRace(int mapId, int mapInstance, int enterTime)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance)
				return;
			
			this.enterRaceTime = enterTime;
			SBean.MapLocation mapLocation = Role.this.getSuperArenaSpawnLocation(mapId, mainSpawnPos);
			if(mapLocation != null)
				this.location = mapLocation.location;
			
			gs.getMapService().roleResetMapLocation(Role.this.id, mapId, mapInstance, this.location);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_change_map(mapLocation, mapInstance));
			
			String chatRoomID = this.getChatRoomID();
			if(chatRoomID != null && !chatRoomID.equals(""))
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_chat_room(chatRoomID));
		}
	}
	
	//正邪道场
	class BWArenaMapCopyContext extends MapCopyContext
	{
		boolean sameBWArenaLvl;
		int addScore;
		int addExp;
		boolean petLack;
		Set<Integer> fightPets = new HashSet<>();

		BWArenaMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

		int getPKMode()
		{
			return GameData.ATTACK_MODE_ALL;
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_BWARENA;
		}

		void setPetLack(boolean petLack)
		{
			this.petLack = petLack;
		}

		boolean isPetLack()
		{
			return this.petLack;
		}

		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Role.this.getMapFightPetsWithoutLock(this.fightPets);
		}

		void setFightPets(Set<Integer> fightPets)
		{
			this.fightPets = fightPets;
		}
		
		List<Integer> getPetSeq()
		{
			return new ArrayList<>(this.fightPets);
		}
		
		void setIsSameBWArenaLvl(boolean sameBWArenaLvl)
		{
			this.sameBWArenaLvl = sameBWArenaLvl;
		}

		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}
		
		void onAfterLeaveMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					Role.this.updateBWAreneEnemies();
					gs.getBWArenaManager().roleLeaveBWArenaMap(Role.this.id);
				}
			});
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			if (!super.onStart(mapId, mapInstance, time))
				return false;

			Role.this.arenaInfo.roleArenaData.bwarena.timesUsed++;
			logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_BW_MAPCOPY, 1);
			Role.this.logTaskScheduleData(GameData.SCHEDULE_TYPE_BW_MAPCOPY);
			Role.this.logActivityChallengeGift(GameData.ACTIVITY_CHALLENGE_TYPE_ZXDC, 0, 1);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_bwarenamap_start());
			gs.getTLogger().logBWArenaCopyFlow(Role.this, mapId, TLog.ARENAEVENT_START, false);
			return true;
		}

		boolean onEnd(int mapId, int mapInstance, int time, int addScore, SBean.BattleArrayHp attackingSideHp, SBean.BattleArrayHp defendingSideHp)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BWARENA_MAPCOPY_ONEND);
			if (!super.onEnd(mapId, mapInstance, time))
				return false;

			this.addScore = addScore;
			boolean win = addScore > 0;

			SBean.BWArenaBaseCFGS baseCfg = GameData.getInstance().getBWArenaCFGS().base;
			int winScore = sameBWArenaLvl ? baseCfg.winScore.get(1) : baseCfg.winScore.get(0);
			Role.this.updateBWAreneEnemies(defendingSideHp.roleId, win ? winScore : -winScore);

			if (win)
			{
				Role.this.arenaInfo.roleArenaData.bwarena.winTimes++;
				addExp = sameBWArenaLvl ? baseCfg.winExp.get(1) : baseCfg.winExp.get(0);
			}
			else
			{
				addExp = sameBWArenaLvl ? baseCfg.loseExp.get(1) : baseCfg.loseExp.get(0);
			}

			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_bwarenamap_end());
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			
			for(int petID: this.fightPets)
			{
				Role.this.syncAddPetExploit(petID, GameData.getInstance().getCommonCFG().pet.bwArenaExploit);
			}
			
			testChallengeTask(GameData.CHALLENGE_TASK_ID_BW_COPY_LEVEL, 0);
			gs.getTLogger().logBWArenaCopyFlow(Role.this, mapId, TLog.ARENAEVENT_FINISH, win);
			gs.getTLogger().reportPVPMission(Role.this, mapId, win);
			
			return true;
		}

		void earlyLeave()
		{
			gs.getTLogger().reportPVPMission(Role.this, mapId, false);
		}

		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapId, mapInstance, time))
				return false;

			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_bwarena_result(this.addScore, this.addExp));
			return true;
		}
	}

	//势力战
	class ForceWarMapCopyContext extends MapCopyContext
	{
		boolean rewardMapTimes = false;
		private int gainFeat;
		private int winSide;
		private int killedBoss;
		private int whiteScore;
		private int blackScore;
		private List<SBean.ForceWarOverview> whiteSide = new ArrayList<>();
		private List<SBean.ForceWarOverview> blackSide = new ArrayList<>();
		boolean mainSpawnPos;
		
		ForceWarMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}
		
		boolean isMainSpawnPos()
		{
			return mainSpawnPos;
		}

		void setIsMainSpawnPos(boolean mainSpawnPos)
		{
			this.mainSpawnPos = mainSpawnPos;
		}
		
		@Override
		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					// 势力战进入即离队
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}
		
		@Override
		void onAfterLeaveMapCopy()
		{
			if(Role.this.team.id != 0)
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.team_sync(Role.this.team.kdClone()));
		}

		void earlyLeave()
		{
			Role.this.forceWarInfo.forcewar.punishEndTime = GameTime.getTime() + GameData.getInstance().getForceWarBaseCFGS().match.punishTime;
			gs.getTLogger().reportPVPMission(Role.this, mapId, false);
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_FORCEWAR;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Collections.emptyMap();
		}

		int getPKMode()
		{
			return GameData.ATTACK_MODE_PEACE;
		}

		boolean onStart(int mapId, int mapInstance, int time)
		{
			if (!super.onStart(mapId, mapInstance, time))
				return false;
			
			Role.this.forceWarInfo.forcewar.log.dayEnterTimes++;
			Role.this.forceWarInfo.forcewar.log.enterTimes++;
			Role.this.masterLogGraduateTaskWithoutLock(GameData.MASTER_GRADUATE_TASK_FORCE_WAR, 1);
			Role.this.logActivityChallengeGift(GameData.ACTIVITY_CHALLENGE_TYPE_ZXSLZ, 0, 1);
			Role.this.logTaskScheduleData(GameData.SCHEDULE_TYPE_FORCEWAR);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_forcewarmap_start());
			gs.getTLogger().logForceWarFlow(Role.this, mapId, TLog.ARENAEVENT_START, false);
			testChallengeTask(GameData.CHALLENGE_TASK_ID_FORCEWAR_TIMES, 0);
			return true;
		}

		boolean onEnd(int mapId, int mapInstance, int time, int rankClearTime, int winSide, int killedBoss, int whiteScore, int blackScore, List<SBean.ForceWarOverview> whiteSide, List<SBean.ForceWarOverview> blackSide)
		{
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			
			this.whiteScore = whiteScore;
			this.blackScore = blackScore;
			this.whiteSide = whiteSide;
			this.blackSide = blackSide;
			this.winSide = winSide;
			this.killedBoss = killedBoss;
			
			boolean win = winSide == Role.this.BWType;
			final SBean.ForceWarOtherCFG otherCfg = GameData.getInstance().getForceWarBaseCFGS().other;
			
			rewardMapTimes = Role.this.forceWarInfo.forcewar.log.dayEnterTimes <= otherCfg.dayMapRewardTimes;
			if(win)
			{
				Role.this.forceWarInfo.forcewar.log.winTimes++;
				Role.this.normalMapCopyLogs.merge(otherCfg.goldMapID, new SBean.DBNormalMapCopyLog(0, 0, 0, 0, 0, otherCfg.winAdd), (ov, nv) ->
				{
					if(rewardMapTimes)
					{
						ov.rewardTimes += otherCfg.winAdd;
						if(ov.rewardTimes > GameData.getInstance().getForceWarBaseCFGS().other.goldMapMaxTime)
							ov.rewardTimes = GameData.getInstance().getForceWarBaseCFGS().other.goldMapMaxTime;
					}
					return ov;
				});
			}
			else
			{
				Role.this.normalMapCopyLogs.merge(otherCfg.silverMapID, new SBean.DBNormalMapCopyLog(0, 0, 0, 0, 0, otherCfg.loseAdd), (ov, nv) ->
				{
					if(rewardMapTimes)
					{
						ov.rewardTimes += otherCfg.loseAdd;
						if(ov.rewardTimes > GameData.getInstance().getForceWarBaseCFGS().other.silverMapMaxTime)
							ov.rewardTimes = GameData.getInstance().getForceWarBaseCFGS().other.silverMapMaxTime;
					}
					return ov;
				});
			}
			
			if (rankClearTime != Role.this.forceWarInfo.forcewar.rankClearTime)
			{
				Role.this.forceWarInfo.forcewar.weekFeats = 0;
				Role.this.forceWarInfo.forcewar.rankClearTime = rankClearTime;
			}
			
			for(SBean.ForceWarOverview e: (Role.this.BWType == 1) ? whiteSide : blackSide)
			{
				if(e.rid == Role.this.id)
				{
					Role.this.syncAddForceWarFeat(e.gainFeat);
					Role.this.forceWarInfo.forcewar.weekFeats += e.gainFeat;
					this.gainFeat = e.gainFeat;
					break;
				}
			}
			
			Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_FORCEWAR_TIMES, 0);
			
			gs.getTLogger().logForceWarFlow(Role.this, mapId, TLog.ARENAEVENT_FINISH, win);
			gs.getTLogger().reportPVPMission(Role.this, mapId, win);
			
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_forcewarmap_end());
			return true;
		}

		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapId, mapInstance, time))
				return false;

			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_forcewar_result(gainFeat, Role.this.forceWarInfo.forcewar.weekFeats, winSide, killedBoss, whiteScore, blackScore, whiteSide, blackSide, rewardMapTimes ? 1 : 0));
			return true;
		}
	}
	
	class ActivityMapCopyContext extends CommonMapCopyContext
	{
		int groupId;
		Map<Integer, Integer> monster;

		ActivityMapCopyContext(int groupId, int mapId, SBean.Location location)
		{
			super(mapId, location);
			this.groupId = groupId;
			SBean.ActivityMapCFGS activityMap = GameData.getInstance().getActivityMapCFGS(this.mapId);
			monster = new HashMap<>();
			for (SBean.MapEntity mon : activityMap.allMonsters.values())
			{
				monster.put(mon.id, mon.count);
			}
		}

		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_ACTIVITY;
		}

		Set<Integer> getFightPets()
		{
			return Role.this.activityMapPets;
		}

		void syncMapCopy()
		{
			super.syncMapCopy();
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_activitymap_sync(this.mapId, this.killMonsters));
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_cantake_drop(this.mapId, (byte)(this.canTakeDrop ? 1 : 0)));
			SBean.ActivityMapCFGS activityMap = GameData.getInstance().getActivityMapCFGS(this.mapId);
			if (activityMap == null)
				return;
			if (activityMap.groupId != GameData.ACTIVITY_MAP_TYPE_EXP && activityMap.groupId != GameData.ACTIVITY_MAP_TYPE_COIN)
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_activity_map_cur_process(this.process));
		}

		void onEnterCommonMapCopy()
		{
			SBean.DBActivityMapGroupLog log = Role.this.activityMapGroupLogs.merge(groupId, new SBean.DBActivityMapGroupLog(1, new TreeSet<Integer>(), 1, 0, new HashMap<>()), (ov, nv) ->
			{
				ov.dayEnterTimes += 1;
				ov.historyEnterTimes += 1;
				return ov;
			});

			log.enterMaps.add(mapId);
			Role.this.logTasks(GameData.TASK_TYPE_GOTO_ACTIVITYGROUP, 0, 0, 0);
			Role.this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_ACTIVITY_MAPCOPY_1, 1);
			Role.this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_ACTIVITY_MAPCOPY_2, 1);
			Role.this.logActivityChallengeGift(GameData.ACTIVITY_CHALLENGE_TYPE_ACTIVITY_MAP, this.groupId, 1);
			logMapScheduleData(groupId, log.dayEnterTimes - 1, 1);
			gs.getTLogger().logActiveCopyFlow(Role.this, mapId, 0, TLog.COPYEVENT_START, 0);
		}

		void onFinishCommonMapCopy()
		{
			SBean.DBActivityMapGroupLog log = Role.this.activityMapGroupLogs.get(groupId);
			if (log == null)
				return;
			SBean.ActivityMapCFGS activityMap = GameData.getInstance().getActivityMapCFGS(this.mapId);
			if (activityMap == null)
				return;
			if (activityMap.groupId == GameData.ACTIVITY_MAP_TYPE_EXP || activityMap.groupId == GameData.ACTIVITY_MAP_TYPE_COIN)
			{
				log.records.merge(this.mapId, this.killMonsters, (ov, nv)-> (nv > ov ? nv : ov));
			}
			else
			{
				if (this.process == 10000)
				{
					this.process += this.endTime - this.startTime;
				}
				log.records.merge(this.mapId, this.process, (ov, nv)-> ((ov < 10000 && nv > ov) || (ov > 10000 && nv > 10000 && nv < ov)? nv : ov));
			}
			gs.getTLogger().logActiveCopyFlow(Role.this, mapId, 0, TLog.COPYEVENT_FINISH, 0);
		}

		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					// 活动副本进入即离队
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
			SBean.ActivityMapCFGS activityMap = GameData.getInstance().getActivityMapCFGS(this.mapId);
			if (activityMap == null)
				return;
			if (activityMap.groupId != GameData.ACTIVITY_MAP_TYPE_EXP && activityMap.groupId != GameData.ACTIVITY_MAP_TYPE_COIN)
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_activity_map_cur_process(this.process));
		}

		void addKillMonster(int id, int count, int killRole)
		{
			super.addKillMonster(id, count, killRole);
			SBean.ActivityMapCFGS activityMap = GameData.getInstance().getActivityMapCFGS(this.mapId);
			if (activityMap == null)
				return;
			if (activityMap.groupId != GameData.ACTIVITY_MAP_TYPE_EXP && activityMap.groupId != GameData.ACTIVITY_MAP_TYPE_COIN)
			{
				if (!monster.containsKey(id))
					return;
				int ov = monster.get(id);
				int killcount = count;
				if (ov <= count)
				{
					killcount = ov;
					monster.remove(id);
				}
				else
				{
					monster.put(id, ov - count);
				}
				if (monster.isEmpty())
					this.process = 10000;
				else
				{
					int monprocess = GameData.getInstance().getMonsterPercent(this.mapId, id);
					if (monprocess > 0 && killcount > 0)
					{
						this.process += monprocess * killcount;
					}
				}
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_activity_map_cur_process(this.process));
			}
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}
		
		void onAfterLeaveMapCopy()
		{
			
		}

	}
	
	
	//爬塔副本
	class ClimbTowerMapCopyContext extends CommonMapCopyContext
	{
		int groupId;
		ClimbTowerMapCopyContext(int groupId, int mapId, SBean.Location location)
		{
			super(mapId, location);
			this.groupId = groupId;
			// TODO Auto-generated constructor stub
		}
		
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_CLIMBTOWER;
		}
		
		Set<Integer> getFightPets()
		{
			return Role.this.climbTowerData.roleClimbTowerData.pets;
		}
		
		void onEnterCommonMapCopy()
		{
			Role.this.climbTowerData.roleClimbTowerData.dayTimesUsed++;
			if (Role.this.climbTowerData.roleClimbTowerData.dayTimesUsed == GameData.getInstance().getClimbTowerBaseData().dayTimes)
				Role.this.syncClimbTowerSecretArea();
			logDailyTask(GameData.DAILY_TASK_ID_ENTER_ANY_CLIMB_TOWER, 1);
	        Role.this.logTaskScheduleData(GameData.SCHEDULE_TYPE_CLIMB_TOWER);  
	        gs.getTLogger().logClimbTowerCopyFlow(Role.this, groupId, mapId, TLog.COPYEVENT_START, false);
		}
		
		void onFinishCommonMapCopy()
		{
			if (Role.this.climbTowerData.roleClimbTowerData.history.getOrDefault(groupId, 0) < Role.this.climbTowerFightFloor)
			{
				Role.this.climbTowerData.roleClimbTowerData.history.put(groupId, Role.this.climbTowerFightFloor);
			}
			int sectId = Role.this.getSectId();
			if (sectId > 0)
			{
				SBean.DBClimbTowerRecordDataCfg sectData = new SBean.DBClimbTowerRecordDataCfg(Role.this.id, Role.this.name, Role.this.climbTowerFightFloor);
				gs.getLoginManager().addNormalTaskEvent(new Runnable()
				{
					@Override
					public void run()
					{
						gs.getSectManager().setClimbTowerData(Role.this, groupId, sectId, sectData);
					}
				});
			}
			SBean.DBClimbTowerRecordDataCfg serverData = new SBean.DBClimbTowerRecordDataCfg(Role.this.id, Role.this.name, Role.this.climbTowerFightFloor);
			gs.getClimbTowerManager().updateClimbTowerRecord(groupId, serverData);
			Role.this.climbTowerData.roleClimbTowerData.finishFloors.add((groupId << 16) | Role.this.climbTowerFightFloor);
			Role.this.climbTowerFightFloor = 0;
			
	        gs.getTLogger().logClimbTowerCopyFlow(Role.this, groupId, mapId, TLog.COPYEVENT_FINISH, false);
			testChallengeTask(GameData.CHALLENGE_TASK_ID_ANY_TOWER_LEVEL, 0);
		}
		
		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					// 爬塔副本进入即离队
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}
		
		@Override
		void onBeforeLeaveMapCopy()
		{
			
		}

        void onAfterLeaveMapCopy()
		{
			// TODO Auto-generated method stub
			
		}

		void syncMapCopy()
		{
			super.syncMapCopy();
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towermap_sync(this.mapId, this.killMonsters));
		}
	}
	
	//------------------------------------------------------------------------------------------------
	class WeaponMapCopyContext extends CommonMapCopyContext
	{
		WeaponMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

		@Override
		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			// TODO Auto-generated method stub
		}

		@Override
		void onAfterLeaveMapCopy()
		{
			
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_WEAPON;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Collections.emptyMap();
		}
		
		@Override
		Set<Integer> getFightPets()
		{
			return GameData.emptySet();
		}

		@Override
		void onEnterCommonMapCopy()
		{
			Role.this.weaponUSkill.addEnterTimes(this.mapId);
		}

		@Override
		void onFinishCommonMapCopy()
		{
			
		}
	}
	
	// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class JusticeMapCopyContext extends CommonMapCopyContext
	{
		JusticeMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);

			int groupId = GameData.getInstance().getJusticeMapCopyCFGS(this.mapId).npcMapGroup;
			if (groupId == 0)
			{
				SBean.JusticeMapCFGS cfg = GameData.getInstance().getJusticeMapCFGS();
				this.canTakeDrop = Role.this.dayJusticeJoinTime < cfg.dayEnterTimes;
			}
			else 
			{
				SBean.NpcMapCFGS cfg = GameData.getInstance().getNpcMapCFGS(groupId);
				this.canTakeDrop = Role.this.dayNpcCpoyTimes.getOrDefault(groupId, 0) < cfg.dayEnterTime;
			}
		}

		@Override
		void onBeforeEnterMapCopy()
		{
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			if (endTime == 0)
			{
				gs.getLoginManager().addNormalTaskEvent(new Runnable()
				{
					@Override
					public void run()
					{
						Role.this.leaveTeam();
					}
				});
			}
		}

		@Override
		void onAfterLeaveMapCopy()
		{
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_JUSTICE;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return Collections.emptyMap();
		}
		
		@Override
		Set<Integer> getFightPets()
		{
			return GameData.emptySet();
		}

		@Override
		void onEnterCommonMapCopy()
		{
			int groupId = GameData.getInstance().getJusticeMapCopyCFGS(this.mapId).npcMapGroup;
			if (groupId == 0)
			{
				Role.this.dayJusticeJoinTime++;
				Role.this.logTaskScheduleData(GameData.SCHEDULE_TYPE_JUSTICE_MAP);
				gs.getTLogger().logJusticeActivityFlow(Role.this, mapId, TLog.JUSTICE_JOIN_MAP);
			}
			else 
			{
				Role.this.dayNpcCpoyTimes.merge(groupId, 1, (ov, nv)->ov + nv);
				Role.this.logNpcMapScheduleData(groupId);
			}
		}

		@Override
		void onFinishCommonMapCopy()
		{
            gs.getTLogger().logJusticeActivityFlow(Role.this, mapId, TLog.JUSTICE_FINISH_MAP);
		}
	}
	
	// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	class DemonHoleMapCopyContext extends MapCopyContext
	{
		int pkMode = GameData.ATTACK_MODE_PEACE;
		
		List<SBean.RoleDemonHole> curFloor = new ArrayList<>();
		List<SBean.RoleDemonHole> total = new ArrayList<>();
		int floor;
		int grade;
		DemonHoleMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
			SBean.DemonHoleMapCFGS mapCfg = GameData.getInstance().getDemonHoleMapCFGS(this.mapId);
			if(mapCfg != null)
			{
				switch (mapCfg.pkType)
				{
				case GameData.MAP_PKTYPE_SAFE:
					this.pkMode = GameData.ATTACK_MODE_PEACE;
					break;
				case GameData.MAP_PKTYPE_SECT:
					this.pkMode = GameData.ATTACK_MODE_SECT;
					break;
				case GameData.MAP_PKTYPE_KILL:
					this.pkMode = GameData.ATTACK_MODE_ALL;
					break;
				default:
					break;
				}
			}
		}
		
		void setDemonHole(int floor, int grade)
		{
			this.floor = floor;
			this.grade = grade;
		}
		
		@Override
		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			// TODO Auto-generated method stub
		}

		@Override
		void onAfterLeaveMapCopy()
		{
			Role.this.demonHoleInfo.leaveDemonHole();
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_DEMON_HOLE;
		}

		int getPKMode()
		{
			return pkMode;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return GameData.emptyMap();
		}
		
		void syncMapCopy()
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_demonholemap_sync(this.floor, this.grade, this.startTime));
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_mapcopy_cantake_drop(this.mapId, (byte)(this.canTakeDrop ? 1 : 0)));
		}
		
		boolean onStart(int mapId, int mapInstance)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance || this.startTime != 0)
				return false;
			this.startTime = GameTime.getDayTime(GameData.getInstance().getDemonHoleBaseCFGS().startTime);
			syncMapCopy();
			
			boolean firstEnter = Role.this.onEnterDemonHole(this.mapId, this.floor); 
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_demonhole_start(firstEnter ? 1 : 0));
			return true;
		}
		
		boolean onEnd(int mapId, int mapInstance, int time, List<SBean.RoleDemonHole> curFloor, List<SBean.RoleDemonHole> total)
		{
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			
			this.curFloor = curFloor;
			this.total = total;
			Role.this.demonHoleInfo.leaveDemonHole();
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_demonhole_end());
			return true;
		}
		
		boolean onPopupResult(int mapId, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapId, mapInstance, time))
				return false;
			
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_demonhole_result(this.curFloor, this.total, Role.this.demonHoleInfo.demonHole.addExp));
			return true;
		}
	}
	
	class FightNpcMapCopyContext extends MapCopyContext
	{
		boolean win;
		
		FightNpcMapCopyContext(int mapId, SBean.Location location)
		{
			super(mapId, location);
		}

		@Override
		void onBeforeEnterMapCopy()
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					gs.getTeamManager().teamMemberLeave(Role.this);
				}
			});
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			// TODO Auto-generated method stub
		}

		@Override
		void onAfterLeaveMapCopy()
		{
			// TODO Auto-generated method stub
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_FIGHTNPC;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return GameData.emptyMap();
		}
		
		boolean onStart(int mapID, int mapInstance, int time)
		{
			if (!super.onStart(mapID, mapInstance, time))
				return false;
			
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_fightnpcmap_start());
            gs.getTLogger().logFightNpcActivityFlow(Role.this, mapId, TLog.FIGHTNPC_JOIN_EVENT, 0);
			return true;
		}
		
		boolean onEnd(int mapID, int mapInstance, int time, boolean win)
		{
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			
			this.win = win;
			if(win)
				Role.this.fightNpc.state = 1;
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_fightnpcmap_end());

            gs.getTLogger().logFightNpcActivityFlow(Role.this, mapId, TLog.FIGHTNPC_JOIN_EVENT, win?1:0);
			return true;
		}
		
		boolean onPopupResult(int mapID, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapID, mapInstance, time))
				return false;
			
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_fightnpcmap_result(Role.this.fightNpc.curIndex, win ? 1 : 0));
			return true;
		}
	}
	
	class TowerDefenceMapCopyContext extends MapCopyContext
	{
		int score;
		int count;
		int useTime;
		List<SBean.DropItemCFGS> cards;
		int finishedTurnPlateDropID;
		int exp;
		Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();
		
		
		TowerDefenceMapCopyContext(int mapId, int turnPlateDropID, SBean.Location location)
		{
			super(mapId, location);

			SBean.TowerDefenceCFGS cfg = GameData.getInstance().getTowerDefenceCFGS(mapId);
			SBean.DBTowerDefenceMapLog log = Role.this.towerDefence.logs.get(mapId);
			this.canTakeDrop = log == null || log.dayEnterTimes < cfg.base.dayEnterTimes;
			this.finishedTurnPlateDropID = turnPlateDropID;
		}

		void pickUpDrops(Map<Integer, SBean.DummyGoods> drops)
		{
			Map<Integer, Integer> counters = new HashMap<>();
			for(SBean.DummyGoods d: drops.values())
			{
				counters.merge(d.id, d.count, (ov, nv) -> ov + nv);
				this.drops.merge(d.id, d.count, (ov, nv) -> ov + nv);
			}
			
			this.pickUpDropsImpl(drops, counters);
		}
		
		void pickUpRareDrop(int dropId, SBean.DummyGoods drop, int monsterId)
		{
			this.drops.merge(drop.id, drop.count, (ov, nv) -> ov + nv);
			super.pickUpRareDrop(dropId, drop, monsterId);
		}
		
		void addItems(Map<Integer, Integer> counters)
		{
			for(Map.Entry<Integer, Integer> e: counters.entrySet())
				this.drops.merge(e.getKey(), e.getValue(), (ov, nv) -> ov + nv);
			
			if(Role.this.canAddGameItems(counters))
			{
				Role.this.addDropsToBag(this.mapId, counters);
			}
			else
			{
				this.onBagFull(counters, new HashSet<>());
			}
		}
		
		void addItem(int itemID, int count)
		{
			this.drops.merge(itemID, count, (ov, nv) -> ov + nv);
			if(Role.this.canAddGameItem(itemID, count))
			{
				Role.this.addDropToBag(this.mapId, itemID, count);
			}
			else
			{
				this.onBagFull(itemID, count, 0);
			}
		}
		
		@Override
		void onBeforeEnterMapCopy()
		{
			// TODO Auto-generated method stub
		}

		@Override
		void onBeforeLeaveMapCopy()
		{
			if (endTime == 0)
			{
				gs.getLoginManager().addNormalTaskEvent(new Runnable()
				{

					@Override
					public void run()
					{
						Role.this.leaveTeam();
					}
				});
			}
		}

		@Override
		void onAfterLeaveMapCopy()
		{
			// TODO Auto-generated method stub
		}

		@Override
		int getMapType()
		{
			return GameData.MAP_TYPE_MAPCOPY_TOWER_DEFENCE;
		}

		@Override
		Map<Integer, SBean.FightPet> getMapPets()
		{
			return GameData.emptyMap();
		}
		
		void syncMapCopy()
		{
			super.syncMapCopy();
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_info(this.score, this.count));
		}
		
		int addExp(int exp, int addType, int addParam)
		{
			int addExp = super.addExp(exp, addType, addParam);
			this.exp += addExp;
			return addExp;
		}
		
		boolean onStart(int mapID, int mapInstance, int time)
		{
			if (!super.onStart(mapID, mapInstance, time))
				return false;

			Role.this.towerDefence.logs.merge(mapID, new SBean.DBTowerDefenceMapLog(1, 1, 1, 0, 0, 0, 0, 0), (ov, nv) -> 
			{
				ov.dayEnterTimes++;
				ov.enterTimes++;
				ov.finishTimes++;
				return ov;
			});
			Role.this.logTDScheduleData(mapID);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_start(this.mapId));
			return true;
		}
		
		boolean onEnd(int mapID, int mapInstance, int time, int count, int useTime)
		{
			if (!super.onEnd(mapId, mapInstance, time))
				return false;
			
			this.count = count;
			this.useTime = useTime;
			Role.this.towerDefence.logs.merge(mapID, new SBean.DBTowerDefenceMapLog(1, 1, 1, 0, count, score, useTime, 0), (ov, nv) -> 
			{
				ov.bestCount = this.count > ov.bestCount ? this.count : ov.bestCount;
				ov.bestScore = this.score > ov.bestScore ? this.score : ov.bestScore;
				ov.useTime = this.useTime < ov.useTime ? this.useTime : ov.useTime;
				return ov;
			});
			
			if(canTakeDrop)
				giveMapCopyFinishedReward(mapID, mapInstance, count);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_end());
			return true;
		}
		
		private void giveMapCopyFinishedReward(int mapID, int mapInstance, int count)
		{
			gs.getLogger().info("give role " + Role.this.id + " tower defence map[" + mapID + " " + mapInstance + "] finish reward, count " + count);
			SBean.TowerDefenceCFGS cfg = GameData.getInstance().getTowerDefenceCFGS(mapID);
			if(cfg != null)
			{
				List<SBean.DummyGoods> reward = GameData.getFloorReward(cfg.mapRewards, count);
				if(reward != null && !reward.isEmpty())
				{
					this.addItems(GameData.toCounter(reward));
//					List<SBean.GameItem> gis = GameData.getInstance().toGameItems(reward);
//					if(Role.this.canAddGameItems(gis))
//					{
//						TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TD_MAP_FINISH_REWARD);
//						Role.this.syncAddGameItems(gis, tlogEvent);
//						tlogEvent.setArg(mapID, count);
//						gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//					}
//					else
//					{
//						Role.this.addDropsToMailBox(mapID, gis);
//					}
				}
			}
		}
		
		boolean onPopupResult(int mapID, int mapInstance, int time)
		{
			if (!super.onPopupResult(mapID, mapInstance, time))
				return false;
			
			Integer rcoin = this.drops.remove(GameData.COMMON_ITEM_ID_COIN);
			if (rcoin == null)
				rcoin = 0;
			
			Integer fcoin = this.drops.remove(-GameData.COMMON_ITEM_ID_COIN);
			if(fcoin == null)
				fcoin = 0;
			
			this.cards = GameData.getInstance().getNoDuplicateDrops(this.finishedTurnPlateDropID, GameData.getInstance().getCommonCFG().map.palteCount);
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_result(mapID, mapInstance, useTime, new SBean.MapRewards(this.exp, rcoin + fcoin, GameData.toDummGoods(this.drops), GameData.convertDrops(this.cards))));
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_result(score, count, useTime, GameData.convertDrops(this.cards)));
			return true;
		}
		
		void addKillMonster(int id, int count, int killRole)
		{
			//TODO
		}
		
		SBean.DummyGoods onSelectRewardCard(int cardNo)
		{
			if (!this.canTakeDrop)
				return null;
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ON_SELECT_REWARD_CARD);
			if (this.cards == null)
				return null;
			int cardCount = GameData.getInstance().getCommonCFG().map.palteCount;
			if (cardNo - 1 + this.cards.size() != cardCount || (cardNo != 1 && cardNo != 2))
				return null;

			int cost = GameData.getInstance().getCommonCFG().map.lotteryCostDiamond;
			if (cardNo != 1 && !Role.this.canUseDiamond(cost, false))
				return null;
			SBean.DummyGoods item = GameData.getInstance().getNextDrop(this.cards);
			if (item == null)
				return null;
			
			SBean.GameItem gi = GameData.getInstance().toGameItem(item.id, item.count);
			if(Role.this.canAddGameItem(item.id, item.count))
			{
				Role.this.addGameItem(gi, tlogEvent.getGameItemRecords());
				tlogEvent.setArg(cardNo, this.mapId, item.id, item.count);
			}
			else
			{
				List<SBean.GameItem> gis = new ArrayList<>();
				gis.add(gi);
				Role.this.addDropsToMailBox(mapId, gis);
			}
			if (cardNo != 1)
				Role.this.useDiamond(cost, false, tlogEvent.getGameItemRecords());

			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			return item;
		}
		
		void onEndSelectCard(int mapId, int mapInstance, int time)
		{
			if (this.mapId != mapId || this.instanceId != mapInstance || this.cards == null || !this.canTakeDrop)
				return;
			if (GameData.getInstance().getCommonCFG().map.palteCount == this.cards.size())
			{
				SBean.DummyGoods item = GameData.getInstance().getNextDrop(this.cards);
				SBean.GameItem gi = GameData.getInstance().toGameItem(item.id, item.count);
				if(Role.this.canAddGameItem(item.id, item.count))
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ON_SELECT_REWARD_CARD);
					tlogEvent.setArg(-1, this.mapId, item.id, item.count);
					Role.this.addGameItem(gi, tlogEvent.getGameItemRecords());
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
				}
				else
				{
					List<SBean.GameItem> gis = new ArrayList<>();
					gis.add(gi);
					Role.this.addDropsToMailBox(mapId, gis);
				}
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_autocard(item));
			}
		}
		
		void syncSpawnCount(int mapID, int mapInstance, int count)
		{
			if(mapID != this.mapId || mapInstance != this.instanceId)
				return;
			this.count = count;
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_info(this.score, this.count));
		}
		
		void syncScore(int mapID, int mapInstance, int monsterID)
		{
			if(mapID != this.mapId || mapInstance != this.instanceId)
				return;
			
			SBean.MonsterCFGS monsterCfg = GameData.getInstance().getMonsterCFGS(monsterID);
			if(monsterCfg == null || monsterCfg.tdScore <= 0)
				return;
			
			this.score += monsterCfg.tdScore;
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_towerdefence_info(this.score, this.count));
		}
	}
	
	//-----------------------------------------------------------------------------------------------------------------------------------------
	private void tryClearDiamondReviveTime(int timeTick)
	{
		if(this.lastDiamondReviveTime == 0)
			return;
		
		if (this.lastDiamondReviveTime + GameData.getInstance().getCommonCFG().revives.clearRecentReviveTime <= timeTick)
		{
			this.lastDiamondReviveTime = 0;
			this.diamondReviveTimes = 0;
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_revive_info(this.diamondReviveTimes));
		}
	}
	
	public synchronized boolean reviveInSitu(boolean useStone)
	{
		if (this.gameMapContext.getCurMapContext().getHp() > 0 || !this.gameMapContext.getCurMapContext().canRevive())
			return false;

		final SBean.CommonRevivesCFGS cfg = GameData.getInstance().getCommonCFG().revives;
		boolean pve = cfg.pveReviveMapTypes.contains(this.gameMapContext.getCurMapContext().getMapType());
		int cost = (int) Math.ceil((getReviveInSituCost(cfg, pve) * (1 - (GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).reviveReduction / 10000f))));
		if (!this.canUseDiamond(cost, false))
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_REVIVE_IN_SITU);
		tlogEvent.setArg(cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		if(!pve)
		{
			this.diamondReviveTimes++;
			this.lastDiamondReviveTime = GameTime.getTime();
		}
		gs.getMapService().syncRoleRevive(this.id, this.gameMapContext.getCurMapId(), true);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	private int getReviveInSituCost(final SBean.CommonRevivesCFGS cfg, boolean pve)
	{
		if(pve)
			return cfg.pveReviveCost;
		
		return cfg.pvpReviveCostBase + cfg.pvpReviveCostAdd * this.diamondReviveTimes;
	}
	
	synchronized boolean reviveOther()
	{
		int now = GameTime.getTime();
		if (this.lastSpawnReviveTime + GameData.getInstance().getCommonCFG().revives.spawnReviveCD > now)
			return false;

		if (this.gameMapContext.getCurMapContext().getHp() > 0 || !this.gameMapContext.getCurMapContext().canRevive())
			return false;

		SBean.Location location = GameData.getInstance().getMapRevivePosition(this.gameMapContext.getCurMapId(), true);
		if (location == null)
			return false;
		
		gs.getMapService().syncRoleRevive(this.id, this.gameMapContext.getCurMapId(), false);
		boolean inPrivate = this.gameMapContext.getCurMapContext() instanceof PrivateMapCopyContext;
		if(!inPrivate)
		{
			this.gameMapContext.resetLocation(location.kdClone());
			this.gameMapContext.roleChangeMap();
		}
		
		this.lastSpawnReviveTime = now;
		this.lastUseHpPoolTime = now;
		this.lastUseHpTime = now;
		return true;
	}
	
	synchronized boolean reviveSafe()
	{
		if (this.gameMapContext.getCurMapContext().getHp() > 0 || !this.gameMapContext.isInWorldMap())
			return false;
		
		SBean.WorldMapCFGS w = GameData.getInstance().getWorldMapCFGS(this.gameMapContext.getCurMapId());
		if(w == null)
			return false;
		
		SBean.Location location = GameData.getInstance().getSafeRevivePosition(w);
		if(location == null)
			return false;
		
		if(this.gameMapContext.getCurMapId() == w.safeReviveMap)
		{
			this.gameMapContext.resetLocation(location.kdClone());
			gs.getMapService().syncRoleRevive(this.id, this.gameMapContext.getCurMapId(), false);
			this.gameMapContext.roleChangeMap();
		}
		else
		{
			SBean.MapLocation mapLocation = new SBean.MapLocation(w.safeReviveMap, location.kdClone());
			this.gameMapContext.changeWorld(mapLocation, this.getPriorityLine(mapLocation.mapID));
			gs.getMapService().syncRoleRevive(this.id, this.gameMapContext.getCurMapId(), false);
			this.gameMapContext.roleChangeMap();
		}
		
		return true;
	}
	
	// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private void updatePKValue(int timeTick)
	{
		int mode = this.gameMapContext.getCurMapContext().getPKMode();
		if (mode != GameData.ATTACK_MODE_PEACE || this.pkValue <= 0)
			return;

		if (this.pkValueTime > 0)
		{
			if (--this.pkValueTime == 0)
			{
				if (--this.pkValue > 0)
					this.pkValueTime = GameData.getInstance().getCommonCFG().pk.pkValueInterval;
				this.updateRedNamePunish();
				gs.getMapService().syncRoleUpdatePKInfo(this.id, this.gameMapContext.getCurMapId(), mode, this.pkValue);
			}
		}
	}

	public synchronized boolean setPKMode(int mode)
	{
		if (this.level < GameData.getInstance().getCommonCFG().pk.needLvl)
			return false;
		
		switch (mode)
		{
		case GameData.ATTACK_MODE_PEACE:
		case GameData.ATTACK_MODE_ALL:
		case GameData.ATTACK_MODE_BW:
			break;
		case GameData.ATTACK_MODE_SECT:
			if(this.sectData.data.sectBrief.sectID == 0)
				return false;
			break;
		default:
			return false;
		}
		
		if (!this.gameMapContext.getCurMapContext().setPKMode(mode))
			return false;

		gs.getMapService().syncRoleUpdatePKInfo(this.id, this.gameMapContext.getCurMapId(), mode, this.pkValue);
		return true;
	}

	// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public synchronized boolean transform(byte tlvl, byte bwType)
	{
		if (tlvl != this.transformLevel + 1)
			return false;
		if (this.BWType != 0 && this.BWType != bwType)
			return false;
		SBean.TransformCFGS cfg = GameData.getInstance().getTransformCFGS(this.classType, tlvl, bwType);
		if (cfg == null || !this.containsEnoughGameItems(cfg.cost))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRANSFORM);
		tlogEvent.setArg(this.classType, tlvl, bwType);
		this.delGameItems(cfg.cost, tlogEvent.getGameItemRecords());
		this.transformImpl(tlvl, bwType, cfg);
		this.logTasks(GameData.TASK_TYPE_TRANSFROM_LEVEL, 0, 0, 0);
		this.updateRanks();
		if(GameData.getInstance().getRollNoticeCFGS().transfers.contains((int) tlvl))
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_TRANSFER, this.name + "|" + bwType + "|" + this.classType + "|" + tlvl);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	private void transformImpl(byte tlvl, byte bwType, SBean.TransformCFGS cfg)
	{
		byte oldBWType = this.BWType;
		this.transformLevel = tlvl;
		this.BWType = bwType;
		if (oldBWType != bwType)
		{
			gs.getBWArenaManager().updateBWArenaLvlRoleCache(this);
			if (this.level >= (GameData.getInstance().getBWArenaCFGS().base.lvlReq - GameData.getInstance().getBWArenaCFGS().base.lvlReq - GameData.BWARENA_LVL_ADVANCE))
			{
				this.initBWArenaPet();
				//				this.refreshBwArenaEnemiesImpl();
			}
			
			notifyTeamMemberUpdateProfile();
			notifyARoomMemberUpdateOverview();
		}
		gs.getMapService().syncRoleUpdateTransformInfo(this.id, this.gameMapContext.getCurMapId(), tlvl, bwType);

		for (int skillid : cfg.skills)
		{
			SBean.DBSkill skill = new SBean.DBSkill(skillid, 1, 0);
			this.skills.put(skillid, skill);
			gs.getMapService().syncRoleUpdateSkill(this.id, this.gameMapContext.getCurMapId(), skill);

			this.roleProperties.onUpdateSkill(skill, false);
		}
		this.roleProperties.onUpdateTransformInfo(tlvl, bwType);
	}

	int tryStartMine(int mineId, int mineInstance)
	{
		SBean.MineralCFGS minralCfg = GameData.getInstance().getMineralCFGS(mineId);
		if (minralCfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		int result = GameData.PROTOCOL_OP_SUCCESS;
		switch (minralCfg.mineralType)
		{
		case GameData.MINERAL_TYPE_TASK:
			result = !checkTaskMine(mineId) ? GameData.PROTOCOL_OP_FAILED : result;
			break;
		case GameData.MINERAL_TYPE_FLAG:
			result = checkFlagMine(mineId);
			break;
		case GameData.MINERAL_TYPE_WEDDINF_BOX:
			result = checkWeddingBox(mineId);
			break;
		case GameData.MINERAL_TYPE_BANQUET:
			result = checkBanquet(mineId);
			break;
		case GameData.MINERAL_TYPE_STELE:
			result = gs.getSteleManager().roleTryMineStele(this, mineId);
			break;
		default:
			break;
		}
		if (result <= 0)
			return result;
			
		return tryStartMineImpl(minralCfg, mineId, mineInstance);
	}
	
	synchronized int tryStartMineImpl(SBean.MineralCFGS minralCfg, int mineId, int mineInstance)
	{
		if (this.level < minralCfg.needLvl)
			return GameData.PROTOCOL_OP_FAILED;
		if (minralCfg.needItem != 0 && !this.containsEnoughGameItem(minralCfg.needItem, 1))
			return GameData.PROTOCOL_OP_FAILED;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRY_START_MINE);
		tlogEvent.setArg(mineId, mineInstance, minralCfg.needItem);
		if (minralCfg.needItem != 0 && minralCfg.isCostItem != 0)
			this.delGameItem(minralCfg.needItem, 1, tlogEvent.getGameItemRecords());
		gs.getMapService().syncRoleStartMine(this.id, this.gameMapContext.getCurMapId(), mineId, mineInstance);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private void checkSuite(int equipId)
	{
		equipId = equipId < 0 ? -equipId : equipId;
		int suiteId = GameData.getInstance().getEquipToSuites(equipId);
		if (suiteId > 0)
		{
			SBean.SuiteCFGS suiteCfg = GameData.getInstance().getSuites(suiteId);
			if (suiteCfg != null)
			{
				SBean.DBSuite suite = suites.get(suiteId);
				if (suite == null)
				{
					suite = new SBean.DBSuite(suiteId, new TreeSet<Integer>());
					suites.put(suite.id, suite);
				}
				suite.collect.add(equipId);
				if (suite.collect.size() == suiteCfg.parts.size())
				{
					if(this.roleProperties.onGainNewSuite(suite.id))
						gs.getMapService().syncRoleGainNewSuite(this.id, this.gameMapContext.getCurMapId(), suite.id);
				}
			}
		}
	}

	public synchronized List<Integer> buyCoin(int times)
	{
		if (times < 1 || times > 10)
			return null;
		SBean.VipCFGS vipcfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipcfg == null || times + this.dayBuyCoinTimes > vipcfg.dayMaxBuyCoinTimes)
			return null;
		SBean.CommonCoinCFGS coincfg = GameData.getInstance().getCommonCFG().coin;
		int coinCostPerTime = GameData.getTimesCost(coincfg.buyTimesCost, 1 + this.dayBuyCoinTimes);
		for (int t = 2; t <= times; ++t)
		{
			if (coinCostPerTime != GameData.getTimesCost(coincfg.buyTimesCost, t + this.dayBuyCoinTimes))
				return null;
		}
		if (!this.canUseDiamond(coinCostPerTime * times, false))
			return null;

		int buyCoinAmount = 0;
		List<Integer> multipliers = new ArrayList<Integer>();
		for (int t = 1; t <= times; ++t)
		{
			int dayTimes = this.dayBuyCoinTimes + t;
			int multiplier = 1;
			if (dayTimes == 1)
			{
				multiplier = 2;
			}
			else
			{
				multiplier = GameData.getRandomMultiplier(coincfg.buyCrits);
				if (dayTimes % 5 == 0 && multiplier == 1)
					multiplier = 2;
			}
			multipliers.add(multiplier);
			buyCoinAmount += (coincfg.buyBaseAmount + this.level * coincfg.buyRoleLvlAmount + dayTimes * coincfg.buyTimesAmount) * multiplier;
		}
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_COIN);
		this.useDiamond(coinCostPerTime * times, false, tlogEvent.getGameItemRecords());
		this.syncAddCoin(buyCoinAmount, true, tlogEvent);
		this.dayBuyCoinTimes += times;
		this.logDailyTask(GameData.DAILY_TASK_ID_BUY_COINS, 1);

		tlogEvent.setArg(times, this.dayBuyCoinTimes);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);

		return multipliers;
	}

	public synchronized boolean buyVit()
	{
		SBean.VipCFGS vipcfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipcfg == null || this.dayBuyVitTimes + 1 > vipcfg.dayMaxBuyVitTimes)
			return false;
		int maxVit = GameData.getInstance().getMaxVit(this.level);
		if (this.vit > maxVit)
			return false;
		int cost = GameData.getTimesCost(GameData.getInstance().getCommonCFG().vit.buyTimesCost, this.dayBuyVitTimes + 1);
		if (!this.canUseDiamond(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_VIT);
		tlogEvent.setArg(this.dayBuyVitTimes, cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.syncAddVit(GameData.getInstance().getCommonCFG().vit.buyVitValue, tlogEvent);
		this.dayBuyVitTimes += 1;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean testCheckIn()
	{
		GameData.CheckInInfo info = GameData.getInstance().getCheckInRewardCFG(this.lastDayRefresh);
		if (info == null)
			return false;
		SBean.DBCheckInLog log = this.tryCheckCheckInLog(info);
		if (log == null)
			return false;
		return true;
	}

	public synchronized SBean.CheckInInfo syncCheckInInfo()
	{
		GameData.CheckInInfo info = GameData.getInstance().getCheckInRewardCFG(this.lastDayRefresh);
		if (info == null)
			return null;
		SBean.DBCheckInLog log = this.syncCheckInLog(info);
		return new SBean.CheckInInfo(log.checkinId, log.finishedDays, log.lastCheckInDaySeq < info.daySeq ? 1 : 0);
	}

	private SBean.DBCheckInLog syncCheckInLog(GameData.CheckInInfo info)
	{
		if (this.checkinLog.checkinId != info.cfg.id)
		{
			this.checkinLog.checkinId = info.cfg.id;
			this.checkinLog.finishedDays = 0;
			this.checkinLog.lastCheckInDaySeq = 0;
		}
		return this.checkinLog;
	}

	private SBean.DBCheckInLog tryCheckCheckInLog(GameData.CheckInInfo info)
	{
		SBean.DBCheckInLog log = this.syncCheckInLog(info);
		if (log.lastCheckInDaySeq >= info.daySeq)
			return null;
		return log;
	}

	public synchronized boolean takeCheckInRewards()
	{
		GameData.CheckInInfo info = GameData.getInstance().getCheckInRewardCFG(this.lastDayRefresh);
		if (info == null)
			return false;
		SBean.DBCheckInLog log = this.tryCheckCheckInLog(info);
		if (log == null)
			return false;
		SBean.CheckInRewardCFGS rcfg = info.cfg.rewards.get(log.finishedDays);
		int rewardId = rcfg.reward.id;
		int rewardCount = (rcfg.doubleVip > 0 && this.getUseableVipLvl() >= rcfg.doubleVip) ? rcfg.reward.count * 2 : rcfg.reward.count;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CHECKIN_TAKE);
		tlogEvent.setArg(rewardId, rewardCount);
		this.syncAddGameItem(GameData.getInstance().toGameItem(rewardId, rewardCount), tlogEvent);
		log.finishedDays += 1;
		log.lastCheckInDaySeq = info.daySeq;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	//杂货店
	public synchronized int storeBuy(int id, int count)
	{
		if (id <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.StoreCFGS storeCFGS = GameData.getInstance().getStoreCFGS(id);
		if (storeCFGS == null || storeCFGS.isStop == 0)
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_STROE_BUY);
		float priceIncrease = GameData.getInstance().getPriceIncrease(this.pkValue);
		int realPrice = storeCFGS.money + (int) Math.floor(storeCFGS.money * priceIncrease);
		int finalCost = realPrice * count;
		if (!this.containsEnoughGameItem(storeCFGS.costType, finalCost))
			return GameData.PROTOCOL_OP_FAILED;

		tlogEvent.setArg(id, count, realPrice);
		this.delGameItem(storeCFGS.costType, finalCost, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(storeCFGS.itemId, storeCFGS.count * count), tlogEvent);

		gs.getTLogger().logRoleStoreBuyFlow(this, TLog.NPC_STORE, id, count, storeCFGS.costType, finalCost, storeCFGS.itemId, storeCFGS.count * count);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return finalCost;
	}

	public synchronized void roleSyncMap()
	{
		this.notifyClientChangeMap(this.gameMapContext.getCurMapContext().getMapLocation(), this.gameMapContext.getCurMapContext().getMapLine());
	}

	public boolean teleportNpc(int mapId, int npcPoint)
	{
		SBean.MapLocation mapLocation = null;
		synchronized(this)
		{
			if (!this.gameMapContext.isInWorldMap() || this.mulRolesLock > 0 || this.isMulRolesMember())
				return false;

			int itemID = GameData.getInstance().getCommonCFG().activity.transItemID;
			boolean freeTrans = GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).freeTransfrom == 1;
			if (!freeTrans && !this.containsEnoughGameItem(itemID, 1))
				return false;
			
			SBean.MapClusterCFGS mccfg = GameData.getInstance().getMapClusterCFGS(mapId);
			if (mccfg == null || !mccfg.npcs.contains(npcPoint))
				return false;

			SBean.NpcPointCFGS npcPointCFGS = GameData.getInstance().getNpcPointCfg(npcPoint);
			if (npcPointCFGS == null)
				return false;
			
			mapLocation = new SBean.MapLocation(mapId, GameData.createRandomLocation(200, (float)Math.PI / 2.f, npcPointCFGS.position, npcPointCFGS.rotation));
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TELEPORT_NPC);
			tlogEvent.setArg(itemID, mapId, npcPoint);
			if (!freeTrans)
				this.delGameItem(itemID, 1, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(mapLocation, this.getPriorityLine(mapLocation.mapID));
				this.gameMapContext.roleChangeMap();
				return true;
			}
		}
		
		this.mulRolesChangeMap(mapLocation);
		return true;
	}

	public boolean teleportMonster(int mapId, int spawnPoint)
	{
		SBean.MapLocation monsterLocation = null;
		synchronized(this)
		{
			if (!this.gameMapContext.isInWorldMap() || this.mulRolesLock > 0)
				return false;
			
			int itemID = GameData.getInstance().getCommonCFG().activity.transItemID;
			boolean freeTrans = GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).freeTransfrom == 1;
			if (!freeTrans && !this.containsEnoughGameItem(itemID, 1))
				return false;
			
			SBean.MapClusterCFGS mccfg = GameData.getInstance().getMapClusterCFGS(mapId);
			if (mccfg == null || !mccfg.spawnPoints.contains(spawnPoint))
				return false;

			SBean.SpawnPointCFGS spawnPointCFGS = GameData.getInstance().getSpawnPoint(spawnPoint);
			if (spawnPointCFGS == null)
				return false;
			
			monsterLocation = new SBean.MapLocation(mapId, new SBean.Location(spawnPointCFGS.position, new SBean.Vector3F(1.0f, 0.0f, 0.0f)));
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TELEPORT_MONSTER);
			tlogEvent.setArg(itemID, mapId, spawnPoint);
			if (!freeTrans)
				this.delGameItem(itemID, 1, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(monsterLocation, this.getPriorityLine(monsterLocation.mapID));
				this.gameMapContext.roleChangeMap();
				return true;
			}
		}
		
		this.mulRolesChangeMap(monsterLocation);
		return true;
	}

	public boolean teleportMineral(int mapId, int mineralPoint)
	{
		SBean.MapLocation mineralLocation = null;
		synchronized(this)
		{
			if (!this.gameMapContext.isInWorldMap() || this.mulRolesLock > 0 || this.isMulRolesMember())
				return false;

			int itemID = GameData.getInstance().getCommonCFG().activity.transItemID;
			boolean freeTrans = GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).freeTransfrom == 1;
			if (!freeTrans && !this.containsEnoughGameItem(itemID, 1))
				return false;
			
			SBean.MapClusterCFGS mccfg = GameData.getInstance().getMapClusterCFGS(mapId);
			if (mccfg == null || !mccfg.minerals.contains(mineralPoint))
				return false;

			SBean.MineralPointCFGS mineralPointCFGS = GameData.getInstance().getMineralPointCFGS(mineralPoint);
			if (mineralPointCFGS == null)
				return false;
			
			mineralLocation = new SBean.MapLocation(mapId, new SBean.Location(mineralPointCFGS.position, new SBean.Vector3F(1.0f, 0.0f, 0.0f)));
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TELEPORT_MINERAL);
			tlogEvent.setArg(itemID, mapId, mineralPoint);
			if (!freeTrans)
				this.delGameItem(itemID, 1, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(mineralLocation, this.getPriorityLine(mineralLocation.mapID));
				this.gameMapContext.roleChangeMap();
				return true;
			}
		}
		
		this.mulRolesChangeMap(mineralLocation);
		return true;
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	boolean testGroupBuyActivity()
	{
		int now = GameTime.getTime();
		GameConf.GroupBuyConfig cfg = gs.getGameConf().getGroupConfig(now);
		if(cfg == null)
			return false;
		
		return true;
	}
	
	boolean testCanBuyGroupBuy()
	{
		int now = GameTime.getTime();
		GameConf.GroupBuyConfig cfg = gs.getGameConf().getGroupConfig(now);
		if(cfg == null)
			return false;
		
		SBean.DBRoleGroupBuyLog log = syncGroupBuyLog(cfg, now);
		for(SBean.GroupBuyGoods goods: cfg.getConfigData().goods)
		{
			if(this.level < goods.levelReq || this.getUseableVipLvl() < goods.vipReq)
				continue;
			
			if(goods.restriction == null)
				return true;
			
			SBean.DBGoodsGroupBuyLog gLog = log.logs.get(goods.id);
			if(gLog == null || gLog.dayBuyTimes < goods.restriction.times)
				return true;
		}
		
		return false;
	}
	
	synchronized RpcRes<SBean.RoleGroupBuyInfo> syncGroupInfoImpl()
	{
		int now = GameTime.getTime();
		GameConf.GroupBuyConfig cfg = gs.getGameConf().getGroupConfig(now);
		if(cfg == null)
			return new RpcRes<SBean.RoleGroupBuyInfo>(GameData.PROTOCOL_OP_CONF_GROUPBUY_NOT_FOUND);
		
		SBean.DBRoleGroupBuyLog log = syncGroupBuyLog(cfg, now);
		return new RpcRes<SBean.RoleGroupBuyInfo>(new SBean.RoleGroupBuyInfo(cfg.getEffectiveTime(), cfg.getConfigData().kdClone(), log.kdClone(), gs.getGameConf().getGroupBuyCounts(cfg.getId())));
	}
	
	public void syncGroupInfo()
	{
		RpcRes<SBean.RoleGroupBuyInfo> res = syncGroupInfoImpl();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.groupbuy_sync_res(res.errCode, res.info));
	}

    synchronized RpcRes<SBean.RolePayRankInfo> syncPayRankInfoImpl()
    {
        int now = GameTime.getTime();
        GameConf.PayRankConfig cfg = gs.getGameConf().getPayRankConfig(now);
        if (cfg == null)
            return new RpcRes<SBean.RolePayRankInfo>(GameData.PROTOCOL_OP_CONF_GROUPBUY_NOT_FOUND);

        SBean.DBRolePayRankLog log = this.payRankLogs.get(cfg.getId()) == null ? new SBean.DBRolePayRankLog(cfg.getId(), 0) : this.payRankLogs.get(cfg.getId());
        List<SBean.RankRole> rankRoles = gs.getGameConf().getPayRankShowList(cfg.getId(), cfg);
        int selfRank = gs.getGameConf().getRoleRank(cfg.getId(), this.id);
        return new RpcRes<SBean.RolePayRankInfo>(new SBean.RolePayRankInfo(cfg.getEffectiveTime(), selfRank, cfg.getConfigData(), log.kdClone(), rankRoles));
    }

	public void syncPayRankInfo()
    {
        RpcRes<SBean.RolePayRankInfo> res = syncPayRankInfoImpl();
        gs.getRPCManager().sendStrPacket(this.netsid, new SBean.payrank_sync_res(res.errCode, res.info));
    }

	private SBean.DBRoleGroupBuyLog syncGroupBuyLog(GameConf.GroupBuyConfig cfg, int now)
	{
		SBean.DBRoleGroupBuyLog log = this.groupBuyLogs.get(cfg.getId());
		if(log == null)
		{
			log = new SBean.DBRoleGroupBuyLog(now, new HashMap<>());
			this.groupBuyLogs.put(cfg.getId(), log);
		}
		else
		{
			int nowDay = GameTime.getDay(now);
			int lastDay = GameTime.getDay(log.logTime);
			if(nowDay > lastDay)
			{
				for(SBean.DBGoodsGroupBuyLog e: log.logs.values())
				{
					SBean.GroupBuyGoods g = cfg.getGroupBuyGoods(e.id);
					if(g == null || g.restriction == null || g.restriction.dayRefresh != 1)
						continue;
					
					e.dayBuyTimes = 0;
				}
			}
			log.logTime = now;
		}
		
		return log;
	}
	
	//花费非绑定元宝(free)
	public synchronized int buyGroupBuyGoods(int effectiveTime, int activityID, int gid, int count)
	{
		int now = GameTime.getTime();
		GameConf.GroupBuyConfig cfg = gs.getGameConf().getGroupConfig(now);
		if(cfg == null || cfg.getId() != activityID)
			return GameData.PROTOCOL_OP_CONF_GROUPBUY_NOT_FOUND;
		
		if(cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		
		if(!cfg.isInBuyTime(now))
			return GameData.PROTOCOL_OP_CONF_GROUPBUY_OVER_BUYENDTIME;
		
		SBean.GroupBuyGoods goods = cfg.getGroupBuyGoods(gid);
		if(goods == null || this.level < goods.levelReq || this.getUseableVipLvl() < goods.vipReq)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.DBRoleGroupBuyLog log = syncGroupBuyLog(cfg, now);
		SBean.DBGoodsGroupBuyLog gLog = log.logs.get(gid);
		if(gLog == null)
			gLog = new SBean.DBGoodsGroupBuyLog(gid, 0, 0);
		
		if(goods.restriction != null && gLog.dayBuyTimes + count > goods.restriction.times)
			return GameData.PROTOCOL_OP_CONF_GROUPBUY_RESTRICTION;
		
		if(!this.canUseDiamond(goods.price * count, true))
			return GameData.PROTOCOL_OP_FAILED;
		
		if(!this.canAddGameItem(goods.iid, goods.icount * count))
			return GameData.PROTOCOL_OP_FAILED;;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GROUPUY_GOODS);
		tlogEvent.setArg(activityID, gid, count);

		this.useDiamond(goods.icount * count, true, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(goods.iid, goods.icount * count), tlogEvent);
		gLog.allBuyTimes += count;
		gLog.dayBuyTimes += count;
		log.logs.put(gid, gLog);
		
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getGameConf().updateGroupBuyLog(activityID, this.id, gid, count);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

    boolean testFlashSaleActivity()
    {
        int now = GameTime.getTime();
        GameConf.FlashSaleConfig cfgs = gs.getGameConf().getFlashSaleConfig(now);
        if(cfgs == null)
            return false;

        return true;
    }
    
	private boolean testCanBuyFlashSale()
    {
		int now = GameTime.getTime();
        GameConf.FlashSaleConfig cfg = gs.getGameConf().getFlashSaleConfig(now);

        if(cfg==null || !cfg.isInBuyTime(now))
            return false;

        SBean.DBRoleFlashSaleLog log = syncFlashSaleLog(cfg, now);
        for (SBean.FlashSaleGoods goodCfg : cfg.getGoodConfigs())
        {
            Integer buyTimes = log.logs.getOrDefault(goodCfg.id, 0);
            if (buyTimes < cfg.getMaxBuyTimes(goodCfg, this.getUseableVipLvl()) && this.level >= goodCfg.levelReq)
                return true;
        }

        return false;
    }
	
    synchronized public void syncFlashSaleInfo()
    {
		int now = GameTime.getTime();
		GameConf.FlashSaleConfig cfg = gs.getGameConf().getFlashSaleConfig(now);
		if(cfg==null)
		{
		    gs.getRPCManager().sendStrPacket(this.netsid, new SBean.flashsale_sync_res(GameData.PROTOCOL_OP_CONF_FLASHSALE_NOT_FOUND, null));
		    return;
		}
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.flashsale_sync_res(GameData.PROTOCOL_OP_SUCCESS, 
		        new SBean.RoleFlashSaleInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), new HashMap<>(syncFlashSaleLog(cfg, now).logs))));
    }
	
    synchronized private SBean.DBRoleFlashSaleLog syncFlashSaleLog(FlashSaleConfig cfg, int now)
    {
        SBean.DBRoleFlashSaleLog log = flashSaleLogs.get(cfg.getId());
        if (log==null)
        {
            log = new SBean.DBRoleFlashSaleLog(now, new HashMap<>());
            flashSaleLogs.put(cfg.getId(), log);
        }
        
        return log;
    }

    
    public synchronized int buyFlashSaleGoods(int effectiveTime, int activityID, int wantId)
    {
		int now = GameTime.getTime();
		GameConf.FlashSaleConfig cfg = gs.getGameConf().getFlashSaleConfig(now);
		if(cfg == null || cfg.getId() != activityID)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		
		if (cfg.getEffectiveTime()!=effectiveTime)
		    return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		
		if(!cfg.isInBuyTime(now))
			return GameData.PROTOCOL_OP_CONF_FLASHSALE_OVER_BUYENDTIME;
		
		SBean.FlashSaleGoods goods = cfg.getGoods(wantId);
		if (goods==null)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		
		if(this.level < goods.levelReq)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.DBRoleFlashSaleLog log = syncFlashSaleLog(cfg, now);
		Integer buyedTime = log.logs.get(wantId);
		buyedTime = buyedTime==null?0:buyedTime;
		if (buyedTime>=cfg.getMaxBuyTimes(goods, this.getUseableVipLvl()))
		    return GameData.PROTOCOL_OP_CONF_FLASHSALE_TIME_LIMIT;
	
		if (!containsEnoughGameItem(goods.moneyid, goods.nowprice))
		    return GameData.PROTOCOL_OP_FAILED;
		
		if (!canAddGameItems(goods.items))
		    return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_FLASHSALE_GOODS);
		tlogEvent.setArg(activityID, goods.id, 1);

		delGameItem(goods.moneyid, goods.nowprice, tlogEvent.getGameItemRecords());
		this.syncAddGameItems(GameData.getInstance().toGameItems(goods.items), tlogEvent);
		log.logs.putIfAbsent(goods.id, 0);
		log.logs.merge(goods.id, 1, (o, n) -> o + n);
		log.logTime = now;
		
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
        return GameData.PROTOCOL_OP_SUCCESS;
    }
    
    
    boolean testLuckRollerActiveity()
    {
        return gs.getGameConf().getLuckyRollerConfig(GameTime.getTime()) != null;
    }
    
	private SBean.DBRoleLuckyRollerLog syncLuckyRollerLog(int id)
    {
        SBean.DBRoleLuckyRollerLog log = luckyRollerLogs.get(id);
        if (log == null)
        {
            log = new SBean.DBRoleLuckyRollerLog(id, 0, 0, 0);
            luckyRollerLogs.put(id, log);
        }
        if (GameTime.getDay(log.lastPlayTime) != GameTime.getDay())
        {
        	log.lastPlayTime = GameTime.getTime();
        	log.dayPlayTimes = 0;
        }
        return log;
    }
	
 	public void syncLuckyRollerInfo()
    {
		RpcRes<SBean.LuckyRollInfo> res = syncLuckyRollerInfoImpl();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.luckyroll_sync_res(res.errCode, res.info ));
    }
    
	synchronized RpcRes<SBean.LuckyRollInfo> syncLuckyRollerInfoImpl()
	{
		GameConf.LuckyRollerConfig cfg = gs.getGameConf().getLuckyRollerConfig(GameTime.getTime());
		if (cfg == null)
			return new RpcRes<SBean.LuckyRollInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		SBean.DBRoleLuckyRollerLog log = syncLuckyRollerLog(cfg.getId());
		return new RpcRes<SBean.LuckyRollInfo>(new SBean.LuckyRollInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), cfg.getLuckyRollRecordsCopy(), log.dayPlayTimes));
	}

    public synchronized int playLuckyRoller(int effectiveTime, int id)
    {
		GameConf.LuckyRollerConfig cfg = gs.getGameConf().getLuckyRollerConfig(GameTime.getTime());
		
		if(cfg==null || cfg.getEffectiveTime() != effectiveTime || cfg.getId() != id)
		    return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;

		SBean.DBRoleLuckyRollerLog log = syncLuckyRollerLog(cfg.getId());
		if (cfg.getDayMaxPlayTimes() > 0 && log.dayPlayTimes >= cfg.getDayMaxPlayTimes())
			return GameData.PROTOCOL_OP_FAILED;
        if (!containsEnoughGameItem(-GameData.COMMON_ITEM_ID_DIAMOND, cfg.getPrice()))
            return GameData.PROTOCOL_OP_FAILED;
        
        if(this.bag.getCanUseSize()<1)
        {
	        return GameData.PROTOCOL_OP_CONF_BAG_NEED;
        }
        
		SBean.LuckyRollerGift gift = cfg.rollGift(log.seq + 1);
        List<SBean.DummyGoods> rewards = new ArrayList<SBean.DummyGoods>();
        rewards.add(gift.gift);
        rewards.add(cfg.getExReward());
        
        if (!canAddGameItems(rewards) || this.bag.getCanUseSize() < GameData.getInstance().getCommonCFG().bagSizeNeed.wheelNeeds)
            return GameData.PROTOCOL_OP_CONF_BAG_NEED;

        TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PLAY_LUCKYROLL);
        tlogEvent.setArg(gift.id);
        delGameItem(-GameData.COMMON_ITEM_ID_DIAMOND, cfg.getPrice(), tlogEvent.getGameItemRecords());
        syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		
        if (gift.valuable != 0)
        {
            cfg.addLuckyRollRecordsCopy(new SBean.LuckyRollerRecord(name, gift.id));
        }
        if (cfg.needResetRollTimes(gift.id))
        {
            log.seq = 0;
        }
        else 
        {
            log.seq += 1;
        }
        log.dayPlayTimes ++;
        
        gs.getTLogger().logRoleEventFlow(this, tlogEvent);
        return gift.id;
    }
   

    public synchronized SBean.RoleMallInfo syncMallInfo()
	{
		int now = GameTime.getTime();
		GameConf.MallConfig cfg = gs.getGameConf().getMallConfig(now);
		if (cfg == null)
			return new SBean.RoleMallInfo(0, null, null);
		SBean.DBRoleMallLog log = syncMallLog(cfg, now);

		return new SBean.RoleMallInfo(cfg.getEffectiveTime(), cfg.getConfigData().kdClone(), log.kdClone());
	}

	private SBean.DBRoleMallLog syncMallLog(GameConf.MallConfig cfg, int now)
	{
		//商城是自然天，无5点偏移
		SBean.DBRoleMallLog log = this.mallBuyLogs.get(cfg.getId());
		if (log == null)
		{
			log = new SBean.DBRoleMallLog(cfg.getId(), now, new TreeMap<Integer, SBean.DBGoodsBuyLog>(), new TreeMap<Integer, SBean.DBGoodsBuyLog>());
			this.mallBuyLogs.put(cfg.getId(), log);
		}
		else
		{
			int nowDay = GameTime.getDay(now);
			int nowWeek = GameTime.getWeek(nowDay);
			int lastDay = GameTime.getDay(log.logTime);
			int lastWeek = GameTime.getWeek(lastDay);
			if (nowDay > lastDay || nowWeek > lastWeek)
			{
				for (SBean.DBGoodsBuyLog e : log.fbuyLogs.values())
				{
					if (nowDay != lastDay)
						e.dayBuyTimes = 0;
					if (nowWeek != lastWeek)
						e.weekBuyTimes = 0;
				}
				for (SBean.DBGoodsBuyLog e : log.rbuyLogs.values())
				{
					if (nowDay != lastDay)
						e.dayBuyTimes = 0;
					if (nowWeek != lastWeek)
						e.weekBuyTimes = 0;
				}
			}
			log.logTime = now;
		}
		return log;
	}

	public synchronized int buyMallGoods(int effectiveTime, int id, int gid, int count, boolean free, int price)
	{
		int now = GameTime.getTime();
		GameConf.MallConfig cfg = gs.getGameConf().getMallConfig(now);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		if (cfg.getId() != id)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.MallGoods goods = cfg.getMallGoods(gid, free);
		if (goods == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.TimeSpan saleTime = goods.time != null ? goods.time : cfg.getTimeSpan();
		if (now < saleTime.startTime || now >= saleTime.endTime)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.level < goods.levelReq || this.getUseableVipLvl() < goods.vipReq)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleMallLog log = syncMallLog(cfg, now);
		Map<Integer, SBean.DBGoodsBuyLog> logs = free ? log.fbuyLogs : log.rbuyLogs;
		SBean.DBGoodsBuyLog buyLog = logs.get(gid);
		if (buyLog == null)
			buyLog = new SBean.DBGoodsBuyLog(gid, 0, 0, 0);
		if (goods.restriction != null && (goods.restriction.time == null || now >= goods.restriction.time.startTime && now < goods.restriction.time.endTime))
		{
			if (goods.restriction.weekPeriod != 0)
			{
				if (buyLog.weekBuyTimes + count > goods.restriction.times)
					return GameData.PROTOCOL_OP_CONF_MALL_GOODS_RESTRICTION;
			}
			else
			{
				if (buyLog.dayBuyTimes + count > goods.restriction.times)
					return GameData.PROTOCOL_OP_CONF_MALL_GOODS_RESTRICTION;
			}
		}
		int finalPrice = goods.price;
		if (goods.discount != null && (goods.discount.time == null || now >= goods.discount.time.startTime && now < goods.discount.time.endTime))
			finalPrice = goods.discount.price;
		if (price != finalPrice)
			return GameData.PROTOCOL_OP_CONF_MALL_GOODS_DISCOUNT;

		float priceIncrease = free ? 0 : GameData.getInstance().getPriceIncrease(this.pkValue);
		int usePrice = finalPrice + (int) Math.floor(finalPrice * priceIncrease);

		int totalCost = usePrice * count;
		if (!this.canUseDiamond(totalCost, free))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItem(goods.iid, goods.icount * count))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_MALL_GOODS);
		tlogEvent.setArg(id, gid, count, free ? -GameData.COMMON_ITEM_ID_DIAMOND : GameData.COMMON_ITEM_ID_DIAMOND);

		this.useDiamond(totalCost, free, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(goods.iid, goods.icount * count), tlogEvent);

		buyLog.allBuyTimes += count;
		buyLog.dayBuyTimes += count;
		buyLog.weekBuyTimes += count;
		logs.put(buyLog.id, buyLog);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logRoleMallBuyFlow(this, gid, count, free ? -GameData.COMMON_ITEM_ID_DIAMOND : GameData.COMMON_ITEM_ID_DIAMOND,
		        totalCost, goods.iid, goods.icount * count);
		return totalCost;
	}

	public boolean testBenefit()
	{
		return testCheckIn() || testDailyOnlineGift() || testDailyVitReward() || testCommonActivity();
	}
	
	public boolean testCommonActivity()
	{
		int now = GameTime.getTime();
		return gs.getGameConf().getCommonActivityConfig(now).stream().anyMatch(cfg -> cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && cfg.isCanTakeRewards(this, now));
	}

	public boolean testPayActivity()
	{
		int now = GameTime.getTime();
		return gs.getGameConf().getPayActivityConfig(now).stream().anyMatch(cfg -> cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && cfg.isCanTakeRewards(this, now));
	}
	
	public boolean testFirstPayGiftActivity()
	{
		int now = GameTime.getTime();
		return gs.getGameConf().getFirstPayGiftActivities().getOpenedConfigs(now).stream().anyMatch(cfg ->  cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && cfg.isCanTakeRewards(this, now));
	}
	
	public void tryTestFirstPayGiftCompleted()
	{
		int now = GameTime.getTime();
		boolean finished = gs.getGameConf().getFirstPayGiftActivities().getOpenedConfigs(now).stream().allMatch(cfg ->  cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && cfg.isNoRewardsLeft(this, now));
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_firstpay(finished ? 1 : 0));
	}

	public synchronized List<SBean.ActivityInfo> syncCommonActivityInfo()
	{
		int now = GameTime.getTime();
		return gs.getGameConf().getCommonActivityConfig(now).stream().filter(cfg -> cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && !cfg.isNoRewardsLeft(this, now)).map(cfg -> cfg.getBrief(this, now)).collect(Collectors.toList());
	}
	
	public synchronized List<SBean.ActivityInfo> syncPayActivityInfo()
	{
		int now = GameTime.getTime();
		return gs.getGameConf().getPayActivityConfig(now).stream().filter(cfg -> cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && !cfg.isNoRewardsLeft(this, now)).map(cfg -> cfg.getBrief(this, now)).collect(Collectors.toList());
	}

	boolean isNoFirstPayGiftLeft(GameConf.FirstPayGiftConfig cfg, int now)
	{
		SBean.DBRoleFirstPayGiftLog log = this.syncFirstPayGiftLog(cfg.getId());
		return log.reward > 0;
	}

	boolean isCanTakeFirstPayGift(GameConf.FirstPayGiftConfig cfg, int now)
	{
		SBean.DBRoleFirstPayGiftLog log = this.syncFirstPayGiftLog(cfg.getId());
		return this.canTakeFirstPayGiftReward(cfg, log);
	}

	SBean.DBRoleFirstPayGiftLog syncFirstPayGiftLog(int id)
	{
		SBean.DBRoleFirstPayGiftLog log = this.firstPayGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleFirstPayGiftLog(id, 0, 0);
			this.firstPayGiftLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.RoleFirstPayGiftInfo> syncFirstPayGiftInfoImpl(int id)
	{
		GameConf.FirstPayGiftConfig cfg = gs.getGameConf().getFirstPayGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleFirstPayGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleFirstPayGiftInfo>(new SBean.RoleFirstPayGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncFirstPayGiftLog(id)));
	}

	public void syncFirstPayGiftInfo(int id)
	{
		RpcRes<SBean.RoleFirstPayGiftInfo> res = syncFirstPayGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.firstpaygift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeFirstPayGiftReward(GameConf.FirstPayGiftConfig cfg, SBean.DBRoleFirstPayGiftLog log)
	{
		return log.pay > 0 && log.reward <= 0;
	}

	public synchronized int takeFirstPayGiftReward(int effectiveTime, int id)
	{
		GameConf.FirstPayGiftConfig cfg = gs.getGameConf().getFirstPayGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.DBRoleFirstPayGiftLog log = this.syncFirstPayGiftLog(id);
		if (!this.canTakeFirstPayGiftReward(cfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		Collection<SBean.DummyGoods> classRewards = GameData.getClassTypeRewards(cfg.getInnerConfig().gifts, this.classType);
		Map<Integer, Integer> rewards = GameData.toCounter(classRewards);
		rewards.merge(cfg.getInnerConfig().biggift.id, cfg.getInnerConfig().biggift.count, (ov, nv) -> ov + nv);
		if (!this.canAddGameItems(rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_FIRST_PAY_GIFT_REWARD);
		tlogEvent.setArg(id);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		log.reward = 1;

		this.tryTestFirstPayGiftCompleted();
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	void logPayOnFirstPayGift(int pay)
	{
		int now = GameTime.getTime();
		for (GameConf.FirstPayGiftConfig cfg : gs.getGameConf().getFirstPayGiftActivities().getOpenedConfigs(now))
		{
			if(cfg.isInRoleEffectiveTimeSpan(now, this.createTime))
			{
				SBean.DBRoleFirstPayGiftLog log = this.syncFirstPayGiftLog(cfg.getId());
				log.pay += pay;
			}
		}
	}

	boolean isNoDailyPayGiftLeft(GameConf.DailyPayGiftConfig cfg, int now)
	{
		SBean.DBRoleDailyPayGiftLog log = this.syncDailyPayGiftLog(cfg.getId());
		int day = GameTime.getDay() - GameTime.getDay(cfg.getInnerConfig().time.startTime) + 1;
		return !cfg.getInnerConfig().gifts.containsKey(day) || log.reward.contains(day);
	}

	boolean isCanTakeDailyPayGift(GameConf.DailyPayGiftConfig cfg, int now)
	{
		SBean.DBRoleDailyPayGiftLog log = this.syncDailyPayGiftLog(cfg.getId());
		return this.canTakeDailyPayGiftReward(cfg, log);
	}

	SBean.DBRoleDailyPayGiftLog syncDailyPayGiftLog(int id)
	{
		SBean.DBRoleDailyPayGiftLog log = this.dailyPayGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleDailyPayGiftLog(id, new HashMap<>(), new TreeSet<>());
			this.dailyPayGiftLogs.put(id, log);
		}
		return log;
	}
	
	synchronized RpcRes<SBean.RoleDailyPayGiftInfo> syncDailyPayGiftInfoImpl(int id)
	{
		GameConf.DailyPayGiftConfig cfg = gs.getGameConf().getDailyPayGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleDailyPayGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		int day = GameTime.getDay() - GameTime.getDay(cfg.getInnerConfig().time.startTime) + 1;
		return new RpcRes<SBean.RoleDailyPayGiftInfo>(new SBean.RoleDailyPayGiftInfo(cfg.getEffectiveTime(), cfg.getId(), day, cfg.getInnerConfig().gifts.get(day), this.syncDailyPayGiftLog(id)));
	}

	public void syncDailyPayGiftInfo(int id)
	{
		RpcRes<SBean.RoleDailyPayGiftInfo> res = syncDailyPayGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.dailypaygift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeDailyPayGiftReward(GameConf.DailyPayGiftConfig cfg, SBean.DBRoleDailyPayGiftLog log)
	{
		int day = GameTime.getDay() - GameTime.getDay(cfg.getInnerConfig().time.startTime) + 1;
		return cfg.getInnerConfig().gifts.get(day) != null && log.pay.getOrDefault(day, 0) >= cfg.getInnerConfig().gifts.get(day).pay && !log.reward.contains(day);
	}

	public synchronized int takeDailyPayGiftReward(int effectiveTime, int id)
	{
		GameConf.DailyPayGiftConfig cfg = gs.getGameConf().getDailyPayGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		int day = GameTime.getDay() - GameTime.getDay(cfg.getInnerConfig().time.startTime) + 1;
		SBean.DayPayGift giftcfg = cfg.getInnerConfig().gifts.get(day);
		if (giftcfg == null)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.DBRoleDailyPayGiftLog log = this.syncDailyPayGiftLog(id);
		if (!this.canTakeDailyPayGiftReward(cfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		Map<Integer, Integer> rewards = GameData.toCounter(giftcfg.gifts);
		rewards.merge(giftcfg.biggift.id, giftcfg.biggift.count, (ov, nv) -> ov + nv);
		if (!this.canAddGameItems(rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_DAILY_PAY_GIFT_REWARD);
		tlogEvent.setArg(id);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		log.reward.add(day);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	void logPayOnDailyPayGift(int pay)
	{
		int now = GameTime.getTime();
		for (GameConf.DailyPayGiftConfig cfg : gs.getGameConf().getDailyPayGiftActivities().getOpenedConfigs(now))
		{
			if(cfg.isInRoleEffectiveTimeSpan(now, this.createTime))
			{
				int day = GameTime.getDay() - GameTime.getDay(cfg.getInnerConfig().time.startTime) + 1;
				SBean.DBRoleDailyPayGiftLog log = this.syncDailyPayGiftLog(cfg.getId());
				log.pay.merge(day, pay, (ov, nv) -> ov + nv);
			}
		}
	}

	boolean isNoLastPayGiftLeft(GameConf.LastPayGiftConfig cfg, int now)
	{
		SBean.DBRoleLastPayGiftLog log = this.syncLastPayGiftLog(cfg.getId());
		return  log.reward.size() >= cfg.getInnerConfig().gifts.size() || (cfg.getInnerConfig().fromRegister == 1 && getLastPayDay(cfg) > cfg.getInnerConfig().gifts.size());
	}

	boolean isCanTakeLastPayGift(GameConf.LastPayGiftConfig cfg, int now)
	{
		SBean.DBRoleLastPayGiftLog log = this.syncLastPayGiftLog(cfg.getId());
		return this.canTakeLastPayGiftReward(cfg, log);
	}

	SBean.DBRoleLastPayGiftLog syncLastPayGiftLog(int id)
	{
		SBean.DBRoleLastPayGiftLog log = this.lastPayGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleLastPayGiftLog(id, new HashMap<>(), new TreeSet<>(), new TreeSet<>());
			this.lastPayGiftLogs.put(id, log);
		}
		return log;
	}
	
	synchronized RpcRes<SBean.RoleLastPayGiftInfo> syncLastPayGiftInfoImpl(int id)
	{
		GameConf.LastPayGiftConfig cfg = gs.getGameConf().getLastPayGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleLastPayGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleLastPayGiftInfo>(new SBean.RoleLastPayGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncLastPayGiftLog(id)));
	}

	public void syncLastPayGiftInfo(int id)
	{
		RpcRes<SBean.RoleLastPayGiftInfo> res = syncLastPayGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.lastpaygift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeLastPayGiftReward(GameConf.LastPayGiftConfig cfg, SBean.DBRoleLastPayGiftLog log)
	{
		return (cfg.getInnerConfig().fromRegister != 1 || getLastPayDay(cfg) <= cfg.getInnerConfig().gifts.size()) && log.payDay.size() > log.reward.size() && log.reward.size() < cfg.getInnerConfig().gifts.size();
	}

	public synchronized int takeLastPayGiftReward(int effectiveTime, int id, int seq)
	{
		GameConf.LastPayGiftConfig cfg = gs.getGameConf().getLastPayGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.DummyGoodList giftcfg = cfg.getInnerConfig().gifts.get(seq);
		if (giftcfg == null)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.DBRoleLastPayGiftLog log = this.syncLastPayGiftLog(id);
		if (log.reward.contains(seq) || seq > log.payDay.size())
			return GameData.PROTOCOL_OP_FAILED;
		Map<Integer, Integer> rewards = GameData.toCounter(giftcfg.gifts);
		if (!this.canAddGameItems(rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_LAST_PAY_GIFT_REWARD);
		tlogEvent.setArg(seq);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		log.reward.add(seq);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private int getLastPayDay(GameConf.LastPayGiftConfig cfg)
	{
		int createDay = GameTime.getDay(this.register.createTime);
		int activityDay = GameTime.getDay(cfg.getId());
		int startDay = cfg.getInnerConfig().fromRegister == 1 ? (createDay > activityDay ? createDay : activityDay) : activityDay;
		return GameTime.getDay() - startDay + 1;
	}

	void logPayOnLastPayGift(int payPoints)
	{
		int now = GameTime.getTime();
		for (GameConf.LastPayGiftConfig cfg : gs.getGameConf().getLastPayGiftActivities().getOpenedConfigs(GameTime.getTime()))
		{
			int day = getLastPayDay(cfg);
			if (cfg.getInnerConfig().fromRegister == 1 && day > cfg.getInnerConfig().gifts.size())
				continue;
			SBean.DBRoleLastPayGiftLog log = this.syncLastPayGiftLog(cfg.getId());
			log.dayPayNum.merge(day, payPoints, (ov, nv) -> ov + nv);
			if (cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && !log.payDay.contains(day) && log.dayPayNum.getOrDefault(day, 0) >= cfg.getInnerConfig().lastPayNum)
			{
				log.payDay.add(day);
			}
		}
	}

	boolean isNoActivityChallengeGiftLeft(GameConf.ActivityChallengeGiftConfig cfg, int now)
	{
		SBean.DBRoleActivityChallengeGiftLog log = this.syncActivityChallengeGiftLog(cfg.getId());
		return  cfg.getInnerConfig().gifts.stream().allMatch(conf -> conf.gifts.size() <= log.reward.getOrDefault(conf.id, new SBean.DBRoleChallengeGiftLog(0, 0, GameData.emptySet())).reward.size());
	}

	boolean isCanTakeActivityChallengeGift(GameConf.ActivityChallengeGiftConfig cfg, int now)
	{
		SBean.DBRoleActivityChallengeGiftLog log = this.syncActivityChallengeGiftLog(cfg.getId());
		return this.canTakeActivityChallengeGiftReward(cfg, log);
	}

	SBean.DBRoleActivityChallengeGiftLog syncActivityChallengeGiftLog(int id)
	{
		SBean.DBRoleActivityChallengeGiftLog log = this.activityChallengeGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleActivityChallengeGiftLog(id, new HashMap<>());
			this.activityChallengeGiftLogs.put(id, log);
		}
		return log;
	}
	
	synchronized RpcRes<SBean.RoleActivityChallengeGiftInfo> syncActivityChallengeGiftInfoImpl(int id)
	{
		GameConf.ActivityChallengeGiftConfig cfg = gs.getGameConf().getActivityChallengeGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleActivityChallengeGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleActivityChallengeGiftInfo>(new SBean.RoleActivityChallengeGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncActivityChallengeGiftLog(id).kdClone()));
	}

	public void syncActivityChallengeGiftInfo(int id)
	{
		RpcRes<SBean.RoleActivityChallengeGiftInfo> res = syncActivityChallengeGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.activitychallengegift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeActivityChallengeGiftReward(GameConf.ActivityChallengeGiftConfig cfg, SBean.DBRoleActivityChallengeGiftLog log)
	{
		return cfg.getInnerConfig().gifts.stream().anyMatch(conf -> conf.gifts.stream().anyMatch(giftentry -> log.reward.containsKey(conf.id) && giftentry.times <= log.reward.get(conf.id).times && !log.reward.get(conf.id).reward.contains(giftentry.times)));
	}

	public synchronized int takeActivityChallengeGiftReward(int effectiveTime, int confId, int activityId, int times)
	{
		GameConf.ActivityChallengeGiftConfig cfg = gs.getGameConf().getActivityChallengeGiftActivities().getOpendConfigById(confId);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime || !cfg.getInnerConfig().gifts.stream().anyMatch(gift -> gift.id == activityId))
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		List<SBean.DummyGoods> giftcfg = GameData.getActivityChallengeTimeReward(cfg, activityId, times);
		SBean.DBRoleActivityChallengeGiftLog log = this.syncActivityChallengeGiftLog(confId);
		if (!log.reward.containsKey(activityId))
		{
			log.reward.put(activityId, new SBean.DBRoleChallengeGiftLog(activityId, 0, new HashSet<>()));
		}
		SBean.DBRoleChallengeGiftLog curlog = log.reward.get(activityId);
		if (this.level < cfg.getInnerConfig().levelReq || this.getUseableVipLvl() < cfg.getInnerConfig().vipReq)
			return GameData.PROTOCOL_OP_FAILED;
		if (giftcfg == null || curlog.reward.contains(times) || times > curlog.times)
			return GameData.PROTOCOL_OP_FAILED;
		Map<Integer, Integer> rewards = GameData.toCounter(giftcfg);
		if (!this.canAddGameItems(rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_ACT_CHALLENGE_GIFT);
		tlogEvent.setArg(activityId, times);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		curlog.reward.add(times);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	void logActivityChallengeGift(int type, int arg, int times)
	{
		int now = GameTime.getTime();
		for (GameConf.ActivityChallengeGiftConfig cfg : gs.getGameConf().getActivityChallengeGiftActivities().getOpenedConfigs(now))
		{
			int id = GameData.getInstance().getActivityChallengeType(type, arg);
			if (cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && cfg.getInnerConfig().gifts.stream().anyMatch(gift -> gift.id == id))
			{
				SBean.DBRoleActivityChallengeGiftLog log = this.syncActivityChallengeGiftLog(cfg.getId());
				if (!log.reward.containsKey(id))
					log.reward.put(id, new SBean.DBRoleChallengeGiftLog(id, 0, new HashSet<>()));
				SBean.DBRoleChallengeGiftLog activitylog = log.reward.get(id);
				activitylog.times += times;
			}
		}
	}
	
	boolean isNoUpgradePurchaseLeft(GameConf.UpgradePurchaseConfig cfg, int now)
	{
		SBean.DBRoleUpgradePurchaseLog log = this.syncUpgradePurchaseLog(cfg.getId());
		return  log.reward == 1 || !isInLevelupTime(cfg.getInnerConfig().levelPurchases.level, cfg.getInnerConfig().levelPurchases.limitedTime, true);
	}

	private synchronized boolean isInLevelupTime(int cfglevel, int time, boolean canTake)
	{
		Integer key = this.levelUpTimeMap.higherKey(cfglevel - 1);
		if (key == null)
			return !canTake;
		return this.levelUpTimeMap.get(key) + time > GameTime.getTime();
	}

	private synchronized int getLevelupEndTime(int cfglevel, int time)
	{
		Integer key = this.levelUpTimeMap.higherKey(cfglevel - 1);
		if (key == null)
			return 0;
		return this.levelUpTimeMap.get(key) + time;
	}

	boolean isCanTakeUpgradePurchase(GameConf.UpgradePurchaseConfig cfg, int now)
	{
		SBean.DBRoleUpgradePurchaseLog log = this.syncUpgradePurchaseLog(cfg.getId());
		return log.reward == 0 && isInLevelupTime(cfg.getInnerConfig().levelPurchases.level, cfg.getInnerConfig().levelPurchases.limitedTime, true);
	}

	SBean.DBRoleUpgradePurchaseLog syncUpgradePurchaseLog(int id)
	{
		SBean.DBRoleUpgradePurchaseLog log = this.upgradePurchaseLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleUpgradePurchaseLog(id, 0);
			this.upgradePurchaseLogs.put(id, log);
		}
		return log;
	}
	
	synchronized RpcRes<SBean.RoleUpgradePurchaseInfo> syncUpgradePurchaseInfoImpl(int id)
	{
		GameConf.UpgradePurchaseConfig cfg = gs.getGameConf().getUpgradePurchaseActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleUpgradePurchaseInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleUpgradePurchaseInfo>(new SBean.RoleUpgradePurchaseInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncUpgradePurchaseLog(id), getLevelupEndTime(cfg.getInnerConfig().levelPurchases.level, cfg.getInnerConfig().levelPurchases.limitedTime)));
	}

	public void syncUpgradePurchaseInfo(int id)
	{
		RpcRes<SBean.RoleUpgradePurchaseInfo> res = syncUpgradePurchaseInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.upgradepurchase_sync_res(res.errCode, res.info));
	}

	public synchronized int buyUpgradePurchaseGoods(int effectiveTime, int confId)
	{
		GameConf.UpgradePurchaseConfig cfg = gs.getGameConf().getUpgradePurchaseActivities().getOpendConfigById(confId);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.DBRoleUpgradePurchaseLog log = this.syncUpgradePurchaseLog(confId);
		if (!isCanTakeUpgradePurchase(cfg, GameTime.getTime()) || !canUseDiamond(cfg.upgradePurchase.levelPurchases.price, true))
			return GameData.PROTOCOL_OP_FAILED;
		Map<Integer, Integer> rewards = GameData.toCounter(cfg.upgradePurchase.levelPurchases.goods);
		if (!this.canAddGameItems(rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_UPGRADE_PURCHASE);
		tlogEvent.setArg(confId);
		this.useDiamond(cfg.upgradePurchase.levelPurchases.price, true, tlogEvent.getGameItemRecords());
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		log.reward = 1;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	boolean isNoDirectPurchaseLeft(GameConf.DirectPurchaseConfig cfg, int now)
	{
		SBean.DBRoleDirectPurchaseLog log = this.syncDirectPurchaseLog(cfg.getId(), now);
		SBean.DirectPurchase icfg = cfg.getInnerConfig();
		return icfg.levelPurchases.stream().allMatch(lp -> lp.dayBuyTimes > 0 && log.rewardTimes.getOrDefault(lp.payLevel, 0) >= lp.dayBuyTimes);
	}
	
	boolean isCanTakeDirectPurchase(GameConf.DirectPurchaseConfig cfg, int now)
	{
		SBean.DBRoleDirectPurchaseLog log = this.syncDirectPurchaseLog(cfg.getId(), now);
		return cfg.getInnerConfig().levelPurchases.stream().anyMatch(lcfg -> this.canTakeDirectPurchaseRewards(lcfg, log));
	}
	
	SBean.DBRoleDirectPurchaseLog syncDirectPurchaseLog(int id, int now)
	{
		SBean.DBRoleDirectPurchaseLog log = this.directPurchaseLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleDirectPurchaseLog(id, now, new TreeMap<>());
			this.directPurchaseLogs.put(id, log);
		}
		else
		{
			if (GameTime.getDay(log.lastRewardTime) != GameTime.getDay(now))
			{
				log.lastRewardTime = now;
				log.rewardTimes.clear();
			}
		}
		return log;
	}
	
	synchronized RpcRes<SBean.RoleDirectPurchaseInfo> syncDirectPurchaseInfoImpl(int id)
	{
		GameConf.DirectPurchaseConfig cfg = gs.getGameConf().getDirectPurchaseActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleDirectPurchaseInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		SBean.PayCFGS paycfg = GameData.getInstance().getChannelPayCFG();
		if (paycfg == null)
			return null;
		return new RpcRes<SBean.RoleDirectPurchaseInfo>(new SBean.RoleDirectPurchaseInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncDirectPurchaseLog(id, GameTime.getTime()).kdClone(), this.syncDirectPayInfo()));
	}
	
	public void syncDirectPurchaseInfo(int id)
	{
		RpcRes<SBean.RoleDirectPurchaseInfo> res = syncDirectPurchaseInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.directpurchase_sync_res(res.errCode, res.info));
	}
	
	private static int getDirectPurchaseDayRewardTimes(int payLevel, SBean.DBRoleDirectPurchaseLog log)
	{
		int dayRewardTimes = log.rewardTimes.getOrDefault(payLevel, 0);
		if (GameTime.getDay(log.lastRewardTime) != GameTime.getDay())
			dayRewardTimes = 0;
		return dayRewardTimes;
	}
	
	private int getDirectPurchaseLeftRewardTimes(int payLevel)
	{
		return this.payLevelTimes.getOrDefault(payLevel, 0) - this.payRewardTimes.getOrDefault(payLevel, 0);
	}
	
	private boolean canTakeDirectPurchaseRewards(SBean.DirectLevelPurchase lcfg, SBean.DBRoleDirectPurchaseLog log)
	{
		return getDirectPurchaseLeftRewardTimes(lcfg.payLevel) > 0 && (lcfg.dayBuyTimes == 0 || getDirectPurchaseDayRewardTimes(lcfg.payLevel, log) < lcfg.dayBuyTimes);
	}
	
	public synchronized int takeDirectPurchaseReward(int effectiveTime, int id, int payLevel)
	{
		GameConf.DirectPurchaseConfig cfg = gs.getGameConf().getDirectPurchaseActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.DirectLevelPurchase lcfg = cfg.getInnerConfig().levelPurchases.stream().filter(e -> e.payLevel == payLevel).findFirst().orElse(null);
		if (lcfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		int now = GameTime.getTime();
		SBean.DBRoleDirectPurchaseLog log = this.syncDirectPurchaseLog(id, now);
		if (!this.canTakeDirectPurchaseRewards(lcfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItems(lcfg.gifts))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_DIRECT_PURCHASE_REWARD);
		tlogEvent.setArg(id, payLevel);
		this.syncAddGameItems(GameData.getInstance().toGameItems(lcfg.gifts), tlogEvent);
		this.payRewardTimes.merge(payLevel, 1, (ov, nv) -> ov + nv);
		//已经在sync log时修改过了
		log.rewardTimes.merge(payLevel, 1, (ov, nv) -> ov + nv);
		log.lastRewardTime = now;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	boolean isNoOneArmBanditLeft(GameConf.OneArmBanditConfig cfg, int now)
	{
		SBean.DBRoleOneArmBanditLog log = this.syncOneArmBanditLog(cfg.getId());
		return log.useTimes >= 2;
	}
	
	boolean isCanPlayOneArmBandit(GameConf.OneArmBanditConfig cfg, int now)
	{
		SBean.DBRoleOneArmBanditLog log = this.syncOneArmBanditLog(cfg.getId());
		return this.canPlayOneArmBanditRewards(cfg.getLevelTimesReq(), cfg.getPayTimesReq(), log);
	}
	
	SBean.DBRoleOneArmBanditLog syncOneArmBanditLog(int id)
	{
		SBean.DBRoleOneArmBanditLog log = this.oneArmBanditLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleOneArmBanditLog(id, 0, 0);
			this.oneArmBanditLogs.put(id, log);
		}
		return log;
	}
	
	synchronized RpcRes<SBean.RoleOneArmBanditInfo> syncOneArmBanditInfoImpl(int id)
	{
		GameConf.OneArmBanditConfig cfg = gs.getGameConf().getOneArmBanditActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleOneArmBanditInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleOneArmBanditInfo>(new SBean.RoleOneArmBanditInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncOneArmBanditLog(id).kdClone()));
	}
	
	public void syncOneArmBanditInfo(int id)
	{
		RpcRes<SBean.RoleOneArmBanditInfo> res = syncOneArmBanditInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.onearmbandit_sync_res(res.errCode, res.info));
	}
	
	private RpcRes<SBean.Advers> syncAdversInfoImpl(int id)
    {
        GameConf.AdversConfig cfg = gs.getGameConf().getAdvertisingActivities().getOpendConfigById(id);
        if (cfg == null)
            return new RpcRes<SBean.Advers>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
        return new RpcRes<SBean.Advers>(cfg.getInnerConfig());
    }

    public void syncAdversInfo(int id)
    {
        RpcRes<SBean.Advers> res = syncAdversInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.adver_sync_res(res.errCode, res.info));
    }


    private boolean canPlayOneArmBanditRewards(int levelTimesReq, int payTimesReq, SBean.DBRoleOneArmBanditLog log)
	{
		return log.useTimes < ((this.level >= levelTimesReq ? 1 : 0) + (log.pay >= payTimesReq ? 1 : 0));
	}

	public synchronized int playOneArmBanditReward(int effectiveTime, int id)
	{
		GameConf.OneArmBanditConfig cfg = gs.getGameConf().getOneArmBanditActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.DBRoleOneArmBanditLog log = this.syncOneArmBanditLog(id);
		if (!this.canPlayOneArmBanditRewards(cfg.getLevelTimesReq(), cfg.getPayTimesReq(), log))
			return GameData.PROTOCOL_OP_FAILED;

		int giftCount = cfg.getRandomGift();
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PLAY_ONE_ARM_BANDIT);
		tlogEvent.setArg(id, giftCount);
		this.syncAddDiamond(giftCount, false, tlogEvent);
		log.useTimes += 1;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return giftCount;
	}
	
	void logPayOnOneArmBandit(int pay)
	{
		int now = GameTime.getTime();
		for (GameConf.OneArmBanditConfig cfg : gs.getGameConf().getOneArmBanditActivities().getOpenedConfigs(now))
		{
			if(cfg.isInRoleEffectiveTimeSpan(now, this.createTime))
			{
				SBean.DBRoleOneArmBanditLog log = this.syncOneArmBanditLog(cfg.getId());
				log.pay += pay;
			}
		}
	}

	void logPayRank(int pay)
    {
        int now = GameTime.getTime();
        GameConf.PayRankConfig cfg = gs.getGameConf().getPayRankConfig(now);
        if (cfg != null && cfg.isOpened(now)) {
            SBean.DBRolePayRankLog log = this.payRankLogs.get(cfg.getId());
            if (log != null) {
                log.pay += pay;
            } else {
                log = new SBean.DBRolePayRankLog(cfg.getId(), pay);
            }
            this.payRankLogs.put(cfg.getId(), log);
            gs.getGameConf().updatePayRankLogs(cfg.getId(), new SBean.RankRole(getRoleOverview(), log.pay), cfg);
        }
    }
	
	boolean isCanTakePayGift(GameConf.PayGiftConfig cfg, int now)
	{
		SBean.DBRolePayGiftLog log = this.syncPayGiftLog(cfg.getId());
		return cfg.getInnerConfig().levelGifts.stream().anyMatch(lcfg -> this.canTakePayGiftRewards(lcfg, log));
	}

	SBean.DBRolePayGiftLog syncPayGiftLog(int id)
	{
		SBean.DBRolePayGiftLog log = this.payGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRolePayGiftLog(id, 0, new TreeSet<Integer>());
			this.payGiftLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.RolePayGiftInfo> syncPayGiftInfoImpl(int id)
	{
		GameConf.PayGiftConfig cfg = gs.getGameConf().getPayGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RolePayGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RolePayGiftInfo>(new SBean.RolePayGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncPayGiftLog(id).kdClone()));
	}

	public void syncPayGiftInfo(int id)
	{
		RpcRes<SBean.RolePayGiftInfo> res = syncPayGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.paygift_sync_res(res.errCode, res.info));
	}

	private boolean canTakePayGiftRewards(SBean.PayLevelGift lcfg, SBean.DBRolePayGiftLog log)
	{
		return log.pay >= lcfg.pay && !log.rewards.contains(lcfg.pay);
	}

	public synchronized int takePayGiftReward(int effectiveTime, int id, int payLevel)
	{
		GameConf.PayGiftConfig cfg = gs.getGameConf().getPayGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.PayLevelGift lcfg = cfg.getInnerConfig().levelGifts.stream().filter(e -> e.pay == payLevel).findFirst().orElse(null);
		if (lcfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRolePayGiftLog log = this.syncPayGiftLog(id);
		if (!this.canTakePayGiftRewards(lcfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItems(lcfg.gifts))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_PAY_GIFT_REWARD);
		tlogEvent.setArg(id, payLevel);
		this.syncAddGameItems(GameData.getInstance().toGameItems(lcfg.gifts), tlogEvent);
		log.rewards.add(payLevel);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	void logPayOnPayGift(int pay)
	{
		int now = GameTime.getTime();
		for (GameConf.PayGiftConfig cfg : gs.getGameConf().getPayGiftActivities().getOpenedConfigs(now))
		{
			if(cfg.isInRoleEffectiveTimeSpan(now, this.createTime))
			{
				SBean.DBRolePayGiftLog log = this.syncPayGiftLog(cfg.getId());
				log.pay += pay;
			}
		}
	}

	boolean isCanTakeConsumeGift(GameConf.ConsumeGiftConfig cfg, int now)
	{
		SBean.DBRoleConsumeGiftLog log = this.syncConsumeGiftLog(cfg.getId());
		return cfg.getInnerConfig().levelGifts.stream().anyMatch(lcfg -> this.canTakeConsumeGiftRewards(lcfg, log));
	}

	SBean.DBRoleConsumeGiftLog syncConsumeGiftLog(int id)
	{
		SBean.DBRoleConsumeGiftLog log = this.consumeGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleConsumeGiftLog(id, 0, new TreeSet<Integer>());
			this.consumeGiftLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.RoleConsumeGiftInfo> syncConsumeGiftInfoImpl(int id)
	{
		GameConf.ConsumeGiftConfig cfg = gs.getGameConf().getConsumeGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleConsumeGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleConsumeGiftInfo>(new SBean.RoleConsumeGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncConsumeGiftLog(id)));
	}

	public void syncConsumeGiftInfo(int id)
	{
		RpcRes<SBean.RoleConsumeGiftInfo> res = syncConsumeGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.consumegift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeConsumeGiftRewards(SBean.ConsumeLevelGift lcfg, SBean.DBRoleConsumeGiftLog log)
	{
		return log.consume >= lcfg.consume && !log.rewards.contains(lcfg.consume);
	}

	public synchronized int takeConsumeGiftReward(int effectiveTime, int id, int consumeLevel)
	{
		GameConf.ConsumeGiftConfig cfg = gs.getGameConf().getConsumeGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.ConsumeLevelGift lcfg = cfg.getInnerConfig().levelGifts.stream().filter(e -> e.consume == consumeLevel).findFirst().orElse(null);
		if (lcfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleConsumeGiftLog log = this.syncConsumeGiftLog(id);
		if (!canTakeConsumeGiftRewards(lcfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItems(lcfg.gifts))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_CONSUME_GIFT_REWARD);
		tlogEvent.setArg(effectiveTime, id, consumeLevel);
		this.syncAddGameItems(GameData.getInstance().toGameItems(lcfg.gifts), tlogEvent);
		log.rewards.add(consumeLevel);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	void logConsumeOnConsumeGift(int consume)
	{
		int now = GameTime.getTime();
		for (GameConf.ConsumeGiftConfig cfg : gs.getGameConf().getConsumeGiftActivities().getOpenedConfigs(now))
		{
			if(cfg.isInRoleEffectiveTimeSpan(now, this.createTime))
			{
				SBean.DBRoleConsumeGiftLog log = this.syncConsumeGiftLog(cfg.getId());
				log.consume += consume;
			}
		}
	}

	boolean isCanTakeUpgradeGift(GameConf.UpgradeGiftConfig cfg, int now)
	{
		SBean.DBRoleUpgradeGiftLog log = this.syncUpgradeGiftLog(cfg.getId());
		return cfg.getInnerConfig().levelGifts.stream().anyMatch(lcfg -> this.canTakeUpgradeGiftRewards(lcfg, log));
	}

	SBean.DBRoleUpgradeGiftLog syncUpgradeGiftLog(int id)
	{
		SBean.DBRoleUpgradeGiftLog log = this.upgradeGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleUpgradeGiftLog(id, new TreeSet<Integer>());
			this.upgradeGiftLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.RoleUpgradeGiftInfo> syncUpgradeGiftInfoImpl(int id)
	{
		GameConf.UpgradeGiftConfig cfg = gs.getGameConf().getUpgradeGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleUpgradeGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleUpgradeGiftInfo>(new SBean.RoleUpgradeGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncUpgradeGiftLog(id)));
	}

	public void syncUpgradeGiftInfo(int id)
	{
		RpcRes<SBean.RoleUpgradeGiftInfo> res = syncUpgradeGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.upgradegift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeUpgradeGiftRewards(SBean.UpgradeLevelGift lcfg, SBean.DBRoleUpgradeGiftLog log)
	{
		return this.level >= lcfg.level && !log.rewards.contains(lcfg.level);
	}

	public synchronized int takeUpgradeGiftReward(int effectiveTime, int id, int level)
	{
		GameConf.UpgradeGiftConfig cfg = gs.getGameConf().getUpgradeGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.UpgradeLevelGift lcfg = cfg.getInnerConfig().levelGifts.stream().filter(e -> e.level == level).findFirst().orElse(null);
		if (lcfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleUpgradeGiftLog log = this.syncUpgradeGiftLog(id);
		if (!this.canTakeUpgradeGiftRewards(lcfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		Map<Integer, Integer> rewards = GameData.toCounter(lcfg.gifts);
		if (lcfg.giftEx != null && this.createTime + cfg.getInnerConfig().limitedTime >= GameTime.getTime())
			rewards.merge(lcfg.giftEx.id, lcfg.giftEx.count, (ov, nv) -> ov + nv);
		if (!this.canAddGameItems(rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_UPGRADE_GIFT_REWARD);
		tlogEvent.setArg(id, level);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		log.rewards.add(level);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	boolean isNoInvestmentFundGiftLeft(GameConf.InvestmentFundConfig cfg, int now)
	{
		SBean.DBRoleInvestmentFundLog log = this.syncInvestmentFundLog(cfg.getId());
		SBean.InvestmentFund icfg = cfg.getInnerConfig();
		return now >= icfg.buyEndTime && log.buyTime <= 0;
	}

	boolean isCanTakeInvestmentFundGift(GameConf.InvestmentFundConfig cfg, int now)
	{
		SBean.DBRoleInvestmentFundLog log = this.syncInvestmentFundLog(cfg.getId());
		return log.buyTime > 0 && cfg.getInnerConfig().returns.stream().anyMatch(lcfg -> this.canTakeInvestmentFundGiftRewards(lcfg, log, now));
	}

	SBean.DBRoleInvestmentFundLog syncInvestmentFundLog(int id)
	{
		SBean.DBRoleInvestmentFundLog log = this.investmentFundLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleInvestmentFundLog(id, 0, new TreeSet<Integer>());
			this.investmentFundLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.RoleInvestmentFundInfo> syncInvestmentFundInfoImpl(int id)
	{
		GameConf.InvestmentFundConfig cfg = gs.getGameConf().getInvestmentFundActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleInvestmentFundInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleInvestmentFundInfo>(new SBean.RoleInvestmentFundInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncInvestmentFundLog(id)));
	}

	public void syncInvestmentFundInfo(int id)
	{
		RpcRes<SBean.RoleInvestmentFundInfo> res = syncInvestmentFundInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.investmentfund_sync_res(res.errCode, res.info));
	}

	public synchronized int buyInvestmentFund(int effectiveTime, int id)
	{
		GameConf.InvestmentFundConfig cfg = gs.getGameConf().getInvestmentFundActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		int now = GameTime.getTime();
		if (now >= cfg.getInnerConfig().buyEndTime)
			return GameData.PROTOCOL_OP_FAILED;
		if (Role.this.level < cfg.getInnerConfig().levelNeed || Role.this.getUseableVipLvl() < cfg.getInnerConfig().vipLevelNeed)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleInvestmentFundLog log = this.syncInvestmentFundLog(id);
		if (log.buyTime > 0)
			return GameData.PROTOCOL_OP_FAILED;
		int price = cfg.getInnerConfig().price;
		if (!this.canUseDiamond(price, true))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_INVESTMENT_FUND);
		tlogEvent.setArg(effectiveTime, id, price);
		this.useDiamond(price, true, tlogEvent.getGameItemRecords());
		log.buyTime = now;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private boolean canTakeInvestmentFundGiftRewards(SBean.FundDayReturn lcfg, SBean.DBRoleInvestmentFundLog log, int now)
	{
		return log.buyTime > 0 && now > GameTime.getTimeH0(log.buyTime) + lcfg.daySeq * GameTime.getDayTimeSpan() && !log.rewards.contains(lcfg.daySeq);
	}

	public synchronized int takeInvestmentFundReward(int effectiveTime, int id, int day)
	{
		GameConf.InvestmentFundConfig cfg = gs.getGameConf().getInvestmentFundActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		if (Role.this.level < cfg.getInnerConfig().levelNeed || Role.this.getUseableVipLvl() < cfg.getInnerConfig().vipLevelNeed)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.FundDayReturn lcfg = cfg.getInnerConfig().returns.stream().filter(e -> e.daySeq == day).findFirst().orElse(null);
		if (lcfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleInvestmentFundLog log = this.syncInvestmentFundLog(id);
		if (!this.canTakeInvestmentFundGiftRewards(lcfg, log, GameTime.getTime()))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItem(lcfg.fundReturn.id, lcfg.fundReturn.count))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_INVESTMENT_FUND_REWARD);
		tlogEvent.setArg(id, day);
		this.syncAddGameItem(GameData.getInstance().toGameItem(lcfg.fundReturn.id, lcfg.fundReturn.count), tlogEvent);
		log.rewards.add(day);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	boolean isNoGrowthFundGiftLeft(GameConf.GrowthFundConfig cfg, int now)
	{
		SBean.DBRoleGrowthFundLog log = this.syncGrowthFundLog(cfg.getId());
		SBean.GrowthFund icfg = cfg.getInnerConfig();
		return now >= icfg.buyEndTime && log.buyCount <= 0;
	}

	boolean isCanTakeGrowthFundGift(GameConf.GrowthFundConfig cfg, int now)
	{
		SBean.DBRoleGrowthFundLog log = this.syncGrowthFundLog(cfg.getId());
		return log.buyCount > 0 && cfg.getInnerConfig().returns.stream().anyMatch(lcfg -> this.canTakeGrowthFundGiftRewards(lcfg, log));
	}

	SBean.DBRoleGrowthFundLog syncGrowthFundLog(int id)
	{
		SBean.DBRoleGrowthFundLog log = this.growthFundLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleGrowthFundLog(id, 0, new TreeSet<Integer>());
			this.growthFundLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.RoleGrowthFundInfo> syncGrowthFundInfoImpl(int id)
	{
		GameConf.GrowthFundConfig cfg = gs.getGameConf().getGrowthFundActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleGrowthFundInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleGrowthFundInfo>(new SBean.RoleGrowthFundInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncGrowthFundLog(id)));
	}

	public void syncGrowthFundInfo(int id)
	{
		RpcRes<SBean.RoleGrowthFundInfo> res = syncGrowthFundInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.growthfund_sync_res(res.errCode, res.info));
	}

	public synchronized int buyGrowthFund(int effectiveTime, int id)
	{
		GameConf.GrowthFundConfig cfg = gs.getGameConf().getGrowthFundActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		if (GameTime.getTime() >= cfg.getInnerConfig().buyEndTime)
			return GameData.PROTOCOL_OP_FAILED;
		if (Role.this.level < cfg.getInnerConfig().levelNeed || Role.this.getUseableVipLvl() < cfg.getInnerConfig().vipLevelNeed)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleGrowthFundLog log = this.syncGrowthFundLog(id);
		if (log.buyCount > 0)
			return GameData.PROTOCOL_OP_FAILED;
		int price = cfg.getInnerConfig().price;
		if (!this.canUseDiamond(price, true))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_GROWTH_FUND);
		tlogEvent.setArg(id, price);
		this.useDiamond(price, true, tlogEvent.getGameItemRecords());
		log.buyCount = 1;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private boolean canTakeGrowthFundGiftRewards(SBean.FundLevelReturn lcfg, SBean.DBRoleGrowthFundLog log)
	{
		return log.buyCount > 0 && !log.rewards.contains(lcfg.levelReq) && this.level >= lcfg.levelReq;
	}

	public synchronized int takeGrowthFundReward(int effectiveTime, int id, int level)
	{
		GameConf.GrowthFundConfig cfg = gs.getGameConf().getGrowthFundActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		if (Role.this.level < cfg.getInnerConfig().levelNeed || Role.this.getUseableVipLvl() < cfg.getInnerConfig().vipLevelNeed)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.FundLevelReturn lcfg = cfg.getInnerConfig().returns.stream().filter(e -> e.levelReq == level).findFirst().orElse(null);
		if (lcfg == null || this.level < lcfg.levelReq)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleGrowthFundLog log = this.syncGrowthFundLog(id);
		if (!this.canTakeGrowthFundGiftRewards(lcfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItem(lcfg.fundReturn.id, lcfg.fundReturn.count))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_GROWTH_FUND_REWARD);
		tlogEvent.setArg(id, level);
		this.syncAddGameItem(GameData.getInstance().toGameItem(lcfg.fundReturn.id, lcfg.fundReturn.count), tlogEvent);
		log.rewards.add(level);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	synchronized RpcRes<SBean.DoubleDropInfo> syncDoubleDropInfoImpl(int id)
	{
		GameConf.DoubleDropConfig cfg = gs.getGameConf().getDoubleDropActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.DoubleDropInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.DoubleDropInfo>(new SBean.DoubleDropInfo(cfg.getTimeSpan(), cfg.getTitle(), cfg.getContent()));
	}

	public void syncDoubleDropInfo(int id)
	{
		RpcRes<SBean.DoubleDropInfo> res = syncDoubleDropInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.doubledrop_sync_res(res.errCode, res.info));
	}

	synchronized RpcRes<SBean.ExtraDropInfo> syncExtraDropInfoImpl(int id)
	{
		GameConf.ExtraDropConfig cfg = gs.getGameConf().getExtraDropActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.ExtraDropInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.ExtraDropInfo>(new SBean.ExtraDropInfo(cfg.getTimeSpan(), cfg.getTitle(), cfg.getContent(), cfg.getPossibleDropItems()));
	}

	public void syncExtraDropInfo(int id)
	{
		RpcRes<SBean.ExtraDropInfo> res = syncExtraDropInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.extradrop_sync_res(res.errCode, res.info));
	}

	boolean isCanTakeExchangeGift(GameConf.ExchangeGiftConfig cfg, int now)
	{
		SBean.DBRoleExchangeGiftLog log = this.syncExchangeGiftLog(cfg.getId());
		return cfg.getInnerConfig().itemGifts.stream().anyMatch(lcfg -> this.canTakeExchangeGiftRewards(lcfg, log));
	}

	SBean.DBRoleExchangeGiftLog syncExchangeGiftLog(int id)
	{
		SBean.DBRoleExchangeGiftLog log = this.exchangeGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleExchangeGiftLog(id, new TreeMap<Integer, Integer>());
			this.exchangeGiftLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.ExchangeGiftInfo> syncExchangeGiftInfoImpl(int id)
	{
		GameConf.ExchangeGiftConfig cfg = gs.getGameConf().getExchangeGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.ExchangeGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.ExchangeGiftInfo>(new SBean.ExchangeGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncExchangeGiftLog(id)));
	}

	public void syncExchangeGiftInfo(int id)
	{
		RpcRes<SBean.ExchangeGiftInfo> res = syncExchangeGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.exchangegift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeExchangeGiftRewards(SBean.ExchangeItemGift lcfg, SBean.DBRoleExchangeGiftLog log)
	{
		return (lcfg.maxExchange <= 0 || log.exchangeCount.getOrDefault(lcfg.seq, 0) < lcfg.maxExchange) && this.containsEnoughGameItems(lcfg.items);
	}

	public synchronized int takeExchangeGiftReward(int effectiveTime, int id, int seq)
	{
		GameConf.ExchangeGiftConfig cfg = gs.getGameConf().getExchangeGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.ExchangeItemGift lcfg = cfg.getInnerConfig().itemGifts.stream().filter(e -> e.seq == seq).findFirst().orElse(null);
		if (lcfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleExchangeGiftLog log = this.syncExchangeGiftLog(id);
		if (!this.canTakeExchangeGiftRewards(lcfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItem(lcfg.gift.id, lcfg.gift.count))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_EXCHANGE_GIFT_REWARD);
		tlogEvent.setArg(effectiveTime, id, seq);
		this.delGameItems(lcfg.items, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(lcfg.gift.id, lcfg.gift.count), tlogEvent);
		log.exchangeCount.merge(seq, 1, (ov, nv) -> ov + nv);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	boolean isNoLoginGiftLeft(GameConf.LoginGiftConfig cfg, int now)
	{
		SBean.DBRoleLoginGiftLog log = this.syncLoginGiftLog(cfg.getId());
		SBean.LoginGift icfg = cfg.getInnerConfig();
		return icfg.dayGifts.stream().allMatch(daygift -> log.rewards.contains(daygift.dayReq));
	}

	boolean isCanTakeLoginGift(GameConf.LoginGiftConfig cfg, int now)
	{
		SBean.DBRoleLoginGiftLog log = this.syncLoginGiftLog(cfg.getId());
		return cfg.getInnerConfig().dayGifts.stream().anyMatch(lcfg -> this.canTakeLoginGiftRewards(lcfg, log));
	}

	SBean.DBRoleLoginGiftLog syncLoginGiftLog(int id)
	{
		SBean.DBRoleLoginGiftLog log = this.loginGiftLogs.get(id);
		if (log == null)
		{
			log = new SBean.DBRoleLoginGiftLog(id, 0, 0, new TreeSet<Integer>());
			this.loginGiftLogs.put(id, log);
		}
		return log;
	}

	synchronized RpcRes<SBean.RoleLoginGiftInfo> syncLoginGiftInfoImpl(int id)
	{
		GameConf.LoginGiftConfig cfg = gs.getGameConf().getLoginGiftActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.RoleLoginGiftInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.RoleLoginGiftInfo>(new SBean.RoleLoginGiftInfo(cfg.getEffectiveTime(), cfg.toRoleCfg(this), this.syncLoginGiftLog(id)));
	}

	public void syncLoginGiftInfo(int id)
	{
		RpcRes<SBean.RoleLoginGiftInfo> res = syncLoginGiftInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.logingift_sync_res(res.errCode, res.info));
	}

	private boolean canTakeLoginGiftRewards(SBean.LoginDayGift lcfg, SBean.DBRoleLoginGiftLog log)
	{
		return log.loginDays >= lcfg.dayReq && !log.rewards.contains(lcfg.dayReq);
	}

	public synchronized int takeLoginGiftReward(int effectiveTime, int id, int loginDay)
	{
		GameConf.LoginGiftConfig cfg = gs.getGameConf().getLoginGiftActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
			return GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED;
		SBean.LoginDayGift lcfg = cfg.getInnerConfig().dayGifts.stream().filter(e -> e.dayReq == loginDay).findFirst().orElse(null);
		if (lcfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBRoleLoginGiftLog log = this.syncLoginGiftLog(id);
		if (!this.canTakeLoginGiftRewards(lcfg, log))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItems(lcfg.gifts))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_LOGIN_GIFT_REWARD);
		tlogEvent.setArg(id, loginDay);
		this.syncAddGameItems(GameData.getInstance().toGameItems(lcfg.gifts), tlogEvent);
		log.rewards.add(loginDay);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	void logLoginOnLoginGift(int now)
	{
		for (GameConf.LoginGiftConfig cfg : gs.getGameConf().getLoginGiftActivities().getOpenedConfigs(now))
		{
			SBean.DBRoleLoginGiftLog log = this.syncLoginGiftLog(cfg.getId());
			int nowDay = GameData.getDayByRefreshTimeOffset(now);
			int lastLoginDay = GameData.getDayByRefreshTimeOffset(log.lastLoginTime);
			if (cfg.isInRoleEffectiveTimeSpan(now, this.createTime) && nowDay > lastLoginDay)
			{
				log.loginDays++;
				log.lastLoginTime = now;
			}
		}
	}
	
	
	synchronized RpcRes<SBean.GiftPackageInfo> syncGiftPackageInfoImpl(int id)
	{
		GameConf.GiftPackageConfig cfg = gs.getGameConf().getGiftPackageActivities().getOpendConfigById(id);
		if (cfg == null)
			return new RpcRes<SBean.GiftPackageInfo>(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED);
		return new RpcRes<SBean.GiftPackageInfo>(new SBean.GiftPackageInfo(cfg.getEffectiveTime(), cfg.getTimeSpan(), cfg.getTitle(), cfg.getContent()));
	}

	public void syncGiftPackageInfo(int id)
	{
		RpcRes<SBean.GiftPackageInfo> res = syncGiftPackageInfoImpl(id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.giftpackage_sync_res(res.errCode, res.info));
	}

	public void takeGiftPackageReward(int effectiveTime, int id, String cdkey)
	{
		if (cdkey.length() == KeyGen.getCodeLength())
		{
			takeGiftPackageRewardImpl(effectiveTime, id, cdkey.toLowerCase(), (errCode, pack)->
			{	
				gs.getLogger().info("take gift package reward : effectiveTime = " + effectiveTime + ", id = " + id + ", CDKey = " + cdkey + " res = " + errCode);
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.giftpackage_take_res(errCode, pack));
			});
		}
		else if (cdkey.length() < KeyGen.getCodeLength())
		{
			takeSpecialGiftPacketRewardImpl(effectiveTime, id, cdkey.toLowerCase(), (errCode, pack)->
			{	
				gs.getLogger().info("take gift package reward : effectiveTime = " + effectiveTime + ", id = " + id + ", CDKey = " + cdkey + " res = " + errCode);
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.giftpackage_take_res(errCode, pack));
			});
		}
		else
		{
			takeCDKeyRewardImpl(cdkey.toLowerCase(), (errCode, pack) ->
			{
				gs.getLogger().info("take gift package reward : effectiveTime = " + effectiveTime + ", id = " + id + ", CDKey = " + cdkey + " res = " + errCode);
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.giftpackage_take_res(errCode, pack));
			});
		}
	}
		

	interface TakeGiftPackageRewardCallback
	{
		void onCallback(int errCode, SBean.Pack pack);
	}

	public synchronized void takeGiftPackageRewardImpl(int effectiveTime, int id, String cdkey, TakeGiftPackageRewardCallback callback)
	{
		GameConf.GiftPackageConfig cfg = gs.getGameConf().getGiftPackageActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED, null);
			return;
		}
		KeyGen.CDKeyIDInfo keyInfo = gs.getLoginManager().getCDKeyGen().getCodeIDInfo(cdkey);
		if (keyInfo.batchID < 0 || keyInfo.genID < 0)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CDKEY_INVALID, null);
			return;
		}
		SBean.GiftPack giftPack = cfg.getGiftPack(keyInfo.batchID, keyInfo.genID);
		if (giftPack == null)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CDKEY_NOT_UNLOCK, null);
			return;
		}
		if (!GameConf.GameConfig.isOpened(giftPack.time, GameTime.getTime()))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CDKEY_NOT_GO_INTO_EFFECT, null);
			return;
		}
		if (!giftPack.channel.isEmpty() && !giftPack.channel.contains(this.getChannel()))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CHANNEL_NOT_MATCH, null);
			return;
		}
		if (this.level < giftPack.levelNeed || this.getUseableVipLvl() < giftPack.vipLevelNeed)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_ROLE_LEVEL_NEED, null);
			return;
		}
		if (!this.canAddGameItems(giftPack.pack.gifts))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_BAG_NOT_ENOUGH_CELLS, null);
			return;
		}
		gs.getGameWebService().doUseCDKey(cdkey, keyInfo.batchID, keyInfo.genID, giftPack.maxUse, gs.getConfig().id, this.id, this.name, this.getChannel(), this.getUid(), new GameWebService.UseCDKeyCallback()
		{
			@Override
			public void onCallback(int result)
			{
				if (result < 0)
				{
					callback.onCallback(result, null);
					return;
				}
				TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_GIFT_PACKAGE_REWARD);
				tlogEvent.setArg(effectiveTime, id);
				tlogEvent.setArg(cdkey);
				synchronized (Role.this)
				{
					Role.this.syncAddGameItems(GameData.getInstance().toGameItems(giftPack.pack.gifts), tlogEvent);
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
				}
				callback.onCallback(GameData.PROTOCOL_OP_SUCCESS, giftPack.pack);
			}
		});
	}
	
	public synchronized void takeSpecialGiftPacketRewardImpl(int effectiveTime, int id, String shortcode, TakeGiftPackageRewardCallback callback)
	{
		GameConf.GiftPackageConfig cfg = gs.getGameConf().getGiftPackageActivities().getOpendConfigById(id);
		if (cfg == null || cfg.getEffectiveTime() != effectiveTime)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_CONFIG_CHANGED, null);
			return;
		}
		SBean.GiftPack giftPack = cfg.getShortGiftPack(shortcode);
		if (giftPack == null)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CDKEY_NOT_UNLOCK, null);
			return;
		}
		if (!GameConf.GameConfig.isOpened(giftPack.time, GameTime.getTime()))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CDKEY_NOT_GO_INTO_EFFECT, null);
			return;
		}
		if (!giftPack.channel.isEmpty() && !giftPack.channel.contains(this.getChannel()))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CHANNEL_NOT_MATCH, null);
			return;
		}
		if (this.level < giftPack.levelNeed || this.getUseableVipLvl() < giftPack.vipLevelNeed)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_ROLE_LEVEL_NEED, null);
			return;
		}
		if (!this.canAddGameItems(giftPack.pack.gifts))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_BAG_NOT_ENOUGH_CELLS, null);
			return;
		}
		SBean.DBRoleGiftPackageLog log = this.giftPackageLogs.get(id);
		if (log != null)
		{
			if (log.logs.contains(shortcode))
			{
				callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_SELF_ALREADY_USED, null);
				return;	
			}
		}
		else
		{
			log = new SBean.DBRoleGiftPackageLog(id, new HashSet<>());
		}
		if (!gs.getGameConf().getGiftPackageActivities().tryUseSpecialPack(id, shortcode, giftPack.maxUse))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_SHORT_CODE_GIFT_NOT_LEFT, null);
			return;
		}
		log.logs.add(shortcode);
		this.giftPackageLogs.put(log.id, log);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_GIFT_PACKAGE_REWARD);
		tlogEvent.setArg(effectiveTime, id);
		tlogEvent.setArg(shortcode);
		this.syncAddGameItems(GameData.getInstance().toGameItems(giftPack.pack.gifts), tlogEvent);
		gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
		callback.onCallback(GameData.PROTOCOL_OP_SUCCESS, giftPack.pack);
	}
	
    public synchronized void takeCDKeyRewardImpl(String cdkey, TakeGiftPackageRewardCallback callback)
	{
		final int bid = getCDKeyBatchIdFromCdkey(cdkey);
		if (bid <= 0)
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CDKEY_INVALID, null);
			return;
		}
		String code = cdkey.substring(Integer.toString(bid).length());
		if (code.length() == KeyGen.getCodeLength() && !gs.getLoginManager().getCDKeyGen().testCodeValid(code))
		{
			callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_PACKAGE_CDKEY_INVALID, null);
			return;
		}
		
		gs.getGameWebService().doQueryCDKey(bid, code, gs.getConfig().id, this.id, this.getChannel(), this.getGameId(), this.level, this.share.getVipLevel(), new GameWebService.QueryCDKeyCallback()
		{
			@Override
			public void onCallback(String result)
			{
				try
				{
					RpcRes<SBean.Pack> res = parseQueryCDKeyResult(result);
					if (res.errCode < 0)
					{
						callback.onCallback(res.errCode, null);
						return;
					}
					synchronized (Role.this)
					{
						if (!Role.this.canAddGameItems(res.info.gifts))
						{
							callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_CDKEY_BAG_NOT_ENOUGH_CELLS, null);
							return;
						}				
					}
					gs.getGameWebService().doExchangeCDKey(bid, code, gs.getConfig().id, Role.this.id, Role.this.name, Role.this.getChannel(),
					        Role.this.getUid(), Role.this.getGameId(), Role.this.level, Role.this.share.getVipLevel(), Role.this.totalPayPoint,
					        new GameWebService.ExchangeCDKeyCallback()
					{
						@Override
						public void onCallback(int result)
						{
							if (result < 0)
							{
								callback.onCallback(result, null);
								return;
							}
							TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_GIFT_CDKEY_REWARD);
							tlogEvent.setArg(bid);
							tlogEvent.setArg(cdkey);
							synchronized (Role.this)
							{
								Role.this.syncAddGameItems(GameData.getInstance().toGameItems(res.info.gifts), tlogEvent);
								gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
							}
							callback.onCallback(GameData.PROTOCOL_OP_SUCCESS, res.info);
						}
					});
				}
				catch (Exception e)
				{
					gs.getLogger().warn("role " + Role.this.id + " query cdkey bid=" + bid + " cdkey=" + cdkey + " result=" + result + ", but parse failed for " + e.getMessage());
					callback.onCallback(GameData.PROTOCOL_OP_CONF_GIFT_CDKEY_QUERY_RESULT_INVALID, null);
					return;
				}				
			}
		});
	}
	
	private int getCDKeyBatchIdFromCdkey(String cdkey)
	{
		final int UNIVERSAL_CODE_LENGTH = 8;
		if (cdkey.length() == KeyGen.getCodeLength() || cdkey.length() <= UNIVERSAL_CODE_LENGTH)
			return -1;
		try
		{
			int bid = Integer.parseInt(cdkey.substring(0, cdkey.length() > KeyGen.getCodeLength() ? (cdkey.length() - KeyGen.getCodeLength()) : (cdkey.length() - UNIVERSAL_CODE_LENGTH)));
			return bid;
		}
		catch (Exception e)
		{
		}
		return -1;
	}
	
	private RpcRes<SBean.Pack> parseQueryCDKeyResult(String result) throws Exception
	{
		String[] strs = result.split("\\|", -1);
		int retCode = Integer.parseInt(strs[0]);
		if (retCode < 0)
			return new RpcRes<SBean.Pack>(retCode);
		if (strs.length != 3)
			throw new Exception("query cdkey result (" + result + ") format is valid!");
		List<SBean.DummyGoods> items = parseExchangeCDKeyReward(strs[1]);
		return new RpcRes<SBean.Pack>(retCode, new SBean.Pack(strs[2], "", items));
	}
	
	private List<SBean.DummyGoods> parseExchangeCDKeyReward(String itemsdesc) throws Exception
	{
		List<SBean.DummyGoods> items = new ArrayList<>();
		String[] itemstrs = itemsdesc.split(";"); 
		for (int i = 0; i < itemstrs.length; ++i)
		{
			String[] itemcountstr = itemstrs[i].split("_");
			if (itemcountstr.length != 2)
				throw new Exception("parse itemstr (" + itemstrs[i] + ") format is valid!");
			int iid = Integer.parseInt(itemcountstr[0]);
			int icount = Integer.parseInt(itemcountstr[1]);
			if (!GameData.getInstance().checkEntityIdValid(iid))
				throw new Exception("cdkey reward item id " + iid + " is invalid !");
			if (icount <= 0)
				throw new Exception("cdkey reward item id " + iid + " count " + icount + " is invalid !");
			items.add(new SBean.DummyGoods(iid, icount));
		}
		return items;
	}
	
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    public void syncPBTCashbackInfo(int bid)
    {
        if (share.cashbacked==0 && share.cashback>0)
        {
	        gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_sync_res(GameData.PROTOCOL_OP_SUCCESS, share.cashback));
	        return;
        }
        
	    gs.getGameWebService().doQueryCashBack(bid, gs.getConfig().id, getChannel(), getUid(), id, name, (result)->
	    {
	        if (result>0)
	        {
	            this.share.cashback = result;
	        }
	        gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_sync_res(GameData.PROTOCOL_OP_SUCCESS, result));
	    });
    }

    public void takePBTCashbackReward(int bid)
    {
	    gs.getGameWebService().doExchangeCashBack(bid, gs.getConfig().id, getChannel(), getUid(), id, name, (result)->
	    {
	        gs.getLogger().debug("takePBTCashbackReward result " + result);
	        if (result < 0)
	        {
	            if (Role.this.share.cashbacked!=0)
	            {
	                gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_take_res(result, 0));
	                return;
	            }
	            
	            if (result==-1002)     // -1002为检查到本服务器已经有使用记录
	            {
	                result = Role.this.share.cashback;  // 重试领取奖励, 必须玩家实际公测充值过才给奖励
	                if (result < 0)
	                {
		                gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_take_res(result, 0));
		                return;
	                }
	            }
	            else
	            {
		            gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_take_res(result, 0));
		            return;
	            }
	        }
	        
	        if (result > 0)
	        {
			    int vipLevel = GameData.getInstance().getVipLevel(result);
			    SBean.VipCFGS vipCfg = GameData.getInstance().getVipCFGS(vipLevel);
			    if (vipCfg==null)
			    {
			        gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_take_res(result, 0));
			    }
				    
				synchronized (Role.this)
				{
					if (!Role.this.canAddGameItems(vipCfg.PBTCashBackRewards))
					{
					    gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_take_res(GameData.PROTOCOL_OP_CONF_PBT_BAG_FULL, 0));
						return;
					}				
					
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_PBTCASHBACK);
					tlogEvent.setArg(bid, result);
					Role.this.share.cashbacked = 1;    // 记录已经发放了返现奖励
					
					List<SBean.DummyGoods> rewards = new ArrayList<>(vipCfg.PBTCashBackRewards);
					if (result > 0)
					{
					    rewards.add(new SBean.DummyGoods(-GameData.COMMON_ITEM_ID_DIAMOND, result*2));
					    Role.this.addPresentVipPointAndSyncVipInfo(result);
					}
				
					Role.this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
					
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pbtcashback_take_res(GameData.PROTOCOL_OP_SUCCESS, result));
					gs.getTLogger().logPBTCashBackTakeFlow(this, bid, result, 0, 0);
				}
	        }
	    });
        
    }

	synchronized private void addPresentVipPointAndSyncVipInfo(int vipPoint)
    {
	    int oldVipLevel = share.getVipLevel();
        this.share.addVipPresentPoint(vipPoint);
        int newVipLevel = share.getVipLevel();
        this.SyncVipInfo(newVipLevel, share.getVipPoints());
        trigerVipTitleReward(oldVipLevel, newVipLevel);
    }
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private List<SBean.DBSpecialCardData> initSpecialCards(List<SBean.DBSpecialCardData> cards)
	{
		int vipCardCount = GameData.getInstance().getSpecialCardCount();
		for(int i = cards.size(); i < vipCardCount; i++)
			cards.add(new SBean.DBSpecialCardData(0, (byte)0));
		
		return cards;
	}
	
	public int getUseableVipLvl()
	{
		int now = GameTime.getTime();
		if (this.tempVIP.vipEndtime > now && this.tempVIP.vipLvl > share.getVipLevel())
			return this.tempVIP.vipLvl;
		else
			return share.getVipLevel();
	}

	public boolean addSpecialCard(int seconds, int cardType)
	{
		return setSpecialCardImpl(seconds, cardType);
	}

	public void setSpecialCard(int cardType)
	{
		SBean.SpecialCardCFGS vipCardCfg = GameData.getInstance().getSpecialCardCFGS(cardType);
		if(vipCardCfg == null)
			gs.getLogger().warn("on add pay set vip card " + cardType + " not found in cfgs");
		else
			setSpecialCardImpl(vipCardCfg.lastTime, cardType);
	}
	
	public boolean setSpecialCardImpl(int seconds, int cardType)
	{
		boolean addUp = false;		//时间累加
		SBean.DBSpecialCardData cardData = getSpecialCardData(cardType);
		if(cardData == null)
		{
			gs.getLogger().warn("set special card " + cardType + " not found in role data");
		}
		else
		{
			int now = GameTime.getTime();
			if (cardData.cardEndTime < now)
			{
				cardData.cardEndTime = GameTime.getTimeH0(now) + seconds;
				tryUpdateSpecialCard(now);
			}
			else
			{
				cardData.cardEndTime += seconds;
				addUp = true;
			}
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_specialcards(Stream.clone(this.specialCards)));
		}
		
		return addUp;
	}
	
	private SBean.DBSpecialCardData getSpecialCardData(int cardType)
	{
		if(cardType <= 0 || cardType > this.specialCards.size())
			return null;
		
		return this.specialCards.get(cardType - 1);
	}
	
	public void SyncVipInfo(int vipLvl, int totalPoints)
	{
		this.syncMapRoleVipLevel();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.user_vip_sync(vipLvl, totalPoints));
	}
	
	SBean.DirectPayInfo syncDirectPayInfo()
	{
		SBean.PayCFGS cfg = GameData.getInstance().getChannelPayCFG();
		if (cfg == null)
			return null;
		Map<Integer, SBean.PayLevelInfo> info = GameData.getPayLevelsInfoByType(cfg, GameData.GAME_PAY_GOODS_TYPE_GIFT);
		Map<Integer, Integer> leftRewardTimes = info.keySet().stream().collect(Collectors.toMap(lvl->lvl, lvl->getDirectPurchaseLeftRewardTimes(lvl)));
		return new SBean.DirectPayInfo(cfg.id, info, leftRewardTimes);
	}

	public synchronized SBean.PayInfo syncPayInfo()
	{
		//SBean.PayCFGS cfg = GameData.getInstance().getChannelPayCFG(this.getGameId(), this.getChannel());
		SBean.PayCFGS cfg = GameData.getInstance().getChannelPayCFG();
		if (cfg == null)
			return null;
		return this.share.getPayInfo(cfg.id, new ArrayList<>(GameData.getPayLevelsInfoByType(cfg, GameData.GAME_PAY_GOODS_TYPE_DIAMOND).values()), new HashSet<>(this.vipRewards));
	}

	public int tryPayAsGod(int payLevel)
	{
		if (gs.getConfig().godMode > 0)
			return this.godPay(payLevel) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		else
			return GameData.PROTOCOL_OP_PAY_SERVER_NOT_GOD_MOD;
	}

	public synchronized boolean godPay(int payLevel)
	{
//		SBean.PayCFGS cfg = GameData.getInstance().getChannelPayCFG(this.getGameId(), this.getChannel());
//		if (cfg == null)
//			return false;
		SBean.PayLevelCFGS payLvlcfg = GameData.getInstance().getPayLevelCFGS(payLevel);
		if (payLvlcfg == null)
			return false;
		return this.share.tryAddPay(this, GameData.GAME_GOD_PAY_ORDER_ID, payLvlcfg, null, true);
	}

	//role锁包在shareRole锁外面
	public synchronized boolean userPay(String orderId, int payLevel, String goodsId, Role sameUserRole)
	{
//		SBean.PayCFGS cfg = GameData.getInstance().getChannelPayCFG(this.getGameId(), this.getChannel());
//		if (cfg == null)
//			return false;
		SBean.PayLevelCFGS payLvlcfg = GameData.getInstance().getPayLevelCFGS(payLevel);
		if (payLvlcfg == null)
			return false;
		if (!goodsId.equals(payLvlcfg.id))
			return false;
		return this.share.tryAddPay(this, orderId, payLvlcfg, sameUserRole, false);
	}
	
	void trigerVipTitleReward(int fromVip, int toVip)
	{
		for (int i = fromVip + 1; i <= toVip; i++)
		{
			SBean.VipCFGS cfg = GameData.getInstance().getVipCFGS(i);
			if (cfg == null)
				continue;
			if (cfg.title > 0)
				this.addRoleTitle(cfg.title);
		}
	}

	void onAddPay(String orderId, int payLevel, int payLvlTimes, int payMoney, int payPoints, int payType, int payParam, int userPoints, int addDiamond, int addCredit, int beforeVip, int finalVip)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PAY);
		tlogEvent.setArg(payLevel);
		tlogEvent.setArg(orderId);
		this.syncAddDiamond(addDiamond, true, tlogEvent);
		this.syncAddCredit(addCredit, tlogEvent);
		trigerVipTitleReward(beforeVip, finalVip);
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_pay_notice(payLevel, userPoints, addDiamond, addCredit));
		if (payType == GameData.GAME_PAY_GOODS_TYPE_CARD)
			setSpecialCard(payParam);
		if (payPoints > 0)
		{
			this.logPayOnFirstPayGift(payPoints);
			this.logPayOnDailyPayGift(payPoints);
			this.logPayOnLastPayGift(payPoints);
			this.logPayOnPayGift(payPoints);
			this.logPayOnOneArmBandit(payPoints);
			this.logPayRank(payPoints);
			this.totalPayPoint += payPoints;
		}
		this.payLevelTimes.merge(payLevel, 1, (ov, nv)-> ov + nv);
		gs.getLoginManager().getSnatchRedEnvelopeActivity().testSendPayRedEnvelope(this.id, this.name, payPoints);
		gs.getTLogger().logRolePay(this, beforeVip, finalVip, payPoints, userPoints, this.totalPayPoint, payLevel, payLvlTimes, payMoney, addDiamond, orderId, tlogEvent);
		gs.getLogger().info("@@@ user finish add pay ok:[" + this.getUsername() +"(" + this.id + ")], orderid=["+ orderId + "], paylevel=" + payLevel + ", rmb="+payMoney+", stone="+addDiamond);
	}

	synchronized boolean takeVipRewards(int level)
	{
		SBean.VipCFGS cfg = GameData.getInstance().getVipCFGS(level);
		if (cfg == null)
			return false;
		if (this.share.getVipLevel() < level)
			return false;
		if (!this.vipRewards.add(level))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_VIP_REWARD);
		tlogEvent.setArg(level);
		this.useDiamond(cfg.vipRewardPrice, true, tlogEvent.getGameItemRecords());
		this.syncAddGameItems(GameData.getInstance().toGameItems(cfg.rewards), tlogEvent);
		
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public int sendMsg(int type, int targetid, String msg, String serverName)
	{
		if (msg.startsWith("@#"))
			return processGMCommand(msg.substring(2)) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		int now = GameTime.getTime();
		if (ban.isBanChat(now))
		{
			BanInfo banInfo = ban.getBanChatInfo(now);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_chat_banned(banInfo.leftTime, banInfo.reason));
			return GameData.PROTOCOL_OP_CHAT_BE_BAN;
		}
		return sendMsgImpl(type, targetid, createRoleNormalMessage(msg), serverName);
	}

	private int sendMsgImpl(int type, int targetid, SBean.MessageContent content, String serverName)
	{
		if (content == null)
			return GameData.PROTOCOL_OP_CHAT_INPUT_INVALID;
		int now = GameTime.getTime();
		if (type == SBean.MessageInfo.MTypeWorld)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_CHAT_ITEM);
			if (content.type == SBean.MessageContent.MsgTypeNormal)
			{
				int chatItem = GameData.getInstance().getCommonCFG().chat.worldChatItem;
				synchronized (this)
				{
					if (!this.containsEnoughGameItem(chatItem, 1))
						return GameData.PROTOCOL_OP_CHAT_ITEM_NEED;
					this.delGameItem(chatItem, 1, tlogEvent.getGameItemRecords());
				}
			}
			else if (content.type == SBean.MessageContent.MsgTypeMRoomInvite)
			{
				synchronized (this)
				{
					if (this.lastMRoomInviteChatTime + GameData.getInstance().getCommonCFG().chat.mRoomInviteChatInterval >= now)
						return GameData.PROTOCOL_OP_CHAT_IN_CD;
					this.lastMRoomInviteChatTime = now;
				}
			}
			else if (content.type == SBean.MessageContent.MsgTypeSectInvite)
			{
				synchronized (this)
				{
					if (this.lastSectInviteChatTime + GameData.getInstance().getCommonCFG().chat.sectInviteChatInterval >= now)
						return GameData.PROTOCOL_OP_CHAT_IN_CD;
					this.lastSectInviteChatTime = now;
				}
			}
			gs.getLoginManager().receiveWorldMsg(new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content));

			gs.getTLogger().logRoleChatFlow(this, targetid, TLog.CHAT_TYPE_WORLD, content.msg);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (type == SBean.MessageInfo.MTypeSect)
		{
			synchronized (this)
			{
				if (this.lastSectChatTime + GameData.getInstance().getCommonCFG().chat.publicChatInterval >= now)
					return GameData.PROTOCOL_OP_CHAT_IN_CD;
				this.lastSectChatTime = now;
			}
			gs.getTLogger().logRoleChatFlow(this, targetid, TLog.CHAT_TYPE_SECT, content.msg);
			return gs.getSectManager().roleSendSectMsg(this, new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content)) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		else if (type == SBean.MessageInfo.MTypeTeam)
		{
			synchronized (this)
			{
				if (this.lastTeamChatTime + GameData.getInstance().getCommonCFG().chat.publicChatInterval >= now)
					return GameData.PROTOCOL_OP_CHAT_IN_CD;
				this.lastTeamChatTime = now;
			}
			if(this.team.id < 0)
			{
				gs.getFightService().roleSendMsgGlobalTeam(this.id, new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content));
				gs.getTLogger().logRoleChatFlow(this, targetid, TLog.CHAT_TYPE_TEAM, content.msg);
				return GameData.PROTOCOL_OP_SUCCESS;
			}
			gs.getTLogger().logRoleChatFlow(this, targetid, TLog.CHAT_TYPE_TEAM, content.msg);
			return gs.getTeamManager().roleSendMsg(this.id, new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content)) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		else if (type == SBean.MessageInfo.MTypePrivate)
		{
			if (targetid == this.id)
				return GameData.PROTOCOL_OP_FAILED;
			Role receiveRole = gs.getLoginManager().getOnGameRole(targetid);
			if (receiveRole == null)
				return GameData.PROTOCOL_OP_CHAT_TARGET_OUTLINE;
			synchronized (receiveRole)
			{
				if (receiveRole.friend.getBlackListIds().contains(this.id))
					return GameData.PROTOCOL_OP_CHAT_IN_TARGET_BLACKLIST;
			}
			synchronized (this)
			{
				if (this.friend.getBlackListIds().contains(targetid))
					return GameData.PROTOCOL_OP_CHAT_TARGET_IN_BLACKLIST;
				if (this.lastPrivateChatTime + GameData.getInstance().getCommonCFG().chat.privateChatInterval >= now)
					return GameData.PROTOCOL_OP_CHAT_IN_CD;
				this.lastPrivateChatTime = now;
				this.receiveMsgImpl(new SBean.MessageInfo(now, type, -receiveRole.id, receiveRole.name, receiveRole.sectData.data.sectBrief.sectID, receiveRole.headIcon, receiveRole.BWType, receiveRole.getUseableVipLvl(), serverName, content));// -id表示是自己发送给其他人
			}
			synchronized (receiveRole)
			{
				receiveRole.receiveMsgImpl(new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content));
			}
			gs.getTLogger().logRoleChatFlow(this, receiveRole.id, TLog.CHAT_TYPE_PRIVATE, content.msg);
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (type == SBean.MessageInfo.MTypeFight)
		{
			if (this.gameMapContext.getCurMapContext().getMapType() != GameData.MAP_TYPE_MAPCOPY_FORCEWAR)
				return GameData.PROTOCOL_OP_CHAT_WRONE_AREA;
			synchronized (this)
			{
				if (this.lastFightChatTime + GameData.getInstance().getCommonCFG().chat.publicChatInterval >= now)
					return GameData.PROTOCOL_OP_CHAT_IN_CD;
				this.lastFightChatTime = now;
			}
			gs.getFightService().roleSendMsgFight(this.id, this.gameMapContext.getCurMapContext().getMapId(), this.gameMapContext.getCurMapInstance(), new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content));
			gs.getTLogger().logRoleChatFlow(this, this.gameMapContext.getCurMapContext().getMapId(), TLog.CHAT_TYPE_PRIVATE, content.msg);
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (type == SBean.MessageInfo.MTypeAllServer)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_CHAT_ITEM);
			int chatItem = GameData.getInstance().getCommonCFG().chat.allServerChatItem;
			synchronized (this)
			{
				if (!this.containsEnoughGameItem(chatItem, 1))
					return GameData.PROTOCOL_OP_CHAT_ITEM_NEED;
				if (this.lastAllServerChatTime + GameData.getInstance().getCommonCFG().chat.allServerChatInterval >= now)
					return GameData.PROTOCOL_OP_CHAT_IN_CD;
				if (this.getUseableVipLvl() < GameData.getInstance().getCommonCFG().chat.allServerChatVipNeed)
					return GameData.PROTOCOL_OP_CHAT_VIP_LEVEL_NEED;
				this.delGameItem(chatItem, 1, tlogEvent.getGameItemRecords());
				this.lastAllServerChatTime = now;
			}
			SBean.MessageInfo msg = new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content);
			gs.getExchangeService().sendAllServerMsg(msg);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			gs.getTLogger().logRoleChatFlow(this, 0, TLog.CHAT_TYPE_ALLSERVER, content.msg);
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (type == SBean.MessageInfo.MTypeJusticeInvite)
		{
			synchronized (this)
			{
				if (this.lastJusticeInviteChatTime + GameData.getInstance().getJusticeMapCFGS().teamInviteChatInterval >= now)
					return GameData.PROTOCOL_OP_CHAT_IN_CD;
				this.lastJusticeInviteChatTime = now;
			}
			content.type = SBean.MessageContent.MsgTypeJusticeInvite;
			gs.getLoginManager().receiveWorldMsg(new SBean.MessageInfo(now, type, this.id, this.name, this.sectData.data.sectBrief.sectID, this.headIcon, this.BWType, this.getUseableVipLvl(), serverName, content));

			return GameData.PROTOCOL_OP_SUCCESS;
		}
		return GameData.PROTOCOL_OP_FAILED;
	}

	private SBean.MessageContent createRoleNormalMessage(String msg)
	{
		try
		{
			Matcher matcher = GameData.getInstance().getMsgPatternMatcher(msg);
			StringBuffer sb = new StringBuffer();
			StringBuffer sbdisplay = new StringBuffer();
			SBean.DBEquip refEquip = null;
			int type = SBean.MessageContent.MsgTypeNormal;
			int lastindex = 0;
			while (matcher.find())
			{
				if(lastindex != matcher.start()){
					String filteredmsg = GameData.getInstance().checkFilterInputStr(msg.substring(lastindex, matcher.start()), "1", GameData.getInstance().getCommonCFG().input.maxMsgLength);
					if (filteredmsg == null)
						return null;
					sb.append(filteredmsg);
					sbdisplay.append(filteredmsg);
				}
				lastindex = matcher.end();
				String matchStr = matcher.group();
				if (matchStr.startsWith("#I"))// #Iiid,iguid#
				{
					String captureStr = matcher.group(1);
					String[] strs = captureStr.split(",", -1);
					if (strs.length != 2)
						return null;
					int iid = Integer.parseInt(strs[0]);
					String iguid = strs[1];
					String itemname = GameData.getInstance().getItemName(iid);
					if (itemname == null)
						return null;
					if (GameData.getInstance().getEquipCFG(iid) != null)
					{
						SBean.DBEquip equip = checkGetEquip(iid, iguid);
						if (equip == null || (refEquip != null && refEquip != equip))
							return null;
						refEquip = equip;
					}
					String replaceName = "[" + itemname + "]";
					sbdisplay.append(replaceName);
				}
				else if (matchStr.startsWith("#M"))
				{
					String captureStr = matcher.group(2);
					String[] strs = captureStr.split(",", -1);
					if (strs.length != 5)
						return null;
					int mapId = Integer.parseInt(strs[0]);
					int x = Integer.parseInt(strs[1]);
					int y = Integer.parseInt(strs[2]);
					int z = Integer.parseInt(strs[3]);
					int mapLine = Integer.parseInt(strs[4]);
					SBean.MapClusterCFGS mapCfg = GameData.getInstance().getMapClusterCFGS(mapId);
					if (mapCfg == null)
						return null;
					GVector3 pos = new GVector3(x, y, z);
					if (pos.distance(new GVector3(this.gameMapContext.getCurMapContext().getMapLocation().location.position)) > 5.0f 
							|| mapLine != this.gameMapContext.getCurMapInstance())
						return null;
					String replaceName = "[" + mapCfg.name + "]";
					sbdisplay.append(replaceName);
				}
				else if (matchStr.startsWith("#T"))
				{
					String captureStr = matcher.group(3);
					int teamId = Integer.parseInt(captureStr);
					if (teamId > 0 && this.getTeamId() != teamId)
						return null;
					String replaceStr = "[" + "****" + "]";
					sbdisplay.append(replaceStr);
				}
				else if (matchStr.startsWith("#V"))
				{
					String captureStr = matcher.group(5);
					if(captureStr.isEmpty())
						return null;
					String replaceStr = "[url]";
					sbdisplay.append(replaceStr);
				}
				else if (matchStr.startsWith("#R"))
				{
					if (!this.isInMRoom() || !this.isMRoomLeader())
						return null;
					String captureStr = matcher.group(6);
					String[] strs = captureStr.split(",", -1);
					if (strs.length != 3)
						return null;
					int mapId = Integer.parseInt(strs[0]);
					int roomId = Integer.parseInt(strs[1]);
					int roomType = Integer.parseInt(strs[2]);
					if (mapId != this.getMRoomTargetMap() || roomId != this.getMRoomId() || roomType != this.getMRoomType())
						return null;
					if(captureStr.isEmpty())
						return null;
					String replaceStr = "[" + "****" + "]";
					type = SBean.MessageContent.MsgTypeMRoomInvite;
					sbdisplay.append(replaceStr);
				}
				else if (matchStr.startsWith("#S"))
				{
					String captureStr = matcher.group(7);
					String[] strs = captureStr.split(",", -1);
					if (strs.length != 2)
						return null;
					int sectId = Integer.parseInt(strs[0]);
					String sectName = strs[1];
					if (this.sectData.data.sectBrief.sectID != sectId || !sectName.equals(this.sectData.data.sectBrief.sectName))
						return null;
					if(captureStr.isEmpty())
						return null;
					String replaceStr = "[" + "****" + "]";
					type = SBean.MessageContent.MsgTypeSectInvite;
					sbdisplay.append(replaceStr);
				}
				else if (matchStr.startsWith("#DPS"))
				{
					//木桩伤害信息，不需要做验证
				}
				else
				{
					String captureStr = matcher.group(4);
					int iconId = Integer.parseInt(captureStr);
					if (!checkMessageIcon(iconId))
						return null;
					String replaceName = "*" + captureStr;
					sbdisplay.append(replaceName);
				}
				sb.append(msg.substring(matcher.start(), matcher.end()));
				//保留#K 用于diyskill
			}
			if (lastindex != msg.length())
			{
				String filteredmsg = GameData.getInstance().checkFilterInputStr(msg.substring(lastindex, msg.length()), "1", GameData.getInstance().getCommonCFG().input.maxMsgLength);
				if (filteredmsg == null)
					return null;
				sb.append(filteredmsg);
				sbdisplay.append(filteredmsg);
			}
			if (sbdisplay.indexOf("#") >= 0 || sbdisplay.length() > GameData.getInstance().getCommonCFG().input.maxMsgLength)
				return null;
			return new SBean.MessageContent(type, sb.toString(), refEquip, null, null);
		}
		catch (Exception e)
		{

		}
		return null;
	}

	private boolean checkMessageIcon(int iconId)
	{
		return true;
	}

	private SBean.MessageContent createDiyskillMessage(SBean.FlauntDiySkillInfo info)
	{
		if (info.diyskill == null || info.icons.size() > 3)
			return null;
		for (int iconId : info.icons)
		{
			if (!checkMessageIcon(iconId))
				return null;
		}
		return new SBean.MessageContent(SBean.MessageContent.MsgTypeDiySkill, "", null, info, null);
	}

	private SBean.MessageContent createSendFlowerMessage(SBean.SendFlowersInfo info)
	{
		return new SBean.MessageContent(SBean.MessageContent.MsgTypeSendFlowers, "", null, null, info);
	}
	

	private synchronized SBean.DBEquip checkGetEquip(int id, String guid)
	{
		SBean.DBEquip equip = null;
		CellItem bi = this.getBagItem(id);
		if (bi != null)
		{
			CellItem.Wearable wearable = bi.getWearable();
			if (wearable != null)
				equip = wearable.getEquipData(guid).kdClone();
		}
		else
		{
			for (SBean.DBWearEquip e : this.wearEquips.values())
			{
				if (e.equip.guid.equals(guid))
				{
					equip = e.equip.kdClone();
					break;
				}
			}
		}
		return equip;
	}

	private void receiveMsgImpl(SBean.MessageInfo msg)
	{
		this.msgs.add(msg);
		if (this.msgs.size() > 50)
			this.msgs.subList(0, this.msgs.size() - 50).clear();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_new_msg(msg));
	}

	public synchronized void receiveMsg(SBean.MessageInfo msg)
	{
		receiveMsgImpl(msg);
	}

	private boolean processGMCommand(String cmd)
	{
		if( superGM.verify(cmd) )
			return true;
		if ( superGM.isEnable())
		{
			if( superGM.process(cmd) )
				return true;
		}
		else if (gs.getConfig().godMode <= 0 )
			return false;
		
		GMCommond c = parseGMCommond(cmd);
		if (c == null)
			return false;
		boolean processResult = false;
		switch (c.cmd)
		{
		case "add":
			processResult = this.gmAddGameItem(c.iArg1, c.iArg2);
			break;
		case "addequip":
			processResult = this.gmAddEquip(c.iArg1, c.iArg2);
			break;
		case "addexp":
			processResult = this.gmAddExp(c.iExp);
			break;
		case "to":
			processResult = this.gmTeleport(c.iArg1);
			break;
		case "power":
			processResult = this.gmShowPower();
			break;
		case "props":
			processResult = this.gmShowProps(c.iArg1);
			break;
		case "addcharm":
			processResult = this.gmAddCharm(c.iArg1);
			break;
		case "addtitle":
			processResult = this.gmAddTitle(c.iArg1);
			break;
		case "addhonor":
			processResult = this.gmAddHonor(c.iArg1);
			break;
		case "jumpmtask":
			processResult = this.gmJumpMainTask(c.iArg1);
			break;
		case "settimeoffset":
			processResult = this.setTimeOffset(c.iArg1);
			break;
		case "showtimeoffset":
			processResult = this.showTimeOffset();
			break;
		case "addfeat":
			processResult = this.gmAddFeat(c.iArg1);
			break;
		case "addsectvit":
			processResult = this.gmAddSectVit(c.iArg1);
			break;
		case "addpetexploit":
			processResult = this.gmAddPetExploit(c.iArg1, c.iArg2);
			break;
		case "startparade":
			processResult = this.gmStartMarriageParade();
			break;
		case "setrolelevel":
			processResult = this.modifyLevel(c.iArg1);
			break;
		case "setrolevippoint":
			processResult = this.modifyVipPoint(c.iArg1);
			break;
		case "startweaponmap":
			processResult = this.gmStartWeaponMapCopy();
			break;
		case "startmrgbanquet":
			processResult =  this.gmStartMarriageBanquet(c.iArg1);
			break;
		case "telenpc":
			processResult = this.gmTeleNpc(c.iArg1, c.iArg2);
			break;
		case "changeline":
			processResult = this.gmChangeLine(c.iArg1);
			break;
		case "addmarriageexp":
			processResult = this.gmAddMarriageExp(c.iArg1);
			break;
		case "addweaponmaster":
			processResult = this.gmAddWeaponMaster(c.iArg1, c.iArg2);
			break;
		case "createrobot":
			processResult = this.gmCreateRobotHero(c.iArg1);
			break;
		case "destroyrobot":
			processResult = this.gmDestroyRobotHero();
			break;
		case "joinstele":
			processResult = this.joinStele() > 0;
			break;
		case "findjusticenpc":
			processResult = this.transformToJusticeNpc();
			break;
		case "leavemapcopy":
			processResult = tryLeaveMapCopy();
			break;
		case "changedemonfloor":
			this.changeDemonHoleFloor(c.iArg1);
			processResult = true;
			break;
		case "startfightnpc":
			processResult = this.gmStartFightNpcMap();
			break;
		case "sendsocialcomment":
			this.sendSocialComment(this.netsid, gs.getConfig().id, "server1001", c.iArg1, c.iArg2, c.sArg);
			processResult = true;
			break;
		case "mroomcreate":
			processResult = this.mroomNewCreate(c.iArg1, c.iArg2) > 0;
			break;
		case "starttd":
			processResult = this.startTowerDefenceMapCopy(c.iArg1) > 0;
			break;
		case "rbjoinsuperarena":
			Role robot = gs.getLoginManager().createRobot(this, 0);
			robot.singleJoinSuperArena(c.iArg1);
			processResult = true;
			break;
		case "setsuperarenaelo":
			processResult = this.gmSetSuperArenaELO(c.iArg1, c.iArg2);
			break;
		case "worldboss":
			processResult = this.gmWorldBoss(c);
			break;
			//@#showdebug
			//@#closeui
		default:
			break;
		}
		return processResult;
	}
	
	private boolean transformToJusticeNpc()
	{
		SBean.MapLocation curLocation = gs.getJusticeManager().getCurLocation();
		if (curLocation == null)
			return false;
		return this.transformToRolePosition(curLocation, 1) > 0;
	}

	private boolean showTimeOffset()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_show_timeoffset(GameTime.getServerTimeOffset()));
		return true;
	}

	
	private boolean setTimeOffset(int timeOffset)
	{
		if (timeOffset <= GameTime.getServerTimeOffset())
			return false;
		gs.getRPCManager().resetServerTimeOffset(timeOffset);
		gs.getRPCManager().onModifyServerTimeOffset(timeOffset);
		return true;
	}



	static class GMCommond
	{
		String cmd;
		int iArg1;
		int iArg2;
		int iArg3;
		
		long iExp;
		String sArg = "";
	}

	GMCommond parseGMCommond(String cmd)
	{
		String[] v = cmd.split("\\s+");// cmd.replaceAll("\\s", "#").split("#");
		if (v == null || v.length == 0)
			return null;
		try
		{
			GMCommond c = null;
			switch (v[0])
			{
			case "add":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				break;
			case "addequip":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				break;
			case "addexp":
				c = new GMCommond();
				c.cmd = v[0];
				c.iExp = Long.parseLong(v[1]);
				break;
			case "to":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "power":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "props":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "addcharm":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "addtitle":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "addhonor":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "jumpmtask":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "settimeoffset":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "showtimeoffset":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "addfeat":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "addsectvit":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "addpetexploit":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				break;
			case "startparade":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "setrolelevel":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "setrolevippoint":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "startweaponmap":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "startmrgbanquet":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "telenpc":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				break;
			case "changeline":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "addmarriageexp":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "createrobot":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "destroyrobot":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "addweaponmaster":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				break;
			case "joinstele":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "findjusticenpc":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "leavemapcopy":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "changedemonfloor":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "startfightnpc":
				c = new GMCommond();
				c.cmd = v[0];
				break;
			case "sendsocialcomment":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				c.sArg = v[3];
				break;
			case "mroomcreate":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				break;
			case "starttd":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "rbjoinsuperarena":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			case "setsuperarenaelo":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				c.iArg2 = Integer.parseInt(v[2]);
				break;
			case "worldboss":
				c = new GMCommond();
				c.cmd = v[0];
				c.iArg1 = Integer.parseInt(v[1]);
				break;
			default:
				break;
			}
			return c;
		}
		catch (Exception e)
		{

		}
		return null;
	}

	synchronized boolean gmAddGameItem(int id, int count)
	{
		SBean.GameItem gi = GameData.getInstance().toGameItem(id, count);
		if (gi == null)
			return false;
		if (!canAddGameItem(gi.id, gi.count))
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GM_ADD_GAME_ITEM);
		tlogEvent.setArg(id, count);
		this.syncAddGameItem(gi, tlogEvent);
		if( ! isSuperGM() )
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	synchronized boolean gmAddEquip(int id, int randLegend)
	{
		if (!canAddGameItem(id, 1))
			return false;
		
		SBean.DBEquip equip = GameData.getInstance().createNewEquip(id, 1, randLegend);
		if(equip == null)
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GM_ADD_GAME_ITEM);
		tlogEvent.setArg(id, 1);
		this.syncAddGameItem(GameData.toGameItem(equip), tlogEvent);
		if( ! isSuperGM() )
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		return true;
	}
	
	synchronized boolean gmAddExp(long exp)
	{
		this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
		return true;
	}

	boolean gmTeleport(int mapId)
	{
		SBean.MapLocation mapLocation = null;
		synchronized(this)
		{
			SBean.WorldMapCFGS worldMapCfg = GameData.getInstance().getWorldMapCFGS(mapId);
			SBean.MapClusterCFGS mapClusterCfg = GameData.getInstance().getMapClusterCFGS(mapId);
			if (worldMapCfg == null || mapClusterCfg == null || this.mulRolesLock > 0 || this.isMulRolesMember())
				return false;
			
			if (!this.gameMapContext.isInWorldMap())
				return false;

			mapLocation = GameData.getMapSpawnLocation(mapClusterCfg);
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(mapLocation, this.getPriorityLine(mapLocation.mapID));
				this.gameMapContext.roleChangeMap();
				return true;
			}
		}
		
		this.mulRolesChangeMap(mapLocation);
		return true;
	}

	boolean gmTeleNpc(int mapID, int npcPoint)
	{
		return this.teleportNpc(mapID, npcPoint);
	}
	
	boolean gmChangeLine(int line)
	{
		return this.changeWorldLine(line) > 0;
	}
	
	synchronized boolean gmShowPower()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_show_power(this.roleProperties.getRoleFightPower()));
		return true;
	}
	
	synchronized boolean gmShowProps(int propID)
	{
		if(propID > 0 && GameData.getInstance().getPropertyCFGS(propID) == null)
			return false;
		
		gs.getMapService().roleShowProps(this.gameMapContext.getCurMapId(), this.id, propID);
		return true;
	}
	
	synchronized boolean gmWorldBoss(GMCommond c)
	{
		SBean.WorldBossCFGS bossCfg = GameData.getInstance().getWorldBossCFGS(c.iArg1);
		if(bossCfg == null)
			return false;
		
		gmCommondToMap("worldboss", c.iArg1, c.iArg2, c.iArg3, c.sArg);
		return true;
	}
	
	private void gmCommondToMap(String iType, int iArg1, int iArg2, int iArg3, String sArg)
	{
		gs.getMapService().gmCommandToMap(this.gameMapContext.getCurMapId(), this.id, iType, iArg1, iArg2, iArg3, sArg);
	}
	
	synchronized boolean gmAddCharm(int charm)
	{
		this.syncAddCharm(charm);
		return true;
	}
	
	synchronized boolean gmAddTitle(int titleID)
	{
		return this.addRoleTitle(titleID);
	}
	
	boolean gmAddMarriageExp(int addExp)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return false;
		
		Role partner = null;
		synchronized(this)
		{
			if(this.team.leader == 0)
				return false;
			
			if(this.team.leader != this.id)
				return false;
			
			partner = getTeamMrgPartner(marriage);
			if(partner == null)
				return false;
		}
		
		boolean change = marriage.gmAddMarriageExp(this, partner, addExp);
		
		if(change)
		{
			synchronized(this)
			{
				this.onMarriageLvlChange(marriage.getMarriageLevel());
			}
			
			synchronized(partner)
			{
				partner.onMarriageLvlChange(marriage.getMarriageLevel());
			}
		}
		
		return true;
	}
	
	//添加会武竞技场荣誉 不能加锁
	synchronized boolean gmAddHonor(int addHonor)
	{
		this.onSuperArenaEnd(addHonor, 1, this.arenaInfo.roleArenaData.superarena.rankClearTime);
		return true;
	}
	
	synchronized boolean gmSetSuperArenaELO(int elo, int arenaType)
	{
		if(elo < GameData.getInstance().getSuperArenaCFGS().minELO || elo > GameData.getInstance().getSuperArenaCFGS().maxELO)
			return false;
		
		this.arenaInfo.roleArenaData.superarena.logs.merge(arenaType, new SBean.SuperArenaLog(1, 1, 0, 0, 0, (short)0, (short)elo), (ov, nv) ->
		{
			ov.elo = (short) elo;
			return ov;
		});
		return true;
	}
	
	synchronized boolean gmAddFeat(int addFeat)
	{
		this.syncAddForceWarFeat(addFeat);
		return true;
	}
	//跳转到目标主线任务
	synchronized private boolean gmJumpMainTask(int mtaskID)
	{
		return this.jumpMainTask(mtaskID);
	}

	private boolean gmAddSectVit(int vit)
	{
		return gs.getSectManager().gmAddSectVit(this, vit);
	}
	
	synchronized boolean gmAddPetExploit(int petID, int addExploit)
	{
		this.syncAddPetExploit(petID, addExploit);
		return true;
	}
	
	synchronized boolean gmStartWeaponMapCopy()
	{
		return this.startWeaponMapCopy();
	}
	
	synchronized boolean gmStartFightNpcMap()
	{
		return startFightNpcMapCopy() > 0;
	}
	
	synchronized boolean gmAddWeaponMaster(int weaponID, int add)
	{
		SBean.DBWeapon weapon = this.weapons.get(weaponID);
		if (weapon == null || weapon.uniqueSkill.open == 1)
			return false;
		
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(weaponID);
		if(wCfg == null || wCfg.isUSkillOpen == 0 || weapon.uniqueSkill.master >= wCfg.maxMaster)
			return false;
		
		int lastM = weapon.uniqueSkill.master / GameData.getInstance().getCommonCFG().skill.weaponMasterInterval;
		weapon.uniqueSkill.master += add;
		if(weapon.uniqueSkill.master > wCfg.maxMaster)
			weapon.uniqueSkill.master = wCfg.maxMaster;
		
		int newM = weapon.uniqueSkill.master / GameData.getInstance().getCommonCFG().skill.weaponMasterInterval;
		if(lastM !=  newM || weapon.uniqueSkill.master == wCfg.maxMaster)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_weapon_master(weapon.uniqueSkill.master));
		
		return true;
	}
	
	synchronized boolean gmCreateRobotHero(int spawnPoint)
	{
		int mapID = this.gameMapContext.getCurMapId();
		SBean.MapClusterCFGS mccfg = GameData.getInstance().getMapClusterCFGS(mapID);
		if (mccfg == null || !mccfg.spawnPoints.contains(spawnPoint))
			return false;
		
		SBean.FightRole robot = this.getMapFightRoleWithoutLock();
		robot.base.roleID = -robot.base.roleID;
		robot.roleName = robot.roleName + "_robot"; 
		gs.getMapService().syncCreateRobotHero(mapID, 
											   this.gameMapContext.getCurMapInstance(), 
											   robot, 
											   this.getMapFightPetsWithoutLock(this.worldMapPets), 
											   spawnPoint);
		return true;
	}
	
	synchronized boolean gmDestroyRobotHero()
	{
		gs.getMapService().syncDestroyRobotHero(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance(), -this.id);
		return true;
	}
	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private void dayRefreshShops()
	{
		for (SBean.DBShop shop : this.shops.values())
		{
			shop.refreshTimes = 0;
		}
	}
	
	private void dayRefreshGambleShops()
	{
		for (SBean.DBGambleShop shop : this.gambleShops.values())
		{
			shop.refreshTimes = 0;
		}
	}

	private SBean.DBShop createNewShop(int type)
	{
		SBean.DBShop shop = new SBean.DBShop(type, 0, 0, null);
		doRefreshShop(shop, 0);
		return shop;
	}
	
	private SBean.DBGambleShop createNewGambleShop(int type)
	{
		SBean.DBGambleShop shop = new SBean.DBGambleShop(type, 0, 0, null);
		doRefreshGambleShop(shop, 0);
		return shop;
	}
	
	private void doRefreshGambleShop(SBean.DBGambleShop shop, int times)
	{
		SBean.GambleShopCFGS cfg = GameData.getInstance().getGambleShopCFG(shop.type);
		List<SBean.DBGambleShopGoods> goods = GameData.getGambleShopGoods(cfg, Role.this.level);
		Collections.shuffle(goods);
		shop.refreshTimes = times;
		shop.stamp = GameTime.getTime();
		shop.goods = goods;
	}

	private synchronized SBean.GambleShopInfo syncGambleShopInfo(int type)
	{
		SBean.DBGambleShop shop = this.gambleShops.get(type);
		if (shop == null)
			return null;
		tryRefreshGambleShop(shop);
		return new SBean.GambleShopInfo(shop.refreshTimes, Stream.clone(shop.goods));
	}

	private void tryRefreshGambleShop(SBean.DBGambleShop shop)
	{
		SBean.GambleShopCFGS cfg = GameData.getInstance().getGambleShopCFG(shop.type);
		int lastRefreshTime = GameData.getLastRefreshTime(GameTime.getTime(), cfg.refreshTime);
		if (lastRefreshTime > shop.stamp)
		{
			doRefreshGambleShop(shop, shop.refreshTimes);
		}
	}

	private void doRefreshShop(SBean.DBShop shop, int times)
	{
		SBean.ShopCFGS cfg = GameData.getInstance().getShopCFG(shop.type);
		List<SBean.DBShopGoods> goods = GameData.getShopGoods(cfg, Role.this.level);
		Collections.shuffle(goods);
		shop.refreshTimes = times;
		shop.stamp = GameTime.getTime();
		shop.goods = goods;
	}

	private SBean.ShopInfo syncShopInfo(int type)
	{
		SBean.DBShop shop = this.shops.get(type);
		if (shop == null)
			return null;
		tryRefreshShop(shop);
		return new SBean.ShopInfo(shop.refreshTimes, Stream.clone(shop.goods));
	}

	private void tryRefreshShop(SBean.DBShop shop)
	{
		SBean.ShopCFGS cfg = GameData.getInstance().getShopCFG(shop.type);
		int lastRefreshTime = GameData.getLastRefreshTime(GameTime.getTime(), cfg.refreshTime);
		if (lastRefreshTime > shop.stamp)
		{
			doRefreshShop(shop, shop.refreshTimes);
		}
	}

	private synchronized SBean.ShopInfo userRefreshShop(int type, int times, int isSecondType)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USER_REFRESH_SHOP);
		SBean.DBShop shop = this.shops.get(type);
		if (shop == null || times != shop.refreshTimes + 1)
			return null;
		SBean.ShopCFGS cfg = GameData.getInstance().getShopCFG(shop.type);
		int costId = isSecondType == 1 ? cfg.refreshCurUnit2 : cfg.refreshCurUnit;
		int price = GameData.getTimesCost(isSecondType == 1 ? cfg.refreshPrice2 : cfg.refreshPrice, times);
		if (!Role.this.containsEnoughGameItem(costId, price))
			return null;
		tlogEvent.setArg(type, times, costId, price);
		Role.this.delGameItem(costId, price, tlogEvent.getGameItemRecords());
		doRefreshShop(shop, times);
		gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
		return new SBean.ShopInfo(shop.refreshTimes, Stream.clone(shop.goods));
	}

	private synchronized boolean buyShopGoogs(int type, int seq)
	{
		SBean.DBShop shop = this.shops.get(type);
		if (shop == null)
			return false;
		tryRefreshShop(shop);
		if (seq <= 0 || seq > shop.goods.size())
			return false;
		SBean.DBShopGoods sg = shop.goods.get(seq - 1);
		if (sg.buyTimes > 0)
			return false;
		SBean.ShopCFGS cfg = GameData.getInstance().getShopCFG(shop.type);
		SBean.ShopGoodsCFGS sgcfg = GameData.getShopGoodsById(cfg, sg.id);
		if (sgcfg == null)
			return false;

		if (!this.containsEnoughGameItem(sgcfg.curUnit, sgcfg.price))
			return false;
		if (!this.canAddGameItem(sgcfg.item.id, sgcfg.item.count))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_SHOP_GOOGS);
		tlogEvent.setArg(type, seq, sg.id);
		Role.this.delGameItem(sgcfg.curUnit, sgcfg.price, tlogEvent.getGameItemRecords());
		sg.buyTimes += 1;
		this.syncAddGameItem(GameData.getInstance().toGameItem(sgcfg.item.id, sgcfg.item.count), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		gs.getTLogger().logRoleStoreBuyFlow(this, type, sg.id, 1, sgcfg.curUnit, sgcfg.price, sgcfg.item.id, sgcfg.item.count);
		return true;
	}

	private synchronized SBean.GambleShopInfo userRefreshGambleShop(int type, int times)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USER_REFRESH_GAMBLE_SHOP);
		SBean.DBGambleShop shop = this.gambleShops.get(type);
		if (shop == null || times != shop.refreshTimes + 1)
			return null;
		SBean.GambleShopCFGS cfg = GameData.getInstance().getGambleShopCFG(shop.type);
		int price = GameData.getTimesCost(cfg.refreshPrice, times);
		if (!Role.this.containsEnoughGameItem(cfg.refreshCurUnit, price))
			return null;
		tlogEvent.setArg(type, times, cfg.refreshCurUnit, price);
		Role.this.delGameItem(cfg.refreshCurUnit, price, tlogEvent.getGameItemRecords());
		doRefreshGambleShop(shop, times);
		gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
		return new SBean.GambleShopInfo(shop.refreshTimes, Stream.clone(shop.goods));
	}

	private synchronized List<SBean.DummyGoods> buyGambleShopGoods(int type, int seq)
	{
		SBean.DBGambleShop shop = this.gambleShops.get(type);
		if (shop == null)
			return null;
		tryRefreshGambleShop(shop);
		if (seq <= 0 || seq > shop.goods.size())
			return null;
		SBean.DBGambleShopGoods sg = shop.goods.get(seq - 1);
		if (sg.buyTimes > 0)
			return null;
		SBean.GambleShopCFGS cfg = GameData.getInstance().getGambleShopCFG(shop.type);
		SBean.GambleShopGoodsCFGS sgcfg = GameData.getGambleShopGoodsById(cfg, sg.id);
		if (sgcfg == null || this.bag.getCanUseSize() < GameData.getInstance().getCommonCFG().bagSizeNeed.gambleShopNeeds)
			return null;
		if (!this.testCanBuyGambleGoods(sgcfg))
			return null;
		if (!this.containsEnoughGameItem(sgcfg.curUnit, sgcfg.price))
			return null;
		List<SBean.DummyGoods> drops = GameData.toDummGoods(GameData.getInstance().getMergedRandomDrop(sgcfg.randomDropId, 1, 1));
		if (drops.isEmpty() || !this.canAddGameItems(drops))
			return null;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_GAMBLE_SHOP_GOOGS);
		tlogEvent.setArg(type, seq, sg.id);
		Role.this.delGameItem(sgcfg.curUnit, sgcfg.price, tlogEvent.getGameItemRecords());
		sg.buyTimes += 1;
		this.syncAddGameItems(GameData.getInstance().toGameItems(drops), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);

		int shopType = 0;
		switch (type)
		{
		    case GameData.GAMBLE_SHOP_TYPE_EVIL:
		    	shopType = TLog.GAMBLE_SHOP_TYPE_EVIL;
		        break;
		    case GameData.GAMBLE_SHOP_TYPE_JUSTICE:
		    	shopType = TLog.GAMBLE_SHOP_TYPE_JUSTICE;
		        break;
		}
		gs.getTLogger().logRoleStoreBuyFlow(this, shopType, sg.id, 1, sgcfg.curUnit, sgcfg.price, drops.get(0).id, drops.get(0).count);
		
		return drops;
	}
	
	private boolean testCanBuyGambleGoods(SBean.GambleShopGoodsCFGS goodsCFGS)
	{
		switch (goodsCFGS.conditiontype)
		{
		case GameData.GAMBLE_SHOP_CONDITION_FEAT:
			return this.forceWarInfo.forcewar.totalFeats >= goodsCFGS.conditionnum;
		default:
			return false;
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public List<SBean.RankBrief> syncRanksBrief()
	{
		return gs.getRankManager().getRoleRankBriefs(this.level);
	}

	public void getRankList(int id, int refreshTime, int index, int len)
	{
		RpcRes<List<SBean.RankRole>> res = gs.getRankManager().getRanksSnapshotById(id, refreshTime, index, len);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rank_get_res(res.errCode, res.info));
	}
	
	public int getSelfRank(int id)
	{
		return gs.getRankManager().getRoleSnapshotRank(id, this.id);
	}

	public List<SBean.RankBrief> syncSectRanksBrief()
	{
		return gs.getRankManager().getSectRankBriefs(this.level);
	}
	
	public void getSectRankList(int rankID, int refreshTime, int index, int len)
	{
		RpcRes<List<SBean.RankSect>> res = gs.getRankManager().getSectRanksSnapshotById(rankID, refreshTime, index, len);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sectrank_get_res(res.errCode, res.info));
	}
	
	public int getSelfSectRank(int rankID)
	{
		synchronized(this)
		{
			if(this.sectData.data.sectBrief.sectID <= 0)
				return -1;
		}
		return gs.getRankManager().getSectSnapshotRank(rankID, this.sectData.data.sectBrief.sectID);
	}
	
	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	void tryUseHpPool(int timeTick)
	{
		if (this.hpPool > 0 && this.gameMapContext.getCurMapContext().canUseHpPool())
		{
			MapContext mapContext = this.gameMapContext.getCurMapContext();
			int interval = GameData.getInstance().getCommonCFG().medicine.vipTripInterval > this.equipLegend.getHpPoolCDReduce() ? 
					GameData.getInstance().getCommonCFG().medicine.vipTripInterval - this.equipLegend.getHpPoolCDReduce() : 0;
			if (this.lastUseHpPoolTime + interval < timeTick)
			{
				int hpMax = mapContext.getHpMax();
				int hp = mapContext.getHp();
				if (hp > 0)
				{
					int lostHp = hpMax - hp;
					if (lostHp > 0)
					{
						int addHp = lostHp > this.hpPool ? this.hpPool : lostHp;
						this.hpPool -= addHp;
						this.lastUseHpPoolTime = timeTick;
						
						gs.getMapService().syncRoleAddHp(this.id, this.gameMapContext.getCurMapId(), addHp);
						gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_hppool_used(addHp));
					}
				}
			}
			if (this.petCanUsePool)
			{
				for (Entry<Integer, SBean.Hp> petHp : mapContext.getCurPetHp().entrySet())
				{
					if (petHp.getValue().curValue > 0 && petHp.getValue().curValue < petHp.getValue().maxValue * GameData.getInstance().getCommonCFG().pet.autoUsePoolHp && (!this.petLastUsePool.containsKey(petHp.getKey()) || this.petLastUsePool.get(petHp.getKey()) + GameData.getInstance().getCommonCFG().pet.poolCD / 1000 < timeTick))
					{
						int needpool = (petHp.getValue().maxValue - petHp.getValue().curValue) / GameData.getInstance().getCommonCFG().pet.healPerPool;
						int usepool = needpool > this.hpPool ? this.hpPool : needpool;
						this.hpPool -= usepool;
						this.petLastUsePool.put(petHp.getKey(), timeTick);
						petHp.getValue().curValue += usepool * GameData.getInstance().getCommonCFG().pet.healPerPool;
						gs.getMapService().syncRolePetAddHp(this.id, this.gameMapContext.getCurMapId(), petHp.getKey(), usepool * GameData.getInstance().getCommonCFG().pet.healPerPool);
						gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_hppool_used(usepool));
					}
				}
			}
		}
	}

	// /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public int getSharedWarehouseId()
	{
		return this.marriageData.marriageShareId;
	}
	
	private DBMarriageShare copyDBSharedMarriage()
	{
		MarriageShare marriage = this.getSharedMarriage();
		return marriage == null ? null : marriage.toDB();
	}
	
	private void updateSharedMarriageUseTime(int now)
	{
		MarriageShare marriage = this.getSharedMarriage();
		if (marriage != null)
			marriage.updateUseTime(now);
	}
	
	private MarriageShare getSharedMarriage()
	{
		return gs.getLoginManager().getSharedMarriage(this.marriageData.marriageShareId);
	}
	
	public boolean canAddGameItem(int id, int count)
	{
		return bag.canPutIn(id, count);
	}

	public boolean canAddGameItems(Map<Integer, Integer> counter)
	{
		return bag.canPutIn(counter);
	}

	public boolean canAddGameItems(Collection<SBean.DummyGoods> dgs)
	{
		return bag.canPutIn(dgs);
	}

	public boolean canAddGameItems(List<SBean.GameItem> gis)
	{
		return bag.canPutIn(gis);
	}

	//	// TODO del
	//	public boolean canAddDummyItems(SBean.DBDummyItems dis)
	//	{
	//		return bag.canPutInBag(dis);
	//	}

	public void syncAddGameItem(SBean.GameItem gi, TLogger.TLogEvent tLogger)
	{
		if (gi == null || gi.count <= 0)
			return;
		this.addGameItem(gi, tLogger.getGameItemRecords());
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_item(gi, tLogger.eventID));
	}

	private int addGameItem(SBean.GameItem gi, TLogger.GameItemRecords records)
	{
		int addCount = 0;
		switch (gi.id)
		{
		case GameData.COMMON_ITEM_ID_DIAMOND:
			addCount = this.addDiamond(gi.count, false, records);
			break;
		case -GameData.COMMON_ITEM_ID_DIAMOND:
			addCount = this.addDiamond(gi.count, true, records);
			break;
		case GameData.COMMON_ITEM_ID_COIN:
			addCount = this.addCoin(gi.count, false, records);
			break;
		case -GameData.COMMON_ITEM_ID_COIN:
			addCount = this.addCoin(gi.count, true, records);
			break;
		case GameData.COMMON_ITEM_ID_SECT_MONEY:
			this.addSectContribution(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_ARENA_MONEY:
			this.addArenaPoint(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_SUPERARENA_MONEY:
			this.addSuperArenaPoint(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_MASTER_POINT:
			this.addMasterPoint(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_MASTER_REPUTATION:
			this.addMasterReputation(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_EQUIP_ENERGY:
			this.addEquipEnergy(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_GEM_ENERGY:
			this.addGemEnergy(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_BOOK_INSPIRATION:
			this.addBookInspiration(gi.count, records);
			break;
//		case GameData.COMMON_ITEM_ID_XUANTIE:
//			this.addClanXuantie(gi.count, records);
//			break;
//		case GameData.COMMON_ITEM_ID_YAOCAO:
//			this.addClanYaocao(gi.count, records);
//			break;
		case GameData.COMMON_ITEM_ID_VIT:
			this.addVit(gi.count, true, records);
			break;
		case GameData.COMMON_ITEM_ID_SPLITSP:
			this.addSplitSP(gi.count, true, records);
			break;
		case GameData.COMMON_ITEM_ID_ROB_MONEY:
			this.addRobMoney(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_EXPCOIN:
			this.addExpCoin(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_OFFLINE_FUNC_POINT:
			this.addOfflineFuncPoint(gi.count, records);
			break;
		case GameData.COMMON_ITEM_ID_CREDIT:
			this.addCredit(gi.count, records);
			break;
		default:
			this.addBagItem(gi, records);
			break;
		}
		return addCount;
	}

	// 同时添加服务器和客户端的道具
	public void syncAddGameItems(List<SBean.GameItem> gis, TLogger.TLogEvent tLogger)
	{
		if (!gis.isEmpty())
		{
			this.addGameItems(gis, tLogger.getGameItemRecords());
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_items(gis, tLogger.eventID));
		}
	}

	public void addGameItems(Collection<SBean.GameItem> gis, TLogger.GameItemRecords records)
	{
		for (SBean.GameItem gi : gis)
		{
			this.addGameItem(gi, records);
		}
	}

	public boolean containsEnoughGameItem(int id, int count)
	{
		boolean enough = false;
		switch (id)
		{
		case GameData.COMMON_ITEM_ID_DIAMOND:
			enough = this.canUseDiamond(count, false);
			break;
		case -GameData.COMMON_ITEM_ID_DIAMOND:
			enough = this.canUseDiamond(count, true);
			break;
		case GameData.COMMON_ITEM_ID_COIN:
			enough = this.canUseCoin(count, false);
			break;
		case -GameData.COMMON_ITEM_ID_COIN:
			enough = this.canUseCoin(count, true);
			break;
		case GameData.COMMON_ITEM_ID_SECT_MONEY:
			enough = this.canUseSectContribution(count);
			break;
		case GameData.COMMON_ITEM_ID_ARENA_MONEY:
			enough = this.canUseArenaPoint(count);
			break;
		case GameData.COMMON_ITEM_ID_SUPERARENA_MONEY:
			enough = this.canUseSuperArenaPoint(count);
			break;
		case GameData.COMMON_ITEM_ID_MASTER_POINT:
			enough = this.canUseMasterPoint(count);
			break;
		case GameData.COMMON_ITEM_ID_MASTER_REPUTATION:
			enough = this.canUseMasterReputation(count);
			break;
		case GameData.COMMON_ITEM_ID_EQUIP_ENERGY:
			enough = this.canUseEquipEnergy(count);
			break;
		case GameData.COMMON_ITEM_ID_GEM_ENERGY:
			enough = this.canUseGemEnergy(count);
			break;
		case GameData.COMMON_ITEM_ID_BOOK_INSPIRATION:
			enough = this.canUseBookInspiration(count);
			break;
		case GameData.COMMON_ITEM_ID_VIT:
			enough = this.canUseVit(count);
			break;
//		case GameData.COMMON_ITEM_ID_XUANTIE:
//			enough = this.canUseClanXuantie(count);
//			break;
//		case GameData.COMMON_ITEM_ID_YAOCAO:
//			enough = this.canUseClanYaocao(count);
//			break;
		case GameData.COMMON_ITEM_ID_EXPCOIN:
			enough = this.canUseExpCoin(count);
			break;
		case GameData.COMMON_ITEM_ID_ROB_MONEY:
			enough = this.canUseRobMoney(count);
			break;
		case GameData.COMMON_ITEM_ID_OFFLINE_FUNC_POINT:
			enough = this.canUseOfflineFuncPoint(count);
			break;
		case GameData.COMMON_ITEM_ID_SPLITSP:
			enough = this.canUseSplitSp(count);
			break;
		case GameData.COMMON_ITEM_ID_CREDIT:
			enough = this.canUseCredit(count);
			break;
		default:
			enough = this.bag.containsEnough(id, count);
			break;
		}
		return enough;
	}

	public boolean containsEnoughGameItems(Collection<SBean.DummyGoods> dgs)
	{
		Map<Integer, Integer> counter = GameData.toCounter(dgs);
		for (Map.Entry<Integer, Integer> e : counter.entrySet())
		{
			if (!containsEnoughGameItem(e.getKey(), e.getValue()))
				return false;
		}
		return true;
	}

	public boolean containsEquip(int id, String guid)
	{
		return this.bag.containsEquip(id, guid);
	}

	public CellItem getBagItem(int id)
	{
		return this.bag.getCellItem(id);
	}

	public void delGameItem(int id, int count, TLogger.GameItemRecords records)
	{
		switch (id)
		{
		case GameData.COMMON_ITEM_ID_DIAMOND:
			this.useDiamond(count, false, records);
			break;
		case -GameData.COMMON_ITEM_ID_DIAMOND:
			this.useDiamond(count, true, records);
			break;
		case GameData.COMMON_ITEM_ID_COIN:
			this.useCoin(count, false, records);
			break;
		case -GameData.COMMON_ITEM_ID_COIN:
			this.useCoin(count, true, records);
			break;
		case GameData.COMMON_ITEM_ID_SECT_MONEY:
			this.useSectContribution(count, records);
			break;
		case GameData.COMMON_ITEM_ID_ARENA_MONEY:
			this.useArenaPoint(count, records);
			break;
		case GameData.COMMON_ITEM_ID_SUPERARENA_MONEY:
			this.useSuperArenaPoint(count, records);
			break;
		case GameData.COMMON_ITEM_ID_MASTER_POINT:
			this.useMasterPoint(count, records);
			break;
		case GameData.COMMON_ITEM_ID_MASTER_REPUTATION:
			this.useMasterReputation(count, records);
			break;
		case GameData.COMMON_ITEM_ID_EQUIP_ENERGY:
			this.useEquipEnergy(count, records);
			break;
		case GameData.COMMON_ITEM_ID_GEM_ENERGY:
			this.useGemEnergy(count, records);
			break;
		case GameData.COMMON_ITEM_ID_BOOK_INSPIRATION:
			this.useBookInspiration(count, records);
			break;
		case GameData.COMMON_ITEM_ID_VIT:
			this.useVit(count, records);
			break;
//		case GameData.COMMON_ITEM_ID_XUANTIE:
//			this.useClanXuantie(count, records);
//			break;
//		case GameData.COMMON_ITEM_ID_YAOCAO:
//			this.useClanYaocao(count, records);
//			break;
		case GameData.COMMON_ITEM_ID_EXPCOIN:
			this.useExpCoin(count, records);
			break;
		case GameData.COMMON_ITEM_ID_ROB_MONEY:
			this.useRobMoney(count, records);
			break;
		case GameData.COMMON_ITEM_ID_OFFLINE_FUNC_POINT:
			this.useOfflineFuncPoint(count, records);
			break;
		case GameData.COMMON_ITEM_ID_SPLITSP:
			this.useSplitSp(count, records);
			break;
		case GameData.COMMON_ITEM_ID_CREDIT:
			this.useCredit(count, records);
			break;
		default:
			this.delBagItem(id, count, records);
			break;
		}
	}

	public void delGameItems(Collection<SBean.DummyGoods> dgs, TLogger.GameItemRecords records)
	{
		for (SBean.DummyGoods e : dgs)
		{
			this.delGameItem(e.id, e.count, records);
		}
	}

	public int addBagItem(SBean.GameItem gi, TLogger.GameItemRecords records)
	{
		int addCount = this.bag.putIn(gi);
		if (addCount > 0)
		{
			records.addProduce(gi.id, addCount, this.bag.getCount(gi.id));
			this.checkSuite(gi.id);
		}
		return addCount;
	}

	public int delBagItem(int id, int count, TLogger.GameItemRecords records)
	{
		int rDelCount = 0;
		int fDelCount = 0;
		if (id > 0)
		{
			rDelCount = this.bag.del(id, this.bag.calcSafeDel(id, count));
			fDelCount = count - rDelCount;
			fDelCount = this.bag.del(-id, fDelCount);
			if (rDelCount > 0)
				records.addConsume(id, rDelCount, this.bag.getCount(id));
			if (fDelCount > 0)
				records.addConsume(-id, fDelCount, this.bag.getCount(-id));
		}
		else
		{
			fDelCount = this.bag.del(id, count);
			if (fDelCount > 0)
				records.addConsume(id, fDelCount, this.bag.getCount(id));
		}
		return rDelCount + fDelCount;
	}

	public SBean.Counter lockBagItem(int id, int count)
	{
		int rDelCount = 0;
		int fDelCount = 0;
		if (id > 0)
		{
			rDelCount = this.bag.del(id, this.bag.calcSafeDel(id, count));
			fDelCount = count - rDelCount;
			this.bag.del(-id, fDelCount);
		}
		else
		{
			fDelCount = this.bag.del(id, count);
		}
		return new SBean.Counter(fDelCount, rDelCount);
	}

	public void delLockedBagItem(int id, SBean.Counter value, boolean cancel, TLogger.GameItemRecords records)
	{
		if (cancel)
		{
			int realId = id < 0 ? -id : id;
			this.bag.putIn(GameData.getInstance().toGameItem(-realId, value.fvalue));
			this.bag.putIn(GameData.getInstance().toGameItem(realId, value.rvalue));
		}
		else
		{
			int realId = id < 0 ? -id : id;
			if (value.fvalue > 0)
				records.addConsume(-realId, value.fvalue, this.bag.getCount(-realId));
			if (value.rvalue > 0)
				records.addConsume(realId, value.rvalue, this.bag.getCount(realId));
		}
	}

	public SBean.DBEquip delEquip(int id, String guid, TLogger.GameItemRecords records)
	{
		SBean.DBEquip equip = this.bag.del(id, guid);
		if (equip != null)
		{
			records.addConsume(id, 1, this.bag.getCount(id));
		}
		return equip;
	}

	public SBean.GameItem delEquips(int id, Set<String> guids, TLogger.GameItemRecords records)
	{
		SBean.GameItem gi = this.bag.del(id, guids);
		records.addConsume(id, guids.size(), this.bag.getCount(id));
		return gi;
	}

	public SBean.DBEquip lockEquip(int id, String guid)
	{
		return this.bag.del(id, guid);
	}

	public void delLockedEquip(SBean.DBEquip equip, boolean cancel, TLogger.GameItemRecords records)
	{
		if (cancel)
		{
			this.bag.putIn(GameData.toGameItem(equip));
		}
		else
		{
			records.addConsume(equip.id, 1, this.bag.getCount(equip.id));
		}
	}

	//	public SBean.GameItem lockEquips(int id, Set<String> guids)
	//	{
	//		return this.bag.del(id, guids);
	//	}
	//
	//	public void delLockedEquip(SBean.GameItem gi, boolean cancel, TLogger.GameItemRecords records)
	//	{
	//		if (cancel)
	//		{
	//			if (gi != null)
	//				this.bag.putInBag(gi);
	//		}
	//		else
	//		{
	//			//records.addConsume(gi.id, this.bag.getCount(equip.id), equip.guid);
	//		}
	//	}

	public int getDiamond(boolean free)
	{
		return free ? this.diamondF : this.diamondR;
	}

	public int getCoin(boolean free)
	{
		return free ? this.coinF : this.coinR;
	}

	public boolean canUseDiamond(int amount, boolean free)
	{
		return (free ? this.diamondF : (this.diamondF + this.diamondR)) >= amount;
	}

	public boolean canUseCoin(int amount, boolean free)
	{
		return (free ? this.coinF : (this.coinF + this.coinR)) >= amount;
	}

	static int calSafeUse(int value, int amount)
	{
		if (amount > 0)
		{
			int finalVal = value - amount;
			if (finalVal < 0)
				finalVal = 0;
			return value - finalVal;
		}
		return 0;
	}

	public int useDiamond(int amount, boolean free, TLogger.GameItemRecords records)
	{
		return useDiamond(amount, free, false, records);
	}

	public int useDiamond(int amount, boolean free, boolean forceNoLog, TLogger.GameItemRecords records)
	{
		int rUse = free ? 0 : calSafeUse(this.diamondR, amount);
		this.diamondR -= rUse;
		int fUse = calSafeUse(this.diamondF, amount - rUse);
		this.diamondF -= fUse;

		if (!forceNoLog)
		{
			this.diamondRUseTotal += rUse;
			this.diamondFUseTotal += fUse;
			this.logConsumeOnConsumeGift(fUse);
			if (rUse > 0)
				testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_BIND_DIAMOND, 0);
			if (fUse > 0)
				testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_FREE_DIAMOND, 0);
		}
		if (rUse > 0)
			records.addConsume(GameData.COMMON_ITEM_ID_DIAMOND, rUse, this.diamondR);
		if (fUse > 0)
			records.addConsume(-GameData.COMMON_ITEM_ID_DIAMOND, fUse, this.diamondF);
		return rUse + fUse;
	}

	public SBean.Counter lockDiamond(int amount, boolean free)
	{
		int rUse = free ? 0 : calSafeUse(this.diamondR, amount);
		this.diamondR -= rUse;
		int fUse = calSafeUse(this.diamondF, amount - rUse);
		this.diamondF -= fUse;
		return new SBean.Counter(fUse, rUse);
	}

	public void useLockedDiamond(SBean.Counter value, boolean cancel, boolean forceNoLog, TLogger.GameItemRecords records)
	{
		if (cancel)
		{
			this.diamondF += value.fvalue;
			this.diamondR += value.rvalue;
		}
		else
		{
			if (!forceNoLog)
			{
				this.diamondRUseTotal += value.rvalue;
				this.diamondFUseTotal += value.fvalue;
				this.logConsumeOnConsumeGift(value.fvalue);
				if (value.rvalue > 0)
					testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_BIND_DIAMOND, 0);
				if (value.fvalue > 0)
					testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_FREE_DIAMOND, 0);
			}
			if (value.rvalue > 0)
				records.addConsume(GameData.COMMON_ITEM_ID_DIAMOND, value.rvalue, this.diamondR);
			if (value.fvalue > 0)
				records.addConsume(-GameData.COMMON_ITEM_ID_DIAMOND, value.fvalue, this.diamondF);
		}
	}

	public void useLockedDiamond(SBean.Counter value, boolean cancel, TLogger.GameItemRecords records)
	{
		this.useLockedDiamond(value, cancel, false, records);
	}

	public int useCoin(int amount, boolean free, TLogger.GameItemRecords records)
	{
		int rUse = free ? 0 : calSafeUse(this.coinR, amount);
		this.coinR -= rUse;

		int fUse = calSafeUse(this.coinF, amount - rUse);
		this.coinF -= fUse;

		this.coinRUseTotal += rUse;
		this.coinFUseTotal += fUse;
		if (rUse > 0)
		{
			testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_BIND_COIN, 0);
			records.addConsume(GameData.COMMON_ITEM_ID_COIN, rUse, this.coinR);
		}
		if (fUse > 0)
		{
			testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_FREE_COIN, 0);
			records.addConsume(-GameData.COMMON_ITEM_ID_COIN, fUse, this.coinF);
		}
		return rUse + fUse;
	}

	public SBean.Counter lockCoin(int amount, boolean free)
	{
		int rUse = free ? 0 : calSafeUse(this.coinR, amount);
		this.coinR -= rUse;
		int fUse = calSafeUse(this.coinF, amount - rUse);
		this.coinF -= fUse;
		return new SBean.Counter(fUse, rUse);
	}

	public void useLockedCoin(SBean.Counter value, boolean cancel, TLogger.GameItemRecords records)
	{
		if (cancel)
		{
			this.coinF += value.fvalue;
			this.coinR += value.rvalue;
		}
		else
		{
			this.coinRUseTotal += value.rvalue;
			this.coinFUseTotal += value.fvalue;
			if (value.rvalue > 0)
			{
				testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_BIND_COIN, 0);
				records.addConsume(GameData.COMMON_ITEM_ID_COIN, value.rvalue, this.coinR);
			}
			if (value.fvalue > 0)
			{
				testChallengeTask(GameData.CHALLENGE_TASK_ID_USE_FREE_COIN, 0);
				records.addConsume(-GameData.COMMON_ITEM_ID_COIN, value.fvalue, this.coinF);
			}
		}
	}

	static int calSafeAdd(int value, int amount)
	{
		if (amount > 0)
		{
			int finalVal = value + amount;
			if (finalVal > GameData.MAX_CURRENCY_AMOUNT || finalVal <= 0)
				finalVal = GameData.MAX_CURRENCY_AMOUNT;
			return finalVal - value;
		}
		return 0;
	}

	public int addDiamond(int amount, boolean free, TLogger.GameItemRecords records)
	{
		int add = 0;
		if (free)
		{
			add = calSafeAdd(this.diamondF, amount);
			this.diamondF += add;
			records.addProduce(-GameData.COMMON_ITEM_ID_DIAMOND, add, this.diamondF);
		}
		else
		{
			add = calSafeAdd(this.diamondR, amount);
			this.diamondR += add;
			records.addProduce(GameData.COMMON_ITEM_ID_DIAMOND, add, this.diamondR);
		}
		return add;
	}

	public int addCoin(int amount, boolean free, TLogger.GameItemRecords records)
	{
		int add = 0;
		if (free)
		{
			add = calSafeAdd(this.coinF, amount);
			this.coinF += add;
			records.addProduce(-GameData.COMMON_ITEM_ID_COIN, add, this.coinF);
		}
		else
		{
			add = calSafeAdd(this.coinR, amount);
			this.coinR += add;
			records.addProduce(GameData.COMMON_ITEM_ID_COIN, add, this.coinR);
		}
		return add;
	}

	public int syncAddDiamond(int amount, boolean free, TLogger.TLogEvent tLogger)
	{
		int add = this.addDiamond(amount, free, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_diamond(add, free ? 1 : 0, tLogger.eventID));
		return add;
	}

	public int syncAddCoin(int amount, boolean free, TLogger.TLogEvent tLogger)
	{
		int add = this.addCoin(amount, free, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_coin(add, free ? 1 : 0, tLogger.eventID));
		return add;
	}

	public int syncAddEquipEnergy(int value, TLogger.TLogEvent tLogger)
	{
		int add = this.addEquipEnergy(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_equipenergy(add, tLogger.eventID));
		return add;
	}

	int addEquipEnergy(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.equipEnergy += value;
		records.addProduce(GameData.COMMON_ITEM_ID_EQUIP_ENERGY, value, this.equipEnergy);
		return value;
	}

	boolean canUseEquipEnergy(int value)
	{
		return this.equipEnergy >= value;
	}

	int useEquipEnergy(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.equipEnergy >= value ? value : this.equipEnergy;
		this.equipEnergy -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_EQUIP_ENERGY, use, this.equipEnergy);
		return use;
	}

	public int syncAddGemEnergy(int value, TLogger.TLogEvent tLogger)
	{
		int add = this.addGemEnergy(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_gemenergy(add, tLogger.eventID));
		return add;
	}

	int addGemEnergy(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.gemEnergy += value;
		records.addProduce(GameData.COMMON_ITEM_ID_GEM_ENERGY, value, this.gemEnergy);
		return value;
	}

	boolean canUseGemEnergy(int value)
	{
		return this.gemEnergy >= value;
	}

	int useGemEnergy(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.gemEnergy >= value ? value : this.gemEnergy;
		this.gemEnergy -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_GEM_ENERGY, use, this.gemEnergy);
		return use;
	}

	public int syncAddBookInspiration(int value, TLogger.TLogEvent tLogger)
	{
		int add = this.addBookInspiration(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_bookinspiration(add, tLogger.eventID));
		return add;
	}

	int addBookInspiration(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.bookInspiration += value;
		records.addProduce(GameData.COMMON_ITEM_ID_BOOK_INSPIRATION, value, this.bookInspiration);
		return value;
	}

	boolean canUseBookInspiration(int value)
	{
		return this.bookInspiration >= value;
	}

	int useBookInspiration(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.bookInspiration >= value ? value : this.bookInspiration;
		this.bookInspiration -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_BOOK_INSPIRATION, use, this.bookInspiration);
		return use;
	}

	//charm
	public int syncAddCharm(int addCharm)
	{
		int add = this.addCharm(addCharm);
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_charm(add));
		return add;
	}

	int addCharm(int addCharm)
	{
		if (addCharm <= 0)
			return 0;

		this.friend.addCharm(addCharm);
		gs.getRankManager().tryUpdateRoleRank(this.gender == 1 ? GameData.RANK_TYPE_CHARM_MALE : GameData.RANK_TYPE_CHARM_FEMALE, new SBean.RankRole(this.getRoleOverview(), this.friend.getCharm()));
		//更新宗门排行榜（女宗）
//		modifyClanRank();
		return this.friend.getCharm();
	}

	static int calcAddRevertValue(int addValue, int curValue, int maxValue, boolean exceedMaxValue)
	{
		int finalAdd = addValue;
		if (!exceedMaxValue)
		{
			int afterAdd = curValue + addValue;
			if (afterAdd > maxValue)
				afterAdd = maxValue;
			finalAdd = afterAdd - curValue;
		}
		return finalAdd;
	}

	static int testCalcStartOrStopRevert(int curValue, int maxValue, int revertTime)
	{
		if (revertTime == 0)
		{
			if (curValue < maxValue)
				return GameTime.getTime();
		}
		else
		{
			if (curValue >= maxValue)
				return 0;
		}
		return revertTime;
	}

	public int syncAddVit(int addVit, TLogger.TLogEvent tLogger)
	{
		int add = this.addVit(addVit, true, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_vit(add, tLogger.eventID));
		return add;
	}

	int addVit(int vitAdd, boolean exceedMaxVit, TLogger.GameItemRecords records)
	{
		if (vitAdd <= 0)
			return 0;
		int maxVit = GameData.getInstance().getMaxVit(this.level);
		int finalVitAdd = calcAddRevertValue(vitAdd, this.vit, maxVit, exceedMaxVit);
		this.vit += finalVitAdd;
		this.vitRevertTime = testCalcStartOrStopRevert(this.vit, maxVit, this.vitRevertTime);
		records.addProduce(GameData.COMMON_ITEM_ID_VIT, finalVitAdd, this.vit);
		return finalVitAdd;
	}

	boolean canUseVit(int value)
	{
		return this.vit >= value;
	}

	int useVit(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.vit >= value ? value : this.vit;
		this.vit -= use;
		this.dayUseVit += use;
		int maxVit = GameData.getInstance().getMaxVit(this.level);
		this.vitRevertTime = testCalcStartOrStopRevert(this.vit, maxVit, this.vitRevertTime);

		records.addConsume(GameData.COMMON_ITEM_ID_VIT, use, this.vit);
		return use;
	}

	void tryRefreshVit(int timeTick)
	{
		if (this.vitRevertTime > 0)
		{
			int d = timeTick - this.vitRevertTime;
			int interval = GameData.getInstance().getCommonCFG().vit.revertInterval;
			if (d > interval)
			{
				int n = d / interval;
				int r = d % interval;
				this.vitRevertTime = timeTick - r;
				int oldVit = this.vit;
				TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRY_REFRESH_VIT);
				this.addVit(n * GameData.getInstance().getCommonCFG().vit.revertValue, false, tlogEvent.getGameItemRecords());
				tlogEvent.setArg(n, GameData.getInstance().getCommonCFG().vit.revertValue);
				gs.getTLogger().logRoleEventFlow(this, tlogEvent); // 每秒刷新日志
				gs.getLogger().debug("role " + this.id + " try revert vit " + n + ", (" + oldVit + " ==> " + this.vit + ")/" + GameData.getInstance().getMaxVit(this.level));
			}
		}
	}

	// 生产相关
	public int syncAddSplitSP(int spAdd, TLogger.TLogEvent tLogger)
	{
		int add = this.addSplitSP(spAdd, true, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_splitsp(add, tLogger.eventID));
		return add;
	}

	int addSplitSP(int spAdd, boolean exceedMaxSP, TLogger.GameItemRecords records)
	{
		int add = addSplitSPImpl(spAdd, exceedMaxSP);
		records.addProduce(GameData.COMMON_ITEM_ID_SPLITSP, add, this.produce.splitSP);
		return add;
	}

	int addSplitSPImpl(int spAdd, boolean exceedMaxSP)
	{
		if (spAdd <= 0)
			return 0;
		int maxSP = GameData.getInstance().getMaxSplitSP(this.getUseableVipLvl());
		int finalSpAdd = calcAddRevertValue(spAdd, this.produce.splitSP, maxSP, exceedMaxSP);;
		this.produce.splitSP += finalSpAdd;
		this.produce.splitSPRevertTime = testCalcStartOrStopRevert(this.produce.splitSP, maxSP, this.produce.splitSPRevertTime);
		return finalSpAdd;
	}

	private boolean canUseSplitSp(int sp)
	{
		return this.produce.splitSP >= sp;
	}

	int useSplitSp(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.produce.splitSP >= value ? value : this.produce.splitSP;
		this.produce.splitSP -= use;
		int maxSP = GameData.getInstance().getMaxSplitSP(this.getUseableVipLvl());
		this.produce.splitSPRevertTime = testCalcStartOrStopRevert(this.produce.splitSP, maxSP, this.produce.splitSPRevertTime);
		records.addConsume(GameData.COMMON_ITEM_ID_SPLITSP, value, this.produce.splitSP);
		return use;
	}

	void tryRefreshSplitSP(int timeTick)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRY_REFRESH_SPLIT_SP);
		if (this.produce.splitSPRevertTime > 0)
		{
			int d = timeTick - this.produce.splitSPRevertTime;
			int interval = GameData.getInstance().getProduceCFGS().spRevertInterval;
			if (d > interval)
			{
				int n = d / interval;
				int r = d % interval;
				this.produce.splitSPRevertTime = timeTick - r;
				tlogEvent.setArg(n);
				this.addSplitSP(n * GameData.getInstance().getProduceCFGS().spRevertCount, false, tlogEvent.getGameItemRecords());
			}
		}
		//		gs.getTLogger().logRoleEventFlow(this, tlogEvent);  // 每秒输出日志
	}

	// 同时添加服务器和客户端帮贡值
	public int syncAddSectContribution(int value, TLogger.GameItemRecords records)
	{
		int add = addSectContribution(value, records);
		if (add > 0)
		{
			gs.getLoginManager().addNormalTaskEvent(new Runnable()
			{
				@Override
				public void run()
				{
					gs.getSectManager().roleAddSectContribution(Role.this, add);
				}
			});
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_sectcontribution(value));
		}
		return add;
	}

	public int addSectContribution(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.sectData.data.contribution += value;
		this.sectData.data.historyContribution += value;
		records.addProduce(GameData.COMMON_ITEM_ID_SECT_MONEY, value, this.sectData.data.contribution);
		return value;
	}

	int useSectContribution(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.sectData.data.contribution >= value ? value : this.sectData.data.contribution;
		this.sectData.data.contribution -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_SECT_MONEY, use, this.sectData.data.contribution);
		return use;
	}

	boolean canUseSectContribution(int value)
	{
		return this.sectData.data.contribution >= value;
	}

	// 同时添加服务器和客户端个人竞技场代币
	public int syncAddArenaPoint(int value, TLogger.TLogEvent tLogger)
	{
		int add = addArenaPoint(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_arenapoint(value, tLogger.eventID));
		return add;
	}

	public int addArenaPoint(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.arenaInfo.roleArenaData.normal.point += value;
		this.arenaInfo.roleArenaData.normal.historyPoint += value;
		records.addProduce(GameData.COMMON_ITEM_ID_ARENA_MONEY, value, this.arenaInfo.roleArenaData.normal.point);
		return value;
	}

	boolean canUseArenaPoint(int value)
	{
		return this.arenaInfo.roleArenaData.normal.point >= value;
	}

	int useArenaPoint(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.arenaInfo.roleArenaData.normal.point >= value ? value : this.arenaInfo.roleArenaData.normal.point;
		this.arenaInfo.roleArenaData.normal.point -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_ARENA_MONEY, use, this.arenaInfo.roleArenaData.normal.point);
		return use;
	}
	
	// 同时添加服务器和客户端4v4竞技场代币
	public int syncAddSuperArenaPoint(int value, TLogger.TLogEvent tLogger)
	{
		int add = addSuperArenaPoint(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_superarenahonor(value, tLogger.eventID));
		return add;
	}

	public int addSuperArenaPoint(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.arenaInfo.roleArenaData.superarena.point += value;
		this.arenaInfo.roleArenaData.superarena.historyPoint += value;
		records.addProduce(GameData.COMMON_ITEM_ID_SUPERARENA_MONEY, value, this.arenaInfo.roleArenaData.superarena.point);
		return value;
	}

	boolean canUseSuperArenaPoint(int value)
	{
		return this.arenaInfo.roleArenaData.superarena.point >= value;
	}

	int useSuperArenaPoint(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.arenaInfo.roleArenaData.superarena.point >= value ? value : this.arenaInfo.roleArenaData.superarena.point;
		this.arenaInfo.roleArenaData.superarena.point -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_SUPERARENA_MONEY, use, this.arenaInfo.roleArenaData.superarena.point);
		return use;
	}
	
	//商誉值
	public int syncAddCredit(int value, TLogger.TLogEvent tLogger)
	{
		int add = addCredit(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_credit(value, tLogger.eventID));
		return add;
	}
	
	public int addCredit(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.credit += value;
		records.addProduce(GameData.COMMON_ITEM_ID_CREDIT, value, this.credit);
		return value;
	}
	
	boolean canUseCredit(int value)
	{
		return this.credit >= value;
	}
	
	int useCredit(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = this.credit >= value ? value : this.credit;
		this.credit -= use;
		this.creditUseTotal += use;
		records.addConsume(GameData.COMMON_ITEM_ID_CREDIT, use, this.credit);
		return use;
	}
	
	public int lockCredit(int value)
	{
		int use = calSafeUse(this.credit, value);
		this.credit -= use;
		return use;
	}
	
	public void useLockCredit(int use, TLogger.GameItemRecords records)
	{
		if(records == null)
		{
			this.credit += use;
		}
		else
		{
			this.creditUseTotal += use;
			records.addConsume(GameData.COMMON_ITEM_ID_CREDIT, use, this.credit);
		}
	}
	
//	//玄铁
//	public int addClanXuantie(int value, TLogger.GameItemRecords records)
//	{
//		if (value <= 0)
//			return 0;
//		this.clanData.data.xuantie += value;
//		records.addProduce(GameData.COMMON_ITEM_ID_XUANTIE, value, this.clanData.data.xuantie);
//		return value;
//	}
//
//	public int useClanXuantieImpl(int value)
//	{
//		if (value <= 0)
//			return 0;
//		int use = this.clanData.data.xuantie >= value ? value : this.clanData.data.xuantie;
//		this.clanData.data.xuantie -= use;
//		return use;
//	}
//
//	public int useClanXuantie(int value, TLogger.GameItemRecords records)
//	{
//		int use = useClanXuantieImpl(value);
//		records.addConsume(GameData.COMMON_ITEM_ID_XUANTIE, use, this.clanData.data.xuantie);
//		return use;
//	}
//
//	public int lockClanXuantie(int value)
//	{
//		return useClanXuantieImpl(value);
//	}
//
//	public void useLockedClanXuantie(int value, boolean cancel, TLogger.GameItemRecords records)
//	{
//		if (cancel)
//		{
//			this.clanData.data.xuantie += value;
//		}
//		else
//		{
//			records.addConsume(GameData.COMMON_ITEM_ID_XUANTIE, value, this.clanData.data.xuantie);
//		}
//	}
//
//	public boolean canUseClanXuantie(int value)
//	{
//		return this.clanData.data.xuantie >= value;
//	}
//
//	public int getClanXuantie()
//	{
//		return this.clanData.data.xuantie;
//	}
//
//	//药材
//	public int addClanYaocao(int value, TLogger.GameItemRecords records)
//	{
//		if (value <= 0)
//			return 0;
//		this.clanData.data.yaocao += value;
//		records.addProduce(GameData.COMMON_ITEM_ID_YAOCAO, value, this.clanData.data.yaocao);
//		return value;
//	}
//
//	public int useClanYaocaoImpl(int value)
//	{
//		if (value <= 0)
//			return 0;
//		int use = this.clanData.data.yaocao >= value ? value : this.clanData.data.yaocao;
//		this.clanData.data.yaocao -= use;
//		return use;
//	}
//
//	public int useClanYaocao(int value, TLogger.GameItemRecords records)
//	{
//		int use = useClanYaocaoImpl(value);
//		records.addConsume(GameData.COMMON_ITEM_ID_YAOCAO, use, this.clanData.data.yaocao);
//		return use;
//	}
//
//	public int lockClanYaocao(int value)
//	{
//		return useClanYaocaoImpl(value);
//	}
//
//	public void useLockedClanYaocao(int value, boolean cancel, TLogger.GameItemRecords records)
//	{
//		if (cancel)
//		{
//			this.clanData.data.yaocao += value;
//		}
//	}
//
//	public boolean canUseClanYaocao(int value)
//	{
//		return this.clanData.data.yaocao >= value;
//	}
//
//	public int getClanYaocao()
//	{
//		return this.clanData.data.yaocao;
//	}

	// 同时添加服务器和客户端帮历练币	
	public int syncAddExpCoin(int value, TLogger.TLogEvent tLogger)
	{
		int add = addExpCoin(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_expcoin(add, tLogger.eventID));
		return add;
	}
	
	public int tryChangeExpToExpCoin(long exp)
	{
		int value = this.roleExpCoin.changetoExpCoin(exp);
		if (value > 0)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ADD_EXP_COIN);
			syncAddExpCoin(value, tlogEvent);
			tlogEvent.setArg(value, this.roleExpCoin.expCoinData.outExp);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);

		}
		return value;
	}

	public int addExpCoin(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;

		return this.roleExpCoin.addExpCoin(value, records);
	}

	public int syncAddOfflineFuncPoint(int value, TLogger.TLogEvent tLogger)
	{
		int add = addOfflineFuncPoint(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_offline_func_point(add, tLogger.eventID));
		return add;
	}
	
	public int addOfflineFuncPoint(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int maxValue = GameData.getInstance().getOfflineExpCFG().maxFuncPoint;
		if (this.offlineWizard.funcPoint + value > maxValue)
		{
			value = maxValue - this.offlineWizard.funcPoint;
			this.offlineWizard.funcPoint = maxValue;
		}
		else
		{
			this.offlineWizard.funcPoint += value;
		}
		if (value > 0)
			records.addProduce(GameData.COMMON_ITEM_ID_OFFLINE_FUNC_POINT, value, this.offlineWizard.funcPoint);
		return value;
	}

	private boolean canAddExpCoin()
	{
		return this.level >= GameData.getInstance().getExpCoinBaseCFGS().lvlReq && this.roleExpCoin.canAddExpCoin();
	}

	boolean canUseExpCoin(int value)
	{
		return this.roleExpCoin.canUseExpCoin(value);
	}

	int useExpCoin(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;

		int use = this.roleExpCoin.useExpCoin(value, records);
		return use;
	}
	
	//武勋
	public int syncAddForceWarFeat(int value)
	{
		int add = addForceWarFeat(value);
		if(add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_feat(value));
		
		return add;
	}
	
	public int addForceWarFeat(int value)
	{
		if (value <= 0)
			return 0;
	
		this.forceWarInfo.forcewar.totalFeats += value;
		int newLvl = GameData.getInstance().getForceWarTotalFeatLvl(this.forceWarInfo.forcewar.totalFeats);
		if(newLvl > this.forceWarInfo.totalFeatLvl)
		{
			for(int oldLvl = this.forceWarInfo.totalFeatLvl; oldLvl < newLvl; oldLvl ++)
			{
				final SBean.ForceWarRewardCFGS oldCfg = GameData.getInstance().getForceWarReward(oldLvl);
				if(oldCfg != null)
					this.delRoleTitle(this.BWType == GameData.BWTYPE_BLACK ? oldCfg.blackTitle : oldCfg.whiteTitle);
			}
			
			
			final SBean.ForceWarRewardCFGS newCfg = GameData.getInstance().getForceWarReward(newLvl);
			int title = this.BWType == GameData.BWTYPE_BLACK ? newCfg.blackTitle : newCfg.whiteTitle;
			if(title > 0)
				this.addRoleTitle(title);
			
			this.forceWarInfo.totalFeatLvl = newLvl;
		}
		return value;
	}

	public int syncAddRobMoney(int value, TLogger.TLogEvent tLogger)
	{
		int add = addRobMoney(value, tLogger.getGameItemRecords());
		if (add > 0)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_robmoney(value, tLogger.eventID));
		return add;
	}
	
	private boolean canUseRobMoney(int count)
	{
		return this.sectDeliver.robMoney >= count;
	}

	private boolean canUseOfflineFuncPoint(int count)
	{
		return this.offlineWizard.funcPoint >= count;
	}

	private int addRobMoney(int count, GameItemRecords records)
	{
		int finalnum = addRobMoney(count);
		records.addProduce(GameData.COMMON_ITEM_ID_ROB_MONEY, count, finalnum);
		return count;
	}
	
	private int addRobMoney(int count)
	{
		if (count <= 0)
			return 0;
		this.sectDeliver.robMoney += count;
		this.sectDeliver.historyRobMoney += count;
		return this.sectDeliver.robMoney;
	}
	
	private int useRobMoney(int count, GameItemRecords records)
	{
		if (count <= 0)
			return 0;
		int use = this.sectDeliver.robMoney >= count ? count : this.sectDeliver.robMoney;
		this.sectDeliver.robMoney -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_ROB_MONEY, use, this.sectDeliver.robMoney);
		return use;
	}
	
	private int useOfflineFuncPoint(int count, GameItemRecords records)
	{
		if (count <= 0)
			return 0;
		int use = this.offlineWizard.funcPoint >= count ? count : this.offlineWizard.funcPoint;
		this.offlineWizard.funcPoint -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_OFFLINE_FUNC_POINT, use, this.offlineWizard.funcPoint);
		return use;
	}
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//this.fashionEquip.isShow 改成 showFashionTypes 的修正
	private void initShowFashions()
	{
		if(this.fashionEquip.idle == 0)
			return;
		
		for(int fashionType: GameData.getInstance().getAllFashionTypes())
		{
			this.showFashionTypes.put(fashionType, 1);
		}
		
		this.fashionEquip.idle = 0;
	}
	
	private boolean containFashionEquip(int fashionID)
	{
		return this.fashionEquip.allFashions.containsKey(fashionID);
	}

	synchronized void addFashionEquip(int fashionID)
	{
		this.fashionEquip.allFashions.put(fashionID, new SBean.DBFashion(fashionID, new ArrayList<>(), 0, 0, 0, 0));
	}

	private void updateFashionEquip(int type, byte isShow, int fashionID)
	{
		this.roleProperties.onUpWearFashion(type, fashionID);
		gs.getMapService().syncRoleUpWearFashions(this.gameMapContext.getCurMapId(), this.id, type, fashionID, isShow);
	}

	synchronized boolean upWearFashionEquip(int fashionID)
	{
		if (!this.containFashionEquip(fashionID))
			return false;

		SBean.FashionCFGS fashionCfg = GameData.getInstance().getFashionCFGS(fashionID);
		if (fashionCfg == null || (fashionCfg.sex != 0 && fashionCfg.sex != this.gender))
			return false;
		
		this.fashionEquip.curFashions.put(fashionCfg.type, fashionID);
		this.updateFashionEquip(fashionCfg.type, (byte) 1, fashionID);
		this.setFashionShow(fashionCfg.type, (byte) 1);
		return true;
	}

	synchronized boolean setFashionShow(int type, int show)
	{
		switch (type)
		{
		case GameData.FASHION_TYPE_WEAPON:
		case GameData.FASHION_TYPE_CLOTHES:
		case GameData.FASHION_TYPE_OTHER:
			break;
		default:
			return false;
		}
		
		Integer fashionID = this.fashionEquip.curFashions.get(type);
		if(fashionID == null || fashionID == 0)
			return false;
		
		int oldShow = this.showFashionTypes.getOrDefault(type, 0);
		if(oldShow == show)
			return false;
		this.showFashionTypes.put(type, show);
		gs.getMapService().syncRoleUpWearFashions(this.gameMapContext.getCurMapId(), this.id, type, fashionID, show);
		return true;
	}
	////////////////////////////////////////////////////////bag/////////////////////////////////////////////////////////////
	public synchronized boolean expandBagCells(int times)
	{
		if (this.bag.getExpandTimes() + 1 != times)
			return false;
		if (times > GameData.getInstance().getCommonCFG().bag.extendCellSize)
			return false;
		int cost = GameData.getTimesCost(GameData.getInstance().getCommonCFG().bag.extendCellCost, times);
		if (!this.canUseDiamond(cost, false))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EXPAND_BAG_CELLS);
		tlogEvent.setArg(times, cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.bag.expand(GameData.getInstance().getCommonCFG().bag.extendCellCount);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean sellBagEquip(int id, String guid)
	{
		CellItem bi = this.getBagItem(id);
		if (bi == null || !bi.contains(guid))
			return false;
		CellItem.Salable salable = bi.getSalable();
		if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_EQUIP_ENERGY)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SELL_BAG_EQUIP);
		tlogEvent.setArg(id, salable.getSalePrice());
		tlogEvent.setArg(guid);
		this.delEquip(id, guid, tlogEvent.getGameItemRecords());
		this.syncAddEquipEnergy(salable.getSalePrice(), tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean sellBagItem(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null || bi.getCount() < count)
			return false;
		CellItem.Salable salable = bi.getSalable();
		if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_COIN)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SELL_BAG_ITEM);
		tlogEvent.setArg(id, count, salable.getSalePrice());
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddCoin((salable.getSalePrice() * count), false, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean sellBagGem(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null || bi.getCount() < count)
			return false;
		CellItem.Salable salable = bi.getSalable();
		if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_GEM_ENERGY)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SELL_BAG_GEM);
		tlogEvent.setArg(id, count, salable.getSalePrice());
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddGemEnergy(salable.getSalePrice() * count, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean sellBagBook(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null || bi.getCount() < count)
			return false;
		CellItem.Salable salable = bi.getSalable();
		if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_BOOK_INSPIRATION)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SELL_BAG_BOOK);
		tlogEvent.setArg(id, count, salable.getSalePrice());
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddBookInspiration(salable.getSalePrice() * count, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean batchSellBagEquips(Map<Integer, SBean.KinEquips> equips)
	{
		int totalPrice = 0;
		for (SBean.KinEquips e : equips.values())
		{
			CellItem bi = this.getBagItem(e.id);
			if (bi == null || e.guids.isEmpty() || !bi.contains(e.guids))
				return false;
			CellItem.Salable salable = bi.getSalable();
			if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_EQUIP_ENERGY)
				return false;
			totalPrice += salable.getSalePrice() * e.guids.size();
		}

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BATCH_SELL_BAG_EQUIPS);
		for (SBean.KinEquips e : equips.values())
		{
			tlogEvent.setArg(e.id, totalPrice);
			this.delEquips(e.id, e.guids, tlogEvent.getGameItemRecords());
		}
		this.syncAddEquipEnergy(totalPrice, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean batchSellBagGems(List<SBean.DummyGoods> items)
	{
		int totalPrice = 0;
		for (SBean.DummyGoods e : items)
		{
			CellItem bi = this.getBagItem(e.id);
			if (e.count <= 0 || bi == null || bi.getCount() < e.count)
				return false;
			CellItem.Salable salable = bi.getSalable();
			if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_GEM_ENERGY)
				return false;
			totalPrice += salable.getSalePrice() * e.count;
		}
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BATCH_SELL_BAG_GEMS);
		for (SBean.DummyGoods e : items)
		{
			tlogEvent.setArg(e.id, e.count, totalPrice);
			this.delGameItem(e.id, e.count, tlogEvent.getGameItemRecords());
		}
		this.syncAddGemEnergy(totalPrice, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean batchSellBagBooks(List<SBean.DummyGoods> items)
	{
		int totalPrice = 0;
		for (SBean.DummyGoods e : items)
		{
			CellItem bi = this.getBagItem(e.id);
			if (e.count <= 0 || bi == null || bi.getCount() < e.count)
				return false;
			CellItem.Salable salable = bi.getSalable();
			if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_BOOK_INSPIRATION)
				return false;
			totalPrice += salable.getSalePrice() * e.count;
		}
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BATCH_SELL_BAG_BOOKS);
		for (SBean.DummyGoods e : items)
		{
			tlogEvent.setArg(e.id, e.count, totalPrice);
			this.delGameItem(e.id, e.count, tlogEvent.getGameItemRecords());
		}
		this.syncAddBookInspiration(totalPrice, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean batchSellBagItems(List<SBean.DummyGoods> items)
	{
		int totalPrice = 0;
		for (SBean.DummyGoods e : items)
		{
			CellItem bi = this.getBagItem(e.id);
			if (e.count <= 0 || bi == null || bi.getCount() < e.count)
				return false;
			CellItem.Salable salable = bi.getSalable();
			if (salable == null || salable.getSalePrice() <= 0 || salable.getSalePriceUnitID() != GameData.COMMON_ITEM_ID_COIN)
				return false;
			totalPrice += salable.getSalePrice() * e.count;
		}
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BATCH_SELL_BAG_ITEMS);
		for (SBean.DummyGoods e : items)
		{
			tlogEvent.setArg(e.id, e.count, totalPrice);
			this.delGameItem(e.id, e.count, tlogEvent.getGameItemRecords());
		}

		this.syncAddCoin(totalPrice, false, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public static class ItemInfoReq
	{
		public String id;
		public int count;

		public ItemInfoReq(String id, int count)
		{
			this.id = id;
			this.count = count;
		}
	}

	public synchronized int useItemGiftBox(int id, int count)
	{
		CellItem vi = this.getBagItem(id);
		if (count <= 0 || vi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = vi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;

		CellItem.GiftBox itemBox = useable.useAsGiftBox();
		if (itemBox == null)
			return GameData.PROTOCOL_OP_FAILED;

		SBean.GiftCFGS cfg = GameData.getInstance().getGiftCFG(itemBox.getGiftID());
		if (cfg == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (itemBox.getCostItemID() != 0 && !this.containsEnoughGameItem(itemBox.getCostItemID(), itemBox.getCostItemCount() * count))
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		List<SBean.DummyGoods> gifts = new ArrayList<SBean.DummyGoods>();
		for (SBean.DummyGoods e : cfg.gifts)
			gifts.add(new SBean.DummyGoods(e.id, e.count * count));
		if (!this.canAddGameItems(gifts))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_GIFT_BOX);
		tlogEvent.setArg(id, count);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		if (itemBox.getCostItemID() != 0)
			this.delGameItem(itemBox.getCostItemID(), itemBox.getCostItemCount() * count, tlogEvent.getGameItemRecords());

		this.syncAddGameItems(GameData.getInstance().toGameItems(gifts), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemDiamondBag(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.DiamondAdder diamondBox = useable.useAsDiamondAdder();
		if (diamondBox == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		int diamondCount = diamondBox.getAmount() * count;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_DIAMOND_BAG);
		tlogEvent.setArg(id, count, diamondCount);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddDiamond(diamondCount, diamondBox.isFree(), tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemCoinBag(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.CoinAdder coinBox = useable.useAsCoinAdder();
		if (coinBox == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_COIN_BAG);
		int coinCount = coinBox.getAmount() * count;
		tlogEvent.setArg(id, count, coinCount);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddCoin(coinCount, coinBox.isFree(), tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemExp(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.ExpAdder expAdder = useable.useAsExpAdder();
		if (expAdder == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;
		if (!canAddExp())
			return GameData.PROTOCOL_OP_FAILED;

		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_EXP);
		tlogEvent.setArg(id, count);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddExp(expAdder.getExp() * (long)count, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemHpPool(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.HPPool hpPool = useable.useAsHPPool();
		if (hpPool == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_HP_POOL);
		tlogEvent.setArg(id, count);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.hpPool += hpPool.getHPPoolAddValue() * count;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemHp(int id, int count)
	{
		if (!this.gameMapContext.getCurMapContext().canUseHpPool())
			return GameData.PROTOCOL_OP_FAILED;

		if (count != 1 || this.gameMapContext.getCurMapContext().getHp() <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		int nowTime = GameTime.getTime();
		if (this.lastUseHpTime + GameData.getInstance().getCommonCFG().medicine.hpCD > nowTime)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;

		CellItem.HpPotion hpPotion = useable.useAsPotion();
		if (hpPotion == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_HP);
		tlogEvent.setArg(id, count);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		int addHp = hpPotion.getHpAddValue();
		this.lastUseHpTime = nowTime;
		gs.getMapService().syncRoleAddHp(this.id, this.gameMapContext.getCurMapId(), addHp);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized RpcRes<List<SBean.Rewards>> useItemChestImpl(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_FAILED);

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_FAILED);

		if (this.bag.getCanUseSize() < count)
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_BAG_NOT_ENOUGH_CELLS);
		
		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE);
		CellItem.TreasureChest chest = useable.useAsTreasureChest();
		if (chest == null)
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_FAILED);

		if (chest.getCostItemID() != 0 && !this.containsEnoughGameItem(chest.getCostItemID(), chest.getCostItemCount() * count))
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_FAILED);

		List<Map<Integer, Integer>> drops = new ArrayList<>();
		for (int i = 0; i < count; ++i)
			drops.add(chest.getRandomDrop());

		Map<Integer, Integer> alldrops = drops.stream().reduce(new TreeMap<Integer, Integer>(), (result, cur) ->
		{
			for (Map.Entry<Integer, Integer> e : cur.entrySet())
				result.merge(e.getKey(), e.getValue(), (ov, nv) -> ov + nv);

			return result;
		});

		if (!this.canAddGameItems(alldrops))
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_BAG_NOT_ENOUGH_CELLS);

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_FAILED);

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_CHEST_IMPL);
		tlogEvent.setArg(id, count);
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		if (chest.getCostItemID() != 0)
			this.delGameItem(chest.getCostItemID(), chest.getCostItemCount() * count, tlogEvent.getGameItemRecords());

		this.syncAddGameItems(GameData.getInstance().toGameItems(alldrops), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return new RpcRes<List<SBean.Rewards>>(GameData.PROTOCOL_OP_SUCCESS, drops.stream().map(SBean.Rewards::new).collect(Collectors.toList()));
	}

	public void useItemChest(int id, int count)
	{
		RpcRes<List<SBean.Rewards>> ret = useItemChestImpl(id, count);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.bag_useitemchest_res(ret.errCode, ret.info));
	}

	public synchronized int useItemEquipEnergy(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.EquipEnergyAdder energyAdder = useable.useAsEquipEnergyAdder();
		if (energyAdder == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		int energy = energyAdder.getEnergy() * count;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_EQUIP_ENERGY);
		tlogEvent.setArg(id, count, energy);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddEquipEnergy(energy, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemOfflineFunc(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.OfflineFuncPoint offlineFuncPoint = useable.useAsOfflineFuncPoint();
		if (offlineFuncPoint == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		int pointNum = offlineFuncPoint.getFuncPoint() * count;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_OFFLINE_FUNC_POINT);
		tlogEvent.setArg(id, count, pointNum);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddOfflineFuncPoint(pointNum, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemTitle(int id)
	{
		CellItem bi = this.getBagItem(id);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.TitleItem titleItem = useable.useAsTitleItem();
		if (titleItem == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + 1 > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, 1, (ov, nv) -> ov + nv);
		this.dayUseItemsTimes.merge(id, 1, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_TITLE);
		tlogEvent.setArg(id, 1);
		this.delGameItem(id, 1, tlogEvent.getGameItemRecords());
		this.addRoleTitle(titleItem.getTitleId());

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemGemEnergy(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.GemEnergyAdder energyAdder = useable.useAsGemEnergyAdder();
		if (energyAdder == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		int energy = energyAdder.getEnergy() * count;
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_GEM_ENERGY);
		tlogEvent.setArg(id, count, energy);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddGemEnergy(energy, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemSpiritInspiration(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.SpiritInspirationAdder inspirationAdder = useable.useAsSpiritInspirationAdder();
		if (inspirationAdder == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;
		int inspiration = inspirationAdder.getInspiration() * count;
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_SPIRIT_INSPIRATION);
		tlogEvent.setArg(id, count, inspiration);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddBookInspiration(inspiration, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemAsRecipeReel(int id)
	{
		CellItem bi = this.getBagItem(id);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.RecipeReel reel = useable.useAsRecipeReel();
		if (reel == null || GameData.getInstance().getProduceDefaultRecipes().contains(reel.getRecipeID()) || this.produce.recipes.contains(reel.getRecipeID()))
			return GameData.PROTOCOL_OP_FAILED;
		
		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + 1 > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;
		
		this.produce.recipes.add(reel.getRecipeID());
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, 1, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_AS_RECIPEREEL);
		tlogEvent.setArg(id, reel.getRecipeID());
		this.dayUseItemsTimes.merge(id, 1, (ov, nv) -> ov + nv);
		this.delGameItem(id, 1, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemAsVit(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.VitAdder vitAdder = useable.useAsVitAdder();
		if (vitAdder == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		int vit = vitAdder.getVit() * count;
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_AS_VIT);
		tlogEvent.setArg(id, count, vit);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddVit(vit, tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useItemFashion(int id)
	{
		CellItem bi = this.getBagItem(id);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;

		CellItem.FashionAdder fashion = useable.useAsFashionAdder();
		if (fashion == null)
			return GameData.PROTOCOL_OP_FAILED;

		SBean.FashionCFGS fashionCFg = GameData.getInstance().getFashionCFGS(fashion.getFashion());
		if (fashionCFg == null || (fashionCFg.sex != 0 && fashionCFg.sex != this.gender))
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + 1 > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (this.containFashionEquip(fashion.getFashion()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, 1, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_FASHION);
		tlogEvent.setArg(id);
		this.delGameItem(id, 1, tlogEvent.getGameItemRecords());
		this.dayUseItemsTimes.merge(id, 1, (ov, nv) -> ov + nv);
		this.addFashionEquip(fashionCFg.id);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useMonthlyCard(int id)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_MONTHLYCARD);
		CellItem bi = this.getBagItem(id);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.SpecialCard specialcard = useable.useAsSpecialCard();
		if (specialcard == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, 1, (ov, nv) -> ov + nv);
		
		//时间累加，加元宝
		if(addSpecialCard(specialcard.getTime(), specialcard.getType()))
			syncAddDiamond(specialcard.getDiamonds(), false, tlogEvent);
		
		this.delGameItem(id, 1, tlogEvent.getGameItemRecords());
		tlogEvent.setArg(id, specialcard.getTime());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int useVipCard(int id)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_VIPCARD);
		CellItem bi = this.getBagItem(id);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.VipCard vipcard = useable.useAsVipCard();
		if (vipcard == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (vipcard.getVipLvl() <= share.getVipLevel() || vipcard.getVipLvl() < getTempVipLvl())
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, 1, (ov, nv) -> ov + nv);
		int now = GameTime.getTime();
		if (this.tempVIP.vipEndtime < now || this.tempVIP.vipLvl < vipcard.getVipLvl())
		{
			this.tempVIP.vipEndtime = now + vipcard.getTime();
			this.tempVIP.vipLvl = vipcard.getVipLvl();
			this.syncMapRoleVipLevel();
		}
		else
			this.tempVIP.vipEndtime += vipcard.getTime();

		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_tempvip(this.tempVIP.vipLvl, this.tempVIP.vipEndtime));
		this.delGameItem(id, 1, tlogEvent.getGameItemRecords());
		tlogEvent.setArg(id, vipcard.getVipLvl(), vipcard.getTime());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized void syncMapRoleVipLevel()
	{
		gs.getMapService().syncRoleVipLevel(this.gameMapContext.getCurMapId(), this.id, this.getUseableVipLvl());
	}
	
	public synchronized int useItemTowerFame(int groupId, int id)
	{
		//int groupId = this.climbTowerData.roleClimbTowerData.data.groupId;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USER_ITEM_TOWER_FAME);
		CellItem bi = this.getBagItem(id);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.TowerFameItem towerFameItem = useable.useAsTowerFameItem();
		if (towerFameItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, 1, (ov, nv) -> ov + nv);
		this.delGameItem(id, 1, tlogEvent.getGameItemRecords());
		//添加声望
		SBean.DBClimbTowerFame fameData = this.climbTowerData.roleClimbTowerFameData.get(groupId);
		if (fameData == null)
		{
			fameData = new SBean.DBClimbTowerFame(1, 0, new HashSet<>());
			this.climbTowerData.roleClimbTowerFameData.put(groupId, fameData);
		}
		tlogEvent.setArg(fameData.level, id);
		SBean.ClimbTowerFameDataCFGS fameLevelCfg = GameData.getInstance().getClimbTowerFameDataCfg(groupId, fameData.level);
		SBean.ClimbTowerFameDataCFGS nextLevelCfg = GameData.getInstance().getClimbTowerFameDataCfg(groupId, fameData.level+1);
		
		if (fameLevelCfg == null || nextLevelCfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		
		int addCount = towerFameItem.getUpFame();
		int totalFame = 0;
		SBean.ClimbTowerFameCFGS fameCfg = GameData.getInstance().getClimbTowerFameDatas().get(groupId);
		for (int level : fameCfg.datas.keySet())
		{
			if (level > fameData.level)
				break;
			SBean.ClimbTowerFameDataCFGS localCfg = GameData.getInstance().getClimbTowerFameDataCfg(groupId, level);
			totalFame = totalFame + localCfg.levelUpNeedFame;
		}
		while (nextLevelCfg != null && (fameData.fame - totalFame + addCount >= nextLevelCfg.levelUpNeedFame))
		{
			//升级操作
			fameData.fame += nextLevelCfg.levelUpNeedFame;//addCount;
			addCount -= nextLevelCfg.levelUpNeedFame;
			totalFame += nextLevelCfg.levelUpNeedFame;
			fameLevelCfg = GameData.getInstance().getClimbTowerFameDataCfg(groupId, ++fameData.level);
			nextLevelCfg = GameData.getInstance().getClimbTowerFameDataCfg(groupId, fameData.level+1);
		}
		fameData.fame += addCount;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private int getTempVipLvl()
	{
		return this.tempVIP.vipEndtime > GameTime.getTime() ? this.tempVIP.vipLvl : 0;
	}

	public synchronized int useItemAsExpCoinPool(int id, int count)
	{
		if (!this.canAddExpCoin())
			return GameData.PROTOCOL_OP_FAILED;

		CellItem bi = this.getBagItem(id);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;

		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.ExpCoinPool expCoinPool = useable.useAsExpCoinPool();
		if (expCoinPool == null)
			return GameData.PROTOCOL_OP_FAILED;

		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_EXPCOIN_POOL);
		tlogEvent.setArg(id, count);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);
		this.syncAddExpCoin(expCoinPool.getVolume() * count, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int useItemFeatPlate(int id, int count)
	{
		CellItem bi = this.getBagItem(id);
		if (count <= 0 || bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		
		CellItem.FeatAdder featPlate = useable.useAsFeatAdder();
		if(featPlate == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + count > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;
		this.dayUseItemsTimes.merge(id, count, (ov, nv) -> ov + nv);

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_FEAT_ADDER);
		int addFeat = featPlate.getFeat() * count;
		tlogEvent.setArg(id, count, addFeat);
		this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.syncAddForceWarFeat(addFeat);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int useItemSkill(int itemId, SBean.Vector3 pos, SBean.Vector3F rotation, int targetID, int targetType, int ownerID, SBean.TimeTick timeTick)
	{
		CellItem bi = this.getBagItem(itemId);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(itemId < 0 ? -itemId : itemId, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		if (this.dayUseItemsTimes.getOrDefault(itemId, 0) + this.dayUseItemsTimes.getOrDefault(-itemId, 0) + 1 > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;

		if (useable.logRoleUseTimes())
			this.lifeUse.merge(itemId < 0 ? -itemId : itemId, 1, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_SKILL);
		tlogEvent.setArg(itemId, 1);
		this.delGameItem(itemId, 1, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		if (this.gameMapContext.getCurMapContext() instanceof PrivateMapCopyContext)
		{
			this.dayUseItemsTimes.merge(itemId, 1, (ov, nv) -> ov + nv);
		}
		else
		{
			gs.getMapService().syncMapRoleUseItemSkill(this.id, this.gameMapContext.getCurMapId(), itemId, pos, rotation, targetID, targetType, ownerID, timeTick);
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int useItemLetter(int itemId)
	{
		CellItem bi = this.getBagItem(itemId);
		if (bi == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bi.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_LETTER_CAN_NOT_USE;
		
		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(itemId < 0 ? -itemId : itemId, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.Letter letter = useable.useAsLetter();
		if (letter == null || letter.getTaskId() == 0)
			return GameData.PROTOCOL_OP_FAILED;
		
		if (this.branchTask.containsKey(letter.getTaskId()))
			return GameData.PROTOCOL_OP_LETTER_EARLY_HAS_TASK;
		
		int receiveTime = this.accessBranchTask(letter.getTaskId());
		if (receiveTime <= 0)
			return GameData.PROTOCOL_OP_LETTER_CAN_NOT_ACCESS_TASK;
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(itemId < 0 ? -itemId : itemId, 1, (ov, nv) -> ov + nv);
		if (letter.getNeedDel() == 0)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_LETTER);
			tlogEvent.setArg(itemId, 1);
			this.delGameItem(itemId, 1, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		return receiveTime;
	}
	
	public synchronized int useItemEvilValue(int itemId, int count)
	{
		CellItem bagItem = this.getBagItem(itemId);
		if (count<=0 || bagItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bagItem.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;

		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(itemId < 0 ? -itemId : itemId, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.EvilValue evilItem = useable.useAsEvilValue();
		if (evilItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.pkValue == 0)
			return GameData.PROTOCOL_OP_FAILED;
		int reduceValue = evilItem.getReduceValue() * count;
		if (reduceValue - this.pkValue > evilItem.getReduceValue())
			return GameData.PROTOCOL_OP_FAILED;
		
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(itemId < 0 ? -itemId : itemId, count, (ov, nv) -> ov + nv);
		this.pkValue = this.pkValue - reduceValue >= 0 ? (this.pkValue - reduceValue) : 0;
		this.updateRedNamePunish();
		if(this.pkValue == 0)
			this.pkValueTime = 0;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_EVIL_VALUE);
		tlogEvent.setArg(itemId, count);
		this.delGameItem(itemId, count, tlogEvent.getGameItemRecords());
		int mode = this.gameMapContext.getCurMapContext().getPKMode();
		gs.getMapService().syncRoleUpdatePKInfo(this.id, this.gameMapContext.getCurMapId(), mode, this.pkValue);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int useItemPropStrength(int itemId, int count)
	{
		CellItem bagItem = this.getBagItem(itemId);
		if (count<=0 || bagItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bagItem.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, count))
			return GameData.PROTOCOL_OP_FAILED;
		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(itemId < 0 ? -itemId : itemId, 0) + count))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		CellItem.PropStrengthItem strengthItem = useable.useAsPropStrengthItem();
		if (strengthItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(itemId < 0 ? -itemId : itemId, count, (ov, nv) -> ov + nv);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_PROP_STRENGTH);
		tlogEvent.setArg(itemId, count);
		this.delGameItem(itemId, count, tlogEvent.getGameItemRecords());
		this.itemGetProp.merge(strengthItem.getPropId(), strengthItem.getPropNum() * count, (ov, nv) -> ov + nv);
		
		this.roleProperties.onUpdateItemProps(this.itemGetProp);
		gs.getMapService().syncRoleItemProps(this.gameMapContext.getCurMapId(), this.id, new HashMap<>(this.itemGetProp));
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
//		gs.getTLogger().logItemStrengthen(this, itemId, count, strengthItem.getPropId(), 
//		        strengthItem.getPropNum() * count, this.itemGetProp.get(strengthItem.getPropId()));
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized boolean pieceCompose(int composeId)
	{
		SBean.ComposeCFGS composeCFGS = GameData.getInstance().getComposeCFGS(composeId);
		if (composeCFGS == null)
			return false;
		if (!this.canAddGameItem(composeCFGS.product.id, composeCFGS.product.count))
			return false;
		if (!this.containsEnoughGameItems(composeCFGS.materials))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PIECE_COMPOSE);
		tlogEvent.setArg(composeId);
		this.delGameItems(composeCFGS.materials, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(composeCFGS.product.id, composeCFGS.product.count), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized void onRoleUseItemSkill(int itemID, int ok)
	{
		if(ok == 0)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_SKILL_FAIL);
			tlogEvent.setArg(itemID, 1);
			this.syncAddGameItem(GameData.getInstance().toGameItem(itemID, 1), tlogEvent);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		if(ok == 1)
		{
			this.dayUseItemsTimes.merge(itemID, 1, (ov, nv) -> ov + nv);
		}
	}
	
	public synchronized int useItemUniqueSkill(int itemId)
	{
		CellItem bagItem = this.getBagItem(itemId);
		if (bagItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bagItem.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.USkillItem uskillItem = useable.useAsUSkillItem();
		if (uskillItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.takeUniqueSkill(uskillItem.getUSkillId()))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_USKILL);
		tlogEvent.setArg(itemId);
		this.delGameItem(itemId, 1, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int useItemHeadItem(int itemId)
	{
		CellItem bagItem = this.getBagItem(itemId);
		if (bagItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.Useable useable = bagItem.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;
		CellItem.HeadItem headItem = useable.useAsHeadItem();
		if (headItem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.itemUnlockHead.contains(headItem.getHeadId()))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_USE_ITEM_HEAD);
		tlogEvent.setArg(itemId);
		this.delGameItem(itemId, 1, tlogEvent.getGameItemRecords());
		this.itemUnlockHead.add(headItem.getHeadId());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	/////////////////////////////////////////equip////////////////////////////////////
	class EquipLegend
	{
		int hpPoolCDReduce;
		
		void clear()
		{
			hpPoolCDReduce = 0;
		}
		
		EquipLegend init(Collection<SBean.DBWearEquip> wearEquips)
		{
			reset(wearEquips);
			return this;
		}
		
		void reset(Collection<SBean.DBWearEquip> wearEquips)
		{
			clear();
			
			for(SBean.DBWearEquip we: wearEquips)
			{
				if(GameData.getInstance().isLegengThreeValid(we.equip))
					setLegend(we.wid, we.equip.legends.get(2), true);
			}
		}
		
		int getHpPoolCDReduce()
		{
			return hpPoolCDReduce;
		}
		
		void onUpdateEquip(int wid, SBean.DBEquip oldEquip, SBean.DBEquip newEquip)
		{
			int oldLegendThree = GameData.getInstance().isLegengThreeValid(oldEquip) ? oldEquip.legends.get(2) : 0;
			int newLegendThree = GameData.getInstance().isLegengThreeValid(newEquip) ? newEquip.legends.get(2) : 0;
			
			if(oldLegendThree != newLegendThree && oldLegendThree > 0)
				setLegend(wid, oldLegendThree, false);
			
			if(oldLegendThree != newLegendThree && newLegendThree > 0)
				setLegend(wid, newLegendThree, true);
		}
		
		void setLegend(int partID, int legendThree, boolean add)
		{
			SBean.LegendThreeCFGS ltCfg = GameData.getInstance().getLegengThreeCFGS(partID, legendThree);
			if(ltCfg == null)
				return;
			
			switch (ltCfg.type)
			{
			case GameData.LEGEND_EQUIP_THREE_TYPE_POOLHPCD:
				updateHpPoolCDReduce(ltCfg.params.get(0), add);
				break;
			default:
				break;
			}
		}
		
		void updateHpPoolCDReduce(int val, boolean add)
		{
			if(add)
				hpPoolCDReduce += val / 1000;
			else
				hpPoolCDReduce -= val / 1000;
			
			if(hpPoolCDReduce < 0)
			{
				gs.getLogger().warn("update hp pool cd reduce cd " + hpPoolCDReduce + " invalid ");
				hpPoolCDReduce = 0;
			}
		}
	}
	
	private void updateEquip(SBean.DBWearEquip wearEquip)
	{
		this.equipLegend.onUpdateEquip(wearEquip.wid, this.wearEquips.get(wearEquip.wid) == null ? null : this.wearEquips.get(wearEquip.wid).equip, wearEquip.equip);
		updateEquipImpl(wearEquip);
		gs.getMapService().syncRoleUpdateEquip(this.id, this.gameMapContext.getCurMapId(), wearEquip.wid, wearEquip.equip == null ? null : wearEquip.equip.kdClone());
	}
	
	private void updateEquipImpl(SBean.DBWearEquip wearEquip)
	{
		if (wearEquip.equip == null)
			this.wearEquips.remove(wearEquip.wid);
		else
			this.wearEquips.put(wearEquip.wid, wearEquip);
		this.roleProperties.onUpdateEquip(wearEquip.wid, wearEquip.equip);
	}
	
	public synchronized boolean upWearEquip(int id, String guid, int pos)
	{
		CellItem bi = this.getBagItem(id);
		if (bi == null || !bi.contains(guid))
			return false;
		CellItem.Wearable wearable = bi.getWearable();
		if (wearable == null || !wearable.canWear(this.level, this.transformLevel, this.BWType, this.classType))
			return false;
		int wearPartID = wearable.getWearPartID();
		if (wearPartID != pos || wearPartID <= 0 || wearPartID > this.wearParts.size())
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UP_WEAR_EQUIP);
		tlogEvent.setArg(id, pos);
		tlogEvent.setArg(guid);

		SBean.DBWearEquip wequip = this.wearEquips.get(wearPartID);
		if (wequip != null)
			this.syncAddGameItem(GameData.toGameItem(wequip.equip), tlogEvent);
		SBean.DBEquip equip = wearable.getEquipData(guid);

		this.delEquip(id, guid, tlogEvent.getGameItemRecords());

		equip.id = equip.id < 0 ? -equip.id : equip.id;
		SBean.DBWearEquip wearEquip = new SBean.DBWearEquip(wearPartID, equip);
		this.updateEquip(wearEquip);
		this.logWearEquip();
		
		gs.getTLogger().logEquipStrength(this, pos, 0, TLog.EQUIPSTRENGTH_EQUIP, wearPartID, true);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean downWearEquip(String guid, int pos)
	{
		if (pos < 0 || pos > this.wearParts.size())
			return false;
		SBean.DBWearEquip wequip = wearEquips.get(pos);
		if (wequip == null || !guid.equals(wequip.equip.guid))
			return false;
		SBean.GameItem gi = GameData.toGameItem(wequip.equip);
		if (!this.canAddGameItem(gi.id, gi.count))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_DOWN_WEAR_EQUIP);
		tlogEvent.setArg(guid);
		tlogEvent.setArg(pos, gi.id, gi.count);
		this.syncAddGameItem(gi, tlogEvent);

		SBean.DBWearEquip wearEquip = new SBean.DBWearEquip(pos, null);
		this.updateEquip(wearEquip);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	private void updateEquipPart(SBean.DBEquipPart wearPart)
	{
		wearParts.set(wearPart.id - 1, wearPart);
		gs.getMapService().syncRoleUpdateEquipPart(this.id, this.gameMapContext.getCurMapId(), wearPart.kdClone());

		this.roleProperties.onUpdateEquipPart(wearPart);
	}

	public int getEquipLevelSum()
	{
		int sum = 0;
		for(SBean.DBEquipPart wearpart: wearParts)
		{
			sum += wearpart.eqGrowLvl;
		}
		return sum;
	}
	
	public synchronized boolean equipLevelUp(int pos, int level)
	{
		if (pos <= 0 || pos > wearParts.size() || !wearEquips.containsKey(pos))
			return false;
		SBean.DBEquipPart wearPart = wearParts.get(pos - 1);
		if (level <= wearPart.eqGrowLvl)
			return false;

		SBean.EquipLevelUpCostCFGS cfg = GameData.getInstance().getEquipLevelUpCost(wearPart.eqGrowLvl, level);
		if (cfg == null)
			return false;
		if (!this.canUseEquipEnergy(cfg.energy) || !this.containsEnoughGameItems(cfg.items))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EQUIP_LEVEL_UP);
		tlogEvent.setArg(pos, level);
		this.useEquipEnergy(cfg.energy, tlogEvent.getGameItemRecords());
		this.delGameItems(cfg.items, tlogEvent.getGameItemRecords());
		int addlevel = level - wearPart.eqGrowLvl;
		Iterator<Integer> rollNoticeLevel = GameData.getInstance().getRollNoticeLevel(wearPart.eqGrowLvl, level);
		wearPart.eqGrowLvl = level;
		this.updateEquipPart(wearPart);
		int sendLevel = 0;
		while (rollNoticeLevel.hasNext())
		{
			int curLevel = rollNoticeLevel.next();
			if (this.wearParts.stream().allMatch(eq -> eq.eqGrowLvl >= curLevel) && sendLevel < curLevel)
				sendLevel = curLevel;
			else
				break;
		}
		if (sendLevel != 0)
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_EQUIP_STRENGTHEN, this.name + "|" + sendLevel);
//		if (GameData.getInstance().getBetaActivity().strengthenReward.keySet().stream().anyMatch(cfgslevel -> cfgslevel <= getEquipLevelSum() && cfgslevel > getEquipLevelSum() - addlevel))
//			tryTestBetaActivityNotice();
		testChallengeTask(GameData.CHALLENGE_TASK_ID_EQUIP_STRENGTHEN, 0);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logEquipStrength(this, pos, 0, TLog.EQUIPSTRENGTH_LEVELUP, level, true);
		return true;
	}
	
	static class EquipPartLevel
	{
		SBean.DBEquipPart equipPart;
		int level;
		EquipPartLevel(SBean.DBEquipPart equipPart, int level)
		{
			this.equipPart = equipPart;
			this.level = level;
		}
	}
	public synchronized boolean equipLevelUpBatch(Map<Integer, Integer> posLevels)
	{
		int energyReq = 0;
		Map<Integer, Integer> itemsReqMap = new TreeMap<>();
		StringBuilder sb = new StringBuilder();
		List<EquipPartLevel> equipParts = new ArrayList<>();
		for (Map.Entry<Integer, Integer> e : posLevels.entrySet())
		{
			int pos = e.getKey();
			int level = e.getValue();
			if (pos <= 0 || pos > wearParts.size() || !wearEquips.containsKey(pos))
				return false;
			SBean.DBEquipPart wearPart = wearParts.get(pos - 1);
			if (level <= wearPart.eqGrowLvl)
				return false;
			SBean.EquipLevelUpCostCFGS cfg = GameData.getInstance().getEquipLevelUpCost(wearPart.eqGrowLvl, level);
			if (cfg == null)
				return false;
			energyReq += cfg.energy;
			GameData.mergeCounter(itemsReqMap, cfg.items);
			if (sb.length() > 0)
				sb.append(";");
			sb.append(pos).append("_").append(level);
			equipParts.add(new EquipPartLevel(wearPart, level));
		}
		List<SBean.DummyGoods> itemsReq = GameData.toDummGoods(itemsReqMap);
		if (!this.canUseEquipEnergy(energyReq) || !this.containsEnoughGameItems(itemsReq))
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EQUIP_LEVEL_UP);
		tlogEvent.setArg(sb.toString());
		this.useEquipEnergy(energyReq, tlogEvent.getGameItemRecords());
		this.delGameItems(itemsReq, tlogEvent.getGameItemRecords());
		int minLevel = Integer.MAX_VALUE;
		int maxLevel = 0;
		for (EquipPartLevel e : equipParts)
		{
			SBean.DBEquipPart wearPart = e.equipPart;
			int level = e.level;
			minLevel = minLevel > wearPart.eqGrowLvl ? wearPart.eqGrowLvl : minLevel;
			maxLevel = maxLevel > level ? maxLevel : level;
			int addlevel = level - wearPart.eqGrowLvl;
			wearPart.eqGrowLvl = level;
			this.updateEquipPart(wearPart);
			
			//Attention I am not sure the below statment is right
			gs.getTLogger().logEquipStrength(this, e.equipPart.id, 0, TLog.EQUIPSTRENGTH_LEVELUP, wearPart.eqGrowLvl, true);
			
//			if (GameData.getInstance().getBetaActivity().strengthenReward.keySet().stream().anyMatch(cfgslevel -> cfgslevel <= getEquipLevelSum() && cfgslevel > getEquipLevelSum() - addlevel))
//				tryTestBetaActivityNotice();
		}
		Iterator<Integer> rollNoticeLevel = GameData.getInstance().getRollNoticeLevel(minLevel, maxLevel);
		int sendLevel = 0;
		while (rollNoticeLevel.hasNext())
		{
			int curLevel = rollNoticeLevel.next();
			if (this.wearParts.stream().allMatch(eq -> eq.eqGrowLvl >= curLevel) && sendLevel < curLevel)
				sendLevel = curLevel;
			else
				break;
		}
		if (sendLevel != 0)
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_EQUIP_STRENGTHEN, this.name + "|" + sendLevel);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_EQUIP_STRENGTHEN, 0);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);	
		return true;
	}

	public synchronized int equipStartUp(int pos, int level)
	{
		if (pos <= 0 || pos > wearParts.size() || !wearEquips.containsKey(pos))
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBEquipPart wearPart = wearParts.get(pos - 1);
		if (level <= wearPart.eqEvoLvl)
			return GameData.PROTOCOL_OP_FAILED;

		SBean.EquipStarUpCostCFGS cfg = GameData.getInstance().getEquipStarUpCost(wearPart.eqEvoLvl, level);
		if (cfg == null || !this.containsEnoughGameItems(cfg.items))
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.EquipUpStarCFGS equipStarCfg = GameData.getInstance().getEquipUpStarCFGS(wearPart.eqEvoLvl);
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EQUIP_STAR_UP);
		
		this.delGameItems(cfg.items, tlogEvent.getGameItemRecords());
		
		if(wearPart.upcnt <equipStarCfg.sucMin 
				||(wearPart.upcnt <equipStarCfg.sucMax-1&&GameRandom.getRandom().nextInt(10000)>=equipStarCfg.sucRate)){
			wearPart.upcnt++;
			tlogEvent.setArg(pos, level,GameData.PROTOCOL_OP_FAILED);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			
			gs.getTLogger().logEquipStrength(this, pos, 0, TLog.EQUIPSTRENGTH_STARUP, level, false);
			return GameData.PROTOCOL_OP_EQUIP_UP_STAR_RATE_FAIL;
		}
		
		tlogEvent.setArg(pos, level,GameData.PROTOCOL_OP_SUCCESS);
		
		wearPart.eqEvoLvl = level;

		this.updateEquipPart(wearPart);
		if (GameData.getInstance().getRollNoticeCFGS().equipStarups.contains(level))
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_EQUIP_STARUP, this.name + "|" + wearPart.id + "|" + level);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_EQUIP_STAR_UP, 0);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logEquipStrength(this, pos, 0, TLog.EQUIPSTRENGTH_STARUP, level, true);
		wearPart.upcnt = 0;
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	// TODO 修理水晶装备只能修理传在身上的
	public synchronized int repairEquip(int pos)
	{
		SBean.DBWearEquip wequip = this.wearEquips.get(pos);
		if (wequip == null)
			return 0;
		SBean.CommonCFGS cfg = GameData.getInstance().getCommonCFG();
		if (wequip.equip.durability < 0 || wequip.equip.durability >= cfg.equip.initDurability)
			return 0;
		
		int legends = 0;
		for(int l: wequip.equip.legends)
		{
			if(l > 0)
				legends++;
		}
		
		int useCoin = (int) Math.floor((cfg.equip.initDurability - wequip.equip.durability) * cfg.equip.fixCostCoin * legends);
		float priceIncrease = GameData.getInstance().getPriceIncrease(this.pkValue);
		int realCost = (int) (useCoin * (1.f + priceIncrease - this.weaponUSkill.getRepairAdjust()));
		realCost = realCost > 0 ? realCost : 0;
		if (!this.canUseCoin(realCost, true))
			return 0;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_REPAIR_EQUIP);
		tlogEvent.setArg(pos, realCost);
		this.useCoin(realCost, true, tlogEvent.getGameItemRecords());
		
		wequip.equip.durability = cfg.equip.initDurability;
		this.updateEquip(wequip);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return realCost;
	}

	public synchronized boolean autoUpwearEquip(Map<Integer, SBean.KinEquips> equips)
	{
		Map<Integer, SBean.DBWearEquip> willWearEquips = new TreeMap<Integer, SBean.DBWearEquip>();
		List<SBean.GameItem> replacedEquips = new ArrayList<SBean.GameItem>();
		for (SBean.KinEquips e : equips.values())
		{
			CellItem bi = this.getBagItem(e.id);
			if (bi == null || e.guids.isEmpty() || !bi.contains(e.guids))
				return false;
			CellItem.Wearable wearable = bi.getWearable();
			if (wearable == null || !wearable.canWear(this.level, this.transformLevel, this.BWType, this.classType))
				return false;
			if (e.guids.size() > 1)
				return false;
			String guid = e.guids.iterator().next();
			SBean.DBEquip equip = wearable.getEquipData(guid);
			int wearPartID = wearable.getWearPartID();
			if (wearPartID <= 0 || wearPartID > this.wearParts.size() || willWearEquips.put(wearPartID, new SBean.DBWearEquip(wearPartID, equip)) != null)
				return false;
			SBean.DBWearEquip wequip = this.wearEquips.get(wearPartID);
			if (wequip != null)
				replacedEquips.add(GameData.toGameItem(wequip.equip));
		}

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_AUTO_UP_WEAR_EQUIP);
		for (SBean.DBWearEquip e : willWearEquips.values())
		{
			tlogEvent.setArg(e.equip.guid);
			tlogEvent.setArg(e.equip.id);
			this.delEquip(e.equip.id, e.equip.guid, tlogEvent.getGameItemRecords());
			e.equip.id = e.equip.id < 0 ? -e.equip.id : e.equip.id;
			this.updateEquip(e);
		}
		this.syncAddGameItems(replacedEquips, tlogEvent);
		this.logWearEquip();

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	// -----------------------------------------gem------------------------------------------------
	// pos 装备位置， seq 宝石位置
	public synchronized boolean gemLevelUp(int pos, int seq, int toGemId)
	{
		if (pos <= 0 || pos > wearParts.size() || !wearEquips.containsKey(pos))
			return false;
		SBean.DBEquipPart equipPart = wearParts.get(pos - 1);
		if (equipPart == null)
			return false;

		if (seq <= 0 || seq > equipPart.eqSlots.size())
			return false;
		int gemInlay = equipPart.eqSlots.get(seq - 1);
		if (gemInlay == 0 || gemInlay > 0 && toGemId < 0 || gemInlay < 0 && toGemId > 0)
			return false;

		SBean.GemLevelUpCostCFGS cfg = GameData.getInstance().getGemLevelUpCost(gemInlay, toGemId);
		if (cfg == null)
			return false;
		if (!canUseGemEnergy(cfg.energy) || !this.containsEnoughGameItems(cfg.items))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GEM_LEVEL_UP);
		tlogEvent.setArg(pos, seq, toGemId);
		useGemEnergy(cfg.energy, tlogEvent.getGameItemRecords());
		this.delGameItems(cfg.items, tlogEvent.getGameItemRecords());
		equipPart.eqSlots.set(seq - 1, toGemId);

		this.updateEquipPart(equipPart);
		int gemLvl = GameData.getInstance().getGemCFG(toGemId).level;
		if (gemLvl > this.historyMaxGemLevel)
			this.historyMaxGemLevel = gemLvl;

		testChallengeTask(GameData.CHALLENGE_TASK_ID_ANY_GEMLEVEL, 0);
		
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logEquipStrength(this, pos, seq, TLog.EQUIPSTRENGTH_GEMUP, toGemId, true);
		return true;
	}

	public synchronized boolean gemInlay(int pos, int seq, int gemId)
	{
		if (pos <= 0 || pos > wearParts.size() || !wearEquips.containsKey(pos))
			return false;
		SBean.DBEquipPart equipPart = wearParts.get(pos - 1);
		if (equipPart == null)
			return false;

		if (seq <= 0 || seq > equipPart.eqSlots.size())
			return false;
		int gemInlay = equipPart.eqSlots.get(seq - 1);
		if (gemInlay != 0)
			return false;

		CellItem bi = this.getBagItem(gemId);
		if (bi == null || bi.getCount() < 1)
			return false;
		CellItem.Inlaidable inlaiable = bi.getInlaidable();
		if (inlaiable == null)
			return false;
		List<Integer> slotTypes = GameData.getInstance().getEquipSlotType(pos, seq);
		if (!slotTypes.contains(inlaiable.getInlaidType()))
			return false;

		equipPart.eqSlots.set(seq - 1, gemId > 0 ? gemId : -gemId);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GEM_INLAY);
		tlogEvent.setArg(pos, seq, gemId);
		this.delGameItem(gemId, 1, tlogEvent.getGameItemRecords());
		this.updateEquipPart(equipPart);
		int gemNum = getWearedGemCnt();
		if (gemNum > this.historyMaxGemNum)
			this.historyMaxGemNum = gemNum;
		int gemLvl = GameData.getInstance().getGemCFG(gemId).level;
		if (gemLvl > this.historyMaxGemLevel)
			this.historyMaxGemLevel = gemLvl;
		testChallengeTask(GameData.CHALLENGE_TASK_ID_EMBED, 0);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logEquipStrength(this, pos, seq, TLog.EQUIPSTRENGTH_INLAY, gemId, true);
		return true;
	}

	public synchronized boolean gemUnlay(int pos, int seq, int gemId)
	{
		if (pos <= 0 || pos > wearParts.size() || !wearEquips.containsKey(pos))
			return false;
		SBean.DBEquipPart equipPart = wearParts.get(pos - 1);
		if (equipPart == null)
			return false;

		if (seq <= 0 || seq > equipPart.eqSlots.size())
			return false;
		int gemInlay = equipPart.eqSlots.get(seq - 1);
		if (gemInlay == 0 || gemInlay != gemId)
			return false;

		equipPart.eqSlots.set(seq - 1, 0);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GEM_UNLAY);
		tlogEvent.setArg(pos, seq, gemId);
		this.syncAddGameItem(GameData.getInstance().toGameItem(gemInlay, 1), tlogEvent);
		this.updateEquipPart(equipPart);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	public synchronized List<SBean.Prop> equipRefine(int equipID, String guid, int pos, int costItem)
	{
		if(this.level < GameData.getInstance().getCommonCFG().funcOpen.equipRefine)
			return null;
		
		CellItem ci = this.getBagItem(costItem);
		if(ci == null)
			return null;
		
		CellItem.Useable useable = ci.getUseable();
		if(useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return null;
		
		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(costItem < 0 ? -costItem : costItem, 0) + 1))
			return null;
		
		if(this.dayUseItemsTimes.getOrDefault(costItem, 0) + this.dayUseItemsTimes.getOrDefault(-costItem, 0) + 1 > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return null;
		
		CellItem.EquipRefineItem refineItem = useable.useAsEquipRefineItem();
		if(refineItem == null)
			return null;
		
		SBean.EquipRefineGroupCFGS ergCfg = GameData.getInstance().getEquipRefineGroupCFGS(refineItem.getRefineGroupID());
		if(ergCfg == null)
			return null;
		
		List<SBean.Prop> props = null;
		if(pos > 0)
			props = wearEquipRefine(equipID, guid, pos, costItem, ergCfg, refineItem.getPropCount());
		else
			props = bagEquipRefine(equipID, guid, costItem, ergCfg, refineItem.getPropCount());
		
		if(props == null)
			return null;
		
		this.dayUseItemsTimes.merge(costItem, 1, (ov, nv) -> ov + nv);
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(costItem < 0 ? -costItem : costItem, 1, (ov, nv) -> ov + nv);
		
		gs.getTLogger().logEquipStrength(this, pos, 0, TLog.EQUIPSTRENGTH_REFINE, 0, true);

		return props;
	}
	
	private List<SBean.Prop> wearEquipRefine(int equipID, String guid, int pos, int costItem, SBean.EquipRefineGroupCFGS ergCfg, int propCount)
	{
		SBean.DBWearEquip wequip = this.wearEquips.get(pos);
		if(wequip == null || wequip.equip.id != equipID || !wequip.equip.guid.equals(guid))
			return null;
		
		SBean.EquipCFGS eCfg = GameData.getInstance().getEquipCFG(equipID);
		if(eCfg == null || !eCfg.refineCosts.contains(costItem < 0 ? - costItem : costItem))
			return null;
		
		if(!this.containsEnoughGameItem(eCfg.refineFixCost.id, eCfg.refineFixCost.count))
			return null;
		
		this.equipRefineCost(eCfg.refineFixCost, costItem, equipID, pos);
		List<SBean.Prop> props = GameData.createRefineProp(ergCfg, propCount, eCfg.lvlReq);
		wequip.equip.refine = Stream.clone(props);
		this.updateEquip(wequip);
		gs.getTLogger().logEquipStrength(this, pos, 0, TLog.AT_EQUIP_REFINE, equipID, true);
		
		return props;
	}
	
	private List<SBean.Prop> bagEquipRefine(int equipID, String guid, int costItem, SBean.EquipRefineGroupCFGS ergCfg, int propCount)
	{
		CellItem ci = this.getBagItem(equipID);
		if (ci == null || !ci.contains(guid))
			return null;
		
		CellItem.Wearable wearable = ci.getWearable();
		if(wearable == null || !wearable.isRefineCostItem(costItem < 0 ? -costItem : costItem))
			return null;
		
		SBean.DBEquip equip = wearable.getEquipData(guid);
		if(equip == null)
			return null;
		
		if(!this.containsEnoughGameItem(wearable.getRefineFixCost().id, wearable.getRefineFixCost().count))
			return null;
		
		this.equipRefineCost(wearable.getRefineFixCost(), costItem, equipID, 0);
		if(costItem > 0 && equip.id < 0)
			this.bag.setEquipLock(equip);
		
		List<SBean.Prop> props = GameData.createRefineProp(ergCfg, propCount, wearable.getLvlReq());
		equip.refine = Stream.clone(props);
		return props;
	}
	
	private void equipRefineCost(SBean.DummyGoods fixCost, int costItem, int equipID, int pos)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EQUIP_REFINE);
		tlogEvent.setArg(equipID, pos);
		this.delGameItem(costItem, 1, tlogEvent.getGameItemRecords());
		this.delGameItem(fixCost.id, fixCost.count, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}
	
	// 技能
	// ////////////////////////////////////////////////////////////////////////////////////////////////////////////
	public synchronized boolean selectSkill(int slotId, int id)
	{
		if (slotId < 1 || slotId > this.curSkills.size())
			return false;
		if (!this.skills.containsKey(id) || this.uniqueSkills.contains(id))
			return false;
		Integer slotSkill = this.curSkills.get(slotId - 1);
		for (int i = 0; i < this.curSkills.size(); ++i)
			if (this.curSkills.get(i) == id)
				if (slotSkill != null)
					this.curSkills.set(i, slotSkill);
				else
					this.curSkills.set(i, 0);
		this.curSkills.set(slotId - 1, id);

		gs.getMapService().syncRoleUpdateCurSkills(this.id, this.gameMapContext.getCurMapId(), this.curSkills);
		return true;
	}

	private void updateSkill(SBean.DBSkill skill)
	{
		this.skills.put(skill.id, skill);

		gs.getMapService().syncRoleUpdateSkill(this.id, this.gameMapContext.getCurMapId(), skill.kdClone());
		this.roleProperties.onUpdateSkill(skill.kdClone(), true);
	}

	public synchronized boolean skillUnlock(int id)
	{
		SBean.ClassRoleCFGS roleCFGS = GameData.getInstance().getClassRoleCFG(classType);
		if (roleCFGS == null || !roleCFGS.skills.contains(id))
			return false;

		SBean.SkillCFGS skillCFGS = GameData.getInstance().getSkillCFG(id);
		if (skillCFGS == null)
			return false;
		SBean.SkillLevelCFGS slCfg = GameData.getSkillLevelCFG(skillCFGS, 1);
		if (slCfg == null || slCfg.common.roleLvlReq > this.level)
			return false;

		if (skills.containsKey(id))
			return false;

		SBean.DBSkill skill = new SBean.DBSkill(id, 1, 0);
		this.updateSkill(skill);
		gs.getTLogger().logSkillUnlock(this, id);
		return true;
	}

	public synchronized boolean skillLevelUp(int id, int level)
	{
		SBean.SkillCFGS skillCFGS = GameData.getInstance().getSkillCFG(id);
		if (skillCFGS == null || level <= 0 || level > skillCFGS.lvlDatas.size())
			return false;
		SBean.DBSkill skill = skills.get(id);
		SBean.SkillLevelCFGS skillLevelCFGS = skillCFGS.lvlDatas.get(skill.level - 1);
		SBean.SkillLevelUpLevelCostCFGS costCFGS = skillLevelCFGS.common.costs.get(level);
		if (skill == null || costCFGS == null || skill.level >= level)
			return false;
		if (this.level < costCFGS.lvlReq)
			return false;
		if (costCFGS.coin > 0 && !this.canUseCoin(costCFGS.coin, false))
			return false;
		for (Map.Entry<Integer, Integer> entry : costCFGS.items.entrySet())
		{
			if (!this.containsEnoughGameItem(entry.getKey(), entry.getValue()))
				return false;
		}

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SKILL_LEVEL_UP);
		tlogEvent.setArg(id, level, costCFGS.coin);
		if (costCFGS.coin > 0)
			this.useCoin(costCFGS.coin, false, tlogEvent.getGameItemRecords());
		for (Map.Entry<Integer, Integer> entry : costCFGS.items.entrySet())
		{
			this.delGameItem(entry.getKey(), entry.getValue(), tlogEvent.getGameItemRecords());
		}
		skill.level = level;
		this.updateSkill(skill);

		if(uniqueSkills.contains(id))
		{
			testChallengeTask(GameData.CHALLENGE_TASK_ID_UNIQUE_SKILL_LEVEL, 0);
		}
		else 
		{
			testChallengeTask(GameData.CHALLENGE_TASK_ID_SKILL_LEVEL, 0);
		}
		if (this.uniqueSkills.contains(id))
		{
		    gs.getTLogger().logUniqueSkillLevelUp(this, id, level);
		}
		else 
		{
		    gs.getTLogger().logSkillLevelUp(this, id, level);
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean skillEnhance(int id, int level)
	{
		SBean.DBSkill skill = skills.get(id);
		if (skill == null || level != skill.bourn + 1)
			return false;
		SBean.SkillBournCFGS sbCfgs = GameData.getInstance().getSkillBournCFGS(level);
		if (sbCfgs == null)
			return false;
		if (!this.containsEnoughGameItems(sbCfgs.items))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SKILL_ENHANCE);
		tlogEvent.setArg(id, level);
		this.delGameItems(sbCfgs.items, tlogEvent.getGameItemRecords());
		skill.bourn = level;
		this.updateSkill(skill);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
        gs.getTLogger().logSkillRankUp(this, id, level);
		return true;
	}
	
	private void initUniqueSkills(Set<Integer> skillIDs)
	{
		for(int skillID: skillIDs)
		{
			if(GameData.getInstance().isUniqueSkill(skillID))
				this.uniqueSkills.add(skillID);
		}
	}
	
	synchronized boolean setCurUniqueSkill(int skillID)
	{
		if(!this.uniqueSkills.contains(skillID) || skillID == this.curUniqueSkill)
			return false;
		
		this.curUniqueSkill = skillID;
		gs.getMapService().syncRoleUpdateCurUniqueSkill(this.id, this.gameMapContext.getCurMapId(), skillID);
		gs.getTLogger().logUniqueSkillSet(this, skillID, skillID);
		return true;
	}
	
	private void updateSpirit(SBean.DBSpirit spirit)
	{
		spirits.put(spirit.id, spirit);
		gs.getMapService().syncRoleUpdateSpirit(this.id, this.gameMapContext.getCurMapId(), spirit.kdClone());
		this.roleProperties.onUpdateSpirit(spirit);
	}

	public synchronized boolean learnSpirit(int id)
	{
		SBean.SpiritCFGS cfg = GameData.getInstance().getSpiritCFGS(id);
		if (cfg == null)
			return false;

		List<Integer> avaiableSpirits = GameData.getInstance().getAvaiableSpirit(this.classType, this.transformLevel, this.BWType);
		if (avaiableSpirits == null || !avaiableSpirits.contains(id))
			return false;
		if (spirits.containsKey(id))
			return false;

		if (!this.containsEnoughGameItem(cfg.studyUse, 1))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_LEARN_SPIRIT);
		tlogEvent.setArg(id, cfg.studyUse);
		this.delGameItem(cfg.studyUse, 1, tlogEvent.getGameItemRecords());
		SBean.DBSpirit spirit = new SBean.DBSpirit(id, 0);
		this.updateSpirit(spirit);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_SPIRIT, 0);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
        gs.getTLogger().logSpiritLearn(this, id, 0);
		return true;
	}

	public synchronized boolean spiritLevelUp(int id, int level)
	{
		SBean.SpiritCFGS cfg = GameData.getInstance().getSpiritCFGS(id);
		if (cfg == null)
			return false;

		List<Integer> avaiableSpirits = GameData.getInstance().getAvaiableSpirit(this.classType, this.transformLevel, this.BWType);
		if (avaiableSpirits == null || !avaiableSpirits.contains(id))
			return false;
		SBean.DBSpirit spirit = spirits.get(id);
		if (spirit == null || level != spirit.level + 1)
			return false;

		SBean.SpiritGrowUpCFGS gucfg = cfg.growups.get(level);
		if (gucfg == null)
			return false;
		if (!this.canUseBookInspiration(gucfg.bookInspiration))
			return false;
		if (!this.containsEnoughGameItems(gucfg.items))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SPIRIT_LEVEL_UP);
		tlogEvent.setArg(id, level, gucfg.bookInspiration);
		this.useBookInspiration(gucfg.bookInspiration, tlogEvent.getGameItemRecords());
		this.delGameItems(gucfg.items, tlogEvent.getGameItemRecords());
		spirit.level = level;

		this.updateSpirit(spirit);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logSpiritLevelUp(this, id, level);
		return true;
	}

	public synchronized boolean installSpirit(int id)
	{
		SBean.SpiritCFGS cfg = GameData.getInstance().getSpiritCFGS(id);
		if (cfg == null)
			return false;
		SBean.DBSpirit spirit = spirits.get(id);
		if (spirit == null)
			return false;

		if (curSpirits.contains(id))
			return false;
		int useTotal = 0;
		for (int tid : curSpirits)
		{
			SBean.SpiritCFGS othercfg = GameData.getInstance().getSpiritCFGS(tid);
			if (othercfg.type == cfg.type)
				useTotal++;
		}
		if (useTotal >= GameData.getInstance().getSpiritUseTotalByType(cfg.type))
			return false;
		curSpirits.add(id);

		this.roleProperties.onUpdateCurSpirit(curSpirits);

		gs.getMapService().syncRoleUpdateCurSpirit(this.id, this.gameMapContext.getCurMapId(), curSpirits);
		return true;
	}

	public synchronized boolean uninstallSpirit(int id)
	{
		SBean.SpiritCFGS cfg = GameData.getInstance().getSpiritCFGS(id);
		if (cfg == null)
			return false;
		SBean.DBSpirit spirit = spirits.get(id);
		if (spirit == null)
			return false;

		if (!curSpirits.contains(id))
			return false;
		curSpirits.remove((Integer.valueOf(id)));

		this.roleProperties.onUpdateCurSpirit(curSpirits);

		gs.getMapService().syncRoleUpdateCurSpirit(this.id, this.gameMapContext.getCurMapId(), curSpirits);
		return true;
	}

	// //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	private boolean testDailyTasks()
	{
		Collection<SBean.DailyTaskCFGS> cfgs = GameData.getInstance().getAllDailyTasks();
		for (SBean.DailyTaskCFGS cfg : cfgs)
		{
			SBean.DBDailyTask task = this.dailyTasks.get(cfg.id);
			if (isDailyTaskCanTakeReward(cfg, task))
				return true;
		}
		return false;
	}

	private void logDailyTask(int id, int times)
	{
		if (times <= 0)
			return;
		SBean.DailyTaskCFGS cfg = GameData.getInstance().getDailyTask(id);
		if (cfg != null && this.level >= cfg.lvlReq)
		{
			SBean.DBDailyTask task = this.dailyTasks.get(id);
			if (task != null)
			{
				if (task.rewards <= 0)
				{
					task.times += times;
					if (task.times >= cfg.times)
						task.times = cfg.times;
				}
			}
		}
	}

	public synchronized List<SBean.DBDailyTask> syncDailyTasks()
	{
		List<SBean.DBDailyTask> tasks = new ArrayList<SBean.DBDailyTask>();
		for (SBean.DBDailyTask e : this.dailyTasks.values())
		{
			SBean.DailyTaskCFGS cfg = GameData.getInstance().getDailyTask(e.id);
			if (cfg != null)
			{
				int curSecondeOfDay = GameTime.getSecondOfDay();
				if (curSecondeOfDay >= cfg.rewardStartTime && curSecondeOfDay <= cfg.rewardEndTime)
				{
					if (this.level >= cfg.lvlReq && e.rewards == 0)
						tasks.add(e.kdClone());
				}
			}
		}
		return tasks;
	}

	private boolean isDailyTaskCanTakeReward(SBean.DailyTaskCFGS cfg, SBean.DBDailyTask task)
	{
		if (cfg == null || this.level < cfg.lvlReq)
			return false;
		int curSecondeOfDay = GameTime.getSecondOfDay();
		if (curSecondeOfDay < cfg.rewardStartTime || curSecondeOfDay > cfg.rewardEndTime)
			return false;
		if (task == null)
			return false;
		if (task.times < cfg.times)
			return false;
		if (task.rewards > 0)
			return false;
		return true;
	}

	public synchronized boolean takeDailyTaskReward(int id)
	{
		SBean.DailyTaskCFGS cfg = GameData.getInstance().getDailyTask(id);
		SBean.DBDailyTask task = this.dailyTasks.get(id);
		if (!isDailyTaskCanTakeReward(cfg, task))
			return false;
		if (!this.canAddGameItems(cfg.rewards))
			return false;
		int exp = (int) (cfg.expFactor * GameData.getInstance().getDailyTaskLevelBaseExp(this.level));

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_DAILY_TASK_REWARD);
		tlogEvent.setArg(id, exp);
		this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_DAILY_TASK, id);
		this.syncAddGameItems(GameData.getInstance().toGameItems(cfg.rewards), tlogEvent);
		task.rewards = 1;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		gs.getTLogger().logDailyTaskFlow(this, id, 0, TLog.TASKEVENT_FINISH);
		
		return true;
	}

	public synchronized int takeMonthlyCardReward()
	{
		SBean.DailyTaskCFGS cfg = GameData.getInstance().getDailyActivity(GameData.DAILY_TASK_ID_RECEIVE_MONTHLY_CARD);
		if (this.level < cfg.lvlReq)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.DBSpecialCardData monthCard = getSpecialCardData(GameData.SPECIALCARD_TYPE_MONTH);
		if (monthCard == null || GameTime.getTime() > monthCard.cardEndTime)
			return GameData.PROTOCOL_OP_FAILED;
		
		if (monthCard.reward != 0)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItems(cfg.rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_DAILY_TASK_REWARD);
		tlogEvent.setArg(id);
		this.syncAddGameItems(GameData.getInstance().toGameItems(cfg.rewards), tlogEvent);
		monthCard.reward = 1;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public void dayRefreshDailyActivity()
	{
		this.dailyVit.reward.clear();
	}

	private void dayRefreshSpecialCard()
	{
		this.specialCards.forEach(card -> card.reward = 0);
	}
	
	public synchronized int takeDailyVitReward(int vitId)
	{
		SBean.DailyTaskCFGS cfg = GameData.getInstance().getDailyActivity(vitId);
		if (this.level < cfg.lvlReq)
			return GameData.PROTOCOL_OP_FAILED;
		int curSecondeOfDay = GameTime.getSecondOfDay();
		if (curSecondeOfDay < cfg.rewardStartTime || curSecondeOfDay > cfg.rewardEndTime)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.dailyVit.reward.contains(vitId))
			return GameData.PROTOCOL_OP_FAILED;
		
		float addtion = getSpecialCardTakeVitAddtion();
		List<SBean.DummyGoods> rewards = new ArrayList<>();
		for(SBean.DummyGoods e: cfg.rewards)
			rewards.add(new SBean.DummyGoods(e.id, (int) (e.count * (1 + addtion))));
		
		if (!this.canAddGameItems(rewards))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_DAILY_TASK_REWARD);
		tlogEvent.setArg(id);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewards), tlogEvent);
		this.dailyVit.reward.add(vitId);
		if (GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).canGetMissVit == 1)
			this.dailyVit.lastReceiveVitTime = GameTime.getTimeH0() + cfg.rewardEndTime;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	// /////////////////////////////--------------------------------------------task-------------------------------------------

	// /////////////////////////////--------------------------------------------challenTask-------------------------------------------
	public synchronized void syncChallengeTasks()
	{
		Map<Integer, SBean.DBChallengeTask> tasks = new TreeMap<Integer, SBean.DBChallengeTask>();
		Map<Integer, Integer> maxValues = new HashMap<Integer, Integer>();
		Map<Integer, Integer> achPoints = new TreeMap<Integer, Integer>(this.achPoints);

		for (SBean.ChallengeTaskGroupCFGS group : GameData.getInstance().getAllChallengeTasks())
		{
			SBean.DBChallengeTask dbTask = this.challengeTasks.get(group.type);
			if (dbTask == null)
			{
				dbTask = new SBean.DBChallengeTask(group.type, 0, (byte) 0);
				this.challengeTasks.put(dbTask.type, dbTask);
			}
			tasks.put(dbTask.type, dbTask);
			maxValues.put(group.type, this.getChTaskMaxValue(group.type, dbTask.seq + 1));
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.chtask_sync_res(tasks, maxValues, achPoints));
	}

	public synchronized boolean takeChallengeTaskReward(int type, int seq)
	{
		SBean.ChallengeTaskCFGS cfg = GameData.getInstance().getChallengeTaskCFGS(type, seq);
		if (cfg == null)
			return false;

		SBean.DBChallengeTask task = this.challengeTasks.get(type);
		if (task == null)
			return false;

		if (seq > task.seq)
			return false;

		if (seq < task.reward)
			return false;

		if (!this.canAddGameItems(cfg.rewards))
			return false;

		task.reward++;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_CHALLENGE_TASK_REWARD);
		tlogEvent.setArg(type, seq, cfg.exp);
		this.syncAddGameItems(GameData.getInstance().toGameItems(cfg.rewards), tlogEvent);
		this.syncAddExp(cfg.exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
		if (cfg.title > 0)
			this.addRoleTitle(cfg.title);

		achPoints.merge(cfg.achtype, cfg.achpoint, (o, v) -> o==null?v:new Integer(o+v));
	    updateRanks();
	    
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	public void testGraspChallengeTask()
	{
	    testChallengeTask(GameData.CHALLENGE_TASK_ID_GRASP_LEVEL, 0);
	}

	private void testChallengeTask(int type, int param)
	{
		SBean.DBChallengeTask dbTask = this.challengeTasks.get(type);
		if (dbTask == null)
		{
			dbTask = new SBean.DBChallengeTask(type, 0, (byte) 0);
			this.challengeTasks.put(type, dbTask);
		}
		SBean.ChallengeTaskGroupCFGS gcfg = GameData.getInstance().getChallengeTaskGroupCFGS(type);
		if (gcfg == null)
			return;
		
		for (int seq = dbTask.seq + 1; seq <= gcfg.tasks.size(); ++seq)
		{
			SBean.ChallengeTaskCFGS cfg = gcfg.tasks.get(seq - 1);
			if (param != 0 && param != cfg.param1)
				break;
			int value = this.getChTaskCurValue(type, cfg.param1);
			if (value < cfg.target)
				break;
			dbTask.seq += 1;
			
		}
		
	}

	private int getChTaskCurValue(int type, int param)
	{
		int value = 0;
		switch (type)
		{
		case GameData.CHALLENGE_TASK_ID_LEVEL:
			value = this.level;
			break;
		case GameData.CHALLENGE_TASK_ID_FIGHTPOWER:
			value = this.roleProperties.getRoleFightPower();
			break;
		case GameData.CHALLENGE_TASK_ID_WEAR_PEQUIP:
			value = this.logWearEquips.getOrDefault(GameData.EQUIP_RANK_PURPLE, 0);
			break;
		case GameData.CHALLENGE_TASK_ID_WEAR_OEQUIP:
			value = this.logWearEquips.getOrDefault(GameData.EQUIP_RANK_ORANGE, 0);
			break;
		case GameData.CHALLENGE_TASK_ID_ONE_STORY_MAPCOPY:
			value = this.getMapCopyFinishTimes(param);
			break;
		case GameData.CHALLENGE_TASK_ID_ONE_EASY_MAPCOPY:
			value = this.getMapCopyFinishTimes(param);
			break;
		case GameData.CHALLENGE_TASK_ID_ONE_HARD_MAPCOPY:
			value = this.getMapCopyFinishTimes(param);
			break;
		case GameData.CHALLENGE_TASK_ID_ONE_TEAM_MAPCOPY:
			value = this.getMapCopyFinishTimes(param);
			break;
		case GameData.CHALLENGE_TASK_ID_ANY_PRIVATE_MAPCOPY:
			value = this.getFinishedMapCopyCount(GameData.MAPCOPY_OPEN_TYPE_PRIVATE);
			break;
		case GameData.CHALLENGE_TASK_ID_ANY_PUBLIC_MAPCOPY:
			value = this.getFinishedMapCopyCount(GameData.MAPCOPY_OPEN_TYPE_PUBLIC);
			break;
		case GameData.CHALLENGE_TASK_ID_NORMALARENA_TOP100:
			value = this.arenaInfo.roleArenaData.normal.top500Days;
			break;
		case GameData.CHALLENGE_TASK_ID_SUPERARENA_TOP100:
			//TODO 废弃
			break;
		case GameData.CHALLENGE_TASK_ID_USE_BIND_COIN:
			value = this.coinRUseTotal;
			break;
		case GameData.CHALLENGE_TASK_ID_USE_BIND_DIAMOND:
			value = this.diamondRUseTotal;
			break;
		case GameData.CHALLENGE_TASK_ID_USE_FREE_COIN:
			value = this.coinFUseTotal;
			break;
		case GameData.CHALLENGE_TASK_ID_USE_FREE_DIAMOND:
			value = this.diamondFUseTotal;
			break;
		case GameData.CHALLENGE_TASK_ID_GAIN_WEAPON:
			value = this.weapons.size();
			break;
		case GameData.CHALLENGE_TASK_ID_WEAPON_LEVEL:
			value = this.getWeaponCountByLevel(param);
			break;
		case GameData.CHALLENGE_TASK_ID_WEAPON_STAR:
			value = this.getWeaponCountByStar(param);
			break;
		case GameData.CHALLENGE_TASK_ID_GAIN_PET:
			value = this.activePets.size();
			break;
		case GameData.CHALLENGE_TASK_ID_PET_LEVEL:
			value = this.getPetCountByLevel(param);
			break;
		case GameData.CHALLENGE_TASK_ID_PET_STAR:
			value = this.getPetCountByStar(param);
			break;
		case GameData.CHALLENGE_TASK_ID_FRIEND_COUNT:
			value = this.friend.getCurFriendCnt();
			break;
		case GameData.CHALLENGE_TASK_ID_OPSEX_FRIEND_COUNT:
			//TODO
			break;
		case GameData.CHALLENGE_TASK_ID_MARRY:
			//TODO
			break;
		case GameData.CHALLENGE_TASK_ID_SWORN:
			//TODO
			break;
		case GameData.CHALLENGE_TASK_ID_EQUIP_STRENGTHEN:
			value = this.getLowestStrengthen();
			break;
		case GameData.CHALLENGE_TASK_ID_EQUIP_STAR_UP:
			value = this.getLowestStarUp();
			break;
		case GameData.CHALLENGE_TASK_ID_SKILL_LEVEL:
			value = this.getSkillLevelSum();
			break;
		case GameData.CHALLENGE_TASK_ID_UNIQUE_SKILL_LEVEL:
			value = this.getUniqueSkillLevelSum();
			break;
		case GameData.CHALLENGE_TASK_ID_SPIRIT:
		    value = this.getSpiritCnt();
		    break;
		case GameData.CHALLENGE_TASK_ID_EMBED:
		    value = this.historyMaxGemNum;
		    break;
		case GameData.CHALLENGE_TASK_ID_ANY_GEMLEVEL:
		    value = this.historyMaxGemLevel;
		    break;
		case GameData.CHALLENGE_TASK_ID_TREASURE:
		    value = this.getTreasureCnt();
		    break;
		case GameData.CHALLENGE_TASK_ID_RIDING_LEVEL:
		    value = this.getHorseSkillMaxLevel();
		    break;
		case GameData.CHALLENGE_TASK_ID_SUPERARENA_TIMES:
		    value = this.getSuperArenaTotalJoinTimes();
		    break;
		case GameData.CHALLENGE_TASK_ID_FORCEWAR_TIMES:
		    value = this.getForceWarJoinTimes();
		    break;
		case GameData.CHALLENGE_TASK_ID_ANY_TOWER_LEVEL:
		    value = this.getClimbTowerMaxFloor();
		    break;
		case GameData.CHALLENGE_TASK_ID_BW_COPY_LEVEL:
		    value = this.getBWArenaMaxLevel();
		    break;
		case GameData.CHALLENGE_TASK_ID_RAREBOOK:
		    value = this.getRareBooksCnt();
		    break;
		case GameData.CHALLENGE_TASK_ID_GRASP_LEVEL:
		    value = this.getGraspTotalLevel();
		    break;
		case GameData.CHALLENGE_TASK_ID_PRODUCE_LEVEL:
		    value = this.getProduceLevel();
		    break;
		case GameData.CHALLENGE_TASK_ID_SELL_OR_BUY:
		    value = this.getAuctionSellAndBuyItemsCnt();
		    break;
		case GameData.CHALLENGE_TASK_ID_ANY_ARMORLEVEL:
		    value = this.getArmorMaxLevel();
		    break;
		case GameData.CHALLENGE_TASK_ID_ANY_ARMORRANK:
		    value = this.getArmorMaxRank();
		    break;
		default:
			break;
		}
		return value;
	}

    private int getAuctionSellAndBuyItemsCnt()
    {
        return auctionInfo.buyItemsCnt + auctionInfo.sellItemsCnt;
    }

    private int getArmorMaxRank()
    {
        return armor.allArmors.stream().mapToInt(e-> e.rank).max().orElse(0);
    }

    private int getArmorMaxLevel()
    {
        return armor.allArmors.stream().mapToInt(e-> e.level).max().orElse(0);
    }

    private int getProduceLevel()
    {
        return produce.produceLvl;
    }

    private int getGraspTotalLevel()
    {
        return this.roleExpCoin.graspData.grasps.entrySet().stream().mapToInt(e-> e.getValue().lvl).sum(); 
    }

    private int getBWArenaMaxLevel()
    {
        return Role.this.arenaInfo.roleArenaData.bwarena.lvl;
    }

    private int getClimbTowerMaxFloor()
    {
        final int maxFloor[] = {0};
        this.climbTowerData.roleClimbTowerData.history.forEach((groupId, groupMaxFloor) ->
        {
            maxFloor[0] = Math.max(maxFloor[0], groupMaxFloor);
        }); 
        return maxFloor[0];
    }

    private int getHorseSkillMaxLevel()
    {
	    int maxLevel = 0;
		for (Entry<Integer, Integer> entry : this.horseData.dbHorse.allHorseSkills.entrySet())
		{
		    Integer skillID = entry.getKey();
		    Integer level = entry.getValue();
		    
		    if (skillID != 0 && level != 0)
		    {
		        maxLevel = Math.max(maxLevel, level);
		    }
		}
		
        return maxLevel;
    }

    private int getTreasureCnt()
    {
        return treasuremapInfo.info.medals.size();
    }

    private int getWearedGemCnt()
    {
	    if (this.wearParts==null)
	        return 0;
	    int result = 0;
	    for (SBean.DBEquipPart p : wearParts)
	    {
	        if (p==null) continue;
	        
	        for (int gem : p.eqSlots)
	        {
	            if (gem!=0)
	            {
	                result += 1;
	            }
	        }
	    }
	    
        return result;
    }

    private int getSpiritCnt()
    {
        return spirits.size();
    }

    private int getRareBooksCnt()
    {
        return (int)this.roleExpCoin.rarebookData.books.entrySet().stream().filter(x-> x.getValue() != 0).count();
    }

    private int getUniqueSkillLevelSum()
	{
		int skillLevelSum = 0;
		for (SBean.DBSkill skill : this.skills.values())
		{
			if (uniqueSkills.contains(skill.id))
				skillLevelSum += skill.level;
		}
		return skillLevelSum;
	}

	private int getSkillLevelSum()
	{
		int skillLevelSum = 0;
		for (SBean.DBSkill skill : this.skills.values())
		{
			if (!uniqueSkills.contains(skill.id))
				skillLevelSum += skill.level;
		}
		return skillLevelSum;
	}

	private int getLowestStarUp()
	{
		int lowestStarUp = Integer.MAX_VALUE;
		for (SBean.DBEquipPart part : this.wearParts)
		{
			if (lowestStarUp > part.eqEvoLvl)
				lowestStarUp = part.eqEvoLvl;
		}
		return lowestStarUp;
	}

	private int getLowestStrengthen()
	{
		int lowestStrengthen = Integer.MAX_VALUE;
		for (SBean.DBEquipPart part : this.wearParts)
		{
			if (lowestStrengthen > part.eqGrowLvl)
				lowestStrengthen = part.eqGrowLvl;
		}
		return lowestStrengthen;
	}

	private int getChTaskMaxValue(int type, int nextSeq)
	{
		SBean.ChallengeTaskCFGS cfg = GameData.getInstance().getChallengeTaskCFGS(type, nextSeq);
		return cfg == null ? 0 : this.getChTaskCurValue(type, cfg.param1);
	}

	private void logWearEquip()
	{
		int pCount = 0;
		int oCount = 0;
		for (SBean.DBWearEquip we : this.wearEquips.values())
		{
			int rank = GameData.getInstance().getItemRank(we.equip.id);
			switch (rank)
			{
			case GameData.EQUIP_RANK_PURPLE:
				pCount++;
				break;
			case GameData.EQUIP_RANK_ORANGE:
				oCount++;
				break;
			default:
				break;
			}
		}
		int p = this.logWearEquips.getOrDefault(GameData.EQUIP_RANK_PURPLE, 0);
		if (pCount > p)
		{
			this.logWearEquips.put(GameData.EQUIP_RANK_PURPLE, pCount);
			testChallengeTask(GameData.CHALLENGE_TASK_ID_WEAR_PEQUIP, 0);
		}

		int o = this.logWearEquips.getOrDefault(GameData.EQUIP_RANK_ORANGE, 0);
		if (oCount > o)
		{
			this.logWearEquips.put(GameData.EQUIP_RANK_ORANGE, oCount);
			testChallengeTask(GameData.CHALLENGE_TASK_ID_WEAR_OEQUIP, 0);
		}
	}

	private int getMapCopyFinishTimes(int mapId)
	{
		SBean.DBNormalMapCopyLog log = this.normalMapCopyLogs.get(mapId);
		return log == null ? 0 : log.finishTimes;
	}

	private int getFinishedMapCopyCount(int openType)
	{
		int count = 0;
		for (Map.Entry<Integer, SBean.DBNormalMapCopyLog> e : this.normalMapCopyLogs.entrySet())
		{
			int type = GameData.getInstance().getMapCopyOpenType(e.getKey());
			if (type == openType)
				count += e.getValue().finishTimes;
		}

		return count;
	}

	private int getWeaponCountByLevel(int needLevel)
	{
		int count = 0;
		for (SBean.DBWeapon w : this.weapons.values())
		{
			if (w.level >= needLevel)
				count++;
		}
		return count;
	}

	private int getWeaponCountByStar(int needStar)
	{
		int count = 0;
		for (SBean.DBWeapon w : this.weapons.values())
		{
			if (w.star >= needStar)
				count++;
		}

		return count;
	}

	private int getPetCountByLevel(int needLevel)
	{
		int count = 0;
		for (SBean.DBPet p : this.activePets.values())
		{
			if (p.fightPet.level >= needLevel)
				count++;
		}
		return count;
	}

	private int getPetCountByStar(int needStar)
	{
		int count = 0;
		for (SBean.DBPet p : this.activePets.values())
		{
			if (p.fightPet.star >= needStar)
				count++;
		}

		return count;
	}

	private boolean testChallengeTask()
	{
		for (SBean.DBChallengeTask dbTask : this.challengeTasks.values())
		{
			SBean.ChallengeTaskCFGS taskCFGS=GameData.getInstance().getChallengeTaskCFGS(dbTask.type, dbTask.reward + 1);
			if (taskCFGS != null && this.level >= taskCFGS.levelNeed && dbTask.seq > dbTask.reward)
				return true;
		}
		return false;
	}
	
	private boolean testFame()
	{
		SBean.FameLevelCFGS cfg = GameData.getInstance().getFameLevelCFGS(this.fame.level + 1);
		return this.level >= GameData.getInstance().getFameOpenLevel() && (this.fame.reward == 0 || (cfg !=null && testFameCanLevelUpImpl(GameTime.getTime(), cfg)));
	}
	
	private boolean testVipReward()
	{
		return this.share.getVipLevel() > this.vipRewards.size();
	}
	
	private boolean testFameCanLevelUpImpl(int now, SBean.FameLevelCFGS cfg)
	{
		for (SBean.FameConditionCFGS condcfg : cfg.condition)
		{
			if (!testFameCondition(condcfg.id, condcfg.value))
				return false;
		}
		if (!this.containsEnoughGameItems(cfg.cost))
			return false;
		return this.fame.upgradeTime + cfg.levelUpCD <= now; 
	}
	
	private boolean testFameCondition(int id, int value)
	{
		boolean achieve = false;
		switch (id)
		{
		case GameData.FAME_ID_ROLE_LEVEL:
			achieve = this.level >= value;
			break;
		case GameData.FAME_ID_HIGHEST_POWER:
			achieve = this.historyHighestPower >= value;
			break;
		case GameData.FAME_ID_JOIN_SECT:
			achieve = this.sectData.data.lastJoinTime > 0;
			break;
		case GameData.FAME_ID_MAX_FRIENDS:
			achieve = this.friend.friendData.historyMaxFriends >= value;
			break;
		case GameData.FAME_ID_TOTAL_CHARM:
			achieve = this.friend.friendData.charm >= value;
			break;
		case GameData.FAME_ID_TOTAL_SECT_CONTRIBUTION:
			achieve = this.sectData.data.historyContribution >= value;
			break;
		case GameData.FAME_ID_TOTAL_AREA_POINT:
			achieve = this.arenaInfo.roleArenaData.normal.historyPoint >= value;
			break;
		case GameData.FAME_ID_TOTAL_SUPERAREA_HONOR:
			achieve = this.arenaInfo.roleArenaData.superarena.historyPoint >= value;
			break;
		case GameData.FAME_ID_TOTAL_ROBMONEY:
			achieve = this.sectDeliver.historyRobMoney >= value;
			break;
		case GameData.FAME_ID_TOTAL_DELIVER:
			achieve = this.sectDeliver.historyAcceptTime >= value;
			break;
		case GameData.FAME_ID_TOTAL_OPEN_BANQUETS:
			achieve = this.sectData.data.historyBanquetOpenTimes >= value;
			break;
		case GameData.FAME_ID_TOTAL_DIY_SKILLS:
			achieve = this.diySkillData.historyCreateCount >= value;
			break;
		case GameData.FAME_ID_TOTAL_ENTER_ACTIVITY_MAPCOPYS:
			achieve = this.getActivityMapCopyTotalEnterTimes() >= value;
			break;
		case GameData.FAME_ID_ALL_TOWER_LEVEL:
			achieve = this.getTowerMinBestLevel() >= value;
			break;
		default:
			break;
		}
		return achieve;
	}
	
	void dayRefreshFame()
	{
		this.fame.reward = 0;
	}
	
	synchronized SBean.FameInfo syncFame(int level)
	{
		List<Integer> nextCond = new ArrayList<Integer>();
		SBean.FameLevelCFGS cfg = GameData.getInstance().getFameLevelCFGS(level + 1);
		if (cfg != null)
		{
			for (SBean.FameConditionCFGS condcfg : cfg.condition)
			{
				if (level < this.fame.level)
					nextCond.add(1);
				else
					nextCond.add(testFameCondition(condcfg.id, condcfg.value) ? 1 : 0);
			}	
		}
		return new SBean.FameInfo(level == this.fame.level ? this.fame.reward : 0, level == this.fame.level ? this.fame.upgradeTime : 0, nextCond);
	}
	
	synchronized boolean upgradeFame(int level)
	{
		if (level != this.fame.level + 1 || this.level < GameData.getInstance().getFameOpenLevel())
			return false;
		SBean.FameLevelCFGS cfg = GameData.getInstance().getFameLevelCFGS(level);
		if (cfg == null)
			return false;
		int now = GameTime.getTime();
		if (!testFameCanLevelUpImpl(now, cfg))
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_FAME_UPGRADE);

		this.delGameItems(cfg.cost, tlogEvent.getGameItemRecords());
		this.fame.level = level;
		this.fame.reward = 0;
		this.fame.upgradeTime = now;
		if (cfg.title > 0)
			this.addRoleTitle(cfg.title);
		
		tlogEvent.setArg(level);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	synchronized boolean takeFameRewards(int level)
	{
		if (level != this.fame.level || this.level < GameData.getInstance().getFameOpenLevel())
			return false;
		SBean.FameLevelCFGS cfg = GameData.getInstance().getFameLevelCFGS(level);
		if (cfg == null)
			return false;
		if (this.fame.reward != 0)
			return false;
		if (!this.canAddGameItems(cfg.rewards))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_FAME_UPGRADE);
		this.syncAddGameItems(GameData.getInstance().toGameItems(cfg.rewards), tlogEvent);
		this.fame.reward = 1;
		
		tlogEvent.setArg(level);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	void resetDailyOnlineTimeRecord(int timeTick)
	{
		this.dailyOnlineLastRecordTime = timeTick;
	}

	void dayRefreshDailyOnlineTime(int timeTick)
	{
		this.resetDailyOnlineTimeRecord(timeTick);
		this.dailyOnlineGift.dayOnlineTime = 0;
		this.dailyOnlineGift.rewards.clear();
	}

	void tryRefreshDailyOnlineTime(int timeTick)
	{
		if (this.dailyOnlineLastRecordTime > 0 && timeTick > this.dailyOnlineLastRecordTime)
		{
			int d = timeTick - this.dailyOnlineLastRecordTime;
			if (d > 60)
			{
				this.dailyOnlineGift.dayOnlineTime += d / 60;
				this.dailyOnlineLastRecordTime = timeTick - d % 60;
			}
		}

	}

	public boolean testDailyOnlineGiftLeft()
	{
		return !this.dailyOnlineGift.rewards.containsAll(GameData.getInstance().getDailyOnlineGiftRewardPoints());
	}

	public boolean testDailyOnlineGift()
	{
		return GameData.getInstance().getDailyOnlineGiftRewardPoints().stream().anyMatch(time -> (this.dailyOnlineGift.dayOnlineTime >= time && !this.dailyOnlineGift.rewards.contains(time)));
	}

	public boolean testDailyVitReward()
	{
		final int second = GameTime.getSecondOfDay();
		return GameData.getInstance().getDailyVits().stream().anyMatch(dailyVit -> !this.dailyVit.reward.contains(dailyVit.id) && dailyVit.rewardStartTime <= second && dailyVit.rewardEndTime >= second);
	}

	public synchronized SBean.DBDailyOnlineGift syncDailyOnlineGift()
	{
		return this.dailyOnlineGift.kdClone();
	}

	public synchronized boolean takeDailyOnlineGift(int minute)
	{
		SBean.DailyOnlineGiftCFGS cfg = GameData.getInstance().getDailyOnlineGift(minute);
		if (cfg == null)
			return false;
		if (this.dailyOnlineGift.dayOnlineTime < minute)
			return false;
		if (this.dailyOnlineGift.rewards.contains(minute))
			return false;

		if (!this.canAddGameItems(cfg.rewards))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_DAILY_ONLINE_GIFT);
		tlogEvent.setArg(minute);
		this.syncAddGameItems(GameData.getInstance().toGameItems(cfg.rewards), tlogEvent);
		this.dailyOnlineGift.rewards.add(minute);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public void logOfflineExp(int timeTick)
	{
		if (this.level >= GameData.getInstance().getOfflineExpCFG().openLevel)
		{
			int time = logOfflineTime(timeTick);
			if (time > 0)
			{
				if (time + this.offlineExp.accTimeTotal > GameData.getInstance().getOfflineExpCFG().maxAccTime)
					time = GameData.getInstance().getOfflineExpCFG().maxAccTime - this.offlineExp.accTimeTotal;
				if (time > 0)
				{
					long exp = time * GameData.getInstance().getOfflineExpCFG().expPerMinute * GameData.getInstance().getOfflineLevelBaseExp(this.level);
					float speedUp = 1.f + GameData.getInstance().getSpeedUpAdd(this.speedUpLvl - this.level);
					exp = (long) (exp * speedUp);
					if (GameData.getInstance().isLevelLimit(this.level, this.exp))
						exp = (long) (exp * GameData.getInstance().getLevelLimit().base.expRate);

					this.offlineExp.accTimeTotal += time;
					this.offlineExp.accExpTotal += exp;
					SBean.OfflineExpCFGS cfg = GameData.getInstance().getOfflineExpCFG();
					SBean.MonsterCFGS monsterCFGS = GameData.getInstance().getOfflineWizardMonsterCFGS(this.level);
					int monsterNum = time * cfg.monsterNumPerMin;
					Map<Integer, Integer> drops = GameData.toCounter(this.offlineExp.accDrops);
					GameData.getInstance().mergeBatchFixedDrop(monsterCFGS.fixedDropID, monsterNum, drops);
					GameData.getInstance().mergeBatchRandomDrop(monsterCFGS.randomDropIDs.get(this.classType - 1), monsterNum * monsterCFGS.randomDropCnt, drops);
					this.offlineExp.accDrops = GameData.toDummGoods(drops);
					this.lastOnlineTime = timeTick;
				}
			}
		}
	}

	private int logOfflineTime(int timeTick)
	{
		int time = 0;
		int today = GameData.getDayByRefreshTimeOffset(timeTick);
		int lastLoginDay = GameData.getDayByRefreshTimeOffset(this.lastOnlineTime);
		int dayMaxTime = GameData.getInstance().getOfflineExpCFG().dayMaxAccTime + getSpecialCardOfflineTimeAddtion();
		if (lastLoginDay != GameData.getDayByRefreshTimeOffset(this.offlineExp.lastLogTime))
		{
			this.offlineExp.lastDayTakeMin = 0;
		}
		if (today == lastLoginDay)
		{
			time = (timeTick - this.lastOnlineTime) / 60;
			if (time + this.offlineExp.lastDayTakeMin > dayMaxTime)
				time = dayMaxTime - this.offlineExp.lastDayTakeMin;
			this.offlineExp.lastDayTakeMin += time;
		}
		else
		{
			int firstDayTime = (GameTime.getDayTime(lastLoginDay + 1, GameData.GAME_DAY_REFRESH_TIME * 3600) - this.lastOnlineTime) / 60;
			if (firstDayTime + this.offlineExp.lastDayTakeMin > dayMaxTime)
				firstDayTime = dayMaxTime - this.offlineExp.lastDayTakeMin;
			int lastDayTime = (timeTick - GameTime.getDayTime(today, GameData.GAME_DAY_REFRESH_TIME * 3600)) / 60;
			if (lastDayTime > dayMaxTime)
				lastDayTime = dayMaxTime;
			time = (today - lastLoginDay - 1) * dayMaxTime + firstDayTime + lastDayTime;
			this.offlineExp.lastDayTakeMin = lastDayTime;
		}
		this.offlineExp.lastLogTime = timeTick;
		return time;
	}
	
	public void dayRefreshOfflineExp(int timeTick)
	{
		this.offlineExp.dailyOfflineExp = 0;
		this.offlineWizard.dayBuyPointTimes = 0;
	}

	public synchronized int buyOfflineFuncPoint(int seq)
	{
		if (seq != this.offlineWizard.dayBuyPointTimes + 1)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.OfflineExpCFGS offlineCFGS = GameData.getInstance().getOfflineExpCFG();
		int cost = GameData.getTimesCost(offlineCFGS.buyFuncPointDiamond, seq);
		if (!this.canUseDiamond(cost, true))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_OFFLINE_FUNC_POINT);
		tlogEvent.setArg(seq);
		this.useDiamond(cost, true, tlogEvent.getGameItemRecords());
		this.syncAddOfflineFuncPoint(offlineCFGS.funcPointBuyNum, tlogEvent);
		this.offlineWizard.dayBuyPointTimes++;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized SBean.OfflineReward takeOfflineAccExp(int accTime, boolean doubleExp)
	{
		if (this.offlineExp.accTimeTotal != accTime)
			return new SBean.OfflineReward(GameData.PROTOCOL_OP_FAILED, 0, null);
		if (this.offlineExp.accExpTotal <= 0)
			return new SBean.OfflineReward(GameData.PROTOCOL_OP_FAILED, 0, null);
		SBean.OfflineExpCFGS cfg = GameData.getInstance().getOfflineExpCFG();
		SBean.MonsterCFGS monsterCFGS = GameData.getInstance().getOfflineWizardMonsterCFGS(this.level);
		SBean.OfflineWizardFuncCFGS funcCFGS = GameData.getInstance().getOfflineWizardLevelCFGS(this.offlineWizard.level);
		if (monsterCFGS == null || funcCFGS == null || this.level < cfg.openLevel)
			return new SBean.OfflineReward(GameData.PROTOCOL_OP_FAILED, 0, null);
		Map<Integer, Integer> drops = GameData.toCounter(this.offlineExp.accDrops);
		int cost = 0;
		long addExp = this.offlineExp.accExpTotal;
		int wizardExp = accTime;
		drops.forEach((k, v) -> {
			int nv = v;
			if (k == GameData.GAME_ITEM_TYPE_COIN)
				nv += (int) (v * (funcCFGS.offlineCoin / 10000f));
			else
				nv += (int) (v * (funcCFGS.offlineDrop / 10000f));
			drops.put(k, nv);
		});
		if (doubleExp)
		{
			cost = (int) (accTime * cfg.doubleCostPerMinute);
			if (!this.canUseOfflineFuncPoint(cost))
				return new SBean.OfflineReward(GameData.PROTOCOL_OP_OFFLINE_WIZARD_FUNC_POINT_NEED, 0, null);
			addExp *= 2;
			wizardExp *= 2;
			drops.forEach((k, v) -> drops.put(k, v * 2));
		}
		if (!this.canAddGameItems(drops))
			return new SBean.OfflineReward(GameData.PROTOCOL_OP_OFFLINE_WIZARD_BAG_NEED, 0, null);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_OFFLINE_EXP);
		if (cost > 0)
		{
			this.useOfflineFuncPoint(cost, tlogEvent.getGameItemRecords());
		}
		long rightExp = 0;
		if (funcCFGS.offlineExpGet > 0)
		{
			rightExp = (long) (addExp * (funcCFGS.offlineExpGet / 10000f));
			this.syncAddExp(rightExp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
			addExp -= rightExp;
		}
		this.offlineExp.accTimeTotal = 0;
		this.offlineExp.accExpTotal = 0;
		this.offlineExp.accDrops.clear();
		this.offlineExp.dailyOfflineExp += addExp;
		this.syncAddGameItems(GameData.getInstance().toGameItems(drops), tlogEvent);
		GameData.LevelExp lvlExp = GameData.getInstance().getAddOfflineWizardExp(this.offlineWizard.level, this.offlineWizard.exp, wizardExp);
		this.offlineWizard.level = lvlExp.level;
		this.offlineWizard.exp = (int) lvlExp.exp;
		
		tlogEvent.setArg(accTime, (int)(addExp / 10000));
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return new SBean.OfflineReward(addExp, rightExp, GameData.toDummGoods(drops));
	}

	public SBean.QuizGiftInfo syncDailyQuizGiftInfo()
	{
		return gs.getLoginManager().getQuizActivity().getQuizGiftInfo(this);
	}

	public synchronized SBean.DBQuizGift getQuizGiftData(int startTime)
	{
		SBean.DBQuizGift data = this.quizGift.get(startTime);
		if (data == null)
		{
			this.quizGift.clear();
			data = new SBean.DBQuizGift(0, 0, 0, 0, 0, 0);
			this.quizGift.put(startTime, data);
		}
		return data;
	}

	public List<SBean.QuizGiftRankRole> queryDailyQuizGiftRank(int startTime)
	{
		return gs.getLoginManager().getQuizActivity().getRanks(startTime);
	}

	public boolean answerDailyQuizQuestion(int startTime, int curSeq, int answer, boolean useDoubleBonus)
	{
		return gs.getLoginManager().getQuizActivity().tryAnswerQuestion(this, startTime, curSeq, answer, useDoubleBonus);
	}

	// 幸运大转盘
	public synchronized boolean testLuckyWheel()
	{
		int activityStartLevel = GameData.getInstance().getLuckyWheelCFGS().openAtLevel;
		if (this.level < activityStartLevel)
			return false;
		int freeDrawTimes = GameData.getInstance().getLuckyWheelCFGS().dayFreeDrawTimes;
		int vipDrawTimes = GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).luckyWheelFreeDrawTiems;
		if (this.luckyWheel.totalDrawTimes >= freeDrawTimes + vipDrawTimes)
			return false;
		return true;
	}

	public synchronized void resetLuckyWheelDrawTimes()
	{
		if (this.luckyWheelSelectPos.size() == GameData.DAYS_IN_A_WEEK)
		{
			this.luckyWheelSelectPos.clear();
		}
		int pos = GameData.getInstance().getOneDiffRandomInteger(this.luckyWheelSelectPos, this.level);
		this.luckyWheelSelectPos.add(pos);
		this.luckyWheel = new SBean.DBLuckyWheel(0, 0, pos);
	}

	public synchronized SBean.DBLuckyWheel syncLuckyWheelDrawTimes()
	{
		// 第一次进入活动
		if (this.luckyWheel.Id == 0)
		{
			this.luckyWheelSelectPos.clear();
			int pos = GameData.getInstance().getOneDiffRandomInteger(this.luckyWheelSelectPos, this.level);
			this.luckyWheelSelectPos.add(pos);
			this.luckyWheel = new SBean.DBLuckyWheel(0, 0, pos);
		}
		return this.luckyWheel.kdClone();
	}

	public synchronized int luckyWheelOnDraw()
	{
		int activityStartLevel = GameData.getInstance().getLuckyWheelCFGS().openAtLevel;
		if (this.level < activityStartLevel)
			return 0;
		int freeDrawTimes = GameData.getInstance().getLuckyWheelCFGS().dayFreeDrawTimes;
		int vipDrawTimes = GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).luckyWheelFreeDrawTiems;
		if (this.luckyWheel.totalDrawTimes >= freeDrawTimes + vipDrawTimes)
			return 0;

		int result = GameData.getInstance().getLuckyWheelDrawPoint(this.level, this.luckyWheelSelectPos);
		SBean.LuckyWheelGradeCFGS gradeCfgList = GameData.getInstance().getLuckyWheelGradeCFGS(this.level);
		int pos = GameData.getInstance().getLuckyWheelListLastPos(this.luckyWheelSelectPos);
		SBean.LuckyWheelRewardsCFGS cfgList = gradeCfgList.rewards.get(pos);
		List<SBean.DummyGoods> gifts = new ArrayList<>();
		gifts.add(cfgList.items.get(result - 1).reward);

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_LUCKY_WHEEL_ON_DRAW);
		tlogEvent.setArg(cfgList.items.get(result - 1).reward.id, cfgList.items.get(result - 1).reward.count);
		if (this.canAddGameItems(gifts))
			this.syncAddGameItems(GameData.getInstance().toGameItems(gifts), tlogEvent);
		else
			return GameData.PROTOCOL_OP_BAG_NOT_ENOUGH_CELLS;

		this.luckyWheel.totalDrawTimes++;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return result;
	}

	public synchronized boolean buyLuckyWheelDrawTimes(int times)
	{
		if (times <= 0)
			return false;
		int allCanBuyTims = GameData.getInstance().getLuckyWheelCFGS().dayBuyTimes;
		if (times > allCanBuyTims - this.luckyWheel.buyTimes)
			return false;
		List<Integer> price = GameData.getInstance().getLuckyWheelCFGS().buyTimesNeedDiamond;
		int totalDiamond = 0;
		int buyPos = this.luckyWheel.buyTimes + 1;
		for (int i = 0; i < times; ++i)
		{
			totalDiamond += GameData.getTimesCost(price, buyPos++);
		}
		if (!canUseDiamond(totalDiamond, false))
			return false;
		this.luckyWheel.totalDrawTimes -= times;
		this.luckyWheel.buyTimes += times;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_LUCKY_WHEEL_DRAW_TIMES);
		tlogEvent.setArg(times, totalDiamond, this.luckyWheel.buyTimes);
		this.useDiamond(totalDiamond, false, tlogEvent.getGameItemRecords());

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	//燃放烟花
	public int playFirework(int id)
	{
		CellItem ci = this.getBagItem(id);
		if(ci == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		CellItem.Useable useable = ci.getUseable();
		if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, 1))
			return GameData.PROTOCOL_OP_FAILED;
		
		if (!useable.testExceedLimit(this.lifeUse.getOrDefault(id < 0 ? -id : id, 0) + 1))
			return GameData.PROTOCOL_OP_BAG_ROLL_LIFE_MAX_USE;
		
		CellItem.FireWork firework = useable.useAsFireWork();
		if(firework == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		if (this.dayUseItemsTimes.getOrDefault(id, 0) + this.dayUseItemsTimes.getOrDefault(-id, 0) + 1 > useable.getMaxCanUseTimes(this.getUseableVipLvl()))
			return GameData.PROTOCOL_OP_FAILED;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PLAY_FIREWORK);
		tlogEvent.setArg(id);
		this.delGameItem(id, 1, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		if (useable.logRoleUseTimes())
			this.lifeUse.merge(id < 0 ? -id : id, 1, (ov, nv) -> ov + nv);
		this.dayUseItemsTimes.merge(id, 1, (ov, nv) -> ov + nv);
		
		if(firework.needBroadCast())
		{
			int mapID = this.gameMapContext.getCurMapId();
			gs.getLoginManager().sendPlayFirework(this.name, mapID, id);
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public void notifyFirework(String roleName, int mapID, int fireworkID)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.notify_play_firework(roleName, mapID, fireworkID));
	}

	
	public void dayRefreshSnatchRedEnvelopes()
	{
		this.daySnatchRedEnvelopes = 0;
		this.dayGetRedEnvelopesEmptyGift = 0;
	}
	
	public synchronized boolean isDaySnatchRedEnvelopesOverlimit()
	{
		return this.daySnatchRedEnvelopes >= GameData.getInstance().getDaySnatchRedEnvelopeMaxTimes(this.level);
	}
	
	public void receiveRedEnvelope(int amount)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SNATCH_RED_ENEVLOPE);
		this.daySnatchRedEnvelopes++; 
		this.addDiamond(amount, false, tlogEvent.getGameItemRecords());
		
		tlogEvent.setArg(this.daySnatchRedEnvelopes, amount);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}
	
	public synchronized boolean reveiveRedEnvelopeEmptyGift()
	{
		if (!this.canAddGameItem(GameData.getInstance().getRedEnvelopeCFGS().emptyGiftId, 1))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GET_RED_ENEVLOPE_EMPTY_GIFT);
		this.dayGetRedEnvelopesEmptyGift++; 
		this.syncAddGameItem(GameData.getInstance().toGameItem(GameData.getInstance().getRedEnvelopeCFGS().emptyGiftId, 1), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	public void notifyRedEnvelopeInfo(int startTime, int id, int payLevel)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.redenvelope_notice(startTime, id, payLevel));
	}
	
	public synchronized RpcRes<Integer> trySnatchRedEnvelopes(int startTime, int id)
	{
		int result = gs.getLoginManager().getSnatchRedEnvelopeActivity().trySnatchRedEnvelope(this, startTime, id);
		return new RpcRes<Integer>(result, this.dayGetRedEnvelopesEmptyGift);
	}
	///////////////////////////////--------------------------------------------challenTask-------------------------------------------
	private boolean checkMainTaskMine(int mineID)
	{
		SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(this.mainTask.id);
		return this.mainTask.state == 1 && mainCFGS != null && mainCFGS.cond.type == GameData.TASK_TYPE_GATHER && mainCFGS.cond.param1 == mineID && !isTaskFinished(mainCFGS.cond, this.mainTask.value);
	}
	
	private boolean checkBranchTaskMine(int mineID)
	{
		final Map<Integer, SBean.BranchTaskCFGS> branchTaskCfgs = GameData.getInstance().getBranchTask();
		for (int groupId : branchTaskCfgs.keySet())
		{
			SBean.DBBranchTask data = this.branchTask.get(groupId);
			if (data == null || data.state == 0)
				continue;
			
			SBean.BranchTaskDataCFGS cfg = GameData.getInstance().getBranchTaskCFG(groupId, data.id);
			if (cfg != null && cfg.taskParam.type == GameData.TASK_TYPE_GATHER && cfg.taskParam.param1 == mineID && !isTaskFinished(cfg.taskParam, data.value))
				return true;
		}
		
		return false;
	}
	
	private boolean checkWeaponTaskMine(int mineID)
	{
		final SBean.WeaponTaskCFGS weaponCFGS = GameData.getInstance().getWeaponTaskCFG(this.weaponTask.type, this.weaponTask.id);
		if (weaponCFGS != null)
		{
			for (int index = 0; index < weaponCFGS.conds.size(); index++)
			{
				SBean.TaskCondCFGS cond = weaponCFGS.conds.get(index);
				if (index >= 0 && index < this.weaponTask.values.size())
				{
					int val = this.weaponTask.values.get(index);
					if (cond.type == GameData.TASK_TYPE_GATHER && cond.param1 == mineID && !isTaskFinished(cond, val))
						return true;
				}
			}
		}
		return false;
	}
	
	private boolean checkPetTaskMine(int mineID)
	{
		for(SBean.DBPet e: this.activePets.values())
		{
			final SBean.PetTaskCFGS petCFGS = GameData.getInstance().getPetTaskCFG(e.task.id);
			if (petCFGS != null && petCFGS.cond.param1 == mineID && petCFGS.cond.type == GameData.TASK_TYPE_GATHER && !isTaskFinished(petCFGS.cond, e.task.value))
				return true;
			
			final SBean.PetLifeTaskCFGS pltCFGS = GameData.getInstance().getPetLifeTaskCFGS(e.fightPet.id, e.lifetask.id);
			if (pltCFGS != null && pltCFGS.cond.param1 == mineID && pltCFGS.cond.type == GameData.TASK_TYPE_GATHER && !isTaskFinished(pltCFGS.cond, e.task.value))
				return true;
		}
		
		return false;
	}
	
	private boolean checkSectTaskMine(int mineID)
	{
		SBean.SectReceivedTask curSectTask = this.sectData.task.curTask;
		if (curSectTask != null)
		{
			final SBean.SectTaskCFGS sectTask = GameData.getInstance().getSectTaskCFG(curSectTask.task.taskId);
			if (sectTask != null && sectTask.cond.param1 == mineID && sectTask.cond.type == GameData.TASK_TYPE_GATHER && !isTaskFinished(sectTask.cond, curSectTask.value))
				return true;
		}
		
		return false;
	}
	
	private boolean checkMrgTaskMine(int mineID)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return false;
		
		Role partner = getTeamMrgPartner(marriage);
		if(partner == null || !MarriageShare.checkParterNearBy(this, partner))
			return false;
		
		return marriage.checkTaskMine(this, mineID);
	}
	
	public int checkFlagMine(int mineID)
	{
		int now = GameTime.getTime();
		SBean.FlagBattleCFGS flagCFGS = GameData.getInstance().getFlagBattleCFGS();
		if (!flagCFGS.flags.containsKey(this.gameMapContext.getCurMapId()))
			return GameData.PROTOCOL_OP_FAILED;
		if (GameTime.getSecondOfDay(now) < flagCFGS.startTime || GameTime.getSecondOfDay(now) > flagCFGS.endTime)
			return GameData.PROTOCOL_OP_FLAG_NOT_ACTIVITY_TIME;
		if (this.sectData.data.sectBrief.sectID == 0)
			return GameData.PROTOCOL_OP_FLAG_NO_SECT;
		if (this.level < flagCFGS.roleMinLevel)
			return GameData.PROTOCOL_OP_FLAG_LEVEL_NEED;
		if (this.sectData.data.lastJoinTime + flagCFGS.roleJoinSectTimeLimit > now)
			return GameData.PROTOCOL_OP_FLAG_JOIN_TIME_NEED;
		if (this.sectData.data.sectBrief.sectLevel < flagCFGS.sectMinLevel)
			return GameData.PROTOCOL_OP_FLAG_SECT_LEVEL_NEED;
		if (!gs.getFlagManager().isSectDif(this.gameMapContext.getCurMapId(), this.sectData.data.sectBrief.sectID))
			return GameData.PROTOCOL_OP_FLAG_SELF;
		if (!gs.getFlagManager().flagCanTake(this.gameMapContext.getCurMapId()))
			return GameData.PROTOCOL_OP_FLAG_MONSTER_CLEAR;
		if (gs.getFlagManager().getSectFlagNum(this.sectData.data.sectBrief.sectID) >= flagCFGS.sectMaxFlagNum)
			return GameData.PROTOCOL_OP_FLAG_FLAG_MAX;
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int checkWeddingBox(int mineID)
	{
		if (this.marriageData.dayTakeWeddingBoxTimes >= GameData.getInstance().getMarriageBaseCFGS().giftMaxGetTimes)
			return GameData.PROTOCOL_OP_MARRIAGE_GIFTBOX_NO_TIMES;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int checkBanquet(int mineID)
	{
		if (this.marriageData.dayTakeBanquetTimes >= GameData.getInstance().getMarriageBaseCFGS().banquetMaxGetTimes)
			return GameData.PROTOCOL_OP_MARRIAGE_BANQUET_NO_TIMES;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public boolean checkTaskMine(int mineID)
	{
		return checkMainTaskMine(mineID) || checkBranchTaskMine(mineID) || checkWeaponTaskMine(mineID) || checkPetTaskMine(mineID) || checkSectTaskMine(mineID) || checkMrgTaskMine(mineID);
	}

	private void sceneTrig(List<Integer> trigIDs, int trigEvent)
	{
		for(int tid: trigIDs)
		{
			SBean.SceneTrigCFGS stc = GameData.getInstance().getSceneTrigCFGS(tid);
			if(stc == null || stc.trigEvent != trigEvent)
				continue;
			
			switch (stc.trigBehavior)
			{
			case GameData.SCENE_TRIG_BEHAVIOR_SPAWN_MONSTER:
				this.sceneTrigSpawnMonster(stc.param1);
				this.addTrigSpawnPoint(stc.param1);
				break;
			case GameData.SCENE_TRIG_BEHAVIOR_TASK_ALTER:
				if(stc.param1 > 0)
					this.setAlterState(stc.param1);
				break;
			case GameData.SCENE_TRIG_BEHAVIOR_QUIT_ALTER:
				this.setAlterState(-1);
				break;
			default:
				break;
			}
		}
	}
	
	private void clearSceneMonster(List<Integer> trigIDs)
	{
		for(int tid: trigIDs)
		{
			SBean.SceneTrigCFGS stc = GameData.getInstance().getSceneTrigCFGS(tid);
			if(stc == null || stc.trigBehavior != GameData.SCENE_TRIG_BEHAVIOR_SPAWN_MONSTER)
				continue;
			
			SBean.SceneSpawnPointCFGS pointCfg = GameData.getInstance().getSceneSpawnPointCFGS(stc.param1);
			if(pointCfg == null)
				continue;
			
			this.delTrigSpawnPoint(pointCfg);
			gs.getMapService().syncRoleClearSceneMonster(pointCfg.mapID, this.id, pointCfg.monsterID);
		}
	}
	
	private void sceneTrigSpawnMonster(int pointID)
	{
		gs.getMapService().syncRoleSpawnSceneMonster(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance(), this.id, pointID);
	}
	
	int testLogTask(SBean.TaskCondCFGS cfg, int addParam1, int addParam2, int addValue, int curValue)
	{
		return testLogTask(cfg, addParam1, addParam2, addValue, curValue, GameData.emptyList());
	}
	
	int testLogTask(SBean.TaskCondCFGS cfg, int addParam1, int addParam2, int addValue, int curValue, List<Integer> trigIDs)
	{
		int newValue = curValue;
		switch (cfg.type)
		{
		case GameData.TASK_TYPE_KILL:
			if (addParam1 == cfg.param1 && curValue < cfg.param2)
			{
				newValue = curValue + addValue;
				if (newValue > cfg.param2)
					newValue = cfg.param2;
			}
			break;
		case GameData.TASK_TYPE_GATHER:
			if (addParam1 == cfg.param1 && curValue < cfg.param2)
			{
				newValue = curValue + addValue;
				if (newValue > cfg.param2)
					newValue = cfg.param2;
				
				this.sceneTrig(trigIDs, GameData.SCENE_TRIG_EVENT_TASK_MINERAL);
			}
			break;
		case GameData.TASK_TYPE_USE_ITEM:// 道具不真实在背包中
		{
			SBean.ItemCFGS itemCfg = GameData.getInstance().getItemCFG(addParam1);
			if (itemCfg != null)
			{
				SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
				if (GameData.getInstance().testNearbyPosition(curLocation.mapID, curLocation.location.position, cfg.param2, cfg.param3, cfg.param4, cfg.param5, cfg.param6))// &&
				{
					newValue = curValue + addValue;
					if (newValue > 1)
						newValue = 1;

					if (itemCfg.arg5 > 0) //添加buff
						gs.getMapService().syncRoleAddBuff(this.id, curLocation.mapID, itemCfg.arg5);
					
					this.sceneTrig(trigIDs, GameData.SCENE_TRIG_EVENT_TASK_USE_ITEM);
				}
			}
			break;
		}
		case GameData.TASK_TYPE_SUBMIT_ITEM:
			if (addParam1 == cfg.param1 && this.containsEnoughGameItem(cfg.param1, cfg.param2) && addValue == cfg.param2 && curValue < cfg.param2)
			{
				TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TEST_LOG_TASK);
				tlogEvent.setArg(GameData.TASK_TYPE_SUBMIT_ITEM, cfg.param1, cfg.param2);
				this.delGameItem(cfg.param1, cfg.param2, tlogEvent.getGameItemRecords());
				newValue = curValue + addValue;
				if (newValue > cfg.param2)
					newValue = cfg.param2;
				
				gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			}
			break;
		case GameData.TASK_TYPE_FINISH_MAPCOPY:
			if (addParam1 == cfg.param1 && curValue < cfg.param2)
			{
				newValue = curValue + addValue;
				if (newValue > cfg.param2)
					newValue = cfg.param2;
			}
			break;
		// 对话和提交道具一样在完成的时候进行
//		case GameData.TASK_TYPE_MAIN_NPC_TALK:
//			break;
		case GameData.TASK_TYPE_NPC_TALK:
			if (addParam1 == cfg.param2 && addParam2 == cfg.param1 && curValue < 1)
			{
				SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
				if (GameData.getInstance().testNearbyNPC(curLocation.mapID, curLocation.location.position, cfg.param1, cfg.param3))
				{
					newValue = curValue + addValue;
					this.sceneTrig(trigIDs, GameData.SCENE_TRIG_EVENT_TALK_NPC);
				}
				else
				{
					gs.getLogger().warn("test log talk npc " + cfg.param1 +  " task failed position " + GameData.toString(curLocation.location.position));
				}
				
				if (newValue > 1)
					newValue = 1;
			}
			break;
		case GameData.TASK_TYPE_CONVOY_NPC:
		{
			if (addParam1 == cfg.param1) //check npcID
			{
				SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
				if (GameData.getInstance().testNearbyPosition(curLocation.mapID, curLocation.location.position, cfg.param2, cfg.param3, cfg.param4, cfg.param5, cfg.param6))
					newValue = 1;
			}
			break;
		}
		case GameData.TASK_TYPE_CONVOY_ITEM:
		{
			SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
			if (GameData.getInstance().testNearbyPosition(curLocation.mapID, curLocation.location.position, cfg.param2, cfg.param3, cfg.param4, cfg.param5, cfg.param6))
				newValue = 1;
			break;
		}
		case GameData.TASK_TYPE_ANSWER:
		{
			//check question and answer
			SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
			if (cfg.param2 == addParam1 && GameData.getInstance().testNearbyNPC(curLocation.mapID, curLocation.location.position, cfg.param1, GameData.getInstance().getCommonCFG().task.npcRadius))
			{
				SBean.QuestionCFGS question = GameData.getInstance().getTaskQuestion(cfg.param2);
				if (question != null && question.answer == addParam2)
					newValue = 1;
			}
			break;
		}
		case GameData.TASK_TYPE_RAND_QUESTION:
			if(addValue > 0)
			{
				SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
				if (GameData.getInstance().testNearbyNPC(curLocation.mapID, curLocation.location.position, cfg.param1, GameData.getInstance().getCommonCFG().task.npcRadius))
					newValue = 1;
			}
			break;
		case GameData.TASK_TYPE_ENTER_WAYPOINT:
			if(addParam1 == cfg.param1)
				newValue = 1;
			break;
		case GameData.TASK_TYPE_ENTER_PRIVATEMAP:
			if(addParam1 == cfg.param1 && curValue < cfg.param2)
			{
				newValue = curValue + addValue;
				if (newValue > cfg.param2)
					newValue = cfg.param2;
			}
			break;
		// 状态相关的信息不记录
		case GameData.TASK_TYPE_LOGIN_DAYS:
		case GameData.TASK_TYPE_ROLE_LEVEL:
		case GameData.TASK_TYPE_GAIN_PET:
		case GameData.TASK_TYPE_POWER_LEVEL:
		case GameData.TASK_TYPE_TRANSFROM_LEVEL:
		case GameData.TASK_TYPE_GOTO_ACTIVITYGROUP:
		case GameData.TASK_TYPE_GOTO_NORMALARENA:
		case GameData.TASK_TYPE_JOIN_FACTION:
			newValue = -1;
			break;
		default:
			break;
		}
		return newValue;
	}

	private boolean logMainTask(int condType, int addParam1, int addParam2, int addValue)
	{
		if(this.mainTask.state != 1)
			return false;
		
		SBean.MainTaskCFGS cfg = GameData.getInstance().getMainTaskCFG(this.mainTask.id);
		if (cfg == null || condType != cfg.cond.type)
			return false;
		
		int newValue = testLogTask(cfg.cond, addParam1, addParam2, addValue, this.mainTask.value, cfg.senceTrigIDs);
		if (this.mainTask.value == newValue)
			return false;
		
		if (newValue > 0)
			this.mainTask.value = newValue;
		if(this.isTaskFinished(cfg.cond, this.mainTask.value))
		{
			this.mainTask.state = 2;
			gs.getTLogger().logMainTaskFlow(this, this.mainTask.id, this.mainTask.state, TLog.TASKEVENT_FINISH);
			
			if(canTrigTaskFinish(condType))
			{
				this.sceneTrig(cfg.senceTrigIDs, GameData.SCENE_TRIG_EVENT_TASK_FINISH);
			}
		}
			
		return true;
	}
	
	private boolean canTrigTaskFinish(int condType)
	{
		switch (condType)
		{
		case GameData.TASK_TYPE_GATHER:
			return false;
		case GameData.TASK_TYPE_USE_ITEM:
			return false;
		case GameData.TASK_TYPE_NPC_TALK:
			return false;
		default:
			return true;
		}
	}
	
	private boolean logWeaponTask(int condType, int addParam1, int addParam2, int addValue)
	{
		if (this.weaponTask.dayLoopCount >= GameData.getInstance().getCommonCFG().weaponTask.dayLoopCount)
			return false;
		SBean.WeaponTaskCFGS cfg = GameData.getInstance().getWeaponTaskCFG(this.weaponTask.type, this.weaponTask.id);
		if (cfg == null)
			return false;
		boolean log = false;
		int index = 0;
		for (SBean.TaskCondCFGS condcfg : cfg.conds)
		{
			if (condcfg.type == condType)
			{
				int oldVal = this.weaponTask.values.get(index);
				int newValue = testLogTask(condcfg, addParam1, addParam2, addValue, oldVal);
				if (oldVal != newValue)
				{
					this.weaponTask.values.set(index, newValue);
					log = true;
				}
			}
			++index;
		}
		return log;
	}

	private boolean logPetTask(int condType, int addParam1, int addParam2, int addValue)
	{
//		if (petId > 0)
//		{
//			SBean.PetTaskCFGS cfg = GameData.getInstance().getPetTaskCFG(pet.task.id);
//			if (cfg == null || condType != cfg.cond.type)
//				return false;
//			int newVal = testLogTask(cfg.cond, addParam1, addParam2, addValue, pet.task.value);
//			if (pet.task.value != newVal)
//			{
//				pet.task.value = newVal;
//				log = true;
//			}
//		}
//		else
//		{
		boolean log = false;
		for (SBean.DBPet e : this.activePets.values())
		{
			SBean.PetTaskCFGS cfg = GameData.getInstance().getPetTaskCFG(e.task.id);
			if (cfg == null || condType != cfg.cond.type)
				continue;
			int newVal = testLogTask(cfg.cond, addParam1, addParam2, addValue, e.task.value);
			if (e.task.value != newVal)
			{
				e.task.value = newVal;
				log = true;
			}
		}
//		}

		return log;
	}

	private boolean logSectTask(int condType, int addParam1, int addParam2, int addValue)
	{
		SBean.SectReceivedTask sectTask = this.sectData.task.curTask;
		if (sectTask == null)
			return false;

		SBean.SectTaskCFGS sectTaskCFGS = GameData.getInstance().getSectTaskCFG(sectTask.task.taskId);
		if (sectTaskCFGS == null || condType != sectTaskCFGS.cond.type)
			return false;

		int newVal = testLogTask(sectTaskCFGS.cond, addParam1, addParam2, addValue, sectTask.value);
		if (sectTask.value == newVal)
			return false;

		sectTask.value = newVal;
		return true;

	}
	
	private boolean logBranchTask(int condType, int addParam1, int addParam2, int addValue)
	{
		Map<Integer, SBean.BranchTaskCFGS> tasks = GameData.getInstance().getBranchTask();
		boolean isOk = false;
		for (int groupId : tasks.keySet())
		{
			SBean.DBBranchTask btask = this.branchTask.get(groupId);
			if(btask == null || btask.state != 1)
				continue;
			
			SBean.BranchTaskDataCFGS taskCfg = GameData.getInstance().getBranchTaskCFG(groupId, btask.id);
			if (taskCfg == null || taskCfg.taskParam.type != condType)
				continue;
			
			int newValue = testLogTask(taskCfg.taskParam, addParam1, addParam2, addValue, btask.value, taskCfg.senceTrigIDs);
			if (btask.value == newValue)
				continue;
			if (newValue > 0)
				btask.value = newValue;
			isOk = true;
			if(this.isTaskFinished(taskCfg.taskParam, btask.value))
			{
				btask.state = 2;
				gs.getTLogger().logBranchTaskFlow(this, groupId, btask.id, btask.state, TLog.TASKEVENT_FINISH);
				
				if(canTrigTaskFinish(condType))
					this.sceneTrig(taskCfg.senceTrigIDs, GameData.SCENE_TRIG_EVENT_TASK_FINISH);
			}
		}
		return isOk;
	}

	private boolean logPetLifeTask(int condType, int addParam1, int addParam2, int addValue)
	{
		MapCopyContext mapcopy = this.gameMapContext.getMapCopyContext();
		if (mapcopy instanceof PetLifeMapCopyContext)
		{
			int petid = ((PetLifeMapCopyContext) mapcopy).getPetId();
			SBean.DBPet pet = activePets.get(petid);
			SBean.PetLifeTaskCFGS cfg = GameData.getInstance().getPetLifeTaskCFGS(petid, pet.lifetask.id);
			if (cfg == null || condType != cfg.cond.type)
				return false;
			int newVal = testLogTask(cfg.cond, addParam1, addParam2, addValue, pet.lifetask.value);
			if (pet.lifetask.value != newVal)
			{
				pet.lifetask.value = newVal;
				return true;
			}
		}
		return false;
	}
	
	private boolean logSecretArenaTasks(int condType, int addParam1, int addParam2, int addValue)
	{
		//Map<Integer, SBean.BranchTaskCFGS> tasks = GameData.getInstance().getBranchTask();
		if (this.secretAreaTaskData == null || this.secretAreaTaskData.id == 0)
			return false;
		SBean.SecretAreaTaskCFGS taskCfg = GameData.getInstance().getSecretTaskCfg(this.secretAreaTaskData.id);
		if (taskCfg == null || taskCfg.taskCond.type != condType)
			return false;
		
		int newValue = testLogTask(taskCfg.taskCond, addParam1, addParam2, addValue, this.secretAreaTaskData.value);
		if (this.secretAreaTaskData.value == newValue)
			return false;
		this.secretAreaTaskData.value = newValue;
		return true;
	}
	
	private boolean logMrgSeriesTask(int condType, int addParam1, int addParam2, int addValue)
	{
		if(condType == GameData.TASK_TYPE_KILL && this.gender == GameData.ROLE_GENDER_WOMAN)
			return false;
		
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return false;
		
		Role partner = getTeamMrgPartner(marriage);
		if(partner == null)
			return false;
		
		boolean logMrgSeries = marriage.logSeriesTask(this, partner, condType, addParam1, addParam2, addValue);
		if(logMrgSeries)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_mrgseriestask_update(marriage.getTask().series.value));
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrgseriestask_update(marriage.getTask().series.value));
		}
		return logMrgSeries;
	}
	
	private boolean logMrgLoopTask(int condType, int addParam1, int addParam2, int addValue)
	{
		if(condType == GameData.TASK_TYPE_KILL && this.gender == GameData.ROLE_GENDER_WOMAN)
			return false;
		
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return false;
		
		Role partner = getTeamMrgPartner(marriage);
		if(partner == null)
			return false;
		
		boolean logMrgLoop = marriage.logLoopTask(this, partner, condType, addParam1, addParam2, addValue);
		if(logMrgLoop)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_mrglooptask_update(marriage.getTask().loop.value));
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrglooptask_update(marriage.getTask().loop.value));
		}
			
			
		
		return logMrgLoop;
	}
	
	boolean logTasks(int taskCat, int condType, int addParam1, int addParam2, int addValue)
	{
		switch (taskCat)
		{
		case GameData.TASK_CATEGORY_MAIN:
			return logMainTask(condType, addParam1, addParam2, addValue);
		case GameData.TASK_CATEGORY_WEAPON:
			return logWeaponTask(condType, addParam1, addParam2, addValue);
		case GameData.TASK_CATEGORY_PET:
			return logPetTask(condType, addParam1, addParam2, addValue);
		case GameData.TASK_CATEGORY_SECT:
			return logSectTask(condType, addParam1, addParam2, addValue);
		case GameData.TASK_CATEGORY_BRANCH:
			return logBranchTask(condType, addParam1, addParam2, addValue);
		case GameData.TASK_CATEGORY_PET_LIFE:
			return logPetLifeTask(condType, addParam1, addParam2, addValue);
		case GameData.TASK_CATEGORY_MRG_SERIES:
			return logMrgSeriesTask(condType, addParam1, addParam2, addValue);
		case GameData.TASK_CATEGORY_MRG_LOOP:
			return logMrgLoopTask(condType, addParam1, addParam2, addValue);
		default:
			return false;
		}
	}
	
	boolean logTasks(int condType, int addParam1, int addParam2, int addValue)
	{
		boolean logMain = this.logMainTask(condType, addParam1, addParam2, addValue);
		boolean logWeapon = this.logWeaponTask(condType, addParam1, addParam2, addValue);
		boolean logPet = this.logPetTask(condType, addParam1, addParam2, addValue);
		boolean logSect = this.logSectTask(condType, addParam1, addParam2, addValue);
		boolean logBranch = this.logBranchTask(condType, addParam1, addParam2, addValue);
		boolean logPetLife = this.logPetLifeTask(condType, addParam1, addParam2, addValue);
		boolean logSecretArena = this.logSecretArenaTasks(condType, addParam1, addParam2, addValue);
		boolean logMrgSeries = this.logMrgSeriesTask(condType, addParam1, addParam2, addValue);
		boolean logMrgLoop = this.logMrgLoopTask(condType, addParam1, addParam2, addValue);
		return logMain || logWeapon || logPet || logSect || logBranch || logPetLife || logSecretArena || logMrgSeries || logMrgLoop;
	}

	boolean isTaskFinished(SBean.TaskCondCFGS cfg, int value)
	{
		boolean finished = false;
		switch (cfg.type)
		{
		case GameData.TASK_TYPE_KILL:
			finished = value >= cfg.param2;
			break;
		case GameData.TASK_TYPE_GATHER:
			finished = value >= cfg.param2;
			break;
		case GameData.TASK_TYPE_USE_ITEM:
			finished = value > 0;
			break;
		case GameData.TASK_TYPE_LOGIN_DAYS:
			finished = this.loginDays >= cfg.param1;
			break;
		case GameData.TASK_TYPE_ROLE_LEVEL:
			finished = this.level >= cfg.param1;
			break;
//		case GameData.TASK_TYPE_MAIN_NPC_TALK:
//			SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
//			finished = GameData.getInstance().testNearbyNPC(curLocation.mapID, curLocation.location.position, cfg.param1, cfg.param2);
//			break;
		case GameData.TASK_TYPE_SUBMIT_ITEM:
			finished = value >= cfg.param2;// this.containsEnoughGameItem(cfg.param1, cfg.param2);
			break;
		case GameData.TASK_TYPE_FINISH_MAPCOPY:
			finished = value >= cfg.param2;
			break;
		case GameData.TASK_TYPE_GAIN_PET:
			finished = this.activePets.size() >= cfg.param2;
			break;
		case GameData.TASK_TYPE_POWER_LEVEL:
			finished = this.roleProperties.getRoleFightPower() >= cfg.param2;
			break;
		case GameData.TASK_TYPE_TRANSFROM_LEVEL:
			finished = this.transformLevel >= cfg.param1;
			break;
		case GameData.TASK_TYPE_NPC_TALK:
			finished = value > 0;
			break;
		case GameData.TASK_TYPE_GOTO_ACTIVITYGROUP:
			SBean.DBActivityMapGroupLog acgLog = this.activityMapGroupLogs.get(cfg.param1);
			finished = acgLog != null && acgLog.enterMaps.size() > 0;
			break;
		case GameData.TASK_TYPE_GOTO_NORMALARENA:
			finished = this.arenaInfo.roleArenaData.normal.enterTimes >= cfg.param1;
			break;
		case GameData.TASK_TYPE_CONVOY_NPC:
			finished = value > 0;
			break;
		case GameData.TASK_TYPE_CONVOY_ITEM:
			finished = value > 0;
			break;
		case GameData.TASK_TYPE_ANSWER:
			finished = value > 0;
			break;
		case GameData.TASK_TYPE_JOIN_FACTION:
			finished = this.sectData.data.sectBrief.sectID != 0;
			break;
		case GameData.TASK_TYPE_RAND_QUESTION:
			finished = value > 0;
			break;
		case GameData.TASK_TYPE_ENTER_WAYPOINT:
			finished = value > 0;
			break;
		case GameData.TASK_TYPE_ENTER_PRIVATEMAP:
			finished = value >= cfg.param2;
			break;
		default:
			break;
		}
		return finished;
	}

	public synchronized boolean taskUseItem(int taskCat, int itemId)
	{
		return logTasks(taskCat, GameData.TASK_TYPE_USE_ITEM, itemId, 0, 1);
	}

	public synchronized boolean taskSubmitItem(int taskCat, int petId, int itemId, int itemCount)
	{
		return logTasks(taskCat, GameData.TASK_TYPE_SUBMIT_ITEM, itemId, 0, itemCount);
	}
	
	public synchronized boolean petTaskSubmitItem(int petId, int itemId, int itemCount)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if (pet == null)
			return false;

		SBean.PetTaskCFGS cfg = GameData.getInstance().getPetTaskCFG(pet.task.id);
		if (cfg == null || GameData.TASK_TYPE_SUBMIT_ITEM != cfg.cond.type)
			return false;
		int newVal = testLogTask(cfg.cond, itemId, 0, itemCount, pet.task.value);
		if (pet.task.value != newVal)
		{
			pet.task.value = newVal;
			return true;
		}

		return false;
	}
	
	public synchronized boolean petLifeTaskSubmitItem(int petId, int itemId, int itemCount)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if (pet == null)
			return false;

		SBean.PetLifeTaskCFGS cfg = GameData.getInstance().getPetLifeTaskCFGS(petId, pet.lifetask.id);
		if (cfg == null || GameData.TASK_TYPE_SUBMIT_ITEM != cfg.cond.type)
			return false;
		int newVal = testLogTask(cfg.cond, itemId, 0, itemCount, pet.lifetask.value);
		if (pet.lifetask.value != newVal)
		{
			pet.lifetask.value = newVal;
			return true;
		}

		return false;
	}

	public synchronized boolean taskNpcTalk(int npcId, int dailogId)
	{
		return logTasks(GameData.TASK_TYPE_NPC_TALK, dailogId, npcId, 1);
	}

	public synchronized boolean taskConvoyItem()
	{
		return logTasks(GameData.TASK_TYPE_CONVOY_ITEM, 0, 0, 0);
	}

	public synchronized boolean taskConvoyNpc(int npcID)
	{
		return logTasks(GameData.TASK_TYPE_CONVOY_NPC, npcID, 0, 0);
	}

	public synchronized boolean taskAnswer(int question, int answer)
	{
		return logTasks(GameData.TASK_TYPE_ANSWER, question, answer, 0);
	}
	
	public synchronized boolean taskRandQuestion(int taskCat)
	{
		return logTasks(taskCat, GameData.TASK_TYPE_RAND_QUESTION, 0, 0, 1);
	}
	
	public synchronized int takeMainTask(int taskID)
	{
		final SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(taskID);
		if(mainCFGS == null || this.mainTask.id != taskID || this.mainTask.state > 0 || (this.alterState.alterID > 0 && GameData.getInstance().isTrigTaskAlter(mainCFGS.senceTrigIDs)))
			return GameData.PROTOCOL_OP_FAILED;
		
		if(mainCFGS.startNPC > 0 && !GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapContext().getMapLocation(), mainCFGS.startNPC, GameData.getInstance().getCommonCFG().task.npcRadius))
			return GameData.PROTOCOL_OP_NPC_TO_FAR;
		
		this.mainTask.value = 0;
		this.mainTask.state = 1;
		this.mainTask.receiveTime = GameTime.getTime();
		
		gs.getTLogger().logMainTaskFlow(this, taskID, this.mainTask.state, TLog.TASKEVENT_TAKE);
		this.logMainTask(mainCFGS.cond.type, 0, 0, 0);
		this.sceneTrig(mainCFGS.senceTrigIDs, GameData.SCENE_TRIG_EVENT_TAKE_TASK);
		this.addTaskDrop(mainCFGS.cond);
		return this.mainTask.receiveTime;
	}
	
	public synchronized boolean quitMainTask(int taskID)
	{
		final SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(taskID);
		if(mainCFGS == null || mainCFGS.canQuit == 0 || this.mainTask.id != taskID || this.mainTask.state == 0)
			return false;
		
		this.mainTask.value = 0;
		this.mainTask.state = 0;
		this.setAlterState(-1);
		this.clearSceneMonster(mainCFGS.senceTrigIDs);
		gs.getTLogger().logMainTaskFlow(this, taskID, mainTask.state, TLog.TASKEVENT_CANCLE);
		return true;
	}
	
	public synchronized boolean takeMainTaskReward(int taskID)
	{
		SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(taskID);
		if (mainCFGS == null || this.mainTask.id != taskID || this.mainTask.state !=2 || (mainCFGS.endNPC > 0 && (mainCFGS.endNPC > 0 && !GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapContext().getMapLocation(), mainCFGS.endNPC, GameData.getInstance().getCommonCFG().task.npcRadius))))
			return false;

		Collection<SBean.DummyGoods> rewardItems = GameData.getMainTaskRewards(mainCFGS, this.classType);
		if (!rewardItems.isEmpty() && !this.canAddGameItems(rewardItems))
			return false;
		
		int nextID = GameData.getNextMainTaskId(mainCFGS, this.BWType);
		if(nextID < 0)
			return false;
		
		this.syncAddExp(mainCFGS.rewardExp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_MAIN_TASK, 0);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_MAIN_TASK_REWARD);
		tlogEvent.setArg(taskID);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewardItems), tlogEvent);
		if (mainCFGS.title > 0)
			this.addRoleTitle(mainCFGS.title);
		
		this.clearSceneMonster(mainCFGS.senceTrigIDs);
		this.sceneTrig(mainCFGS.senceTrigIDs, GameData.SCENE_TRIG_EVENT_TASK_REWARD);
		this.delTaskDrop(mainCFGS.cond);
		
		this.mainTask.id = nextID;
		this.mainTask.value = 0;
		this.mainTask.state = 0;
		
		gs.getTLogger().logMainTaskFlow(this, this.mainTask.id, this.mainTask.state, TLog.TASKEVENT_START);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		SBean.MainTaskCFGS nextCfg = GameData.getInstance().getMainTaskCFG(nextID);
		if(nextCfg != null && nextCfg.startNPC <= 0)
			this.takeMainTask(nextID);
		
//		if (taskID == GameData.getInstance().getBetaActivity().notifyTaskId)
//			this.tryTestBetaActivityNotice();
		return true;
	}

	private boolean jumpMainTask(int mtaskID)
	{
		SBean.MainTaskCFGS curTaskCfg = GameData.getInstance().getMainTaskCFG(this.mainTask.id);
		if(curTaskCfg == null)
			return false;
		
		SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(mtaskID);
		if(mainCFGS == null || !GameData.getInstance().isTaskValid(mtaskID, this.BWType))
			return false;
		
		this.clearSceneMonster(curTaskCfg.senceTrigIDs);
		this.mainTask.id = mainCFGS.id;
		this.mainTask.value = 0;
		this.mainTask.state = 0;
		this.setAlterState(-1);
		if(mainCFGS.startNPC <= 0)
			this.takeMainTask(mainCFGS.id);
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_task(this.mainTask.kdClone()));
		return true;
	}
	
	private void updateAlterState(int timeTick)
	{
		if (this.alterState.alterID == 0 || this.alterState.attrEndTime == 0)
			return;

		if (timeTick > this.alterState.attrEndTime)
		{
			this.alterState.attrEndTime = 0;
			if (this.gameMapContext.isInWorldMap())
			{
				gs.getMapService().syncRoleUpdateAlterState(this.gameMapContext.getCurMapId(), this.id, this.alterState.kdClone());
			}
		}
	}

	SBean.DBAlterState getAlterState()
	{
		return this.gameMapContext.isInWorldMap() ? this.alterState.kdClone() : new SBean.DBAlterState(0, 0);
	}

	private void setAlterState(int alterID)
	{
		int oldAlterID = this.alterState.alterID;
		int oldEndTime = this.alterState.attrEndTime;
		if (alterID < 0)
		{
			this.alterState.alterID = 0;
			this.alterState.attrEndTime = 0;
		}
		else if (alterID > 0)
		{
			SBean.AlterCFGS alterCfg = GameData.getInstance().getAlterCFGS(alterID);
			if (alterCfg != null)
			{
				this.alterState.alterID = alterID;
				this.alterState.attrEndTime = alterCfg.loopTime + GameTime.getTime();
			}
		}

		if (oldAlterID != this.alterState.alterID || oldEndTime != this.alterState.attrEndTime)
		{
			if(this.alterState.alterID > 0)
				this.roleUnRide();
			gs.getMapService().syncRoleUpdateAlterState(this.gameMapContext.getCurMapId(), this.id, this.alterState.kdClone());
		}
	}

	public void dayRefreshWeaponTask()
	{
		this.weaponTask.dayLoopCount = 0;
		this.initWeaponTaskDrop();
	}

	public synchronized void takeWeaponTaskReward(int id)
	{
		if (this.weaponTask.id != id || this.weaponTask.dayLoopCount >= GameData.getInstance().getCommonCFG().weaponTask.dayLoopCount)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.wtask_reward_res(0, 0));
			return;
		}
		
		SBean.WeaponTaskCFGS weaponCFGS = GameData.getInstance().getWeaponTaskCFG(this.weaponTask.type, id);
		if (weaponCFGS == null || !this.canAddGameItem(weaponCFGS.reward.id, weaponCFGS.reward.count))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.wtask_reward_res(0, 0));
			return;
		}

		for (int index = 0; index < weaponCFGS.conds.size(); index++)
		{
			SBean.TaskCondCFGS cond = weaponCFGS.conds.get(index);
			int value = this.weaponTask.values.get(index);
			if (!isTaskFinished(cond, value))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.wtask_reward_res(0, 0));
				return;
			}
			
			this.delTaskDrop(cond);
		}

		SBean.WeaponTaskCFGS weaponNextTask = GameData.getInstance().getNextWeaponTaskCFG(this.level, this.weaponTask.type, id);
		if (weaponNextTask == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.wtask_reward_res(0, 0));
			return;
		}
		
		if (this.weaponTask.type != 0)
			this.weaponTask.dayLoopCount += 1;
		this.weaponTask.type = weaponNextTask.type;
		this.weaponTask.id = weaponNextTask.id;
		this.weaponTask.receiveTime = GameTime.getTime();
		this.weaponTask.values.clear();
		for (int i = 0; i < weaponNextTask.conds.size(); ++i)
		{
			this.weaponTask.values.add(0);
			
			if(this.weaponTask.type == 0 || this.weaponTask.dayLoopCount < GameData.getInstance().getCommonCFG().weaponTask.dayLoopCount)
				this.addTaskDrop(weaponNextTask.conds.get(i));
		}
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_WEAPON_TASK_REWARD);
		tlogEvent.setArg(id);
		this.syncAddGameItem(GameData.getInstance().toGameItem(weaponCFGS.reward.id, weaponCFGS.reward.count), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.wtask_reward_res(this.weaponTask.id, this.weaponTask.receiveTime));
	}



	// ----------------------------------------------------------------------------------------------------------------
	private void updateWeapon(SBean.DBWeapon weapon)
	{
		weapons.put(weapon.id, weapon);

		gs.getMapService().syncRoleUpdateUpdateWeapon(this.id, this.gameMapContext.getCurMapId(), weapon.kdClone());
		this.roleProperties.onUpdateWeapon(weapon);
	}
	
	public synchronized boolean makeWeapon(int wid)
	{
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(wid);
		if (weaponCFGS == null)
			return false;
		if (this.weapons.containsKey(wid))
			return false;
		if (!this.containsEnoughGameItem(weaponCFGS.useId, weaponCFGS.useCount))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MAKE_WEAPON);
		tlogEvent.setArg(wid, weaponCFGS.useId, weaponCFGS.useCount);
		this.delGameItem(weaponCFGS.useId, weaponCFGS.useCount, tlogEvent.getGameItemRecords());
		List<Integer> skills = new ArrayList<>();
		List<Integer> talents = new ArrayList<>();
		
		for (int skillId : weaponCFGS.skills)
		{
			skills.add(1);
		}
		for (int i = 0; i < weaponCFGS.talents.size(); i++)
		{
			talents.add(0);
		}
		SBean.DBWeapon weapon = new SBean.DBWeapon(wid, 
												   1, 
												   0, 
												   weaponCFGS.initStar, 
												   0, 
												   skills, 
												   talents, 
												   GameData.getInstance().getWeaponTalentCommonCFGS().defaultTalentPoint,
												   new SBean.WeaponUSkill((byte)0, 0),
												   GameData.WEAPON_FORM_DEFAULT);

		this.updateWeapon(weapon);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_GAIN_WEAPON, 0);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_WEAPON_STAR, 0);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logWeaponMake(this, wid, 1);
		return true;
	}

	public synchronized boolean weaponLevelUp(int wid, Map<Integer, Integer> items)
	{
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(wid);
		if (weaponCFGS == null)
			return false;
		SBean.DBWeapon weapon = this.weapons.get(wid);
		if (weapon == null || weapon.level >= weaponCFGS.weaponLevel.size())
			return false;

		int expAdd = 0;
		for (Map.Entry<Integer, Integer> e : items.entrySet())
		{
			int iid = e.getKey();
			int icount = e.getValue();
			CellItem bi = this.getBagItem(iid);
			if (bi == null)
				return false;
			CellItem.Useable useable = bi.getUseable();
			if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, icount))
				return false;
			CellItem.WeaponExpAdder expAdder = useable.useAsWeaponExpAdder();
			if (expAdder == null)
				return false;
			expAdd += expAdder.getExp() * icount;
		}
		GameData.LevelExp levelExp = GameData.getAddWeaponExpLvlExp(weaponCFGS, weapon.level, weapon.exp, expAdd);
		SBean.WeaponLevelCFGS lvlcfg = weaponCFGS.weaponLevel.get(levelExp.level - 1);
		if (this.level < lvlcfg.roleLvlReq)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WEAPON_LEVEL_UP);
		for (Map.Entry<Integer, Integer> e : items.entrySet())
		{
			tlogEvent.setArg(wid, e.getKey(), e.getValue());
			this.delGameItem(e.getKey(), e.getValue(), tlogEvent.getGameItemRecords());
		}
		weapon.level = levelExp.level;
		weapon.exp = (int) levelExp.exp;

		this.updateWeapon(weapon);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_WEAPON_LEVEL, 0);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logWeaponLevelUp(this, wid, weapon.level);
		return true;
	}

	public synchronized boolean weaponBuyLevel(int wid, int level)
	{
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(wid);
		SBean.DBWeapon weapon = this.weapons.get(wid);
		if (weaponCFGS == null || weapon == null)
			return false;

		if (weapon.level >= weaponCFGS.weaponLevel.size())
			return false;
		SBean.WeaponLevelCFGS lvlcfg = weaponCFGS.weaponLevel.get(weapon.level - 1);
		if (this.level < lvlcfg.roleLvlReq || !this.canUseDiamond(lvlcfg.useDiamonds.get(level), true))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WEAPON_BUY_LEVEL);
		tlogEvent.setArg(wid, level, lvlcfg.useDiamonds.get(level));
		this.useDiamond(lvlcfg.useDiamonds.get(level), true, tlogEvent.getGameItemRecords());
		weapon.level = level;
		if (weapon.level == weaponCFGS.weaponLevel.size())
			weapon.exp = 0;

		this.updateWeapon(weapon);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_WEAPON_LEVEL, 0);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logWeaponLevelUp(this, wid, weapon.level);
		return true;
	}

	public synchronized boolean weaponStarUp(int wid, int star, int itemCount, int alternativeCount)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WEAPON_STAR_UP);
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(wid);
		if (weaponCFGS == null)
			return false;
		SBean.DBWeapon weapon = this.weapons.get(wid);
		if (weapon == null)
			return false;
		if (weapon.star + 1 != star)
			return false;
		if (star <= 0 || star >= weaponCFGS.weaponStar.size())
			return false;
		SBean.WeaponStarCFGS starcfg = weaponCFGS.weaponStar.get(star);
		if (itemCount < 0 || alternativeCount < 0 || itemCount + alternativeCount != starcfg.useCount)
			return false;
		if (!this.containsEnoughGameItem(starcfg.useId, itemCount) || !this.containsEnoughGameItem(starcfg.replaceId, alternativeCount))
			return false;

		tlogEvent.setArg(starcfg.useId, itemCount, starcfg.replaceId, alternativeCount);
		if (itemCount > 0)
			this.delGameItem(starcfg.useId, itemCount, tlogEvent.getGameItemRecords());
		if (alternativeCount > 0)
			this.delGameItem(starcfg.replaceId, alternativeCount, tlogEvent.getGameItemRecords());
		weapon.star = star;

		if (GameData.getInstance().isFullStar(weapon))
			this.updateWeaponUSkill();
		this.updateWeapon(weapon);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_WEAPON_STAR, 0);
		if(GameData.getInstance().getRollNoticeCFGS().weaponStarups.contains(star))
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_WEAPON_STARUP, this.name + "|" + wid + "|" + star);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logWeaponStarUp(this, wid, star);
		return true;
	}

	public synchronized int selectWeapon(int wid)
	{
		SBean.DBWeapon weapon = this.weapons.get(wid);
		if (weapon == null)
			return GameData.PROTOCOL_OP_FAILED;

		syncWeaponInsight();
		syncWeaponRevenge();
		if (!this.insightData.targetList.isEmpty() || !this.revengeData.targetList.isEmpty())
			return GameData.PROTOCOL_OP_U_SKILL_IN_SEARCH;
		
		int oldWeapon = this.curWeapon;
		this.curWeapon = wid;
		this.updateWeaponUSkill();
		gs.getMapService().syncRoleUpdateUpdateCurWeapon(this.id, this.gameMapContext.getCurMapId(), this.curWeapon);
		gs.getTLogger().logWeaponEquip(this, oldWeapon, wid);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized Map<Integer, Integer> syncWeaponInfo()
	{
		return this.weapons.values().stream().collect(Collectors.toMap(e -> e.id, e -> e.uniqueSkill.master));
	}
	
	public synchronized boolean openWeaponUSkill(int weaponID)
	{
		SBean.DBWeapon dbWeapon = this.weapons.get(weaponID);
		if(dbWeapon == null || dbWeapon.uniqueSkill.open == 1)
			return false;
		
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(weaponID);
		if(wCfg == null || dbWeapon.uniqueSkill.master < wCfg.maxMaster || !checkeOpenWeapon(wCfg))
			return false;
		
		this.onOpenWeaponUSkill(wCfg);
		dbWeapon.uniqueSkill.open = 1;
		
		this.updateWeaponUSkill();
		gs.getMapService().syncRoleWeaponOpen(this.gameMapContext.getCurMapId(), this.id, weaponID);
		return true;
	}
	
	private void updateWeaponUSkill()
	{
		this.weaponUSkill.update(this.weapons.values(), this.curWeapon);
		if(this.weaponUSkill.updateNpc(this.gameMapContext.getCurMapId()))
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_weapon_npc(this.weaponUSkill.getNpc()));
	}
	
	private boolean checkeOpenWeapon(SBean.WeaponCFGS wCfg)
	{
		if(wCfg.isUSkillOpen == 0)
			return false;
		
		Map<Integer, Integer> counter = new HashMap<>();
		for(int uniqueSkillID: wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if(cfg == null || cfg.effectType != GameData.WEAPON_USKILL_EFFECT_TYPE_OPEN)
				continue;

			if(cfg.type == GameData.WEAPON_USKILL_TYPE_ITEM)
				counter.put(cfg.param1, cfg.param2);
		}
		
		if(!this.canAddGameItems(counter))
			return false;
		
		return true;
	}
	
	private void onOpenWeaponUSkill(SBean.WeaponCFGS wCfg)
	{
		for(int uniqueSkillID: wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if(cfg == null || cfg.effectType != GameData.WEAPON_USKILL_EFFECT_TYPE_OPEN)
				continue;
			
			switch (cfg.type)
			{
				case GameData.WEAPON_USKILL_TYPE_ITEM:
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WEAPON_USKILL_OPEN);
					tlogEvent.setArg(wCfg.id, cfg.id);
					this.syncAddGameItem(GameData.getInstance().toGameItem(cfg.param1, cfg.param2), tlogEvent);
					gs.getTLogger().logRoleEventFlow(this, tlogEvent);
					break;
				case GameData.WEAPON_USKILL_TYPE_USKILL:
					this.takeUniqueSkill(cfg.param1, cfg.param2);
					break;
				default:
					break;
			}
		}
	}
	
	public int openWeaponInsight()
	{
		return gs.getBossManager().getInsightList(this, this.gameMapContext.getWorldMapContext().mapId);
	}
	
	public synchronized int setInsightList(List<SBean.ActivityEntity> list)
	{
		this.insightData.targetList = list;
		if (this.insightData.targetList.isEmpty())
			return GameData.PROTOCOL_OP_U_SKILL_TARGET_EMPTY;
		this.insightData.lastInsightTime = GameTime.getTime();
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int checkWeaponInsight()
	{
		SBean.DBWeapon dbWeapon = this.weapons.get(this.curWeapon);
		if(dbWeapon == null)
			return GameData.PROTOCOL_OP_FAILED;
		boolean weaponFullStar = GameData.getInstance().isFullStar(dbWeapon);
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(this.curWeapon);
		if(wCfg == null || dbWeapon.uniqueSkill.open != 1)
			return GameData.PROTOCOL_OP_FAILED;
		for(int uniqueSkillID: wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if (cfg == null || cfg.type != GameData.WEAPON_USKILL_TYPE_INSIGHT)
				continue;
			int now = GameTime.getTime();
			if (now < this.insightData.lastInsightTime + (weaponFullStar ? cfg.fullStarParam1 : cfg.param1))
				return GameData.PROTOCOL_OP_U_SKILL_IN_CD;
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_U_SKILL_NEED_WORLD_MAP;
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		return GameData.PROTOCOL_OP_U_SKILL_HAVE_NOT_SKILL;
	}
	
	public synchronized SBean.DBInsightData syncWeaponInsight()
	{
		SBean.DBInsightData defaultData = new SBean.DBInsightData(0, new ArrayList<>());
		SBean.DBWeapon dbWeapon = this.weapons.get(this.curWeapon);
		boolean weaponFullStar = GameData.getInstance().isFullStar(dbWeapon);
		if (dbWeapon == null)
			return defaultData;
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(this.curWeapon);
		if (wCfg == null || dbWeapon.uniqueSkill.open != 1)
			return defaultData;
		for (int uniqueSkillID : wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if (cfg == null || cfg.type != GameData.WEAPON_USKILL_TYPE_INSIGHT)
				continue;
			int now = GameTime.getTime();
			if (now > this.insightData.lastInsightTime + (weaponFullStar ? cfg.fullStarParam1 : cfg.param1))
				this.insightData.targetList = new ArrayList<>();
			return this.insightData.kdClone();
		}
		this.insightData = defaultData;
		return defaultData;
	}
	
	public synchronized int transformToWeaponInsight(int index)
	{
		SBean.DBWeapon dbWeapon = this.weapons.get(this.curWeapon);
		boolean weaponFullStar = GameData.getInstance().isFullStar(dbWeapon);
		if (dbWeapon == null || index < 0 || index >= this.insightData.targetList.size() || !this.gameMapContext.isInWorldMap())
			return GameData.PROTOCOL_OP_FAILED;
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(this.curWeapon);
		if (wCfg == null || dbWeapon.uniqueSkill.master < wCfg.maxMaster)
			return GameData.PROTOCOL_OP_FAILED;
		for (int uniqueSkillID : wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if (cfg == null || cfg.type != GameData.WEAPON_USKILL_TYPE_INSIGHT)
				continue;
			int now = GameTime.getTime();
			if (now > this.insightData.lastInsightTime + (weaponFullStar ? cfg.fullStarParam1 : cfg.param1))
				return GameData.PROTOCOL_OP_U_SKILL_SKILL_END;
			boolean transfromres = this.transformToActivityEntity(this.insightData.targetList.get(index));
			if (transfromres)
				return GameData.PROTOCOL_OP_SUCCESS;
			else
				return GameData.PROTOCOL_OP_U_SKILL_TAR_INVALID;
		}
		return GameData.PROTOCOL_OP_U_SKILL_HAVE_NOT_SKILL;
	}

	public int transformToWeaponRevenge(int index)
	{
		SBean.DBWeapon dbWeapon = this.weapons.get(this.curWeapon);
		if (dbWeapon == null || index < 0 || index >= this.revengeData.targetList.size() || !this.gameMapContext.isInWorldMap())
			return GameData.PROTOCOL_OP_FAILED;
		boolean weaponFullStar = GameData.getInstance().isFullStar(dbWeapon);
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(this.curWeapon);
		if (wCfg == null || dbWeapon.uniqueSkill.master < wCfg.maxMaster)
			return GameData.PROTOCOL_OP_FAILED;
		for (int uniqueSkillID : wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if (cfg == null || cfg.type != GameData.WEAPON_USKILL_TYPE_REVENGE)
				continue;
			int now = GameTime.getTime();
			if (now > this.revengeData.lastRevengeTime + (weaponFullStar ? cfg.fullStarParam1 : cfg.param1))
				return GameData.PROTOCOL_OP_U_SKILL_SKILL_END;
			Role role = gs.getLoginManager().getOnGameRole(this.revengeData.targetList.get(index).id);
			if(role==null)
			{
				return GameData.PROTOCOL_OP_FAILED;
			}
			SBean.MapLocation targetLocation = null;
			int line = 0;
			synchronized (role)
			{
				if(!role.gameMapContext.isInWorldMap())
				{
					return GameData.PROTOCOL_OP_FAILED;
				}
				targetLocation = role.gameMapContext.getWorldMapContext().getMapLocation().kdClone();
				line = role.gameMapContext.getCurWorldInstanceId();
			}
			int transfromres = 0;
			synchronized (this)
			{
				transfromres = this.transformToRolePosition(targetLocation, line);
			}
			if (transfromres > 0)
				return GameData.PROTOCOL_OP_SUCCESS;
			else
				return GameData.PROTOCOL_OP_U_SKILL_TAR_INVALID;
		}
		return GameData.PROTOCOL_OP_U_SKILL_HAVE_NOT_SKILL;
	}

	public synchronized SBean.DBRevengeData syncWeaponRevenge()
	{
		SBean.DBRevengeData defaultData = new SBean.DBRevengeData(0, new ArrayList<>());
		SBean.DBWeapon dbWeapon = this.weapons.get(this.curWeapon);
		if (dbWeapon == null)
			return defaultData;
		boolean weaponFullStar = GameData.getInstance().isFullStar(dbWeapon);
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(this.curWeapon);
		if (wCfg == null || dbWeapon.uniqueSkill.master < wCfg.maxMaster)
			return defaultData;
		for (int uniqueSkillID : wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if (cfg == null || cfg.type != GameData.WEAPON_USKILL_TYPE_REVENGE)
				continue;
			int now = GameTime.getTime();
			if (now > this.revengeData.lastRevengeTime + (weaponFullStar ? cfg.fullStarParam1 : cfg.param1))
				this.revengeData.targetList = new ArrayList<>();
			return this.revengeData.kdClone();
		}
		this.revengeData = defaultData;
		return defaultData;
	}
	
	public synchronized int openWeaponRevenge()
	{
		SBean.DBWeapon dbWeapon = this.weapons.get(this.curWeapon);
		if (dbWeapon == null)
			return GameData.PROTOCOL_OP_FAILED;
		boolean weaponFullStar = GameData.getInstance().isFullStar(dbWeapon);
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(this.curWeapon);
		if (wCfg == null || dbWeapon.uniqueSkill.master < wCfg.maxMaster)
			return GameData.PROTOCOL_OP_FAILED;
		for (int uniqueSkillID : wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS cfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if (cfg == null || cfg.type != GameData.WEAPON_USKILL_TYPE_REVENGE)
				continue;
			int now = GameTime.getTime();
			if (now < this.revengeData.lastRevengeTime + (weaponFullStar ? cfg.fullStarParam1 : cfg.param1))
				return GameData.PROTOCOL_OP_U_SKILL_IN_CD;
			this.revengeData.targetList = this.getRevengeList((weaponFullStar ? cfg.fullStarParam2 : cfg.param2));
			if (this.revengeData.targetList.isEmpty())
				return GameData.PROTOCOL_OP_U_SKILL_TARGET_EMPTY;
			this.revengeData.lastRevengeTime = now;
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		return GameData.PROTOCOL_OP_U_SKILL_HAVE_NOT_SKILL;
	}

	private List<SBean.RevengeEntity> getRevengeList(int size)
	{
		List<SBean.RevengeEntity> revengeList = new ArrayList<>();
		for (int target : this.friend.friendData.enemys.keySet())
		{
			Role tarRole = gs.getLoginManager().getOnGameRole(target);
			if (tarRole != null)
			{
				revengeList.add(new SBean.RevengeEntity(tarRole.id, tarRole.name));
				if (revengeList.size() == size)
					return revengeList;
			}
		}
		return revengeList;
	}

	public synchronized boolean setWeaponForm(int weaponID, byte form)
	{
		SBean.DBWeapon dbWeapon = this.weapons.get(weaponID);
		if(dbWeapon == null || dbWeapon.uniqueSkill.open == 0 || dbWeapon.form == form)
			return false;
		
		SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(dbWeapon.id);
		if(wCfg == null)
			return false;
		
		boolean canForm = false;
		for(int uniqueSkillID: wCfg.uniqueSkills)
		{
			SBean.WeaponUniqueSkillCFGS wusCfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
			if(wusCfg == null || wusCfg.type != GameData.WEAPON_USKILL_TYPE_SET_FORM)
				continue;
			
			canForm = true;
			break;
		}
		
		if(!canForm)
			return false;
		
		if(form != GameData.WEAPON_FORM_DEFAULT && form != GameData.WEAPON_FORM_RANK)
			return false;
		
		dbWeapon.form = form;
		gs.getMapService().syncRoleSetWeaponForm(this.gameMapContext.getCurMapId(), this.id, dbWeapon.id, dbWeapon.form);
		return true;
	}
	
	public synchronized void syncWeaponMaster(int mapID, int mapInstance, int weaponID)
	{
		if(this.gameMapContext.getCurMapId() == mapID && this.gameMapContext.getCurMapInstance() == mapInstance && this.curWeapon == weaponID)
		{
			SBean.DBWeapon weapon = this.weapons.get(weaponID);
			if (weapon == null || weapon.uniqueSkill.open == 1)
				return;
			
			SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(weaponID);
			if (wCfg == null || wCfg.isUSkillOpen == 0 || weapon.uniqueSkill.master >= wCfg.maxMaster)
				return;
			int lastM = weapon.uniqueSkill.master / GameData.getInstance().getCommonCFG().skill.weaponMasterInterval;
			weapon.uniqueSkill.master += wCfg.addMaster + wCfg.weaponStar.get(weapon.star).proficiencyAdd;
			int newM = weapon.uniqueSkill.master / GameData.getInstance().getCommonCFG().skill.weaponMasterInterval;
			if (weapon.uniqueSkill.master > wCfg.maxMaster)
				weapon.uniqueSkill.master = wCfg.maxMaster;

			if (lastM != newM || weapon.uniqueSkill.master == wCfg.maxMaster)
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_weapon_master(weapon.uniqueSkill.master));
		}
	}
	
	class WeaponUSkill
	{
		private float prAdjust;
		private float repairAdjust;
		
		private boolean enterMapOpen;
		private SBean.DBWeaponMapLog mapLog;
		private int cfgDayEnterMapTimes;
		private int npcID;
		
		WeaponUSkill init(Collection<SBean.DBWeapon> weapons, int curWeapon, SBean.DBWeaponMapLog mapLog)
		{
			if(mapLog == null)
				this.mapLog = new SBean.DBWeaponMapLog(0, 0, new HashMap<>());
			else
				this.mapLog = mapLog;
			
			update(weapons, curWeapon);
			return this;
		}
		
		void dayRefresh()
		{
			this.mapLog.dayEnterTimes = 0;
		}
		
		SBean.DBWeaponMapLog getMapLog()
		{
			return this.mapLog;
		}
		
		int getDayEnterTimes()
		{
			return this.mapLog.dayEnterTimes;
		}
		
		void addEnterTimes(int mapID)
		{
			this.mapLog.dayEnterTimes++;
			this.mapLog.enterTimes++;
			this.mapLog.logs.compute(mapID, (k,v) -> v == null ? 1 : v + 1);
		}
		
		boolean hasEnterTimes()
		{
			return cfgDayEnterMapTimes > this.mapLog.dayEnterTimes;
		}
		
		int getNpc()
		{
			return npcID;
		}
		
		boolean canEnterMap()
		{
			if(npcID == 0 || !enterMapOpen)
				return false;
			
			if(!hasEnterTimes())
				return false;
			
			return true;
		}
		
		boolean updateNpc(int mapID)
		{
			if(this.npcID > 0)
				return false;
			
			if(!enterMapOpen || !hasEnterTimes())
				return false;
			
			SBean.WorldMapCFGS wmCfg = GameData.getInstance().getWorldMapCFGS(mapID);
			if(wmCfg == null || wmCfg.weaponMapNpcs.isEmpty())
				return false;
			
			this.npcID = wmCfg.weaponMapNpcs.get(GameRandom.getRandInt(0, wmCfg.weaponMapNpcs.size()));
			return true;
		}
		
		int refreshNpc(int mapID)
		{
			int temp = this.npcID;
			this.npcID = 0;
			
			if(!enterMapOpen || !hasEnterTimes())
				return 0;
			
			SBean.WorldMapCFGS wmCfg = GameData.getInstance().getWorldMapCFGS(mapID);
			if(wmCfg == null || wmCfg.weaponMapNpcs.isEmpty())
				return 0;
			
			while(true)
			{
				this.npcID = wmCfg.weaponMapNpcs.get(GameRandom.getRandInt(0, wmCfg.weaponMapNpcs.size()));
				if(this.npcID != temp || wmCfg.weaponMapNpcs.size() == 1)
					break;
			}
			
			return this.npcID;
		}
		
		float getprAdjust()
		{
			return prAdjust;
		}
		
		float getRepairAdjust()
		{
			return repairAdjust;
		}
		
		boolean enterMapOpen()
		{
			return enterMapOpen;
		}
		
		void update(Collection<SBean.DBWeapon> weapons, int curWeapon)
		{
			prAdjust = 0;
			repairAdjust = 0;
			enterMapOpen = false;
			cfgDayEnterMapTimes = 0;
			for(SBean.DBWeapon w: weapons)
			{
				if(w.uniqueSkill.open == 0)
					continue;
				
				SBean.WeaponCFGS wCfg = GameData.getInstance().getWeaponCFGS(w.id);
				if(wCfg == null)
					continue;
				
				for(int uniqueSkillID: wCfg.uniqueSkills)
				{
					SBean.WeaponUniqueSkillCFGS wusCfg = GameData.getInstance().getWeaponUSkillCFGS(uniqueSkillID);
					if(wusCfg == null)
						continue;
					
					switch (wusCfg.effectType)
					{
						case GameData.WEAPON_USKILL_EFFECT_TYPE_ALL_TIME:
							updateUSkill(w, wusCfg);
							break;
						case GameData.WEAPON_USKILL_EFFECT_TYPE_EQUIP:
							if(curWeapon == w.id)
								updateUSkill(w, wusCfg);
							break;
						default:
							break;
					}
				}
			}
		}
		
		private void updateUSkill(SBean.DBWeapon weapon, SBean.WeaponUniqueSkillCFGS wusCfg)
		{
			boolean weaponFullStar = GameData.getInstance().isFullStar(weapon);
			switch (wusCfg.type)
			{
			case GameData.WEAPON_USKILL_TYPE_UP_CRYSTAL_EQUIP:
				int percent = 0;
				if (weaponFullStar)
					percent = wusCfg.fullStarParam1;
				else
					percent = wusCfg.param1;
				if(prAdjust < percent / 10_000.f)
					prAdjust = percent / 10_000.f;
				break;
			case GameData.WEAPON_USKILL_TYPE_REDUCE_FIX_EQUIP_PRICE:
				percent = 0;
				if (weaponFullStar)
					percent = wusCfg.fullStarParam1;
				else
					percent = wusCfg.param1;
				if(repairAdjust < percent / 10_000.f)
					repairAdjust = percent / 10_000.f;
				break;
			case GameData.WEAPON_USKILL_TYPE_ENTER_MAPCOPY:
				enterMapOpen = true;
				if (weaponFullStar)
					cfgDayEnterMapTimes = wusCfg.fullStarParam1;
				else
					cfgDayEnterMapTimes = wusCfg.param1;
				break;
			default:
				break;
			}
		}
	}
	
	// ----------------------------------------------pet-----------------------------------------------------------
	private boolean checkMakePetCondition(SBean.PetCFGS cfg)
	{
		if (cfg.id <= 0 || this.activePets.containsKey(cfg.id))
			return false;

		for (SBean.PetMakeCondCFGS e : cfg.makeConds)
		{
			switch (e.type)
			{
			case GameData.PET_MAKE_CONDITION_MAIN_TASK:
				if (!GameData.getInstance().testMainTaskFinished(e.value, this.mainTask.id, this.BWType))
					return false;
				break;
			case GameData.PET_MAKE_CONDITION_FIGHT_POWER:
				if (this.roleProperties.getRoleFightPower() < e.value)
					return false;
				break;
			case GameData.PET_MAKE_CONDITION_FINISH_MAPCOPY:
				SBean.DBNormalMapCopyLog log = this.normalMapCopyLogs.get(e.value);
				if (log == null || log.finishTimes <= 0)
					return false;
				break;
			case GameData.PET_MAKE_CONDITION_ROLE_LEVEL:
				if (this.level < e.value)
					return false;
				break;
			default:
				return false;
			}
		}
		return true;
	}

	public synchronized boolean makePet(int petId)
	{
		SBean.PetCFGS petCFGS = GameData.getInstance().getPetCFG(petId);
		if (petCFGS == null || this.activePets.containsKey(petId))
			return false;
		if (!checkMakePetCondition(petCFGS))
			return false;
		if (petCFGS.makeConsumeItem != 0 && !this.containsEnoughGameItem(petCFGS.makeConsumeItem, petCFGS.makeConsumeItemCount))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MAKE_PET);
		tlogEvent.setArg(petId, petCFGS.makeConsumeItem, petCFGS.makeConsumeItemCount);
		if (petCFGS.makeConsumeItem != 0)
			this.delGameItem(petCFGS.makeConsumeItem, petCFGS.makeConsumeItemCount, tlogEvent.getGameItemRecords());
		this.makePetImpl(petId, 0, petCFGS);
		this.logTasks(GameData.TASK_TYPE_GAIN_PET, 0, 0, 0);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logPetMake(this, petId, petCFGS.startLevel);
		return true;
	}

	private void makePetImpl(int petId, int petCoPracticeLvl, SBean.PetCFGS petCFGS)
	{
		SBean.DBPet pet = new SBean.DBPet(new SBean.FightPet(petId, petCFGS.startLevel > this.level ? this.level : petCFGS.startLevel, petCFGS.startStar, new TreeMap<>(), petCoPracticeLvl, 0, GameData.getInstance().getInitPetSkill(petId), new ArrayList<>()),
										  0,
										  0,
										  0,
										  new TreeSet<>(),
										  0,
										  new SBean.DBPetTask(0, 0),
										  new SBean.DBPetLifeTask(0, 0, 0),
										  0);
		pet.transformLvl = GameData.getInstance().getPetTransfromLevelFromLvl(pet.fightPet.level);
		
		//init pet curSpirit
		SBean.PetExploitCFGS peCfg = GameData.getInstance().getPetExploitCFGS(petId);
		if(peCfg != null)
		{
			for(int i = 0; i < peCfg.exploits.size(); i++)
			{
				pet.fightPet.curSpirits.add(new SBean.PetSpirit(0, 0));
			}
		}
		int star5PetCount = 0;
		for (SBean.DBPet e : this.activePets.values())
		{
			if (e.fightPet.star >= 5)
				star5PetCount += 1;
		}
		for (SBean.PetBreakSkillCondCFGS bsccfg : petCFGS.breakSkills)
		{
			if (star5PetCount >= bsccfg.value)
				pet.fightPet.breakSkills.putIfAbsent(bsccfg.id, 1);
		}
		activePets.put(petId, pet);
		this.petSpirit.updatePetMaxlevel(pet.fightPet.level);

		pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_GAIN_PET, 0);
	}

	public synchronized boolean petTransform(int petId, int tlvl)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if (pet == null || pet.transformLvl + 1 != tlvl)
			return false;
		SBean.PetTransformCFGS cfg = GameData.getInstance().getPetTransfromCFG(tlvl);
		if (cfg == null)
			return false;
		if (pet.fightPet.level < cfg.mustTransfromLvl)
			return false;
		switch (cfg.cond)
		{
		case GameData.PET_TRANSFORM_CONDITION_NONE:
			break;
		case GameData.PET_TRANSFORM_CONDITION_PET_FINISH_MAPCOPY:
			if (!pet.mapLogs.contains(cfg.value))
				return false;
			break;
		default:
			return false;
		}
		if (!this.containsEnoughGameItems(cfg.costItems))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_TRANSFORM);
		tlogEvent.setArg(petId, tlvl);
		this.delGameItems(cfg.costItems, tlogEvent.getGameItemRecords());
		pet.transformLvl = tlvl;

		// gs.getMapService().syncRoleUpdatePet(this.id,
		// this.gameMapContext.getCurMapId(), pet);
		pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logPetTransform(this, petId, tlvl);
		return true;
	}

	public synchronized boolean petLevelUp(int petId, Map<Integer, Integer> items)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if (pet == null)
			return false;
		int expAdd = 0;
		for (Map.Entry<Integer, Integer> e : items.entrySet())
		{
			int iid = e.getKey();
			int icount = e.getValue();
			CellItem bi = this.getBagItem(iid);
			if (bi == null)
				return false;
			CellItem.Useable useable = bi.getUseable();
			if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, icount))
				return false;
			CellItem.PetExpAdder expAdder = useable.useAsPetExpAdder();
			if (expAdder == null)
				return false;
			expAdd += expAdder.getExp() * icount;
		}
		GameData.LevelExp levelExp = GameData.getInstance().getAddPetExpLvlExp(pet.fightPet.level, pet.exp, expAdd);
		if (levelExp.level > this.level || levelExp.level > GameData.getInstance().getPetTransformMaxLevel(pet.transformLvl))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_LEVEL_UP);
		for (Map.Entry<Integer, Integer> e : items.entrySet())
		{
			tlogEvent.setArg(petId, e.getKey(), e.getValue());
			this.delGameItem(e.getKey(), e.getValue(), tlogEvent.getGameItemRecords());
		}
		final int oldlevel = pet.fightPet.level;
		pet.fightPet.level = levelExp.level;
		pet.exp = (int) levelExp.exp;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		if (oldlevel != levelExp.level)
		{
			testChallengeTask(GameData.CHALLENGE_TASK_ID_PET_LEVEL, 0);
			gs.getMapService().syncRoleUpdatePet(this.id, this.gameMapContext.getCurMapId(), pet.fightPet.kdClone());
			pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);
			this.petSpirit.updatePetMaxlevel(levelExp.level);
			if (GameData.getInstance().getPetAchieveGroupCFGS(GameData.PET_ACHIEVE_TYPE_LEVEL).achieves.stream().anyMatch(levelitem -> levelitem.cond > oldlevel && levelitem.cond <= pet.fightPet.level))
				UpdatePetAchieve();
			
		    gs.getTLogger().logPetLevelUp(this, petId, pet.fightPet.level);
		}
		return true;
	}

	public synchronized boolean petBuyLevel(int petId, int level)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if (pet == null)
			return false;
		SBean.PetLvlCFGS cfg = GameData.getInstance().getPetLevelCFG(pet.fightPet.level);
		if (cfg == null)
			return false;
		if (level > this.level || level > GameData.getInstance().getPetTransformMaxLevel(pet.transformLvl))
			return false;
		if (!cfg.buyDiamonds.containsKey(level))
			return false;
		int usediamond = cfg.buyDiamonds.get(level);
		if (!this.canUseDiamond(usediamond, true))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_BUY_LEVEL);
		tlogEvent.setArg(petId, level, usediamond);
		this.useDiamond(usediamond, true, tlogEvent.getGameItemRecords());
		final int oldlevel = pet.fightPet.level;
		pet.fightPet.level = level;
		if (pet.fightPet.level == GameData.getInstance().getPetLevelLimit())
			pet.exp = 0;

		gs.getMapService().syncRoleUpdatePet(this.id, this.gameMapContext.getCurMapId(), pet.fightPet.kdClone());
		pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_PET_LEVEL, 0);
		this.petSpirit.updatePetMaxlevel(level);
		if (GameData.getInstance().getPetAchieveGroupCFGS(GameData.PET_ACHIEVE_TYPE_LEVEL).achieves.stream().anyMatch(levelitem -> levelitem.cond > oldlevel && levelitem.cond <= pet.fightPet.level))
			UpdatePetAchieve();

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logPetLevelUp(this, petId, level);
		return true;
	}

	private void tryUnlockPetBreakSkills(int star5PetCount)
	{
		for (SBean.DBPet pet : this.activePets.values())
		{
			if (pet.fightPet.star >= 5)
			{
				SBean.PetCFGS petcfg = GameData.getInstance().getPetCFG(pet.fightPet.id);
				if (petcfg != null)
				{
					for (SBean.PetBreakSkillCondCFGS bsccfg : petcfg.breakSkills)
					{
						if (star5PetCount >= bsccfg.value)
							pet.fightPet.breakSkills.putIfAbsent(bsccfg.id, 1);
					}
				}
			}
		}
	}

	public synchronized boolean petStarUp(int petId, int star, int itemCount, int alternativeCount)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if (pet == null || pet.fightPet.star + 1 != star)
			return false;
		SBean.PetCFGS petcfg = GameData.getInstance().getPetCFG(petId);
		if (petcfg == null)
			return false;
		SBean.PetStarCFGS starcfg = GameData.getPetStarCFG(petcfg, star);
		if (starcfg == null)
			return false;

		if (itemCount < 0 || alternativeCount < 0 || itemCount + alternativeCount != starcfg.itemCount)
			return false;
		if (!this.containsEnoughGameItem(starcfg.itemId, itemCount) || !this.containsEnoughGameItem(starcfg.replaceId, alternativeCount))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_STAR_UP);
		tlogEvent.setArg(petId, star, itemCount, alternativeCount);
		if (itemCount > 0)
			this.delGameItem(starcfg.itemId, itemCount, tlogEvent.getGameItemRecords());
		if (alternativeCount > 0)
			this.delGameItem(starcfg.replaceId, alternativeCount, tlogEvent.getGameItemRecords());
		final int oldstar = pet.fightPet.star;
		pet.fightPet.star = star;
		if (star == 5)
		{
			int star5PetCount = 0;
			for (SBean.DBPet e : this.activePets.values())
			{
				if (e.fightPet.star >= 5)
					star5PetCount += 1;
			}
			tryUnlockPetBreakSkills(star5PetCount);
		}

		testChallengeTask(GameData.CHALLENGE_TASK_ID_PET_STAR, 0);
		gs.getMapService().syncRoleUpdatePet(this.id, this.gameMapContext.getCurMapId(), pet.fightPet.kdClone());
		pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);
		if (pet.fightPet.star == GameData.getInstance().getPetStarLimit(petId))
			this.roleProperties.onUpdatePetCoPractice(pet.fightPet.id, pet.fightPet.coPracticeLvl, true);

		if (GameData.getInstance().getRollNoticeCFGS().petStarups.contains(star))
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_PET_STARUP, this.name + "|" + petId + "|" + star);
		if (GameData.getInstance().getPetAchieveGroupCFGS(GameData.PET_ACHIEVE_TYPE_STAR).achieves.stream().anyMatch(staritem -> staritem.cond > oldstar && staritem.cond <= pet.fightPet.star))
			UpdatePetAchieve();

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logPetStarUp(this, petId, star);
		return true;
	}

	public synchronized boolean petBreakSkillLevelUp(int petId, int skillId, int level, int itemCount, int alternativeCount)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if (pet == null)
			return false;
		Integer curLevel = pet.fightPet.breakSkills.get(skillId);
		if (curLevel == null || curLevel + 1 != level)
			return false;
		SBean.PetBreakSkillLevelCFGS cfg = GameData.getInstance().getPetBreakSkillCFG(skillId, level);
		if (itemCount < 0 || alternativeCount < 0 || itemCount + alternativeCount != cfg.itemCount)
			return false;
		if (!this.containsEnoughGameItem(cfg.itemId, itemCount) || !this.containsEnoughGameItem(cfg.replaceId, alternativeCount))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_BREAK_SKILL_LEVEL_UP);
		tlogEvent.setArg(petId, skillId, itemCount, alternativeCount);
		if (itemCount > 0)
			this.delGameItem(cfg.itemId, itemCount, tlogEvent.getGameItemRecords());
		if (alternativeCount > 0)
			this.delGameItem(cfg.replaceId, alternativeCount, tlogEvent.getGameItemRecords());
		final int oldminlevel = pet.fightPet.breakSkills.values().stream().min((a, b) -> a > b ? b : a).get();
		pet.fightPet.breakSkills.put(skillId, level);
		final int newminlevel = pet.fightPet.breakSkills.values().stream().min((a, b) -> a > b ? b : a).get();

		gs.getMapService().syncRoleUpdatePet(this.id, this.gameMapContext.getCurMapId(), pet.fightPet.kdClone());
		pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);


		if (pet.fightPet.breakSkills.values().size() == 4 && oldminlevel != newminlevel && GameData.getInstance().getPetAchieveGroupCFGS(GameData.PET_ACHIEVE_TYPE_BREAKSKILL).achieves.stream().anyMatch(breakitem -> breakitem.cond > oldminlevel && breakitem.cond <= newminlevel))
			UpdatePetAchieve();

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean setWorldMapFightPet(int petId)
	{
		if(petId == 0)
			return umSummonWorldMapPet();
		
		if (!this.activePets.containsKey(petId) || this.worldMapPets.contains(petId) || this.gameMapContext.getCurMapContext().getCurRideHorse() > 0 || this.mulRoleInfo.leader > 0)
			return false;
		
		this.worldMapPets.clear();
		this.worldMapPets.add(petId);
		this.gameMapContext.getWorldMapContext().curPetHp.clear();
		this.roleProperties.onChangeCurFightPet(this.getWorldMapFightPets());
		gs.getMapService().syncRoleChangeCurPets(this.id, this.gameMapContext.getCurMapId(), this.getMapFightPetsWithoutLock(new HashSet<>(this.worldMapPets)));
		return true;
	}
	
	private boolean umSummonWorldMapPet()
	{
		if (!this.gameMapContext.isInWorldMap() || this.worldMapPets.isEmpty())
			return false;
		
		this.worldMapPets.clear();
		this.roleProperties.onChangeCurFightPet(this.getWorldMapFightPets());
		gs.getMapService().syncRoleUnSummonPets(this.id, this.gameMapContext.getCurMapId());
		return true;
	}
	
	public synchronized boolean setPrivateMapFightPet(Set<Integer> petsId)
	{
		for (int petId : petsId)
		{
			if (!this.activePets.containsKey(petId))
				return false;
		}
		if (!petsId.isEmpty())
		{
			List<Integer> fightPetsCountcfg = GameData.getInstance().getCommonCFG().pet.level;
			if (petsId.size() > fightPetsCountcfg.size() || fightPetsCountcfg.isEmpty())
				return false;
			int roleLvlReq = fightPetsCountcfg.get(petsId.size() - 1);
			if (this.level < roleLvlReq)
				return false;
		}

		this.privateMapPets.clear();
		this.privateMapPets.addAll(petsId);
		return true;
	}

	public synchronized boolean setSectMapFightPet(Set<Integer> petsId)
	{
		for (int petId : petsId)
		{
			if (!this.activePets.containsKey(petId))
				return false;
		}
		if (!petsId.isEmpty())
		{
			List<Integer> fightPetsCountcfg = GameData.getInstance().getCommonCFG().pet.level;
			if (petsId.size() > fightPetsCountcfg.size() || fightPetsCountcfg.isEmpty())
				return false;
			int roleLvlReq = fightPetsCountcfg.get(petsId.size() - 1);
			if (this.level < roleLvlReq)
				return false;
		}

		this.sectMapPets.clear();
		this.sectMapPets.addAll(petsId);
		return true;
	}

	public synchronized boolean setActivityMapFightPet(Set<Integer> petsId)
	{
		for (int petId : petsId)
		{
			if (!this.activePets.containsKey(petId))
				return false;
		}
		if (!petsId.isEmpty())
		{
			List<Integer> fightPetsCountcfg = GameData.getInstance().getCommonCFG().pet.level;
			if (petsId.size() > fightPetsCountcfg.size() || fightPetsCountcfg.isEmpty())
				return false;
			int roleLvlReq = fightPetsCountcfg.get(petsId.size() - 1);
			if (this.level < roleLvlReq)
				return false;
		}

		this.activityMapPets.clear();
		this.activityMapPets.addAll(petsId);
		return true;
	}
	
	synchronized Map<Integer, Integer> syncPetInfo()
	{
		return new HashMap<>(this.petSpirit.allPetSpirits);
	}
	
	class PetSpiritInfo
	{
		Map<Integer, Integer> allPetSpirits;
		Map<Integer, SpiritCache> caches;
		int petMaxLevel;
		
		PetSpiritInfo(Map<Integer, Integer> allPetSpirits)
		{
			this.allPetSpirits = allPetSpirits;
			this.caches = new HashMap<>();
		}
		
		PetSpiritInfo init(Collection<SBean.DBPet> dbPets)
		{
			for(SBean.DBPet p: dbPets)
				updatePetMaxlevel(p.fightPet.level);
			
			return this;
		}
		
		void updatePetMaxlevel(int lvl)
		{
			if(lvl > this.petMaxLevel)
				this.petMaxLevel = lvl;
		}
		
		SpiritCache getSpiritCache(int petID)
		{
			return this.caches.get(petID);
		}
		
		void setSpiritCache(int petID, int index, SBean.PetSpirit spirit)
		{
			SpiritCache cache = this.caches.get(petID);
			if(cache == null)
			{
				cache = new SpiritCache();
				this.caches.put(petID, cache);
			}
			
			cache.setCache(index, spirit);
		}
		
		class SpiritCache
		{
			int index = -1;
			SBean.PetSpirit spirit;
			
			void setCache(int index, SBean.PetSpirit spirit)
			{
				this.index = index;
				this.spirit = spirit;
			}
			
			void clear()
			{
				this.index = -1;
				this.spirit = null;
			}
		}
	}
	
	synchronized boolean petSpiritLvlUp(int spiritID)
	{
		if(this.petSpirit.petMaxLevel < GameData.getInstance().getCommonCFG().pet.spiritLvlReq)
			return false;
		
		int spiritLvl = this.petSpirit.allPetSpirits.getOrDefault(spiritID, 0);
		SBean.PetSpiritGroupCFGS groupCfg = GameData.getInstance().getPetSpiritGroupCFGS(spiritID);
		if(groupCfg == null || spiritLvl >= groupCfg.spirits.size())
			return false;
		
		SBean.PetSpiritCFGS cfg = GameData.getPetSpiritCFGS(groupCfg, spiritLvl + 1);
		if(cfg == null)
			return false;
		
		if(!this.containsEnoughGameItems(cfg.cost))
			return false;
		
		this.petSpirit.allPetSpirits.put(spiritID, spiritLvl + 1);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_SPIRIT_LVLUP);
		this.delGameItems(cfg.cost, tlogEvent.getGameItemRecords());
		tlogEvent.setArg(spiritID, spiritLvl + 1);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	synchronized int petSpiritLearn(int petID, int spiritID, int index)
	{
		SBean.DBPet dbPet = this.activePets.get(petID);
		if(dbPet == null || dbPet.fightPet.level < GameData.getInstance().getCommonCFG().pet.spiritLvlReq || index <= 0 || index > dbPet.fightPet.curSpirits.size())
			return GameData.PROTOCOL_OP_FAILED;
		
		Integer spiritLvl = this.petSpirit.allPetSpirits.get(spiritID);
		if(spiritLvl == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.PetSpiritGroupCFGS group = GameData.getInstance().getPetSpiritGroupCFGS(spiritID);
		if(group == null)
			return GameData.PROTOCOL_OP_FAILED; 
		
		int exploit = GameData.getInstance().getPetExploit(petID, index);
		if(exploit < 0 || dbPet.exploit < exploit)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.PetCFGS pCfg = GameData.getInstance().getPetCFG(petID);
		if(pCfg == null || !this.containsEnoughGameItems(pCfg.spiritLearnCost))
			return GameData.PROTOCOL_OP_FAILED;
		
		for(int pos = 0; pos < dbPet.fightPet.curSpirits.size(); pos++)
		{
			if(dbPet.fightPet.curSpirits.get(pos) != null && dbPet.fightPet.curSpirits.get(pos).id == spiritID)
			{
				if(pos + 1 == index)
					break;
				else
					return GameData.PROTOCOL_OP_FAILED;
			}
		}
		
		int newLvl = GameData.petSpiritLearn(group, spiritLvl);
		SBean.PetSpirit old = dbPet.fightPet.curSpirits.get(index - 1);
		if(old == null || old.id == 0)
		{
			dbPet.fightPet.curSpirits.set(index - 1, new SBean.PetSpirit(spiritID, newLvl));
			if(this.worldMapPets.contains(petID))
			{
				this.roleProperties.onUpdateCurPetSpirit(petID, index, new SBean.PetSpirit(spiritID, newLvl));
				gs.getMapService().syncRoleUpdateCurPetSpirit(this.gameMapContext.getCurMapId(), this.id, petID, index, new SBean.PetSpirit(spiritID, newLvl));
			}
			this.roleProperties.onUpdatePetSpirit(petID, index, new SBean.PetSpirit(spiritID, newLvl));
		}
		else
		{
			this.petSpirit.setSpiritCache(petID, index, new SBean.PetSpirit(spiritID, newLvl));
		}
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_SPIRIT_LEARN);
		this.delGameItems(pCfg.spiritLearnCost, tlogEvent.getGameItemRecords());
		tlogEvent.setArg(petID, spiritID, index);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		return newLvl;
	}
	
	synchronized boolean petSpiritRepleace(int petID, int index)
	{
		SpiritCache cache = this.petSpirit.getSpiritCache(petID);
		if(cache == null || cache.spirit == null || cache.index != index)
			return false;
		
		SBean.DBPet dbPet = this.activePets.get(petID);
		if(dbPet == null)
			return false;
		
		SBean.PetSpirit old = dbPet.fightPet.curSpirits.get(index - 1);
		dbPet.fightPet.curSpirits.set(index - 1, cache.spirit.kdClone());
		if(old == null || old.id != cache.spirit.id || old.level != cache.spirit.level)
		{
			if(this.worldMapPets.contains(petID))
			{
				this.roleProperties.onUpdateCurPetSpirit(petID, index, cache.spirit.kdClone());
				gs.getMapService().syncRoleUpdateCurPetSpirit(this.gameMapContext.getCurMapId(), this.id, petID, index, cache.spirit.kdClone());
			}
			this.roleProperties.onUpdatePetSpirit(petID, index, cache.spirit.kdClone());
		}
		cache.clear();
		return true;
	}
	
	void syncAddPetExploit(int petID, int addExploit)
	{
		if(this.addPetExploit(petID, addExploit))
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.pet_add_exploit(petID, addExploit));
	}
	
	boolean addPetExploit(int petID, int addExploit)
	{
		SBean.DBPet dbPet =  this.activePets.get(petID);
		int max = GameData.getInstance().getPetMaxExploit(petID);
		if(dbPet == null || max < 0 || dbPet.exploit >= max || dbPet.fightPet.level < GameData.getInstance().getCommonCFG().pet.spiritLvlReq)
			return false;
		
		dbPet.exploit += addExploit;
		return true;
	}
	// ---------------------------------------------------team----------------------------------------------------------------
	synchronized int getLeaderLine()
	{
		return this.leaderLine;
	}
	
	private int getPriorityLine(int targetMap)
	{
		if(this.escortCar.ownerID > 0 && this.escortCar.mapID == targetMap)
			return this.escortCar.mapInstance;
		
		return this.leaderLine;
	}
	
	synchronized void updateLeaderLine(int leaderLine)
	{
		this.leaderLine = leaderLine;
	}
	
	void onSelfChangeLine(int curLine)
	{
		gs.getLoginManager().addNormalTaskEvent(() -> 
		{
			synchronized(this)
			{
				if(this.team.id == 0 || this.team.leader != this.id)
					return;
			}
			
			gs.getTeamManager().notifyMemberUpdateLeaderLine(this.team.id, curLine);
		});
	}
	
	public synchronized int getTeamId()
	{
		return this.team.id;
	}
	
	public boolean isInTeam()
	{
		return this.team.id != 0;
	}

	public boolean isTeamLeader()
	{
		return this.team.id > 0 && this.team.leader == this.id;
	}

	private boolean isInteamAndTeamFull()
	{
		return (this.team.id != 0 && this.team.members.size() >= GameData.TEAM_MAX_COUNT);
	}

	private boolean isRoleBeInvitedInTeam(int rid)
	{
		return this.teamInvites.contains(rid);
	}

	private boolean isRoleBeAppliedInTeam(int rid)
	{
		return this.teamApplys.contains(rid);
	}

	private boolean isRoleInMyTeam(int rid)
	{
		return this.team.members.contains(rid);
	}

	public Collection<Integer> getAllTeamMembersWithoutLock()
	{
		List<Integer> lst = new ArrayList<Integer>();
		if (team.id==0)
			return lst;
		lst.addAll(this.team.members);
		return lst;
	}
	
	public int getTeamMemberCnt()
	{
		return team.id==0?0:team.members.size();
	}

	public synchronized boolean testCanJoinTeam()
	{
		if (!canJoinTeamMap())
			return false;
		return true;
	}

	synchronized void clearFightTeam()
	{
		if(this.team.id >= 0)
			return;
		
		this.team.id = 0;
		this.team.leader = 0;
		this.team.members.clear();
		this.teamInvites.clear();
		this.teamApplys.clear();
		this.leaderLine = -1;
		
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_leave(this.id, this.name));
	}
	
	// 自己加入队伍
	synchronized void onSelfJoinTeam(SBean.Team team, int leaderLine)
	{
		onSelfJoinTeamImpl(team, leaderLine);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_sync(team.kdClone()));
	}

	synchronized void onSelfJoinTeamImpl(SBean.Team team, int leaderLine)
	{
		this.team = team;
		this.leaderLine = leaderLine;
		if (this.team.leader != this.id)
		{
			this.teamInvites.clear();
			this.teamApplys.clear();
		}
		onTeamMemberChange();
		gs.getTLogger().logRoleJoinTeamFlow(this);
	}
	
	// 别人加入队伍
	synchronized void onNewMemberJoinTeam(Role newMember)
	{
		this.team.members.add(newMember.id);
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_join(newMember.id, newMember.name));
	}

	// 自己离开和队友离开
	synchronized void onTeamMemberLeave(Role member)
	{
		if (member.id == this.id)
		{
			this.team.id = 0;
			this.team.leader = 0;
			this.team.members.clear();
			this.teamInvites.clear();
			this.teamApplys.clear();
			this.leaderLine = -1;
		}
		else
		{
			this.team.members.remove(Integer.valueOf(member.id));
		}
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_leave(member.id, member.name));
	}

	synchronized void onTeamMemberLeave(SBean.RoleOverview member)
	{
		if (member.id == this.id)
		{
			this.team.id = 0;
			this.team.leader = 0;
			this.team.members.clear();
			this.teamInvites.clear();
			this.teamApplys.clear();
			this.leaderLine = -1;
		}
		else
		{
			this.team.members.remove(Integer.valueOf(member.id));
		}
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_leave(member.id, member.name));
	}
	
	private void onTeamMemberChange()
	{
		this.propose = new SBean.ProposeData(0, 0);
		this.escortCar.updateTeamCarCnt(getTeamCarCnt());
		gs.getMapService().syncRoleUpdateTeam(this.id, this.gameMapContext.getCurMapId(), this.team);
	}

	// 自己离开和队友被踢
	synchronized void onTeamMemberKicked(Role member)
	{
		if (member.id == this.id)
		{
			this.team.id = 0;
			this.team.leader = 0;
			this.team.members.clear();
			this.teamInvites.clear();
			this.teamApplys.clear();
			this.leaderLine = -1;
			this.escortCar.updateTeamCarCnt(0);
		}
		else
		{
			this.team.members.remove(Integer.valueOf(member.id));
		}
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_kick(member.id, member.name));
	}

	// 队伍更换队长
	synchronized void onTeamLeaderChange(Role newLeader, int leaderLine)
	{
		this.team.leader = newLeader.id;
		this.leaderLine = leaderLine;
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_change_leader(newLeader.id, newLeader.name));
	}

	synchronized void onTeamLeaderChange(SBean.RoleOverview newLeader, int leaderLine)
	{
		this.team.leader = newLeader.id;
		this.leaderLine = leaderLine;
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_change_leader(newLeader.id, newLeader.name));
	}

	
	// 队伍解散
	synchronized void onTeamDissolve()
	{
		this.team.id = 0;
		this.team.leader = 0;
		this.team.members.clear();
		this.teamInvites.clear();
		this.teamApplys.clear();
		this.leaderLine = -1;
		onTeamMemberChange();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_dissolve());
	}

	void notifyTeamMemberUpdateProfile()
	{
		if (this.team.id != 0)
		{
			SBean.RoleProfile profile = this.getRoleProfileWithoutLock();
			for (int rid : this.team.members)
			{
				//if (rid != this.id)//客户端MyTeam UI弹出框中包含自己的信息，也需要通过此消息通知更新
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.team_member_profile(profile, this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), this.netsid, this.gameMapContext.getCurMapLine()));
					}
				}
			}
		}
	}

	void notifyTeamMemberUpdateHp(int hp, int hpMax)
	{
		if (this.team.id > 0)
		{
			for (int rid : this.team.members)
			{
				if (rid != this.id && rid > 0)
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.team_member_hp(this.id, hp, hpMax));
					}
				}
			}
		}
	}

	void notifyTeamMemberUpdatePosition(int mapId, int line, SBean.Vector3 pos)
	{
		if (this.team.id != 0)
		{
			for (int rid : this.team.members)
			{
				if (rid != this.id && rid > 0)
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.team_member_position(this.id, mapId, pos, line));
					}
				}
			}
		}
	}

	void notifyTeamMemberUpdateConnectionState(int state)
	{
		if (this.team.id != 0)
		{
			for (int rid : this.team.members)
			{
				if (rid != this.id)
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.team_member_connection(this.id, state));
					}
				}
			}
		}
	}

	public void queryRoleProfile(int rid)
	{
		Role role = gs.getLoginManager().getOnGameRole(rid);
		if (role != null)
		{
			synchronized (role)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_member_profile(role.getRoleProfile(), role.gameMapContext.getCurMapId(), role.gameMapContext.getCurMapPosition(), role.netsid, role.gameMapContext.getCurMapLine()));
			}
		}
		else
		{
			if(this.team.id < 0)
			{
				gs.getFightService().queryTeamMemberImpl(rid,  profile -> {
					if(profile != null)
						gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_member_profile(profile, this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), 1, 1));
				});
			}
		}
	}
	
	boolean canJoinTeamMap()
	{
		return this.gameMapContext.isInWorldMap() || this.gameMapContext.getCurMapContext().getMapType() == GameData.MAP_TYPE_MAPCOPY_SECT_GROUP || this.gameMapContext.getCurMapContext().getMapType() == GameData.MAP_TYPE_MAPCOPY_EMERGENCY;
	}

	// 当前无队伍，可以邀请，有队伍不论是否为队长也都可以邀请
	public int teamInvite(int invitedRoleId)
	{
		if (invitedRoleId == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role iRole = gs.getLoginManager().getOnGameRole(invitedRoleId);
		if (iRole == null)
			return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
		synchronized (iRole)
		{
			if (!iRole.canJoinTeamMap())
				return GameData.PROTOCOL_OP_TEAM_ROLE_IN_MAPCOPY;
			
			if(iRole.level < GameData.getInstance().getCommonCFG().team.lvlReq)
				return GameData.PROTOCOL_OP_TEAM_OTHER_LEVEL_LIMIT;
			
			if (iRole.isInTeam())
				return GameData.PROTOCOL_OP_TEAM_ALREADY_IN_TEAM;

			if (iRole.superarenaState != 0)
				return GameData.PROTOCOL_OP_TEAM_ROLE_IN_AROOM_MATCHING;
		}
		synchronized (this)
		{
			if (!canJoinTeamMap())
				return GameData.PROTOCOL_OP_FAILED;
			
			if(this.level < GameData.getInstance().getCommonCFG().team.lvlReq)
				return GameData.PROTOCOL_OP_TEAM_SELF_LEVEL_LIMIT;
			
			if (this.isInteamAndTeamFull())
				return GameData.PROTOCOL_OP_TEAM_TEAM_FULL;
			this.teamInvites.add(invitedRoleId);
		}
		gs.getRPCManager().sendStrPacket(iRole.netsid, new SBean.team_invite_forward(this.id, this.name));
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	// 玩家被邀请后弹框的选择结果
	public int teamInvitedby(int inviteStartRoleId, int accept)
	{
		if (inviteStartRoleId == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role sRole = gs.getLoginManager().getOnGameRole(inviteStartRoleId);
		if (sRole == null)
			return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
		synchronized (sRole)
		{
			if (!sRole.canJoinTeamMap())
				return GameData.PROTOCOL_OP_TEAM_ROLE_IN_MAPCOPY;
			if (!sRole.isRoleBeInvitedInTeam(this.id))
				return GameData.PROTOCOL_OP_FAILED;
		}
		if (accept == 0)
		{
			gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.team_invite_refuse(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (accept == -1)
		{
			gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.team_invite_busy(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (accept == -2)
		{
			gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.team_invite_lead(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}

		synchronized (this)
		{
			if (!canJoinTeamMap())
				return GameData.PROTOCOL_OP_FAILED;
			if (this.isInTeam())
				return GameData.PROTOCOL_OP_TEAM_ALREADY_IN_TEAM;
		}
		Role.MultipleRoles mr = new Role.MultipleRoles(sRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
			return gs.getTeamManager().addTeamMember(sRole, this);
		}
		finally
		{
			mr.unlock();
		}
	}

	// 申请组队，只有申请者不在队伍，被申请者可以在队伍也可以不在队伍
	// public int teamApply(int appliedRoleId)
	// {
	// if (appliedRoleId == this.id)
	// return GameData.PROTOCOL_OP_FAILED;
	// int appliedRoleTeamLeader =
	// gs.getTeamManager().getRoleTeamLeader(appliedRoleId);
	// if (appliedRoleTeamLeader == this.id)
	// return GameData.PROTOCOL_OP_FAILED;
	// Role aRole = gs.getLoginManager().getOnGameRole(appliedRoleTeamLeader > 0
	// ? appliedRoleTeamLeader : appliedRoleId);
	// if (aRole == null)
	// return GameData.TEAM_ERROR_ROLE_OFFLINE;
	// synchronized (this)
	// {
	// if (this.isInteam())
	// return GameData.TEAM_ERROR_ALREADY_IN_TEAM;
	// }
	// synchronized (aRole)
	// {
	// if (aRole.isInteamAndTeamFull())
	// return GameData.TEAM_ERROR_TEAM_FULL;
	// aRole.teamApplys.add(this.id);
	// }
	// gs.getRPCManager().sendStrPacket(aRole.netsid, new
	// SBean.team_apply_forward(this.id, this.name));
	// return GameData.PROTOCOL_OP_SUCCESS;
	// }

	public int teamApply(int teamId)
	{
		int appliedRoleTeamLeader = gs.getTeamManager().getTeamLeader(teamId);
		if (appliedRoleTeamLeader <= 0)
			return GameData.PROTOCOL_OP_TEAM_TEAM_NOT_EXIST;
		Role aRole = gs.getLoginManager().getOnGameRole(appliedRoleTeamLeader);
		if (aRole == null)
			return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
		synchronized (aRole)
		{
			if (aRole.isInteamAndTeamFull())
				return GameData.PROTOCOL_OP_TEAM_TEAM_FULL;
			aRole.teamApplys.add(this.id);
		}
		
		synchronized (this)
		{
			if (this.isInTeam())
				return GameData.PROTOCOL_OP_TEAM_ALREADY_IN_TEAM;
			gs.getRPCManager().sendStrPacket(aRole.netsid, new SBean.team_apply_forward(this.getRoleOverviewWithoutLock()));
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public int teamAppliedby(int applyRoleId, boolean accept)
	{
		if (applyRoleId == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role aRole = gs.getLoginManager().getOnGameRole(applyRoleId);
		if (aRole == null)
			return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
		synchronized (this)
		{
			if (!this.isRoleBeAppliedInTeam(aRole.id))
				return GameData.PROTOCOL_OP_FAILED;
		}
		if (!accept)
		{
			gs.getRPCManager().sendStrPacket(aRole.netsid, new SBean.team_apply_refuse(this.id, this.name));
			return GameData.PROTOCOL_OP_FAILED;
		}
		synchronized (aRole)
		{
			if (aRole.isInTeam())
				return GameData.PROTOCOL_OP_TEAM_ALREADY_IN_TEAM;
		}
		Role.MultipleRoles mr = new Role.MultipleRoles(this, aRole);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
			return gs.getTeamManager().addTeamMember(this, aRole);
		}
		finally
		{
			mr.unlock();
		}
	}

	public boolean leaveTeam()
	{
		synchronized (this)
		{
			if (!this.isInTeam())
				return false;
		}
		
		if(this.team.id < 0)
			return leaveGlobalTeam();
		else
			return gs.getTeamManager().teamMemberLeave(this);
	}

    private boolean leaveGlobalTeam()
    {
        gs.getRPCManager().notifyFightRoleLeaveTeam(this.id);
        return true;
    }

	public int teamKick(int kickedRoleId)
	{
		if (kickedRoleId == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role kickedRole = gs.getLoginManager().getOnGameRole(kickedRoleId);
		if (kickedRole == null)
			return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
		synchronized (this)
		{
			if (!this.isTeamLeader())
				return GameData.PROTOCOL_OP_FAILED;
			if (!this.isRoleInMyTeam(kickedRoleId))
				return GameData.PROTOCOL_OP_FAILED;
		}
		Role.MultipleRoles mr = new Role.MultipleRoles(this, kickedRole);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
			return gs.getTeamManager().kickTeamMember(this, kickedRole) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}

	public int teamDissolve()
	{
		synchronized (this)
		{
			if (!this.isTeamLeader())
				return GameData.PROTOCOL_OP_FAILED;
		}
		return gs.getTeamManager().dissolveTeam(this) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
	}

	public int teamChangeLeader(int newLeader)
	{
		if (newLeader == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role newLeaderRole = gs.getLoginManager().getOnGameRole(newLeader);
		if (newLeaderRole == null)
			return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
		synchronized (this)
		{
			if (!this.isTeamLeader())
				return GameData.PROTOCOL_OP_FAILED;
			if (!this.isRoleInMyTeam(newLeader))
				return GameData.PROTOCOL_OP_FAILED;
		}
		Role.MultipleRoles mr = new Role.MultipleRoles(this, newLeaderRole);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_TEAM_ROLE_OFFLINE;
			return gs.getTeamManager().teamChangeLeader(this, newLeaderRole) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}

	public int queryRoleTeam(int queryRoleId)
	{
		Role role = gs.getLoginManager().getOnGameRole(queryRoleId);
		if (role == null)
			return 0;
		return role.getTeamId();
	}

	public void queryTeamRoles()
	{
		synchronized (this)
		{
			if (!canJoinTeamMap())
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_self_res(GameData.emptyList()));
				return;
			}
		}
		
		if(this.team.id < 0)
			queryGlobalTeamRoles();
		else
			 gs.getTeamManager().getRoleTeamRoles(this);
	}
	
	private void queryGlobalTeamRoles()
	{
		gs.getFightService().queryTeamMembersImpl(this.id, overviews -> {
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.team_self_res(overviews));
		});
	}
	
	public List<SBean.TeamOverview> queryMapNearbyTeams()
	{
		synchronized (this)
		{
			if (!canJoinTeamMap())
				return GameData.emptyList();
		}
		Collection<Integer> mapRoles = gs.getMapService().getWolrdMapRoles(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurWorldInstanceId());
		Map<Integer, SBean.TeamOverview> teams = new HashMap<Integer, SBean.TeamOverview>();
		for (int rid : mapRoles)
		{
			if (rid != this.id)
			{
				Role role = gs.getLoginManager().getOnGameRole(rid);
				if (role != null)
				{
					synchronized (role)
					{
						if (role.isInTeam() && !teams.containsKey(role.getTeamId()))
						{
							SBean.TeamOverview t = new SBean.TeamOverview();
							t.id = role.team.id;
							t.leader = role.team.leader;
							t.memberCount = role.team.members.size();
							if (role.team.leader == role.id)
							{
								t.leaderLvl = role.level;
								t.leaderName = role.name;
							}
							else
							{
								Role leaderRole = gs.getLoginManager().getOnGameRole(t.leader);
								if (leaderRole == null)
									continue;
								t.leaderLvl = leaderRole.level;
								t.leaderName = leaderRole.name;
							}
							teams.put(t.id, t);
							if(teams.size() >= 100)
								break;
						}
					}
				}
			}
		}
		List<SBean.TeamOverview> lst = new ArrayList<SBean.TeamOverview>();
		lst.addAll(teams.values());
		return lst;
	}

	public List<SBean.RoleOverview> queryMapNearbyNoTeamRoles()
	{
		synchronized (this)
		{
			if (!canJoinTeamMap())
				return GameData.emptyList();
		}
		Collection<Integer> mapRoles = new TreeSet<>();
		if (this.gameMapContext.getCurMapContext().getMapType() == GameData.MAP_TYPE_MAPCOPY_SECT_GROUP)
			mapRoles = gs.getMapService().getSectGroupMapRoles(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance());
		else
			mapRoles = gs.getMapService().getWolrdMapRoles(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurWorldInstanceId());
		List<SBean.RoleOverview> noTeamRoles = new ArrayList<SBean.RoleOverview>();
		for (int rid : mapRoles)
		{
			if (rid != this.id)
			{
				Role role = gs.getLoginManager().getOnGameRole(rid);
				if (role != null)
				{
					synchronized (role)
					{
						if (!role.isInTeam() && role.isOnline())
						{
							noTeamRoles.add(role.getRoleOverviewWithoutLock());
							if(noTeamRoles.size() >= 100)
								break;
						}
					}
				}
			}
		}
		return noTeamRoles;
	}

	// -----------room---------------
	private int getMRoomType()
	{
		return this.room.type;
	}
	
	private int getMRoomId()
	{
		return this.room.id;
	}

	private boolean isInMRoom()
	{
		return this.room.id > 0;
	}

	private int getMRoomTargetMap()
	{
		return this.room.mapId;
	}

	private boolean isMRoomLeader()
	{
		return this.room.id > 0 && this.room.leader == this.id;
	}

	private boolean isNotInMRoomOrMRoomFull()
	{
		return (this.room.id <= 0 || this.room.members.size() >= GameData.MAP_ROOM_MAX_COUNT);
	}

	private boolean isInRoomAndRoleBeInvited(int rid)
	{
		return this.room.id > 0 && this.roomInvites.contains(rid);
	}

	private boolean isRoleInMyMRoom(int rid)
	{
		return this.room.members.contains(rid);
	}

	public Collection<Integer> getAllMRoomMembersWithoutLock()
	{
		List<Integer> lst = new ArrayList<Integer>();
		lst.addAll(this.room.members);
		return lst;
	}

	public synchronized int testCanEnterMRoom(int mapId, int roomType)
	{
		if (this.isInMulRolesActivity())
			return GameData.PROTOCOL_OP_MROOM_ALREADY_IN_ROOM;
		if (!this.gameMapContext.isInWorldMap() || this.isMulRolesState())
			return GameData.PROTOCOL_OP_MROOM_ROLE_JOIN_COND_FAILED;
		
		switch (roomType)
		{
		case GameData.MAP_ROOM_TYPE_TOWER_DEFENCE:
			return canEnterTowerDefenceRoom(mapId);
		case GameData.MAP_ROOM_TYPE_NPC_MAP:
			return canEnterNPCMapRoom(mapId);
		default:
			break;
		}
		
		if (mapId == 0)
			return testCanEnterMRoomImpl();
		else
			return testCanEnterMRoomImpl(mapId);
	}

	private int testCanEnterMRoomImpl()
	{
		SBean.JusticeMapCFGS justCFGS = GameData.getInstance().getJusticeMapCFGS();
		if (this.level < justCFGS.openLvl)
			return GameData.PROTOCOL_OP_MROOM_ROLE_JOIN_COND_FAILED;
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private int testCanEnterMRoomImpl(int mapId)
	{
		SBean.MapCopyCFGS cfg = GameData.getInstance().getMapCopyCFGS(mapId);
		if (cfg == null || cfg.openType != GameData.MAPCOPY_OPEN_TYPE_PUBLIC || this.level < cfg.needLevel)
			return GameData.PROTOCOL_OP_MROOM_ROLE_JOIN_COND_FAILED;

		if (cfg.preMapCopy > 0)
		{
			SBean.DBNormalMapCopyLog preMaplog = this.normalMapCopyLogs.get(cfg.preMapCopy);
			if (preMaplog == null || preMaplog.finishTimes <= 0)
				return GameData.PROTOCOL_OP_MROOM_ROLE_JOIN_COND_FAILED;
		}
		
		if (cfg.difficulty == GameData.MAPCOPY_DIFFICULT_MASTER)
		{
			if (this.master.master <= 0 && this.master.apprentices.isEmpty())
				return GameData.PROTOCOL_OP_MROOM_ROLE_JOIN_COND_FAILED;
		}

		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private void dayRefreshTowerDefence()
	{
		for(SBean.DBTowerDefenceMapLog log: this.towerDefence.logs.values())
		{
			log.dayBuyTimes = 0;
			log.dayEnterTimes = 0;
		}
	}
	
	public int startTowerDefenceMapCopy(int mapID)
	{
		return gs.getMapCopyManager().roomLeadedStartTowerDefence(this, mapID);
	}
	
	synchronized boolean enterTowerDefenceMapCopy(int mid, int instanceId, boolean mainSpawnPos)
	{
		if (!this.gameMapContext.isInWorldMap())//此处role已经不在房间里了不能在此处加判断在不在房间失败
			return false;

		TowerDefenceMapCopyContext context = this.tryPrepareTowerDefenceMapCopyContext(mid, instanceId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}
	
	private int canEnterTowerDefenceRoom(int mapID)
	{
		SBean.TowerDefenceMapCFGS mapCfg = GameData.getInstance().getTowerDefenceMapCFGS(mapID);
		if(mapCfg == null)
			return GameData.PROTOCOL_OP_MROOM_MAP_INVALID;
		
		SBean.TowerDefenceCFGS cfg = GameData.getInstance().getTowerDefenceCFGS(mapID);
		if(cfg == null)
			return GameData.PROTOCOL_OP_FAILED;

		if(!GameData.isTowerDefenceInOpneTime(cfg.base))
			return GameData.PROTOCOL_OP_MROOM_NOT_IN_OPEN_TIME;
		
		if(this.level < cfg.base.lvlReq)
			return GameData.PROTOCOL_OP_MROOM_ROLE_JOIN_COND_FAILED;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int canEnterNPCMapRoom(int mapID)
	{
		SBean.NpcMapCFGS cfg = GameData.getInstance().getNpcMapCFGS(mapID);
		if (cfg == null)
			return GameData.PROTOCOL_OP_MROOM_MAP_INVALID;
		int secondOfDay = GameTime.getSecondOfDay();
		int day = GameTime.getDay();
		if (!GameData.isInDay(cfg.opendays) || day < cfg.mapstartDay || day > cfg.mapendDay || secondOfDay < cfg.mapstartTime || secondOfDay > cfg.mapendTime)
			return GameData.PROTOCOL_OP_MROOM_MAP_INVALID;
		if (this.level < cfg.openLvl)
			return GameData.PROTOCOL_OP_FAILED;
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	void notifyMRoomMemberUpdateConnectionState(int state)
	{
		if (this.room.id > 0)
		{
			for (int rid : this.room.members)
			{
				if (rid != this.id && rid > 0)
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.mroom_member_connection(this.id, state));
					}
				}
			}
		}
	}

	// 自己加入房间
	synchronized void onSelfJoinMRoom(SBean.MRoom room)
	{
		this.room = room;
		this.roomInvites.clear();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.mroom_sync(room));
	}

	// 别人加入房间
	synchronized void onNewMemberJoinMRoom(Role newMember)
	{
		this.room.members.add(newMember.id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.mroom_join(newMember.id, newMember.name));
	}

	// 自己离开或队友离开
	synchronized void onMRoomMemberLeave(Role member)
	{
		if (member.id == this.id)
		{
			this.room.id = 0;
			this.room.mapId = 0;
			this.room.leader = 0;
			this.room.members.clear();
		}
		else
		{
			this.room.members.remove(Integer.valueOf(member.id));
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.mroom_leave(member.id, member.name));
	}

	// 自己或队友被踢
	synchronized void onMRoomMemberKicked(Role member)
	{
		if (member.id == this.id)
		{
			this.room.id = 0;
			this.room.mapId = 0;
			this.room.leader = 0;
			this.room.members.clear();
		}
		else
		{
			this.room.members.remove(Integer.valueOf(member.id));
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.mroom_kick(member.id, member.name));
	}

	// 队伍更换队长
	synchronized void onMRoomLeaderChange(Role newLeader)
	{
		this.room.leader = newLeader.id;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.mroom_change_leader(newLeader.id, newLeader.name));
	}

	public int mroomNewCreate(int mapId, int roomType)
	{
		synchronized (this)
		{
			int canEnterMRoom = this.testCanEnterMRoom(mapId, roomType);
			if (canEnterMRoom <= 0)
				return canEnterMRoom;
		}
		int roomId = gs.getMapCopyManager().createMapCopyRoom(mapId, this, roomType);
		if (roomId <= 0)
			return roomId;
		
		Set<Integer> members = new HashSet<>();
		synchronized (this)
		{
			if (this.isTeamLeader())
				members.addAll(this.team.members);
		}
		
		for (int rid : members)
		{
			if (rid != this.id)
			{
				Role iRole = gs.getLoginManager().getOnGameRole(rid);
				if (iRole != null)
				{
					synchronized(iRole)
					{
						if (iRole.testCanEnterMRoom(mapId, roomType) <= 0)
							gs.getRPCManager().sendStrPacket(this.netsid, new SBean.mroom_invite_fail(iRole.id, iRole.name));
						else
						{
							this.roomInvites.add(rid);
							gs.getRPCManager().sendStrPacket(iRole.netsid, new SBean.mroom_invite_forward(this.id, this.name, this.room.mapId, this.room.id, this.room.type));
						}
					}
				}
			}
		}
		return roomId;
	}

	// 邀请者必须在房间，是否为队长都可以邀请，不同于队伍，被邀请者无任何要求和限制
	public int mroomInvite(int invitedRoleId)
	{
		if (invitedRoleId == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role iRole = gs.getLoginManager().getOnGameRole(invitedRoleId);
		if (iRole == null)
			return GameData.PROTOCOL_OP_MROOM_ROLE_OFFLINE;
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;
			if (this.isNotInMRoomOrMRoomFull())
				return GameData.PROTOCOL_OP_MROOM_ROOM_FULL;
			this.roomInvites.add(invitedRoleId);
		}
		synchronized (iRole)
		{
			int ok = iRole.testCanEnterMRoom(this.room.mapId, this.room.type);
			if (ok <= 0)
				return ok;
		}
		gs.getRPCManager().sendStrPacket(iRole.netsid, new SBean.mroom_invite_forward(this.id, this.name, this.room.mapId, this.room.id, this.room.type));
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	// 玩家被邀请后弹框的选择结果
	public int mroomInvitedby(int inviteStartRoleId, int mapId, int roomId, int roomType, int accept)
	{
		if (inviteStartRoleId == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role sRole = gs.getLoginManager().getOnGameRole(inviteStartRoleId);
		if (sRole == null)
			return GameData.PROTOCOL_OP_MROOM_ROLE_OFFLINE;
		synchronized (this)
		{
			int ok = this.testCanEnterMRoom(mapId, roomType);
			if (ok <= 0)
				return ok;
		}
		synchronized (sRole)
		{
			if (!sRole.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;
			if (!sRole.isInRoomAndRoleBeInvited(this.id))
				return GameData.PROTOCOL_OP_FAILED;
			if (sRole.getMRoomId() != roomId)
				return GameData.PROTOCOL_OP_FAILED;
		}

		if (accept == 0)
		{
			gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.mroom_invite_refuse(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (accept == -1)
		{
			gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.mroom_invite_busy(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}

		Role.MultipleRoles mr = new Role.MultipleRoles(sRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_MROOM_ROLE_OFFLINE;
			return gs.getMapCopyManager().addRoomMember(sRole, this);
		}
		finally
		{
			mr.unlock();
		}
	}

	public int enterMRoom(int mapId, int roomId, int roomType)
	{
		synchronized (this)
		{
			int ok = this.testCanEnterMRoom(mapId, roomType);
			if (ok <= 0)
				return ok;
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;
			if (this.getMRoomId() == roomId)
				return GameData.PROTOCOL_OP_MROOM_ALREADY_IN_ROOM;
		}
		return gs.getMapCopyManager().addRoomMember(roomId, this);
	}

	public int quickEnterMRoom(int mapId)
	{
		synchronized (this)
		{
			int ok = this.testCanEnterMRoom(mapId, GameData.MAP_ROOM_TYPE_DEFAULT);
			if (ok <= 0)
				return ok;
			
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;
		}
		return gs.getMapCopyManager().addMemberToRandomRoom(mapId, this);
	}

	// 房间队长踢人
	public int mroomKick(int kickedRoleId)
	{
		if (kickedRoleId == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		Role kickedRole = gs.getLoginManager().getOnGameRole(kickedRoleId);
		if (kickedRole == null)
			return GameData.PROTOCOL_OP_FAILED;
		synchronized (this)
		{
			if (!this.isMRoomLeader())
				return GameData.PROTOCOL_OP_FAILED;
			if (!this.isRoleInMyMRoom(kickedRoleId))
				return GameData.PROTOCOL_OP_FAILED;
		}
		Role.MultipleRoles mr = new Role.MultipleRoles(this, kickedRole);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_MROOM_ROLE_OFFLINE;
			return gs.getMapCopyManager().kickRoomMember(this, kickedRole) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}

	public int leaveMRoom()
	{
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;
			if (!this.isInMRoom())
				return GameData.PROTOCOL_OP_FAILED;
		}
		return gs.getMapCopyManager().roomMemberLeave(this) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
	}

	public int mroomChangeLeader(int newLeader)
	{
		if (newLeader == this.id || newLeader < 0)
			return GameData.PROTOCOL_OP_FAILED;

		Role newLeaderRole = gs.getLoginManager().getOnGameRole(newLeader);
		if (newLeaderRole == null)
			return GameData.PROTOCOL_OP_MROOM_ROLE_OFFLINE;

		synchronized (this)
		{
			if (!this.isMRoomLeader())
				return GameData.PROTOCOL_OP_FAILED;

			if (!this.isRoleInMyMRoom(newLeader))
				return GameData.PROTOCOL_OP_FAILED;
		}

		Role.MultipleRoles mr = new Role.MultipleRoles(this, newLeaderRole);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_MROOM_ROLE_OFFLINE;
			
			return gs.getMapCopyManager().mroomChangeLeader(this, newLeaderRole) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}
	
	public List<SBean.RoleOverview> queryMRoomRoles()
	{
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap())
				return GameData.emptyList();
		}
		return gs.getMapCopyManager().getRoleRoomRoles(this.id);
	}

	interface CanEnterRoom
	{
		boolean canEnterRoom(Role role, int param1, int param2);
	}

	public boolean canEnterMRoom(int param1, int param2)
	{
		return !this.isInMulRolesActivity();
	}

	public boolean canEnterARoom(int type, int grade)
	{
		return testCanEnterARoom(type, grade) > 0;
	}
	
	public boolean canEnterFRoom(int BWType, int forceWarType)
	{
		if(this.testCanEnterFRoom(forceWarType) <= 0)
			return false;
		
		switch (forceWarType)
		{
		case GameData.FORCEWAR_TYPE_BWTYPE:
			return this.BWType == BWType;
		case GameData.FORCEWAR_TYPE_MESS:
			return true;
		default:
			return false;
		}
	}
	
	public List<SBean.RoleOverview> queryMapNearbyNoMRoomRoles(CanEnterRoom func)
	{
		return queryMapNearbyNoRoomRolesImpl(func, 0, 0);
	}
	
	public List<SBean.RoleOverview> queryMapNearbyNoARoomRoles(CanEnterRoom func, int arenaType)
	{
		int grade = GameData.getInstance().getSuperArenaGrade(arenaType, this.level);
		return queryMapNearbyNoRoomRolesImpl(func, arenaType, grade);
	}
	
	public List<SBean.RoleOverview> queryMapNearbyNoFRoomRoles(CanEnterRoom func, int forceWarType)
	{
		return queryMapNearbyNoRoomRolesImpl(func, this.BWType, forceWarType);
	}
	
	public List<SBean.RoleOverview> queryMapNearbyNoRoomRolesImpl(CanEnterRoom func, int param1, int param2)
	{
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap())
				return GameData.emptyList();
		}
		Collection<Integer> mapRoles = gs.getMapService().getWolrdMapRoles(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurWorldInstanceId());
		List<SBean.RoleOverview> noTeamRoles = new ArrayList<SBean.RoleOverview>();
		for (int rid : mapRoles)
		{
			if (rid != this.id)
			{
				Role role = gs.getLoginManager().getOnGameRole(rid);
				if (role != null)
				{
					synchronized (role)
					{
						if (func.canEnterRoom(role, param1, param2) && role.isOnline())
						{
							noTeamRoles.add(role.getRoleOverviewWithoutLock());
							if(noTeamRoles.size() >= 100)
								break;
						}
					}
				}
			}
		}
		return noTeamRoles;
	}
	
	public List<SBean.TeamOverview> queryRooms(int mapId)
	{
		return gs.getMapCopyManager().getMapRooms(mapId);
	}

	// -----------------------------------帮派 sect-----------------------------------------------------------

	private void dayRefreshSect()
	{
		this.sectData.dayFinishTime = 0;
		this.clearSectData();
		this.clearSectTask();
	}

	public void clearSectData()
	{
		Collections.fill(this.sectData.data.dayWorshipTimes, 0);
		Collections.fill(this.sectData.data.dayBanquetOpenTimes, 0);
		Collections.fill(this.sectData.data.dayBanquetJoinTimes, 0);
		this.sectData.data.daySectMapEnterTimes.clear();
	}
	
	//清空帮派任务
	public void clearSectTask()
	{
		this.clearCurSectTask();
		this.sectData.task.maxSeqId = 0;
		this.sectData.task.lastRefreshTime = 0;
		this.sectData.task.dayRefreshCount = 0;
		this.sectData.task.refreshedTasks.clear();
		this.sectData.task.finishedSelfTasks.clear();
		this.sectData.task.finishedSharedTasks.clear();
	}

	public synchronized void exitFromSect(boolean isbyKick)
	{
		this.updateSectMemberLeaveTime(isbyKick);
		this.updateSectInfo(0, "", -1, (short)0, 0);
		this.updateSectAuras(GameData.emptyMap());
		this.clearSectDeliverData();
		this.clearSectTask();
	}
	
	public int getSectId()
	{
		return this.sectData.data.sectBrief.sectID;
	}

	public String getSectName()
	{
		return this.sectData.data.sectBrief.sectName;
	}

	public synchronized void updateSectInfo(int sectId, String sectName, int position, short sectIcon, int sectLevel)
	{
		this.sectData.data.sectBrief = new SBean.SectBrief(sectId, sectName, (byte)position, sectIcon, sectLevel);
		gs.getMapService().syncRoleUpdateSectBrief(this.id, this.gameMapContext.getCurMapId(), this.sectData.data.sectBrief.kdClone());
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_sectinfo(new SBean.SectBrief(sectId, sectName, (byte)position, sectIcon, sectLevel)));
	}

	public synchronized void updateSectAura(int id, int level)
	{
		this.sectAuras.put(id, level);
		this.updateSectAuraExpCoinRateRaise();
		gs.getMapService().syncRoleUpdateSectAura(this.id, this.gameMapContext.getCurMapId(), id, level);
		this.roleProperties.onUpdateSectAura(id, level);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_aura_update(id, level));
	}

	public synchronized void updateSectAuras(Map<Integer, Integer> auras)
	{
		this.sectAuras = auras;
		this.updateSectAuraExpCoinRateRaise();
		gs.getMapService().syncRoleResetSectAuras(this.id, this.gameMapContext.getCurMapId(), new TreeMap<Integer, Integer>(this.sectAuras));
		this.roleProperties.onUpdateSectAuras(auras);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_sectaura(new TreeMap<Integer, Integer>(this.sectAuras)));
	}

	private void updateSectAuraExpCoinRateRaise()
	{
		this.sectAuraExpCoinRateRaise = 0;
		for (Map.Entry<Integer, Integer> e : this.sectAuras.entrySet())
		{
			SBean.SectSkillCFGS skillCfg = GameData.getInstance().getSectSkillCFGS(e.getKey(), e.getValue());
			if (skillCfg != null)
				this.sectAuraExpCoinRateRaise += skillCfg.expcoinRateRaise;
		}
	}

	public SBean.RoleSectData getRoleSectDataWithoutLock()
	{
		return this.sectData.data.kdClone();
	}

	public List<Integer> getSectWorshipWithoutLock()
	{
		return new ArrayList<Integer>(this.sectData.data.dayWorshipTimes);
	}

	//帮派同步协议
	public void syncSectInfo()
	{
		gs.getSectManager().getRoleSectInfo(this);
	}

	//创建帮派
	public void createNewSect(String name, short sectIcon, int useStone)
	{
		SBean.Counter counter = null;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CREATE_NEW_SECT);
		synchronized (this)
		{
			SBean.CommonSectCFGS sectCFGS = GameData.getInstance().getCommonCFG().sect;
			if (this.level < sectCFGS.createLvl)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_create_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			if (this.getSectId() > 0)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_create_res(GameData.PROTOCOL_OP_SECT_ALREADY_JOIN));
				return;
			}

			if (useStone == 1)
			{
				if (!this.canUseDiamond(sectCFGS.diamond, true))
				{
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_create_res(GameData.PROTOCOL_OP_FAILED));
					return;
				}
				counter = this.lockDiamond(sectCFGS.diamond, true);
			}
			else
			{
				if (!this.canUseCoin(sectCFGS.coin, false))
				{
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_create_res(GameData.PROTOCOL_OP_FAILED));
					return;
				}
				counter = this.lockCoin(sectCFGS.coin, false);
			}
			this.sectData.data.sectBrief.sectID = -1;//相当于数据加锁，防止之前申请的帮派管理员正在做批准操作
		}
		final SBean.Counter lockMoney = counter;
		gs.getSectManager().createNewSect(this, name, sectIcon, new SectManager.CreateNewSectCallback()
		{
			public void onCallback(int sectId)
			{
				synchronized (Role.this)
				{
					if (useStone == 1)
						Role.this.useLockedDiamond(lockMoney, sectId <= 0, tlogEvent.getGameItemRecords());
					else
						Role.this.useLockedCoin(lockMoney, sectId <= 0, tlogEvent.getGameItemRecords());
					if (sectId > 0)
					{
						Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_JOIN_SECT, 0);
						gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_SECT_CREATE, name + "|" + Role.this.name);
						tlogEvent.setArg(useStone, lockMoney.fvalue, lockMoney.rvalue);
						tlogEvent.setArg(name);
						gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
						Role.this.logTasks(GameData.TASK_TYPE_JOIN_FACTION, 0, 0, 0);
					}
					else
					{
						Role.this.sectData.data.sectBrief.sectID = 0;//创建过程执行完恢复
					}
					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_create_res(sectId));
					gs.getTLogger().logRoleJoinSect(Role.this.id, Role.this.getChannel(), Role.this.getGameId(), Role.this.getChannelOpenId(), Role.this.getUid(), Role.this.createTime, Role.this.level, Role.this.share.getVipLevel(), sectId, TLog.JOINSECT_CREATESECT);
				}
			}
		});
	}

	public void getCurSectMembers()
	{
		RpcRes<SBean.SectMembers> res = gs.getSectManager().getRoleSectMembers(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_members_res(res.errCode, res.info));
	}

	public Set<Integer> querySectSelfApplied(List<Integer> sects)
	{
		return gs.getSectManager().roleQuerySectSelfApplied(this, sects);
	}

	public List<SBean.SectOverview> getRecentRects()
	{
		return gs.getSectManager().getRecentRects();
	}

	public void querySects(List<Integer> rects)
	{
		gs.getSectManager().getSectOverviews(rects, overviews -> {
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_query_res(new ArrayList<>(overviews.values())));
		});
	}

	public void searchSect(int sectId)
	{
		gs.getSectManager().getSectOverview(sectId, overview -> {
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_searchbyid_res(overview));
		});
	}

	public void searchSect(String name)
	{
		gs.getSectManager().getSectOverviewByName(name, overview -> {
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_searchbyname_res(overview));
		});
	}

	private synchronized int testCanJoinSect()
	{
		if (this.level < GameData.getInstance().getCommonCFG().sect.joinLvlReq)
			return GameData.PROTOCOL_OP_SECT_ROLE_LEVEL_NEED;
		int index = this.sectData.data.leaveTimes - 1;
		int lastLeaveTime = this.sectData.data.lastLeaveTime;
		List<Integer> exitcd = GameData.getInstance().getCommonCFG().sect.exitPunishTime;
		int cfgTime = index < 0 ? 0 : (index >= exitcd.size() ? exitcd.get(exitcd.size() - 1) : exitcd.get(index));
		int nowTime = GameTime.getTime();
		if (nowTime - lastLeaveTime < cfgTime) //JoinInterval
			return GameData.PROTOCOL_OP_SECT_APPLY_TIME_FAILD;
		if (this.getSectId() > 0)
			return GameData.PROTOCOL_OP_SECT_ALREADY_JOIN;
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	//申请加入帮派
	public int applyJoinSect(int sectId)
	{
		int t = testCanJoinSect();
		if (t != GameData.PROTOCOL_OP_SUCCESS)
			return t;
		int ret = gs.getSectManager().roleApplyJoinSect(this, sectId);
		if (GameData.PROTOCOL_OP_SUCCESS == ret)
		{
		    gs.getTLogger().logRoleJoinSect(id, getChannel(), getGameId(), getChannelOpenId(), getUid(), createTime, level, share.getVipLevel(), sectId, TLog.JOINSECT_SENDAPPLICATION);
		}
		return ret;
	}

	public void notifyApplicationNum(int size)
	{
		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_applications_number(size));
	}

	interface GetSectApplicationsCallback
	{
		void onCallback(int errCode, List<SBean.RoleOverview> applicants);
	}

	public void getSectApplications()
	{
		gs.getSectManager().getRoleSectApplications(this, new GetSectApplicationsCallback()
		{

			@Override
			public void onCallback(int errCode, List<SBean.RoleOverview> applicants)
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_applications_res(errCode, applicants));
			}
		});
	}

	public void getSectHistory()
	{
		RpcRes<List<SBean.DBSectHistory>> res = gs.getSectManager().getRoleSectHistory(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_history_res(res.errCode, res.info));
	}

	public void acceptOrRefuseSectApplication(int applicant, boolean accept)
	{
		if (accept)
		{
			gs.getLoginManager().getRoleOverview(applicant, new LoginManager.GetRoleOverviewCallback()
			{

				@Override
				public void onCallback(SBean.RoleOverview overview)
				{
					if (overview == null)
					{
						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_appliedby_res(GameData.PROTOCOL_OP_FAILED));
						return;
					}
					gs.getSectManager().roleAcceptApplicantJoinSect(Role.this, overview, errCode -> {
						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_appliedby_res(errCode));
					});
				}
			});
			return;
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_appliedby_res(gs.getSectManager().roleRefuseApplicantJoinSect(this, applicant)));
	}

	// 全部拒绝
	public int refuseAllSectApplication()
	{
		return gs.getSectManager().roleRefuseAllApplicantsJoinSect(this);
	}

	private void updateSectMemberLeaveTime(boolean isbyKick)
	{
		sectData.data.leaveTimes += 1;
		sectData.data.lastLeaveTime = GameTime.getTime();
		sectData.data.isByKick = (byte) (isbyKick ? 1 : 0);
	}

	//帮派踢人
	public int kickSectMember(int kickId)
	{
		return gs.getSectManager().roleKickSectMember(this, kickId);
	}
	
	//退出帮派
	public int leaveSect()
	{
		return gs.getSectManager().roleLeaveSect(this);
	}

	//解散帮派
	public void disbandSect()
	{

		gs.getSectManager().dismissSect(this, new SectManager.DismissSectCallback()
		{
			@Override
			public void onCallback(int errCode)
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.sect_disband_res(errCode));
			}
		});
	}

	public int appointSectMember(int memberId, int position)
	{
		return gs.getSectManager().roleAppointSectMemberPositon(this, memberId, position);
	}

	public int updateSectCreed(String creed)
	{
		if (!GameData.getInstance().checkInputStrValid(creed, GameData.getInstance().getCommonCFG().input.maxSectCreedLength, false))
			return GameData.PROTOCOL_OP_SECT_CREED_INVALID;
		return gs.getSectManager().roleUpdateSectCreed(this, creed);
	}

	// 帮派升级
	public int sectUpgrade()
	{
		return gs.getSectManager().roleUpgradeSect(this);
	}

	public int sectAccelerateUpgradeCooling(int accTime)
	{
		return gs.getSectManager().roleAccelerateSectUpgradeCooling(this, accTime);
	}

	public int addsSectAuraExp(int auraId, int itemId, int itemCount)
	{
		return gs.getSectManager().roleAddsSectAuraExp(this, auraId, itemId, itemCount);
	}

	public void syncGetSectAuras()
	{
		RpcRes<List<SBean.DBSectAura>> res = gs.getSectManager().roleGetSectAuras(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_aurasync_res(res.errCode, res.info));
	}

	public int worshipSectMember(int memberId, int type)
	{
		return gs.getSectManager().roleWorshipSectMember(this, memberId, type);
	}

	public void syncWorshipReward()
	{
		RpcRes<SBean.SectWorshipedData> res = gs.getSectManager().roleSyncnWorshipReward(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_syncworshipreward_res(res.errCode, res.info));
	}

	public int takeWorshipReward()
	{
		return gs.getSectManager().roleTakeWorshipReward(this);
	}

	public synchronized int tryWorshipSectMember(int type, int memberLevel)
	{
		if (this.level >= memberLevel)
			return GameData.PROTOCOL_OP_LEVEL_UPPER_THAN_MEMBER;

		SBean.SectWorshipCFGS worshipCFGS = GameData.getInstance().getSectWorshipCFGS(type);
		SBean.VipCFGS vipCFGS = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipCFGS == null || worshipCFGS == null || type <= 0 || type > this.sectData.data.dayWorshipTimes.size())
			return GameData.PROTOCOL_OP_FAILED;

		if (worshipCFGS.vipOpenLimit > this.getUseableVipLvl())
			return GameData.PROTOCOL_OP_FAILED;

		int vipWorshipCount = (type == 1) ? vipCFGS.worship1 : ((type == 2) ? vipCFGS.worship2 : ((type == 3) ? vipCFGS.worship3 : 0));
		int curTypeWorshipTimes = this.sectData.data.dayWorshipTimes.get(type - 1);
		if (curTypeWorshipTimes >= vipWorshipCount)
			return GameData.PROTOCOL_OP_FAILED;

		SBean.SectWorshipExpCFGS worshipExpCFGS = GameData.getInstance().getSectWorshipExpCFGS(this.level);
		if (worshipExpCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (type <= 0 || type > worshipExpCFGS.exps.size() || type > worshipExpCFGS.offers.size())
			return GameData.PROTOCOL_OP_FAILED;

		if (!this.containsEnoughGameItem(worshipCFGS.moneyType, worshipCFGS.moneyValue))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRY_WORSHIP_SECT_MEMBER);
		tlogEvent.setArg(type, memberLevel, worshipCFGS.moneyType, worshipCFGS.moneyValue);
		this.delGameItem(worshipCFGS.moneyType, worshipCFGS.moneyValue, tlogEvent.getGameItemRecords());
		int expAdd = worshipExpCFGS.exps.get(type - 1);
		int contributionAdd = worshipExpCFGS.offers.get(type - 1);
		this.syncAddExp(expAdd, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
		this.sectData.data.dayWorshipTimes.set(type - 1, curTypeWorshipTimes + 1);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return contributionAdd;
	}

	public void testSectBanquetNotice()
	{
		boolean notice = this.sectData.data.dayBanquetJoinTimes.stream().mapToInt((x) -> x).sum() < GameData.getInstance().getCommonCFG().sect.eatTotal;
		if (notice)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_notice_banquet());
	}

	public int openSectBanquet(int type)
	{
		return gs.getSectManager().roleOpenSectBanquet(this, type);
	}

	public synchronized boolean tryOpenSectBanquet(SBean.SectBanquetCFGS banquetCFGS)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRY_OPEN_SECT_BANQUET);
		this.tryDayRefresh(GameTime.getTime());// 此处为保证帮派数据和成员数据同时刷新，在此处也测试一下每日刷新
		int daySecond = GameTime.getSecondOfDay();
		if (daySecond < GameData.getInstance().getCommonCFG().sect.banOpenTime || daySecond > GameData.getInstance().getCommonCFG().sect.banEndTime)
			return false;
		if (banquetCFGS.type <= 0 || banquetCFGS.type > this.sectData.data.dayBanquetOpenTimes.size())
			return false;
		int curCount = this.sectData.data.dayBanquetOpenTimes.get(banquetCFGS.type - 1);
		if (curCount >= banquetCFGS.openCount)
			return false;
		if (!this.containsEnoughGameItem(banquetCFGS.moneyType, banquetCFGS.moneyValue))
			return false;

		tlogEvent.setArg(banquetCFGS.moneyType, banquetCFGS.moneyValue, banquetCFGS.createSect);
		this.delGameItem(banquetCFGS.moneyType, banquetCFGS.moneyValue, tlogEvent.getGameItemRecords());
		this.sectData.data.dayBanquetOpenTimes.set(banquetCFGS.type - 1, curCount + 1);
		this.sectData.data.historyBanquetOpenTimes += 1;
		
		this.syncAddSectContribution(banquetCFGS.createSect, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized int tryJoinSectBanquet(SBean.SectBanquetCFGS banquetCFGS)
	{
		this.tryDayRefresh(GameTime.getTime());// 此处为保证帮派数据和成员数据同时刷新，在此处也测试一下每日刷新
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRY_JOIN_SECT_BANQUET);
		if (banquetCFGS.type <= 0 || banquetCFGS.type > this.sectData.data.dayBanquetJoinTimes.size())
			return GameData.PROTOCOL_OP_SECT_BANQUET_TYPEERROR;

		// 每个人只能吃的总数
		int totalCount = 0;
		for (int times : this.sectData.data.dayBanquetJoinTimes)
		{
			totalCount += times;
		}
		if (totalCount >= GameData.getInstance().getCommonCFG().sect.eatTotal)
			return GameData.PROTOCOL_OP_SECT_BANQUET_ROLECOUNT;

		int joinTimes = this.sectData.data.dayBanquetJoinTimes.get(banquetCFGS.type - 1);
		this.sectData.data.dayBanquetJoinTimes.set(banquetCFGS.type - 1, joinTimes + 1);
		int maxrate = 0;
		for (int rate : banquetCFGS.rate)
		{
			maxrate += rate;
		}
		int randint = GameRandom.getRandInt(0, maxrate);
		int defaultPercent = 10000;
		int percentIndex = 1;
		for (int i = 0; i < banquetCFGS.rate.size(); i++)
		{
			int rate = banquetCFGS.rate.get(i);
			if (randint <= rate)
			{
				defaultPercent = banquetCFGS.percent.get(i);
				percentIndex = i + 1;
				break;
			}
			randint -= rate;
		}

		tlogEvent.setArg(banquetCFGS.joinVit * defaultPercent / 10000);
		this.syncAddVit(banquetCFGS.joinVit * defaultPercent / 10000, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return percentIndex;
	}

	public void getSyncBanquets()
	{
		RpcRes<List<SBean.SectBanquet>> res = gs.getSectManager().roleGetBanquets(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_listbanquet_res(res.errCode, res.info));
	}

	public int joinSectBanquet(int bId)
	{
		return gs.getSectManager().roleJoinSectBanquet(this, bId);
	}

	// 商店，帮派商城
	public synchronized void syncSectShopInfo()
	{
		if (getSectId() <= 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_shopsync_res(null, this.sectData.data.contribution));
			return;
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_shopsync_res(this.syncShopInfo(GameData.SHOP_TYPE_SECT), this.sectData.data.contribution));
	}

	public SBean.ShopInfo userRefreshSectShop(int times, int isSecondType)
	{
		if (getSectId() <= 0)
			return null;
		return this.userRefreshShop(GameData.SHOP_TYPE_SECT, times, isSecondType);
	}

	public boolean buySectShopGoogs(int seq)
	{
		return this.buyShopGoogs(GameData.SHOP_TYPE_SECT, seq);
	}

	public void querySectMapsStatus()
	{
		RpcRes<Map<Integer, Integer>> ret = gs.getSectManager().roleQuerySectMapsStatus(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sectmap_status_res(ret.errCode, ret.info));
	}

	public void querySectMap(int mapId)
	{
		RpcRes<SBean.SectMapStatus> ret = gs.getSectManager().roleQuerySectMap(this, mapId);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sectmap_query_res(ret.errCode, ret.info));
	}

	public int openSectMap(int mapId)
	{
		return gs.getSectManager().roleOpenSectMap(this, mapId);
	}

	public int openSectGroupMap(int mapId)
	{
		return gs.getSectManager().roleOpenSectGroupMap(this, mapId);
	}

	public int startSectMapCopy(int mapId)
	{
		return gs.getSectManager().roleStartSectMap(this, mapId);
	}

	public int startSectGroupMapCopy(int mapId)
	{
		return gs.getSectManager().roleStartSectGroupMap(this, mapId);
	}

	public int applySectMapRewards(int mapId, int rewardId)
	{
		return gs.getSectManager().roleApplySectMapRewards(this, mapId, rewardId);
	}

	public void getSectMapAllocation(int mapId)
	{
		RpcRes<SBean.SectMapAllocation> res = gs.getSectManager().roleGetSectMapAllocation(this, mapId);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sectmap_allocation_res(res.errCode, res.info));
	}

	public void getSectMapDamage(int mapId)
	{
		RpcRes<SBean.SectMapDamage> res = gs.getSectManager().roleGetSectMapDamage(this, mapId);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sectmap_damage_res(res.errCode, res.info));
	}

	public void getSectMapDetail(int mapId)
	{
		RpcRes<SBean.SectMapInfo> res = gs.getSectManager().roleGetSectMapDetail(this, mapId);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sectmap_sync_res(res.errCode, res.info));
	}

	public void getSectMapRewardsLog()
	{
		RpcRes<List<SBean.SectMapRewardsLog>> res = gs.getSectManager().roleGetSectMapRewardsLog(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sectmap_rewards_res(res.errCode, res.info));
	}
	
	//帮派任务
	public void notifySectSharedTaskReward()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_notice_sharedtaskreward());
	}

	private void clearCurSectTask()
	{
		SBean.SectTaskCFGS sectTaskCFGS = GameData.getInstance().getSectTaskCFG(this.sectData.task.curTask.task.taskId);
		if(sectTaskCFGS != null)
			this.delTaskDrop(sectTaskCFGS.cond);
		
		this.sectData.task.curTask.task.sid = 0;
		this.sectData.task.curTask.task.taskId = 0;
		this.sectData.task.curTask.value = 0;
		this.sectData.task.curTask.ownerId = 0;
		this.sectData.task.curTask.ownerName = "";
		this.sectData.task.curTask.receiveTime = 0;
	}

	private void doRefreshSectTasksLib()
	{
		SBean.CommonSectCFGS sectCFGS = GameData.getInstance().getCommonCFG().sect;
		int taskCount = (getUseableVipLvl() >= sectCFGS.taskVipMax) ? sectCFGS.taskLibDefaultCount + sectCFGS.taskLibAddCount : sectCFGS.taskLibDefaultCount;
		this.sectData.task.refreshedTasks = GameData.getInstance().getRandomSectTasks(this.sectData.task.maxSeqId, taskCount);
		this.sectData.task.maxSeqId += taskCount;
		this.sectData.task.lastRefreshTime = GameTime.getTime();
	}

	public void tryRefreshSectTasksLib()
	{
		int lastRefreshTime = GameData.getInstance().getSectTaskLastRefreshTime();
		if (lastRefreshTime > this.sectData.task.lastRefreshTime)
		{
			doRefreshSectTasksLib();
		}
	}

	public SBean.SectSelfTaskInfo syncSectSelfTask()
	{
		return gs.getSectManager().roleSyncSectSelfTask(this);
	}

	public synchronized SBean.SectSelfTaskInfo syncSectSelfTaskImpl()
	{
		this.tryRefreshSectTasksLib();
		List<SBean.SectTask> sectTasks = new ArrayList<SBean.SectTask>(sectData.task.refreshedTasks.values());
		return new SBean.SectSelfTaskInfo(this.sectData.task.dayRefreshCount, this.sectData.dayFinishTime, sectTasks);
	}

	//
	public boolean syncSectSharedTask()
	{
		return gs.getSectManager().roleSyncSectSharedTask(this);
	}

	//
	public SBean.SectFinishedTaskRes syncSectFinishedSelfTask()
	{
		List<Integer> shared = new ArrayList<Integer>();
		//完成共享任务存在role
		synchronized (this)
		{
			for (SBean.SectFinishedSelfTask finishedSelfTask : this.sectData.task.finishedSelfTasks.values())
			{
				shared.add(finishedSelfTask.task.sid);
			}
		}

		return gs.getSectManager().roleSyncSectFinishedSelfTask(this, shared); //
	}

	//获取完成的帮派任务
	public synchronized SBean.SectFinishedTaskRes getFinishedSectSelfTasks(Map<Integer, Integer> shareTaskRemainCount)
	{
		this.tryRefreshSectTasksLib();
		List<SBean.SectFinishedSelfTask> lst = new ArrayList<SBean.SectFinishedSelfTask>(this.sectData.task.finishedSelfTasks.values());
		Map<Integer, Integer> shares = new TreeMap<Integer, Integer>(shareTaskRemainCount);
		return new SBean.SectFinishedTaskRes(lst, shares);
	}

	//同步完成的帮派任务
	public synchronized List<SBean.SectFinishedSelfTask> sectTaskFinishSync()
	{
		List<SBean.SectFinishedSelfTask> result = new ArrayList<SBean.SectFinishedSelfTask>();
		result.addAll(this.sectData.task.finishedSelfTasks.values());
		return result;
	}

	public void testSectTaskNotice()
	{
		boolean notice = this.sectData.dayFinishTime < GameData.getInstance().getCommonCFG().sect.dayFinishTask;
		if (notice)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_notice_tasks());
	}

	public int sectTaskReceive(int ownerId, int sid)
	{
		return gs.getSectManager().sectTaskReceive(this, ownerId, sid);
	}

	public synchronized int sectTaskReceiveCB(int ownerId, int sid, int taskId, String name)
	{
		SBean.SectReceivedTask sectTask = this.sectData.task.curTask;
		if (sectTask.ownerId > 0)
			return 0;
		int size = GameData.getInstance().getCommonCFG().sect.dayFinishTask;
		if (this.sectData.dayFinishTime >= size)
			return 0;
		int newTaskId = taskId;
		if (ownerId == this.id)
		{
			if (!this.sectData.task.refreshedTasks.containsKey(sid))
				return 0;
			SBean.SectTask st = this.sectData.task.refreshedTasks.get(sid);
			if (st == null)
				return 0;
			newTaskId = st.taskId;
		}
		else
		{
			// 上次取消任务的时间是否超过2个小时
			if (GameTime.getTime() - this.sectData.task.stCancelTime < GameData.getInstance().getCommonCFG().sect.taskCancelPunishTime)
				return 0;

			// 检查共享任务是否完成过， 每个共享任务只能完成一次
			SBean.SectFinishedSharedTask sharedTasks = this.sectData.task.finishedSharedTasks.get(ownerId);
			if (sharedTasks != null && sharedTasks.tasks.contains(sid))
				return 0;
		}

		SBean.SectTaskCFGS sectTaskCFGS = GameData.getInstance().getSectTaskCFG(newTaskId);
		if (sectTaskCFGS == null)
			return 0;
		
		this.sectData.task.curTask.ownerId = ownerId;
		this.sectData.task.curTask.task.sid = sid;
		this.sectData.task.curTask.task.taskId = newTaskId;
		this.sectData.task.curTask.ownerName = name;
		this.sectData.task.curTask.receiveTime = GameTime.getTime();
		this.addTaskDrop(sectTaskCFGS.cond);
		
		gs.getTLogger().logSectTaskFlow(this, sid, newTaskId, TLog.TASKEVENT_TAKE);

		return this.sectData.task.curTask.receiveTime;
	}

	//放弃完成的帮派任务
	public int sectTaskCancel(int ownerId, int sid)
	{
		return gs.getSectManager().sectTaskCancel(this, ownerId, sid);
	}

	public synchronized int sectTaskCancelCB(int ownerId, int sid)
	{
		SBean.SectReceivedTask sectTask = this.sectData.task.curTask;
		if (sectTask.ownerId == 0)
			return 0;
		if (sectTask.ownerId != ownerId || sectTask.task.sid != sid)
			return 0;

		this.clearCurSectTask();
		// 自己做的任务放弃时候没有惩罚时间
		if(ownerId == this.id)
		{
			return GameTime.getTime();
		}
		this.sectData.task.stCancelTime = GameTime.getTime();
		
		gs.getTLogger().logSectTaskFlow(this, sid, sectTask.task.taskId, TLog.TASKEVENT_CANCLE);
		
		return sectData.task.stCancelTime;
	}
	
	//完成帮派任务
	public boolean sectTaskFinish(int ownerId, int sid)
	{
		return gs.getSectManager().sectTaskFinish(this, ownerId, sid);
	}

	public synchronized int sectTaskFinishCB(int ownerId, int sid)
	{
		SBean.SectReceivedTask sectTask = this.sectData.task.curTask;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_TASK_FINISH_CB);
		if (sectTask == null)
			return 0;
		SBean.SectTaskCFGS sectTaskCFGS = GameData.getInstance().getSectTaskCFG(sectTask.task.taskId);
		if (sectTaskCFGS == null)
			return 0;
		if (!isTaskFinished(sectTaskCFGS.cond, sectTask.value))
			return 0;

		if (!this.canAddGameItems(sectTaskCFGS.taskRewards))
			return 0;
		if (ownerId == this.id)
		{ // 自己任务
			this.sectData.task.finishedSelfTasks.put(sectTask.task.sid, new SBean.SectFinishedSelfTask(sectTask.task.kdClone(), 0));
			this.sectData.task.refreshedTasks.remove(sid);
		}
		else
		{
			SBean.SectFinishedSharedTask finishedSharedTask = this.sectData.task.finishedSharedTasks.get(ownerId);
			if (finishedSharedTask == null)
			{
				finishedSharedTask = new SBean.SectFinishedSharedTask();
				finishedSharedTask.roleId = ownerId;
				this.sectData.task.finishedSharedTasks.put(ownerId, finishedSharedTask);
				finishedSharedTask.tasks = new TreeSet<Integer>();
			}
			finishedSharedTask.tasks.add(sectTask.task.sid);
		}

		this.clearCurSectTask();
		this.delTaskDrop(sectTaskCFGS.cond);
		//gs.getTLogger().logFinishSectTask(this, sid);
		gs.getTLogger().logSectTaskFlow(this, sid, sectData.task.curTask.task.taskId, TLog.TASKEVENT_FINISH);

		tlogEvent.setArg(ownerId, sid);
		this.syncAddGameItems(GameData.getInstance().toGameItems(sectTaskCFGS.taskRewards), tlogEvent);
		int exp = (int) (sectTaskCFGS.rewardExpFactor * GameData.getInstance().getSectTaskLevelBaseExp(this.level));
		this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_SECT_TASK, 0);
		this.syncAddSectContribution((int) (sectTaskCFGS.rewardCon * GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).sectTaskRewardRate), tlogEvent.getGameItemRecords());
		this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_ANY_SECT_TASK, 1);
		logTaskScheduleData(GameData.SCHEDULE_TYPE_FINISH_ANY_SECT_TASK);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		return sectTaskCFGS.rewardCon;
	}

	public List<SBean.SectTask> sectTaskReset()
	{
		return gs.getSectManager().sectTaskReset(this);
	}

	public synchronized List<SBean.SectTask> sectTaskResetCB()
	{
		SBean.CommonCFGS commonCFGS = GameData.getInstance().getCommonCFG();
		if (commonCFGS.sect == null || this.sectData.task.dayRefreshCount + 1 > GameData.DIAMOND_REFRESH_MAX_TIMES)
			return null;
		int diamond = GameData.getTimesCost(commonCFGS.sect.sectTaskDiamond, this.sectData.task.dayRefreshCount + 1);
		if (!this.canUseDiamond(diamond, false))
			return null;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_TASK_RESET_CB);
		tlogEvent.setArg(diamond);
		this.useDiamond(diamond, false, tlogEvent.getGameItemRecords());
		this.doRefreshSectTasksLib();
		this.sectData.task.dayRefreshCount++;
		List<SBean.SectTask> resultTasks = new ArrayList<SBean.SectTask>();
		resultTasks.addAll(this.sectData.task.refreshedTasks.values());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return resultTasks;
	}

	public boolean sectTaskIssuanceShare(int sId)
	{
		SBean.SectFinishedSelfTask finishedSelfTask = null;
		synchronized (this)
		{
			finishedSelfTask = this.sectData.task.finishedSelfTasks.get(sId);
			if (finishedSelfTask == null)
				return false;
			if (finishedSelfTask.shared == 1)
				return false;
		}
		return gs.getSectManager().sectTaskIssuanceShare(this, sId, finishedSelfTask.task.taskId);
	}

	public synchronized boolean sectTaskIssuanceShareCB(int sId)
	{
		SBean.SectFinishedSelfTask finishedSelfTask = this.sectData.task.finishedSelfTasks.get(sId);
		if (finishedSelfTask == null)
			return false;
		if (finishedSelfTask.shared == 1)
			return false;

		finishedSelfTask.shared = 1;
		return true;
	}

	public SBean.SectTaskReward sectTaskShareDoneRewards()
	{
		return gs.getSectManager().sectTaskShareDoneRewards(this);
	}

	public synchronized SBean.SectTaskReward sectTaskShareDoneRewardsCB(Map<Integer, Integer> rewardTasks)
	{
		int totalExp = 0;
		int totalContribution = 0;
		Map<Integer, SBean.DummyGoods> items = new TreeMap<Integer, SBean.DummyGoods>();
		for (Map.Entry<Integer, Integer> entry : rewardTasks.entrySet())
		{
			SBean.SectTaskCFGS sectTaskCFGS = GameData.getInstance().getSectTaskCFG(entry.getKey());
			if (sectTaskCFGS == null)
				return null;

			//totalExp += sectTaskCFGS.sharedRewardExp;
			totalExp = (int) (sectTaskCFGS.sharedRewardExpFactor * GameData.getInstance().getSectTaskLevelBaseExp(this.level));

			totalContribution += sectTaskCFGS.sharedRewardCon;
			for (SBean.DummyGoods item : sectTaskCFGS.shareRewards)
			{
				items.merge(item.id, item, (ov, nv) -> new SBean.DummyGoods(item.id, ov.count + nv.count));
			}
		}
		if (!this.canAddGameItems(items.values()))
			return null;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_TASK_TAKE_SHARE_REWARDS);
		tlogEvent.setArg(totalExp, totalContribution);
		this.syncAddGameItems(GameData.getInstance().toGameItems(items.values()), tlogEvent);
		this.syncAddExp(totalExp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_SECT_TASK, 0);
		this.syncAddSectContribution(totalContribution, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return new SBean.SectTaskReward(totalExp, totalContribution, new ArrayList<SBean.DummyGoods>(items.values()), new TreeMap<Integer, Integer>());
	}

	public void changeSectName(String name)
	{
		gs.getSectManager().changeSectName(this, name, (errCode) -> {
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_changename_res(errCode));
		});
	}


	public int changeJoinSectLevel(int level)
	{
		if (level <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		return gs.getSectManager().changeJoinSectLevel(this, level);
	}

	public int changeSectIconAndFrame(short icon, short frame)
	{
		if (icon <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		return gs.getSectManager().changeSectIconAndFrame(this, icon, frame);
	}

	//帮派邮件
	public int sectSendMail(String content)
	{
		if (!GameData.getInstance().checkInputStrValid(content, GameData.getInstance().getCommonCFG().sectMail.maxContentLength, false))
			return GameData.PROTOCOL_OP_SECT_MAIL_CONTENT_INVALID;

		return gs.getSectManager().sendMail(this, content)  ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
	}

	public synchronized boolean sectSendMailCB()
	{
		if (!this.canUseDiamond(GameData.getInstance().getCommonCFG().sectMail.noFreeUseMoney, false))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_SEND_MAIL_CB);
		tlogEvent.setArg(GameData.getInstance().getCommonCFG().sectMail.noFreeUseMoney);
		this.useDiamond(GameData.getInstance().getCommonCFG().sectMail.noFreeUseMoney, false, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	// ------------------------------Escort Car--------------------------------------
	synchronized void syncCarLocation(int mapID, int mapInstance, SBean.Location location)
	{
		this.escortCar.onSyncLocation(mapID, mapInstance, location);
	}
	
	synchronized void syncCarHP(int mapID, int mapInstance, int curHP)
	{
		this.escortCar.onSyncCurHP(curHP);
	}
	
	synchronized void updateCarDamageRole(int mapID, int mapInstance, int damageRole, int damage)
	{
		this.escortCar.onUpdateDamageRole(mapID, mapInstance, damageRole, damage);
	}
	
	synchronized void syncRoleRobSuccess(int carID)
	{
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		SBean.SectDeliverVehicle car = GameData.getInstance().getSectDeliverVehicleCfgs(carID);
		if (cfg == null || car == null || this.isRob != -GameData.SECT_IS_ROB || this.sectDeliver.dayRobTime >= cfg.robTimes)
			return;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ROB_SUCCESS);
		tlogEvent.setArg(cfg.rewardForQuality.get(car.quality - 1));
		this.syncAddRobMoney(cfg.rewardForQuality.get(car.quality - 1), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		this.isRob = GameData.SECT_IS_NOT_ROB;
		this.sectDeliver.dayRobTime ++;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_rob_finish(cfg.rewardForQuality.get(car.quality - 1)));

		gs.getTLogger().logRoleSectDeliverFlow(this, TLog.SECT_ROB, TLog.SECT_ACT_FINISH, 0);
		gs.getTLogger().logSectRobTask(this, getSectId(), carID, 2, TLog.TASKEVENT_FINISH);
		
		return;
	}
	
	synchronized void updateRoleCarRobber()
	{
		if(this.isRob == GameData.SECT_IS_NOT_ROB)
			return;
		
		this.isRob = -GameData.SECT_IS_ROB;
	}
	
	class RoleEscortCar
	{
		private int mapID;
		private int mapInstance; 
		private SBean.Location location;
		private Map<Integer, Integer> damageRoles;
		private int configID;
		private int curHP;
		private int maxHP;
		private int brokenTimes;
		private int teamCarCnt;
		
		private int ownerID;
		private String ownerName = "";
		private boolean onMapServer;
		
		RoleEscortCar()
		{
			this.location = new SBean.Location(new SBean.Vector3(), new SBean.Vector3F());
			this.damageRoles = new HashMap<>();
		}
		
		RoleEscortCar fromDB(SBean.DBEscortCar carInfo, int ownerID, String ownerName)
		{
			this.mapID = carInfo.mapID;
			this.mapInstance = carInfo.mapInstance;
			this.location = carInfo.location;
			this.damageRoles = carInfo.damageRoles;
			this.configID = carInfo.configID;
			this.curHP = carInfo.curHP;
			this.maxHP = carInfo.maxHP;
			this.brokenTimes = carInfo.brokenTimes;
			
			if(this.mapID > 0)
			{
				this.ownerID = ownerID;
				this.ownerName = ownerName;
			}
		
			return this;
		}
		
		synchronized SBean.DBEscortCar getCarInfo()
		{
			return new SBean.DBEscortCar(mapID, mapInstance, location, damageRoles, configID, curHP, maxHP, brokenTimes);
		}
		
		synchronized void onSyncCurHP(int curHP)
		{
			if(this.ownerID == 0)
				return;
			
			if (this.curHP > 0 && curHP <= this.maxHP * (GameData.getInstance().getSectDeliverCfgs().robSuccessHP / 10000.f))
				addBrokenTimes();
			
			if(curHP > this.maxHP)
				curHP = this.maxHP;
			
			this.curHP = curHP;
		}
		
		void addBrokenTimes()
		{
			Role.this.sectDeliver.beRobbedTimes = ++this.brokenTimes;
			if (Role.this.sectDeliver.beRobbedTimes > 3)
				Role.this.sectDeliver.beRobbedTimes = 3;
		}

		synchronized SBean.MapLocation getCarMapLocation()
		{
			return new SBean.MapLocation(this.mapID, this.location);
		}
		
		synchronized int getCurMapLine()
		{
			return this.mapInstance;
		}
		
		synchronized void onSyncLocation(int mapID, int mapInstance, SBean.Location location)
		{
			if(this.ownerID == 0)
				return;
			
			if (this.mapID == mapID && this.mapInstance == mapInstance)
			{
				this.location = location;
			}
		}
		
		synchronized void onUpdateDamageRole(int mapID, int mapInstance, int roleID, int damage)
		{
			if(this.ownerID == 0)
				return;
			
			if (this.mapID == mapID && this.mapInstance == mapInstance)
				this.damageRoles.compute(roleID, (k,v) -> v == null ? damage : v + damage);
		}
		
		int getCarID()
		{
			return this.configID;
		}
		
		synchronized void createNewCar(int mapID, int mapInstance, int ownerID, String ownerName, int configID, int maxHP, SBean.Location location, int teamCarCnt)
		{
			if(this.ownerID > 0)
				return;
			
			this.mapID = mapID;
			this.mapInstance = mapInstance;
			this.configID = configID;
			this.curHP = maxHP;
			this.maxHP = maxHP;
			this.location = location;
			this.teamCarCnt = teamCarCnt;
			this.brokenTimes = 0;
			
			this.ownerID = ownerID;
			this.ownerName = ownerName;
			this.enterMap();
		}
		
		synchronized void destoryCar()
		{
			leaveMap();
			this.mapID = 0;
			this.mapInstance = -1;
			this.configID = 0;
			this.curHP = 0;
			this.maxHP = 0;
			this.brokenTimes = 0;
			this.teamCarCnt = 0;
			this.damageRoles.clear();
			
			this.ownerID = 0;
			this.ownerName = "";
		}
		
		synchronized boolean changeMap(int mapID, int mapInstance, SBean.Location location)
		{
			if(this.mapID == mapID)
				return false;
			
			this.leaveMap();
			this.mapID = mapID;
			this.mapInstance = mapInstance;
			this.location = location;
			this.enterMap();
			return true;
		}
		
		synchronized boolean checkCarChangeLine(int ownerMapID, int ownerMapInstance, SBean.Vector3 ownerPos)
		{
			if(this.ownerID == 0)
				return false;
			
			if(this.mapID != ownerMapID || this.mapInstance != ownerMapInstance)
				return false;
			
			if(new GVector3(ownerPos).distance(new GVector3(this.location.position)) > GameData.getInstance().getSectDeliverCfgs().stopDistance + 500)
				return false;
			
			return true;
		}
		
		synchronized void changeLine(int mapInstance)
		{
			if(this.ownerID == 0)
				return;
			
			this.leaveMap();
			this.mapInstance = mapInstance;
			this.enterMap();
		}
		
		void enterMap()
		{
			if(!onMapServer)
			{
				gs.getMapService().syncCarEnterMap(this.getCarInfo(), this.ownerID, this.ownerName, this.teamCarCnt, Role.this.team, Role.this.getSectId());
				onMapServer = true;
			}
		}
		
		void leaveMap()
		{
			if(onMapServer)
			{
				gs.getMapService().syncCarLeaveMap(this.ownerID, this.mapID, this.mapInstance);
				onMapServer = false;
			}
		}
		
		void updateTeamCarCnt(int teamCarCnt)
		{
			if(this.teamCarCnt == teamCarCnt)
				return;
			
			this.teamCarCnt = teamCarCnt;
			gs.getMapService().syncCarUpdateTeamCarCnt(this.ownerID, this.mapID, this.teamCarCnt);
		}
	}
	
	// ------------------------------自创武功--------------------------------------

	public void tryRefreshDiySkil(int now) // minute task
	{
		SBean.DIYSkillUniqueCFGS skillUniqueCFGS = GameData.getInstance().getDIYSkillUniqueCFGS();
		if (skillUniqueCFGS == null)
			return ;
		if (this.diySkillData.borrowTime > 0 && this.diySkillData.borrowTime + skillUniqueCFGS.shareSkillStandTime * 3600 < now)
		{
			this.diySkillData.borrowDiySkill = null;
			this.diySkillData.borrowTime = 0;
			if(this.diySkillData.curSkillId == 0)
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_diyskill(this.getCurDIYSkill(), this.getDiyskillSurplusCount()));
		}
	}

	private void dayRefreshDiySkill()
	{
		this.diySkillData.dayUnlockCount = 0;
		this.diySkillData.dayBuyCount = 0;
		this.diySkillData.dayCreateCount = 0;
	}

	private void initNewRoleDiySkillData()
	{
		int availableSlotCount = GameData.getInstance().getDiySkillSlotTotal() - GameData.getInstance().getDiySkillTotalUnlockSlot();
		availableSlotCount = availableSlotCount > 0 ? availableSlotCount : 0;
		this.diySkillData = new SBean.DBRoleDiySkillData(1, 0, availableSlotCount, 0, 0, 0, 0, 0, new ArrayList<SBean.DBDiySkill>(), null, null, 0);
	}

	public void diySkillSync()
	{
//		gs.getClanService().clanDiySkillGetShare(this.id, clanId, new ClanService.ClanDiySkillGetShareCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.DBDiySkillShare> diySkillShare)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_sync_res(new SBean.DBShareDiySkillData(Role.this.diySkillData, diySkillShare)));
//				}
//				else
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_sync_res(null));
//				}
//			}
//		});
		List<SBean.DBDiySkillShare> skills = gs.getSectManager().sectDiySkillGetShare(this);
		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_sync_res(new SBean.DBShareDiySkillData(this.diySkillData, skills)));
	}

	public int getDiyskillSurplusCount()
	{
		SBean.DIYSkillBaseCFGS diyBaseCFGS = GameData.getInstance().getDIYSkillBaseCFGS(this.diySkillData.level);
		SBean.VipCFGS vipCfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (diyBaseCFGS == null || vipCfg == null)
			return 0;
		return (diyBaseCFGS.dayUseTimes + this.diySkillData.dayBuyCount + vipCfg.diyDayAddCount) - this.diySkillData.dayCreateCount;
	}

	public synchronized SBean.DBDIYSkillData diySkillCreateNew(Map<Integer, Integer> params, Set<Integer> trends)
	{
		SBean.DIYSkillBaseCFGS diyBaseCFGS = GameData.getInstance().getDIYSkillBaseCFGS(this.diySkillData.level);
		SBean.VipCFGS vipCfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (diyBaseCFGS == null || vipCfg == null)
			return null;
		if (this.diySkillData.dayCreateCount >= diyBaseCFGS.dayUseTimes + this.diySkillData.dayBuyCount + vipCfg.diyDayAddCount)
			return null;
		if (diyBaseCFGS.haseChase == 0)
		{
			if (params.size() != 5)
				return null;
		}
		else
		{
			if (params.size() != 6 /*
									 * || diyBaseCFGS.chaseCount !=
									 * trends.size()
									 */)
				return null;
			for (int id : trends)
			{
				if (id != GameData.DIY_SKILL_BREAK && id != GameData.DIY_SKILL_CONTROL && id != GameData.DIY_SKILL_UNREAL)
					return null;
			}
		}
		int wdpointTotal = 0;
		boolean isPutAllPoint = true;
		for (Map.Entry<Integer, Integer> entry : params.entrySet())
		{
			int id = entry.getKey();
			int num = entry.getValue();
			Integer maxNum = diyBaseCFGS.investLimits.get(id);
			if (maxNum == null || num > maxNum)
				return null;
			wdpointTotal += num;
		}
		if (wdpointTotal > diyBaseCFGS.totalSavvy)
			return null;
		if (wdpointTotal != diyBaseCFGS.totalSavvy )
			isPutAllPoint = false;

		int gradeId = GameData.getInstance().getDiySkillGradeId( this.diySkillData.level, isPutAllPoint );
		SBean.DBDIYSkillData newDiySkill = GameData.getInstance().createDIYSkill(this.classType, params, this.diySkillData.level, gradeId);
		if (newDiySkill == null)
			return null;

		SBean.DIYSkillGradeCFGS skillGradeCFGS = GameData.getInstance().getDIYSkillGradeCFGS(gradeId);
		SBean.DIYSkillBaseCFGS nextDiyBaseCFGS = GameData.getInstance().getDIYSkillBaseCFGS(this.diySkillData.level + 1);
		if (skillGradeCFGS != null && nextDiyBaseCFGS != null)
		{
			this.diySkillData.exp += skillGradeCFGS.addProficiency;
			if (this.diySkillData.exp >= nextDiyBaseCFGS.needProficiency)
			{
				this.diySkillData.level += 1;
				this.diySkillData.exp -= nextDiyBaseCFGS.needProficiency;
			}
		}
		this.diySkillData.tmpDiySkill = newDiySkill;
		this.diySkillData.dayCreateCount += 1;
		this.diySkillData.historyCreateCount += 1;
		gs.getTLogger().logRoleSectDiySkillFlow(this, TLog.SECT_DIY_SKILL_CREATE);
		this.logTaskScheduleData(GameData.SCHEDULE_TYPE_DIYSKILL);
		return this.diySkillData.tmpDiySkill;
	}

	public synchronized boolean diySkillSave(String name, int iconId)
	{
		if (!GameData.getInstance().checkInputStrValid(name, GameData.getInstance().getCommonCFG().input.maxDiySkillNameLength, true) || this.diySkillData.tmpDiySkill == null)
			return false;

		SBean.DIYSkillUniqueCFGS skillUniqueCFGS = GameData.getInstance().getDIYSkillUniqueCFGS();
		if (skillUniqueCFGS == null || !skillUniqueCFGS.icons.contains(iconId))
			return false;

		int id = this.diySkillData.diySkills.size() + 1;
		SBean.DBDiySkill diySkill = new SBean.DBDiySkill(id, name, iconId, this.diySkillData.tmpDiySkill.kdClone());
		this.diySkillData.diySkills.add(diySkill);
		this.diySkillData.tmpDiySkill = null;
		gs.getTLogger().logRoleSectDiySkillFlow(this, TLog.SECT_DIY_SKILL_SAVE);
		return true;
	}

	//自创武功遗忘
	public void diySkillDiscard(int skillPos)
	{
		if (skillPos == 0)
		{
			this.diySkillData.tmpDiySkill = null;
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_discard_res(GameData.PROTOCOL_OP_SUCCESS));
			return;
		}
		if (skillPos > this.diySkillData.diySkills.size())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_discard_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		SBean.DBDiySkill diySkill = this.diySkillData.diySkills.get(skillPos - 1);
		if (diySkill == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_discard_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}

//		gs.getClanService().clanCancelShareDiySkill(this.id, diySkill.id, new ClanService.ClanCancelShareDiySkillCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				//TODO 加锁
//				if (skillPos == Role.this.diySkillData.curSkillId)
//					Role.this.diySkillData.curSkillId = 0;
//				Role.this.diySkillData.diySkills.remove(skillPos - 1);
//				//when remove an element, reset the id
//				int lastCurSkillId = Role.this.diySkillData.curSkillId;
//				if (lastCurSkillId != 0)
//					Role.this.diySkillData.curSkillId = skillPos < lastCurSkillId ? lastCurSkillId - 1 : lastCurSkillId;
//				for (int i = 0; i < Role.this.diySkillData.diySkills.size(); ++i)
//				{
//					SBean.DBDiySkill t = Role.this.diySkillData.diySkills.get(i);
//					t.id = i + 1;
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_discard_res(GameData.PROTOCOL_OP_SUCCESS));
//			}
//		});
		int errCode = gs.getSectManager().sectCancelShareDiySkill(this, diySkill.id);
		// 去掉对取消分享返回错误码的判断
//		if(errCode == GameData.PROTOCOL_OP_SUCCESS)
		{
			synchronized(this)
			{
				if (skillPos == this.diySkillData.curSkillId)
					this.diySkillData.curSkillId = 0;
				this.diySkillData.diySkills.remove(skillPos - 1);
				//when remove an element, reset the id
				int lastCurSkillId = this.diySkillData.curSkillId;
				if (lastCurSkillId != 0)
					this.diySkillData.curSkillId = skillPos < lastCurSkillId ? lastCurSkillId - 1 : lastCurSkillId;
				for (int i = 0; i < this.diySkillData.diySkills.size(); ++i)
				{
					SBean.DBDiySkill t = this.diySkillData.diySkills.get(i);
					t.id = i + 1;
				}
			}
		}
		gs.getTLogger().logRoleSectDiySkillFlow(this, TLog.SECT_DIY_SKILL_DISCARD);
		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_discard_res(GameData.PROTOCOL_OP_SUCCESS));
	}

	public synchronized boolean diySkillSelectUse(int skillPos)
	{
		if (skillPos <= 0 || skillPos > this.diySkillData.diySkills.size())
			return false;
		SBean.DBDiySkill diySkill = this.diySkillData.diySkills.get(skillPos - 1);
		if (diySkill == null)
			return false;

		diySkillData.curSkillId = skillPos;
		if (diySkillData.borrowDiySkill != null)
		{
			diySkillData.borrowDiySkill = null;
			diySkillData.borrowTime = 0;
		}
		gs.getMapService().syncRoleUpdateCurDIYSkill(this.id, this.gameMapContext.getCurMapId(), diySkill.diySkillData);
		return true;
	}

	public synchronized boolean diySkillCancelUse(int skillPos)
	{
		if (skillPos <= 0 || skillPos > this.diySkillData.diySkills.size())
			return false;
		SBean.DBDiySkill diySkill = this.diySkillData.diySkills.get(skillPos - 1);
		if (diySkillData.curSkillId != skillPos)
			return false;

		diySkillData.curSkillId = 0;
		gs.getMapService().syncRoleUpdateCurDIYSkill(this.id, this.gameMapContext.getCurMapId(), diySkill.diySkillData);
		return true;
	}

	public synchronized boolean diySkillSlotUnlock()
	{
		int availableSlotCount = GameData.getInstance().getDiySkillSlotTotal() - GameData.getInstance().getDiySkillTotalUnlockSlot();
		if (this.diySkillData.slot >= GameData.getInstance().getDiySkillTotalUnlockSlot() + availableSlotCount)
			return false;
		SBean.DiySkillSlotUnblockCFGS skillSlotUnblockCFGS = GameData.getInstance().getDiySkillSlotUnblockCFGS(this.diySkillData.slot + 1);
		if (skillSlotUnblockCFGS == null || skillSlotUnblockCFGS.isOpen != 0)
			return false;

		if (!this.canUseCoin(skillSlotUnblockCFGS.openCoin, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_DIYSKILL_SLOT_UNLOCK);
		tlogEvent.setArg(skillSlotUnblockCFGS.openCoin, this.diySkillData.slot);
		this.useCoin(skillSlotUnblockCFGS.openCoin, false, tlogEvent.getGameItemRecords());
		this.diySkillData.slot += 1;
		this.diySkillData.dayUnlockCount += 1;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean diySkillBuyTimes(int count)
	{
		SBean.VipCFGS vipCfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipCfg == null)
			return false;
		if (count <= 0 || vipCfg.diyBuyCount < count || this.diySkillData.dayBuyCount + count > vipCfg.diyBuyCount)
			return false;
		int useDiamond = 0;
		for (int i = 1; i <= count; i++)
		{
			useDiamond += GameData.getTimesCost(vipCfg.diyBuyUseDiamond, this.diySkillData.dayBuyCount + i);
		}
		if (!this.canUseDiamond(useDiamond, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_DIY_SKILL_BUY_TIMES);
		tlogEvent.setArg(count, useDiamond, this.diySkillData.dayBuyCount);
		this.useDiamond(useDiamond, false, tlogEvent.getGameItemRecords());
		this.diySkillData.dayBuyCount += count;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	//自创武功分享
	public void diySkillShare(int diyskillPos)
	{
		final int GRADE_B = 3; // 等级B
		SBean.DBDiySkill diySkill = null;
		synchronized (this)
		{
			if (diyskillPos <= 0 || diyskillPos > this.diySkillData.diySkills.size())
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_share_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			diySkill = this.diySkillData.diySkills.get(diyskillPos - 1);
			if (diySkill == null || diySkill.diySkillData.gradeId < GRADE_B)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_share_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}
//		gs.getClanService().clanShareDiySkill(this.id, diySkill, new ClanService.ClanShareDiySkillCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int shareCount)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.clanData.data.dayShareCount = shareCount;
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_share_res(errCode));
//			}
//		});
		gs.getTLogger().logRoleSectDiySkillFlow(this, TLog.SECT_DIY_SKILL_SHARE);
		int errCode = gs.getSectManager().sectShareDiySkill(this, diySkill);
		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_share_res(errCode));
	}

	//取消分享
	public void diySkillCancelShare(int diyskillPos)
	{
		SBean.DBDiySkill diySkill = null;
		synchronized (this)
		{
			if (diyskillPos <= 0 || diyskillPos > this.diySkillData.diySkills.size())
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_cancelshare_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			diySkill = this.diySkillData.diySkills.get(diyskillPos - 1);
			if (diySkill == null)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_cancelshare_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}

//		gs.getClanService().clanCancelShareDiySkill(this.id, diySkill.id, new ClanService.ClanCancelShareDiySkillCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_cancelshare_res(errCode));
//			}
//		});
		
		int errCode = gs.getSectManager().sectCancelShareDiySkill(this, diySkill.id);
		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_cancelshare_res(errCode));
	}

	//借用
	public void diySkillBorrow(int roleId, int diyskillId)
	{
		if (diyskillId <= 0 || roleId <= 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_borrow_res(GameData.PROTOCOL_OP_FAILED, null));
			return;
		}
//		gs.getClanService().clanDiySkillBorrow(this.id, memId, memGsid, diyskillId, clanId, new ClanService.ClanDiySkillBorrowCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.DBDiySkill diyskill)
//			{
//				if(errCode == GameData.PROTOCOL_OP_SUCCESS && diyskill != null)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.diySkillData.borrowDiySkill = diyskill.kdClone();
//						Role.this.diySkillData.borrowTime = GameTime.getTime();
//						Role.this.diySkillData.curSkillId = 0;
//						gs.getMapService().syncRoleUpdateCurDIYSkill(Role.this.id, Role.this.gameMapContext.getCurMapId(), Role.this.diySkillData.borrowDiySkill.diySkillData);
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_borrow_res(errCode, diyskill));
//			}
//		});
		SBean.DBDiySkill diyskill = gs.getSectManager().sectDiySkillBorrow(this, roleId, diyskillId);
		if(diyskill != null)
		{
			synchronized (this)
			{
				this.diySkillData.borrowDiySkill = diyskill.kdClone();
				this.diySkillData.borrowTime = GameTime.getTime();
				this.diySkillData.curSkillId = 0;
				gs.getTLogger().logRoleSectDiySkillFlow(this, TLog.SECT_DIY_SKILL_BORROW);
				gs.getMapService().syncRoleUpdateCurDIYSkill(this.id, this.gameMapContext.getCurMapId(), this.diySkillData.borrowDiySkill.diySkillData);
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_borrow_res(GameData.PROTOCOL_OP_SUCCESS, diyskill));
			}
		}
		else
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_borrow_res(GameData.PROTOCOL_OP_FAILED, null));
		}
	}

	public synchronized SBean.DBDiySkill checkDiySkillFlaunt(int diyskillPos)
	{
		if (diyskillPos <= 0 || diyskillPos > this.diySkillData.diySkills.size())
			return null;

		return this.diySkillData.diySkills.get(diyskillPos - 1);
	}

	//炫耀
	public boolean diySkillFlaunt(int channel, int diyskillPos, List<Integer> icons)
	{
		SBean.DBDiySkill diySkill = this.checkDiySkillFlaunt(diyskillPos);
		if (diySkill == null)
			return false;

		//下面这个方法中消耗了大喇叭
		this.sendMsgImpl(channel, 0, createDiyskillMessage(new SBean.FlauntDiySkillInfo(diySkill, icons)), "");

		return true;
	}

	//领奖
	public void diySkillShareAward()
	{
//		synchronized (this)
//		{
//			if (this.clanData.data.dayTakeRewardCount >= GameData.getInstance().getDIYSkillUniqueCFGS().awardCount)
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.diyskill_shareaward_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//		}
//		gs.getClanService().clanDiySkillShareAward(this.id, new ClanService.ClanDiySkillShareAwardCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int awardCount)
//			{
//				synchronized (Role.this)
//				{
//					Role.this.clanData.data.dayTakeRewardCount++;
//					Role.this.diySkillData.exp += (awardCount * GameData.getInstance().getDIYSkillUniqueCFGS().shareAward);
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.diyskill_shareaward_res(errCode));
//			}
//		});
	}

	// ----------------------------clan--------------------------------------

//	private void dayRefreshClan()
//	{
////		this.clanData.data.dayBuyTimes = 0;
//		this.clanData.data.dayBuyPowerCount = 0;
//		this.clanData.data.daySearchCount = 0;
//		this.clanData.data.dayMoveCount = 0;
//		this.clanData.clanTaskCount = 0;
//
//		if (this.clanData.data.isOwner > 0)
//		{
//			gs.getClanService().clanDayRefresh(this.id, new ClanService.ClanDayRefreshCallback()
//			{
//
//				@Override
//				public void onCallback(int errCode)
//				{
//
//				}
//			});
//		}
//	}
//
//	//购买声望
//	public void buyPrestige(List<SBean.DummyGoods> items)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_PRESTIGE);
//		if (items.size() <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_buyprestige_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		synchronized (this)
//		{
//			for (SBean.DummyGoods item : items)
//			{
//				if (!this.containsEnoughGameItem(item.id, item.count))
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_buyprestige_res(GameData.PROTOCOL_OP_FAILED));
//					return;
//				}
//			}
//			Role.this.delGameItems(items, tlogEvent.getGameItemRecords());
//		}
//
//		gs.getClanService().clanBuyPrestige(this.id, items, new ClanService.ClanBuyPrestigeCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.syncAddGameItems(GameData.getInstance().toGameItems(items), tlogEvent.getGameItemRecords());
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_buyprestige_res(errCode));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//	}
//
//	public SBean.GlobalRoleOverview getGlobalRoleOverview()
//	{
//		return new SBean.GlobalRoleOverview(this.gs.getConfig().id, this.getRoleOverviewWithoutLock());
//	}
//
//	//宗门同步协议，获取所有宗门简要信息结果，主界面点击宗门按钮时候请求的协议。
//	public void queryClans()
//	{
//		gs.getClanService().queryRoleClans(this.id, new ClanService.QueryRoleClansCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.ClanBrief> clans, int gsID)
//			{
//				synchronized(Role.this)
//				{
//					if(clans != null)
//					{
//						if(clans.size() > 0)
//						{
//							Role.this.clanData.data.isInClan = 1; //是否在宗门的标志位，用于判断更新宗门排行榜和更新宗门服务器内成员信息的标志位
//						}else{
//							Role.this.clanData.data.isInClan = 0;
//						}
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_query_res(errCode, clans, gsID));
//			}
//		});
//	}
//
//	//获取某个宗门的详细信息
//	public synchronized void syncClanInfo(int clanId)
//	{
//		if (clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_sync_res(0, null, null, null, null));
//			return;
//		}
//		gs.getClanService().syncClanInfo(this.id, clanId, new ClanService.SyncClanInfoCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.ClanInfo clanInfo, int applyRedPoint)
//			{
//				if (errCode > 0)
//				{
//					synchronized (Role.this)
//					{
//						for (SBean.DBOreRobTeam ore : Role.this.clanData.occupyOres)
//						{
//							if(clanId == ore.clanId)
//								clanInfo.selfOres.put(ore.oreType, ore);
//						}
//						clanInfo.clanData = Role.this.clanData.data;
//
//						int battleTime = 0;
//						int defendHave = 0;
//						int helpHave = 0;
//						if (Role.this.clanData.clanBattleData != null)
//						{
//							if (Role.this.clanData.clanBattleData.battleType == Clan.CLAN_BATTLE_TYPE_ATTACK)
//								battleTime = Role.this.clanData.clanBattleData.attackTime + Role.this.clanData.clanBattleData.cdTime;
//							if (Role.this.clanData.clanBattleData.defend.size() > 0)
//								defendHave = 1;
//							if (Role.this.clanData.clanBattleData.help.size() > 0)
//							{
//								if(Role.this.clanData.clanBattleData.battleType != Clan.CLAN_BATTLE_TYPE_ATTACK && Role.this.clanData.clanBattleData.defend.size() == 0 )
//								{
//									helpHave = 1;
//								}
//							}
//						}
//
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_syncbattle(battleTime, defendHave, helpHave));
//						if (applyRedPoint == 1)
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_applyadd_push()); // 点击宗门发送红点协议
//					}
//
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_sync_res(errCode, clanInfo, Role.this.clanData.battle, Role.this.clanData.robOreLogs, Role.this.clanData.occupyOres));
//			}
//		});
//	}
//
//	//搜索所有宗门，selfServer 为0是本服搜索，1是跨服搜索
//	public void searchAllClans(int selfServer)
//	{
//		gs.getClanService().searchAllClans(this.id, selfServer, new ClanService.SearchAllClansCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.ClanOverview> clans)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchall_res(errCode, clans));
//			}
//		});
//	}
//
//	//id搜索宗门简要信息结果
//	public void searchClanById(int clanId)
//	{
//		if (clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchbyid_res(0, null));
//			return;
//		}
//		gs.getClanService().searchClanById(this.id, clanId, new ClanService.SearchClanByIdCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.ClanOverview clan)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchbyid_res(errCode, clan));
//			}
//		});
//	}
//
//	//clanname搜索宗门简要信息结果
//	public void searchClanByName(String clanName)
//	{
//		if ("".equals(clanName))
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchbyname_res(0, null));
//			return;
//		}
//		gs.getClanService().searchClanByName(this.id, clanName, new ClanService.SearchClanByNameCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.ClanOverview clan)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchbyname_res(errCode, clan));
//			}
//		});
//	}
//
//
//	//创建一个新的宗门，创建宗门，建立宗门
//	public synchronized void clanCreate(String name, int isFemale)
//	{
//		SBean.Counter counter;
//		boolean createSuccess = true;
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_CREATE);
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (!GameData.getInstance().checkInputStrValid(name, GameData.getInstance().getCommonCFG().input.maxClanNameLength))
//			createSuccess = false;
//		else if (clanCFGS == null)
//			createSuccess = false;
//		else if (isFemale > 0 && this.gender == 1)
//			createSuccess = false;
//		else if (this.level < clanCFGS.level || this.getUseableVipLvl() < clanCFGS.vip)
//			createSuccess = false;
//		else if (!this.canUseDiamond(clanCFGS.diamond, true))
//			createSuccess = false;
//		else if (this.BWType <= 0)
//			createSuccess = false;
//
//		if (!createSuccess)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_create_res(0, null));
//			return;
//		}
//
//		synchronized (this)
//		{
//			counter = this.lockDiamond(clanCFGS.diamond, true);
//		}
//		SBean.GlobalRoleOverview creater = this.getGlobalRoleOverview();
//		gs.getClanService().createClan(creater, name, isFemale, new ClanService.CreateClanCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.ClanInfo clanInfo, int taskId)
//			{
//				synchronized (Role.this)
//				{
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						tlogEvent.setArg(counter.fvalue, counter.rvalue);
//						Role.this.useLockedDiamond(counter, true, tlogEvent.getGameItemRecords());
//					}
//					else
//					{
//						Role.this.clanData.data.xuantie = clanCFGS.others.xuetieInit;
//						Role.this.clanData.data.yaocao = clanCFGS.others.yaocaoInit;
//						Role.this.clanData.data.attackPoint = GameData.getInstance().getClanCFGS().robOre.pointUp;
//						clanInfo.clanData = Role.this.clanData.data;
//						Role.this.lastAddClanTime = GameTime.getTime();
//						Role.this.clanData.tasks.put(clanInfo.clanId, new SBean.DBClanMemberTask(taskId, 0, 0, 0, new TreeSet<Integer>(), 0, 0));
//						//Role.this.initClanTask(clanInfo.clanId, taskId);
//						Role.this.initClanBattleData();
//						Role.this.clanData.data.isOwner = 1;//宗主标志
//						Role.this.clanData.data.isInClan = 1;
//						tlogEvent.setArg(counter.fvalue, counter.rvalue);
//						Role.this.useLockedDiamond(counter, false, tlogEvent.getGameItemRecords());
//						if(Role.this.clanData.clanMaxLevel == 0)
//						{
//							Role.this.clanData.clanMaxLevel = 1;
//							Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_CLAN_LEVEL, 0);
//						}
//						Role.this.clanData.data.isWomanClan = isFemale > 0 ? 1 : 0;
//						modifyClanRank();// 向宗门排行榜中添加数据。
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_create_res(errCode, clanInfo));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//	}
//
//	//申请加入一个宗门
//	public synchronized void clanApplyAdd(int clanId)
//	{
//		if (clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_applyadd_res(-1));
//			return;
//		}
//
//		gs.getClanService().applyAddClan(this.getGlobalRoleOverview(), clanId, new ClanService.ApplyAddClanCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<Integer> rids)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					for (int rid : rids)
//					{
//						Role role = gs.getLoginManager().getOnGameRole(rid);
//						if (role != null)
//						{
//							gs.getRPCManager().sendStrPacket(role.netsid, new SBean.clan_applyadd_push());
//						}
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_applyadd_res(errCode));
//			}
//		});
//	}
//
//	private void clanRatifyAddMember(int clanId, int memberId, int memberGsId, int taskId, SBean.ClanCFGS clanCFGS)
//	{
//		if (memberGsId == gs.getConfig().id)
//		{
//			int nowTime = GameTime.getTime();
//			Role role = gs.getLoginManager().getOnGameRole(memberId);
//			synchronized(role)
//			{
//				if (role != null)
//				{
//					role.syncAddAttackPoint(nowTime);
//				}
//			}
//			gs.getLoginManager().exeCommonRoleVisitor(memberId, false, new LoginManager.CommonRoleVisitor()
//			{
//				@Override
//				public boolean visit(Role role, Role sameUserRole)
//				{
//					if (role.lastAddClanTime <= 0) //padding 是否第一次加入宗门
//					{
//						role.clanData.data.attackPoint = GameData.getInstance().getClanCFGS().robOre.pointUp;
//						role.clanData.data.xuantie = clanCFGS.others.xuetieInit;
//						role.clanData.data.yaocao = clanCFGS.others.yaocaoInit;
//					}
//					role.clanData.tasks.put(clanId, new SBean.DBClanMemberTask(taskId, 0, 0, 0, new TreeSet<Integer>(), 0, 0));
//					role.clanData.data.attackPointLastTime = nowTime;
//					role.lastAddClanTime = nowTime;
//					return true;
//				}
//
//				@Override
//				public void onCallback(boolean success)
//				{
//				}
//			});
//
//		}
//
//	}
//
//	//同意加入宗门
//	public synchronized void clanRatifyAdd(int memberId, int memberGsId, int isAgree)
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || memberId <= 0 || memberGsId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_ratifyadd_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		gs.getClanService().ratifyAddClan(this.id, memberId, memberGsId, isAgree, new ClanService.RatifyAddClanCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, int taskId, int clanId)
//			{
//				if (isAgree == 1 && errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					Role.this.clanRatifyAddMember(clanId, memberId, memberGsId, taskId, clanCFGS);
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_ratifyadd_res(errCode));
//			}
//		});
//	}
//
//	//获取申请加入宗门列表
//	public void getClanApplications()
//	{
//		gs.getClanService().getClanApplications(this.id, new ClanService.GetClanApplicationsCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.GlobalRoleOverview> apps)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_applications_res(errCode, apps));
//			}
//		});
//	}
//
//	//获取宗门的成员列表
//	public void getClanMembers(int clanId)
//	{
//		if (clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_members_res(0, null));
//			return;
//		}
//		gs.getClanService().getClanMemberTask(this.id, clanId, new ClanService.GetClanMembersCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, List<SBean.ClanMember> members)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_members_res(errCode, members));
//			}
//		});
//	}
//
//	private void clanKickMemberCBMember(int memberId, int memberGsId)
//	{
//		if (memberGsId == gs.getConfig().id)
//		{
//			gs.getLoginManager().exeCommonRoleVisitor(memberId, false, new LoginManager.CommonRoleVisitor()
//			{
//				@Override
//				public boolean visit(Role role, Role sameUserRole)
//				{
//					role.lastAddClanTime = GameTime.getTime();
//					//被踢出宗门，清空其占矿信息
//					role.clanData.occupyOres = new ArrayList<SBean.DBOreRobTeam>();
//					return true;
//				}
//
//				@Override
//				public void onCallback(boolean success)
//				{
//
//				}
//			});
//		}
//	}
//
//	// 宗主踢人，成员
//	public void clanKickMember(int memberId, int memberGsId)
//	{
//		if (memberId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_kickmember_res(0));
//			return;
//		}
//		gs.getClanService().clanKickMember(this.id, memberId, memberGsId, new ClanService.ClanKickMemberCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.clanKickMemberCBMember(memberId, memberGsId);
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_kickmember_res(errCode));
//			}
//		});
//	}
//
//	// 离开， 成员主动离开宗门，退出宗门
//	public void clanMemberLeave(int clanId)
//	{
//		if (clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_memberleave_res(0));
//			return;
//		}
//		gs.getClanService().clanMemberLeave(this.id, clanId, new ClanService.ClanMemberLeaveCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode)
//			{
//				if(errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.clanData.occupyOres = new ArrayList<SBean.DBOreRobTeam>();
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_memberleave_res(errCode));
//			}
//		});
//	}
//	
//	public void checkClanDisbandTime()
//	{
//		if(this.clanData == null)
//			return ;
//		if(this.clanData.clanDisbandTime > 0)
//		{
//			SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//			gs.getClanService().clanDisband(this.id, new ClanService.ClanDisbandCallback()
//			{
//				@Override
//				public void onCallback(int errCode, int disbandTime)
//				{
//					if (errCode == GameData.PROTOCOL_OP_SUCCESS || errCode == GameData.PROTOCOL_OP_CLAN_NOTFIND)
//					{
//						synchronized (Role.this)
//						{
//							Map<Integer, SBean.DBClanMemberTask> task = Role.this.clanData.tasks;
//							Role.this.clanData.data.isOwner = 0;
//							Role.this.updateClanOwnerAttriAddition(new SBean.ClanOwnerAttriAddition(0, 0, 0, 0));//清空精英弟子对宗主的属性加成
//							Role.this.initClanBattleData();
//							Role.this.initClanFightData();
//							Role.this.clanData = Role.this.createNewRoleClanData();
//							Role.this.clanData.tasks = task;
//							Role.this.clanData.data.attackPoint = 20;
//							Role.this.clanData.data.xuantie = clanCFGS.others.xuetieInit;
//							Role.this.clanData.data.yaocao = clanCFGS.others.yaocaoInit;
//							Role.this.clanData.clanDisbandTime = 0;
//						}
//					}
//				}
//			});
//		}
//	}
//
//	// 宗主解散宗门
//	public void clanDisband()
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		gs.getClanService().clanDisband(this.id, new ClanService.ClanDisbandCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int disbandTime)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						if(disbandTime == 0)
//						{
//							Map<Integer, SBean.DBClanMemberTask> task = Role.this.clanData.tasks;
//							Role.this.clanData.data.isOwner = 0;
//							Role.this.updateClanOwnerAttriAddition(new SBean.ClanOwnerAttriAddition(0, 0, 0, 0));//清空精英弟子对宗主的属性加成
//							Role.this.initClanBattleData();
//							Role.this.initClanFightData();
//							Role.this.clanData = Role.this.createNewRoleClanData();
//							Role.this.clanData.tasks = task;
//							Role.this.clanData.data.attackPoint = 20;
//							Role.this.clanData.data.xuantie = clanCFGS.others.xuetieInit;
//							Role.this.clanData.data.yaocao = clanCFGS.others.yaocaoInit;
//						}
//						Role.this.clanData.clanDisbandTime = disbandTime;
//					}
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_changeownerattri(new SBean.ClanOwnerAttriAddition(0, 0, 0, 0)));
//					Role.this.clanBattleFightExit(); //宗门战撤退
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_disband_res(errCode, disbandTime));
//			}
//		});
//	}
//
//	//宗主取消解散宗门
//	public void clanCancelDisband()
//	{
//		gs.getClanService().clanCancelDisband(this.id, new ClanService.ClanCancelDisbandCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_canceldisband_res(errCode));
//			}
//		});
//	}
//
//	//查找已经申请过的宗门，
//	public void clanApplied(List<Integer> clanIds)
//	{
//		if (clanIds.size() <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_applied_res(GameData.PROTOCOL_OP_FAILED, null));
//			return;
//		}
//		gs.getClanService().clanApplied(this.id, clanIds, new ClanService.ClanAppliedCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, List<Integer> clanIds)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_applied_res(GameData.PROTOCOL_OP_SUCCESS, clanIds));
//			}
//		});
//	}
//
//	//宗主任命长老，升为客卿
//	public void clanAppointElder(int memberId, int memberGsId)
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (memberId <= 0 || memberGsId <= 0 || clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_appointelder_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//
//		gs.getClanService().clanAppointElder(this.id, memberId, memberGsId, new ClanService.ClanAppointElderCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_appointelder_res(errCode));
//			}
//		});
//	}
//
//	//宗门取消长老职位
//	public void clanCancelElder(int memberId, int memberGsId)
//	{
//		if (memberId <= 0 || memberGsId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_cancelelder_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//
//		gs.getClanService().clanCancelElder(this.id, memberId, memberGsId, new ClanService.ClanCancelElderCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_cancelelder_res(errCode));
//			}
//		});
//	}
//
//	//宗门升级，只有宗主有权限
//	public void clanUplevel(int curLevel)
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (curLevel <= 0 || clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_uplevel_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		SBean.ClanLevelCFGS levelCFGS = clanCFGS.clanLevels.get(curLevel);
//		if (levelCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_uplevel_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		synchronized (this)
//		{
//			if (this.clanData.data.xuantie < levelCFGS.xuetie || this.clanData.data.yaocao < levelCFGS.yaocao)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_uplevel_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//			this.clanData.data.xuantie -= levelCFGS.xuetie;
//			this.clanData.data.yaocao -= levelCFGS.yaocao;
//		}
//
//		// 消耗固定的道具
//		gs.getClanService().clanUplevel(this.id, curLevel, new ClanService.ClanUplevelCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int level, SBean.ClanOwnerAttriAddition attriAddition)
//			{
//				if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.clanData.data.xuantie += levelCFGS.xuetie;
//						Role.this.clanData.data.yaocao += levelCFGS.yaocao;
//					}
//				}
//				else
//				{
//					if (level != curLevel)
//					{
//						if(level > Role.this.clanData.clanMaxLevel)
//						{
//							Role.this.clanData.clanMaxLevel = level;
//							Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_CLAN_LEVEL, 0);
//						}
//					}
//					Role.this.updateClanOwnerAttriAddition(attriAddition);
//					gs.getMapService().syncRoleUpdateClanDiziTangAttr(Role.this.id, Role.this.gameMapContext.getCurMapId(), attriAddition);
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_uplevel_res(errCode));
//			}
//		});
//	}
//
//	// 发布招聘信息
//	public void clanRecruit(int type)
//	{
//		gs.getClanService().clanRecruit(this.id, type, new ClanService.ClanRecruitCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_recruit_res(errCode));
//			}
//		});
//	}
//
//	// 收徒
//	public void clanShoutu()
//	{
//		gs.getClanService().clanShoutu(this.id, new ClanService.ClanShoutuCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, int startTime)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_shoutu_res(errCode, startTime));
//			}
//		});
//	}
//
//	//加速收徒
//	public void clanShoutuSpeedup(int count, int startTime)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_SHOUTU_SPEEDUP);
//		final SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_shoutuspeedup_res(GameData.PROTOCOL_OP_FAILED, 0, 0, 0));
//			return;
//		}
//
//		int timeValue = GameData.getTimesCost(clanCFGS.shoutu.cd1, count);
//
//		int nowTime = GameTime.getTime();
//		int remnantMinute = (int) Math.ceil(((double) nowTime - (double) startTime) / 60);
//		if (timeValue - remnantMinute < 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_shoutuspeedup_res(GameData.PROTOCOL_OP_FAILED, 0, 0, 0));
//			return;
//		}
//		SBean.Counter counter;
//		final int useDiamond = (int) Math.floor((timeValue - remnantMinute) * clanCFGS.shoutu.addSpeed);
//		synchronized (this)
//		{
//			if (!this.canUseDiamond(useDiamond, true))
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_shoutuspeedup_res(GameData.PROTOCOL_OP_CLAN_DIAMOND, 0, 0, 0));
//				return;
//			}
//			//this.useDiamond(useDiamond, true);
//			counter = this.lockDiamond(useDiamond, true);
//		}
//		gs.getClanService().clanShoutuSpeedup(this.id, count, startTime, new ClanService.ClanShoutuSpeedupCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, int dzTotal, int surplusTime)
//			{
//				int diamond = useDiamond;
//				synchronized (Role.this)
//				{
//					tlogEvent.setArg(count, startTime, counter.fvalue, counter.rvalue);
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						Role.this.useLockedDiamond(counter, true, tlogEvent.getGameItemRecords());
//						diamond = 0;
//					}
//					else
//					{
//						Role.this.useLockedDiamond(counter, false, tlogEvent.getGameItemRecords());
//					}
//				}
//
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_shoutuspeedup_res(errCode, dzTotal, nowTime, diamond));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//	}
//
//	//收徒完成领取奖励
//	public void clanShoutuFinish()
//	{
//		gs.getClanService().clanShoutuFinish(this.id, new ClanService.ClanShoutuFinishCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, int dzTotal, int endTime)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_shoutufinish_res(errCode, dzTotal, endTime));
//			}
//		});
//	}
//
//	//宗门比武开始
//	public void clanBiwuStart()
//	{
//		gs.getClanService().clanBiwuStart(this.id, new ClanService.ClanBiwuStartCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int startTime)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_biwustart_res(errCode, startTime));
//			}
//		});
//	}
//
//	//宗门比武加速
//	public void clanBiwuSpeedup(int count, int startTime)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_BIWU_SPEEDUP);
//		final SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_biwuspeedup_res(GameData.PROTOCOL_OP_FAILED, null, 0, 0));
//			return;
//		}
//		int nowTime = GameTime.getTime();
//		int remnantMinute = (int) Math.ceil(((double) nowTime - (double) startTime) / 60);
//		int timeValue = GameData.getTimesCost(clanCFGS.biwu.cd1, count);
//		if (timeValue - remnantMinute < 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_biwuspeedup_res(GameData.PROTOCOL_OP_FAILED, null, 0, 0));
//			return;
//		}
//		SBean.Counter counter;
//		final int useDiamond = (timeValue - remnantMinute) * clanCFGS.biwu.addSpeed;
//		synchronized (this)
//		{
//			if (!this.canUseDiamond(useDiamond, true))
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_biwuspeedup_res(GameData.PROTOCOL_OP_CLAN_DIAMOND, null, 0, 0));
//				return;
//			}
//			//this.useDiamond(useDiamond, true);
//			counter = this.lockDiamond(useDiamond, true);
//		}
//		gs.getClanService().clanBiwuSpeedup(this.id, count, startTime, new ClanService.ClanBiwuSpeedupCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, List<SBean.DBClanEliteDisciple> dzElites, int endTime)
//			{
//				int diamond = useDiamond;
//				synchronized (Role.this)
//				{
//					tlogEvent.setArg(useDiamond, count, startTime);
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						Role.this.useLockedDiamond(counter, true, tlogEvent.getGameItemRecords());
//						diamond = 0;
//					}
//					else
//					{
//						Role.this.useLockedDiamond(counter, false, tlogEvent.getGameItemRecords());
//					}
//				}
//
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_biwuspeedup_res(errCode, dzElites, nowTime, diamond));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//	}
//
//	//宗门比武结束并领取奖励
//	public void clanBiwuFinish()
//	{
//		gs.getClanService().clanBiwuFinish(this.id, new ClanService.ClanBiwuFinishCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, List<SBean.DBClanEliteDisciple> dzElites, int endTime, SBean.ClanOwnerAttriAddition attriAddition)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					Role.this.updateClanOwnerAttriAddition(attriAddition);
//					gs.getMapService().syncRoleUpdateClanDiziTangAttr(Role.this.id, Role.this.gameMapContext.getCurMapId(), attriAddition);
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_biwufinish_res(errCode, dzElites, endTime));
//			}
//		});
//	}
//
//	//更新宗门对宗主的属性加成，只有宗主
//	public void updateClanOwnerAttriAddition(SBean.ClanOwnerAttriAddition attriAddition)
//	{
//		if (attriAddition == null)
//			return;
//		this.clanData.attriAddition.qxAddHarm = attriAddition.qxAddHarm;
//		this.clanData.attriAddition.sbAddHarm = attriAddition.sbAddHarm;
//		this.clanData.attriAddition.ssAddHarm = attriAddition.ssAddHarm;
//		this.clanData.attriAddition.xfAddHarm = attriAddition.xfAddHarm;
//		//
//		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_changeownerattri(attriAddition));
//	}
//
//	//宗门布施开始
//	public void clanBushiStart()
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_BUSHI_START);
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_bushistart_res(GameData.PROTOCOL_OP_FAILED, 0, 0));
//			return;
//		}
//		synchronized (this)
//		{
//			if (!this.containsEnoughGameItem(clanCFGS.bushi.needItemId, clanCFGS.bushi.needItemCount))
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_bushistart_res(GameData.PROTOCOL_OP_CLAN_ITEMLACK, 0, 0));
//				return;
//			}
//			tlogEvent.setArg(clanCFGS.bushi.needItemId, clanCFGS.bushi.needItemCount);
//			Role.this.delGameItem(clanCFGS.bushi.needItemId, clanCFGS.bushi.needItemCount, tlogEvent.getGameItemRecords());
//		}
//
//		gs.getClanService().clanBushiStart(this.id, new ClanService.ClanBushiStartCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int dzTotal, int endTime)
//			{
//				if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.addGameItem(GameData.getInstance().toGameItem(clanCFGS.bushi.needItemId, clanCFGS.bushi.needItemCount), tlogEvent.getGameItemRecords());
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_bushistart_res(errCode, dzTotal, endTime));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//
//	}
//
//	//宗门传道开始
//	public void clanChuandaoStart()
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_CHUANDAO_START);
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_chuandaostart_res(GameData.PROTOCOL_OP_FAILED, 0, null));
//			return;
//		}
//		synchronized (this)
//		{
//			if (!this.containsEnoughGameItem(clanCFGS.chuandao.needItemId, clanCFGS.chuandao.needItemCount))
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_chuandaostart_res(GameData.PROTOCOL_OP_CLAN_ITEMLACK, 0, null));
//				return;
//			}
//			tlogEvent.setArg(clanCFGS.chuandao.needItemId, clanCFGS.chuandao.needItemCount);
//			Role.this.delGameItem(clanCFGS.chuandao.needItemId, clanCFGS.chuandao.needItemCount, tlogEvent.getGameItemRecords());
//		}
//
//		gs.getClanService().clanChuandaoStart(this.id, new ClanService.ClanChuandaoStartCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int startTime, List<SBean.DBClanEliteDisciple> dzElites, SBean.ClanOwnerAttriAddition attriAddition)
//			{
//				synchronized (Role.this)
//				{
//					tlogEvent.setArg(clanCFGS.chuandao.needItemId, clanCFGS.chuandao.needItemCount);
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						Role.this.addGameItem(GameData.getInstance().toGameItem(clanCFGS.chuandao.needItemId, clanCFGS.chuandao.needItemCount), tlogEvent.getGameItemRecords());
//					}
//					else
//					{
//						Role.this.updateClanOwnerAttriAddition(attriAddition);
//						gs.getMapService().syncRoleUpdateClanDiziTangAttr(Role.this.id, Role.this.gameMapContext.getCurMapId(), attriAddition);
//					}
//				}
//
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_chuandaostart_res(errCode, startTime, dzElites));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//
//	}
//
//	//宗门经验提升精英弟子属性
//	public void clanRushTollgateToExp(int dzid, int count, int useMoney)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_RUSH_TOLLGATE_TO_EXP);
//		tlogEvent.setArg(dzid, count, useMoney);
//		SBean.ClanValueCFGS clanValueCFGS = GameData.getInstance().getClanValueCFGS();
//		if (dzid <= 0 || count < 0 || clanValueCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_rushtollgatetoexp_res(GameData.PROTOCOL_OP_FAILED, null));
//			return;
//		}
//		SBean.ClanRushTollgateCFGS rushTollgateCFGS = clanValueCFGS.rushTollgate.get(count);
//		if (rushTollgateCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_rushtollgatetoexp_res(GameData.PROTOCOL_OP_FAILED, null));
//			return;
//		}
//		SBean.Counter counter;
//		if (useMoney > 0)
//		{
//			synchronized (this)
//			{
//				if (!this.canUseDiamond(rushTollgateCFGS.diamond, false))
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_rushtollgatetoexp_res(GameData.PROTOCOL_OP_FAILED, null));
//					return;
//				}
//				//Role.this.useDiamond(rushTollgateCFGS.diamond, false);
//				counter = this.lockDiamond(rushTollgateCFGS.diamond, true);
//			}
//		}
//		else
//			counter = new SBean.Counter(0, 0);
//
//		gs.getClanService().clanRushTollgateToExp(this.id, dzid, count, useMoney, new ClanService.ClanRushTollgateToExpCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.DBClanEliteDisciple attriValue, SBean.ClanOwnerAttriAddition attriAddition)
//			{
//				synchronized (Role.this)
//				{
//					if (useMoney > 0 && errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						Role.this.useLockedDiamond(counter, true, tlogEvent.getGameItemRecords());
//					}
//					else
//					{
//						Role.this.useLockedDiamond(counter, false, tlogEvent.getGameItemRecords());
//						Role.this.updateClanOwnerAttriAddition(attriAddition);
//						gs.getMapService().syncRoleUpdateClanDiziTangAttr(Role.this.id, Role.this.gameMapContext.getCurMapId(), attriAddition);
//					}
//				}
//
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_rushtollgatetoexp_res(errCode, attriValue));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//
//	}
//
//	//宗门道具提升精英弟子属性
//	public void clanRushTollgateToUseItem(int dzid, List<Integer> items)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_RUSH_TOLLGATE_TO_ITEM);
//		tlogEvent.setArg(dzid);
//		if (dzid <= 0 || items.size() <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_rushtollgatetoitem_res(GameData.PROTOCOL_OP_FAILED, null));
//			return;
//		}
//		synchronized (this)
//		{
//			for (int itemId : items)
//			{
//				if (!this.containsEnoughGameItem(itemId, 1))
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_rushtollgatetoitem_res(GameData.PROTOCOL_OP_FAILED, null));
//					return;
//				}
//			}
//			for (int itemId : items)
//			{
//				Role.this.delGameItem(itemId, 1, tlogEvent.getGameItemRecords());
//			}
//		}
//
//		gs.getClanService().clanRushTollgateToItem(this.id, dzid, items, new ClanService.ClanRushTollgateToItemCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, SBean.DBClanEliteDisciple attriValue, SBean.ClanOwnerAttriAddition attriAddition)
//			{
//				synchronized (Role.this)
//				{
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						for (int itemId : items)
//						{
//							Role.this.addGameItem(GameData.getInstance().toGameItem(itemId, 1), tlogEvent.getGameItemRecords());
//						}
//					}
//					else
//					{
//						Role.this.updateClanOwnerAttriAddition(attriAddition);
//						gs.getMapService().syncRoleUpdateClanDiziTangAttr(Role.this.id, Role.this.gameMapContext.getCurMapId(), attriAddition);
//					}
//				}
//
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_rushtollgatetoitem_res(errCode, attriValue));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//
//	}
//
//	//主动回去宗主属性加成， 这个没有用到，改成cs主动同步
//	public void clanOwnerAttriAddition()
//	{
//		gs.getClanService().clanOwnerAttriAddition(this.id, new ClanService.ClanOwnerAttriAdditionCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, SBean.ClanOwnerAttriAddition attriAddition)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_ownerattriaddition_res(errCode, attriAddition));
//			}
//		});
//	}
//	
//	//初始化宗门任务
//	private void initClanTask(int clanId, int taskId)
//	{
//		SBean.DBClanMemberTask task = this.clanData.tasks.get(clanId);
//		if (task != null)
//		{
//			task.taskId = taskId;
//			task.startTime = 0;
//		}
//	}
//
//	// 获取宗门总任务列表
//	public void clanSyncLibTasks()
//	{
//		gs.getClanService().clanTaskLibTask(this.id, new ClanService.SyncClanTaskLibCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, Map<Integer, Integer> tasks)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_synctasklib_res(errCode, tasks));
//			}
//		});
//	}
//
//	//宗门所有成员获取当前自己可接取的任务，还有完成了多少次任务
//	public void clanSyncSelfTask(int clanId)
//	{
//		SBean.DBClanMemberTask task = this.clanData.tasks.get(clanId);
//		if (task == null)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_syncselftask_res(GameData.PROTOCOL_OP_FAILED, null));
//			return;
//		}
//		gs.getClanService().clanTaskSyncSelf(this.id, clanId, task.taskId, new ClanService.SyncSelfClanTaskCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int taskId, int basedz, int usedz)
//			{
//				synchronized (Role.this)
//				{
//					if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//					{
//						if (task.startTime <= 0 && task.taskId != taskId)
//						{
//							task.taskId = taskId;
//						}
//						SBean.SelfClanTask taskRes = new SBean.SelfClanTask(Role.this.clanData.clanTaskCount, task.taskId, task.startTime, task.jydzs, basedz, usedz);
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_syncselftask_res(errCode, taskRes));
//					}
//					else
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_syncselftask_res(errCode, null));
//					}
//				}
//			}
//		});
//	}
//
//	//宗主刷新指定任务
//	public void autoRefreshClanTask(int taskId)
//	{
//		if (taskId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_autorefreshtask_res(GameData.PROTOCOL_OP_FAILED, 0));
//			return;
//		}
//		gs.getClanService().autoRefreshTask(this.id, taskId, new ClanService.AutoRefreshTaskCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int taskId)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_autorefreshtask_res(errCode, taskId));
//			}
//		});
//	}
//
//	//宗门所有成员都可以接取任务，接取宗门任务
//	public void clanTaskReceive(int taskId, List<Integer> eliteDisciples, int clanId)
//	{
//		SBean.DBClanMemberTask task = this.clanData.tasks.get(clanId);
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		SBean.ClanTaskCFGS taskCFGS = GameData.getInstance().getClanTaskCFGS(taskId);
//		if (clanCFGS == null || taskCFGS == null || task == null)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_receivetask_res(GameData.PROTOCOL_OP_FAILED, 0, 0, 0));
//			return;
//		}
//		List<Integer> pets = new ArrayList<Integer>();
//		synchronized (this)
//		{
//			if (task.taskId != taskId || task.startTime > 0)
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_receivetask_res(GameData.PROTOCOL_OP_FAILED, 0, 0, 0));
//				return;
//			}
//			if (this.clanData.clanTaskCount >= clanCFGS.taskParam.dayTaskMax)
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_receivetask_res(GameData.PROTOCOL_OP_TASMCOUNT_NOT, 0, 0, 0));
//				return;
//			}
//			if (eliteDisciples.size() > taskCFGS.calldzCount)
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_receivetask_res(GameData.PROTOCOL_OP_CLAN_JYDZLACK, 0, 0, 0));
//				return;
//			}
//			if (this.activePets.size() > 0)
//			{
//				List<SBean.DBPet> copyAllPets = new ArrayList<SBean.DBPet>();
//				copyAllPets.addAll(this.activePets.values());
//				for (int index = 0; index < 3; index++)
//				{
//					int pos = GameRandom.getRandInt(0, copyAllPets.size());
//					SBean.DBPet tmpPet = copyAllPets.get(pos);
//					pets.add(tmpPet.fightPet.id);
//					copyAllPets.remove(pos);
//					if (copyAllPets.size() <= 0)
//						break;
//				}
//			}
//		}
//		gs.getClanService().receiveTask(this.id, taskId, clanId, eliteDisciples, pets, new ClanService.ClanTaskReceiveCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int useDZTotal, int useTime, int genDisciple, int usedGenDisciple, SBean.DBTaskEnemy clanTaskEnemy)
//			{
//				synchronized (Role.this)
//				{
//					int nowTime = GameTime.getTime();
//					if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//					{
//						Role.this.clanData.clanTaskCount ++;
//						task.jydzs.clear();
//						task.startTime = nowTime;
//						task.jydzs.addAll(eliteDisciples);
//						task.useGenDisciple = useDZTotal;
//						task.needTime = useTime;
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_receivetask_res(errCode, nowTime, genDisciple, usedGenDisciple));
//					}
//					else
//					{
//						if (errCode == GameData.PROTOCOL_OP_CLAN_MEET_ENEMY)
//						{
//							Role.this.initClanFightDataByTask(clanTaskEnemy);
//							Role.this.clanFightData.clanId = clanId;
//							task.jydzs.clear();
//							task.startTime = nowTime;
//							task.jydzs.addAll(eliteDisciples);
//							task.useGenDisciple = useDZTotal;
//							task.needTime = useTime;
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_receivetask_res(errCode, nowTime, genDisciple, usedGenDisciple));
//						}
//						else
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_receivetask_res(errCode, 0, 0, 0));
//						}
//					}
//				}
//			}
//		});
//	}
//
//	//如果接取任务遇到敌人， 获取遭遇战敌人数据
//	public void clanGetClanTaskEnemy()
//	{
//		if (this.clanFightData.taskEnemy == null)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_getclantaskenemy_res(GameData.PROTOCOL_OP_FAILED, null, null));
//			return;
//		}
//		if (this.clanFightData.taskEnemy.roleId <= 0 || this.clanFightData.taskEnemy.serverId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_getclantaskenemy_res(GameData.PROTOCOL_OP_FAILED, null, null));
//			return;
//		}
//		if (this.clanFightData.taskEnemy.serverId == this.gs.getConfig().id)
//		{
//			Role enemyRole = gs.getLoginManager().getOnGameRole(this.clanFightData.taskEnemy.roleId);
//			if (enemyRole == null)
//			{
//				gs.getLoginManager().getRoleAndPetOverviews(this.id, Role.this.clanFightData.taskEnemy.pets, new LoginManager.GetRoleAndPetOverviewsCallback()
//				{
//					@Override
//					public void onCallback(SBean.RoleOverview overview, List<SBean.PetOverview> pets)
//					{
//						if (overview == null)
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getclantaskenemy_res(GameData.PROTOCOL_OP_FAILED, null, null));
//						}
//						else
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getclantaskenemy_res(GameData.PROTOCOL_OP_SUCCESS, overview, pets));
//						}
//					}
//				});
//			}
//			else
//			{
//				List<SBean.PetOverview> petOverviews = new ArrayList<SBean.PetOverview>();
//				for (int petId : this.clanFightData.taskEnemy.pets)
//				{
//					SBean.PetOverview overview = enemyRole.getPetOverviewWithoutLock(petId);
//					petOverviews.add(overview);
//				}
//				SBean.RoleOverview overview = enemyRole.getRoleOverview();
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_getclantaskenemy_res(GameData.PROTOCOL_OP_SUCCESS, overview, petOverviews));
//			}
//		}
//		else
//		{
//			gs.getClanService().clanGetClanTaskEnemy(Role.this.id, Role.this.clanFightData.taskEnemy.roleId, Role.this.clanFightData.taskEnemy.serverId, Role.this.clanFightData.taskEnemy.pets, new ClanService.ClanGetClanTaskEnemyCallback()
//			{
//
//				@Override
//				public void onCallback(int errCode, SBean.RoleOverview overview, List<SBean.PetOverview> petOverviews)
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getclantaskenemy_res(errCode, overview, petOverviews));
//				}
//			});
//		}
//	}
//
//	//遭遇战开始，客户端触发
//	public void clanTaskFightStart(List<Integer> pets, int ownerPet)
//	{
//		if (ownerPet > 0 && this.clanFightData.ownerPet != ownerPet || this.clanFightData.taskEnemy == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_taskfight_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		if (ownerPet <= 0)
//		{
//			clanTaskFightStartCB(pets, null, null);
//		}
//		else
//		{
//			if (this.clanFightData.ownerServerId == gs.getConfig().id)
//			{
//				gs.getLoginManager().getOnLoanPet(Role.this.clanFightData.ownerId, ownerPet, new LoginManager.GetOnLoanPetCallback()
//				{
//					@Override
//					public void onCallback(SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost)
//					{
//						if (ownerFightPet == null || ownerFightPetHost == null)
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_taskfight_res(GameData.PROTOCOL_OP_FAILED));
//							Role.this.clanFightData.taskEnemy = null;
//						}
//						else
//						{
//							Role.this.clanTaskFightStartCB(pets, ownerFightPet, ownerFightPetHost);
//						}
//					}
//				});
//			}
//			else
//			{
//				gs.getClanService().clanGetOwnerFightData(this.id, this.clanFightData.ownerId, this.clanFightData.ownerServerId, ownerPet, new ClanService.ClanGetOwnerFightDataCallback()
//				{
//					@Override
//					public void onCallback(int errCode, SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost)
//					{
//						if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//						{
//							Role.this.clanTaskFightStartCB(pets, ownerFightPet, ownerFightPetHost);
//						}
//						else
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_taskfight_res(errCode));
//						}
//					}
//				});
//			}
//		}
//	}
//
//	public void clanTaskFightStartCB(List<Integer> pets, SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost)
//	{
//		if (this.clanFightData.taskEnemy.serverId == gs.getConfig().id)
//		{
//			gs.getLoginManager().getClanTaskFightArray(this.clanFightData.taskEnemy.roleId, this.clanFightData.taskEnemy.pets, new LoginManager.GetClanTaskFightArrayCallback()
//			{
//				@Override
//				public void onCallback(SBean.BattleArray ba)
//				{
//					if (ba != null)
//					{
//						boolean ok = Role.this.startClanTaskMapCopy(new TreeSet<Integer>(pets), ownerFightPet, ownerFightPetHost, ba);
//						int code = ok ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_taskfight_res(code));
//					}
//					else
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_taskfight_res(GameData.PROTOCOL_OP_FAILED));
//					}
//				}
//			});
//		}
//		else
//		{
//			gs.getClanService().clanGetEnemyFightData(this.id, this.clanFightData.taskEnemy.roleId, this.clanFightData.taskEnemy.serverId, this.clanFightData.taskEnemy.pets, new ClanService.ClanGetEnemyFightDataCallback()
//			{
//				@Override
//				public void onCallback(int errCode, SBean.BattleArray ba)
//				{
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_taskfight_res(errCode));
//						return;
//					}
//					boolean ok = Role.this.startClanTaskMapCopy(new TreeSet<Integer>(pets), ownerFightPet, ownerFightPetHost, ba);
//					int code = ok ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_taskfight_res(code));
//				}
//			});
//		}
//	}
//
//	//任务遭遇战结束
//	public synchronized void clanTaskFightEnd(int endTime, boolean win, SBean.ClanTaskBattleResult result)
//	{
//		//加协议，通知扣除材料， clan拆封扣除材料
//		this.clanFightData.taskEnemy = null;
//		if (win)
//		{
//			this.clanFightData.win = 1;
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clantaskmap_end(this.clanFightData.win));
//		}
//		else
//		{
//			this.clanFightData.win = 0;
//			SBean.DBClanMemberTask task = this.clanData.tasks.get(this.clanFightData.clanId);
//			if (task != null)
//			{
//				task.jydzs.clear();
//				task.useGenDisciple = 0;
//				task.needTime = 0;
//				task.startTime = 0;
//			}
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clantaskmap_end(this.clanFightData.win));
//		}
//		this.clanFightData.clanId = 0;
//		this.clanFightData.startTime = 0;
//		this.clanFightData.ownerPet = 0;
//		this.clanFightData.ownerId = 0;
//	}
//
//	//任务完成领取奖励
//	public void clanTaskFinish(int taskId, int clanId)
//	{
//		SBean.DBClanMemberTask task = this.clanData.tasks.get(clanId);
//		SBean.ClanTaskCFGS taskCFGS = GameData.getInstance().getClanTaskCFGS(taskId);
//		if (taskId <= 0 || taskCFGS == null || task == null)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_finishtask_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		int nowTime = GameTime.getTime();
//		synchronized (this)
//		{
//			if (nowTime - task.startTime < task.needTime || task.taskId != taskId)
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_finishtask_res(GameData.PROTOCOL_OP_CLAN_CDTIME));
//				return;
//			}
//		}
//		gs.getClanService().finishTask(this.id, taskId, clanId, task.jydzs, new ClanService.ClanTaskFinishCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int ownerId, int serverId, int newTaskId)
//			{
//				if (errCode >= GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.syncAddOre(Clan.CLAN_ORE_TYPE_IRON, taskCFGS.xuantie);
//						Role.this.syncAddOre(Clan.CLAN_ORE_TYPE_HERB, taskCFGS.caoyao);
//
//						task.jydzs.clear();
//						task.startTime = 0;
//						task.endTime = nowTime;
//						task.useGenDisciple = 0;
//						task.needTime = 0;
//						Role.this.clanFightData.taskEnemy = null;
//						task.frontTaskId = taskId;
//
//						Role.this.initClanTask(clanId, newTaskId);
//						Role.this.logDailyTask(GameData.DAILY_TASK_ID_FINISH_CLAN_TASK, 1);
////						Role.this.clanData.clanTaskCount++; //在接取任务的时候就增加次数
//						Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_CLAN_TASK, 0);
//						//给宗主加
//						if (ownerId > 0 && ownerId != Role.this.id)
//						{
//							Role.this.clanTaskFinishOwnerRewards(taskCFGS.xuantie, taskCFGS.caoyao, ownerId, serverId);
//						}
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_finishtask_res(errCode));
//			}
//		});
//	}
//
//	//
//	public void clanTaskFinishOwnerRewards(int xuantie, int caoyao, int ownerId, int serverId)
//	{
//		if (serverId == gs.getConfig().id)
//		{
//			Role role = gs.getLoginManager().getOnGameRole(ownerId);
//			if (role != null)
//			{
//				role.syncAddOre(Clan.CLAN_ORE_TYPE_IRON, xuantie);
//				role.syncAddOre(Clan.CLAN_ORE_TYPE_HERB, caoyao);
//			}
//			else
//			{
//				gs.getLoginManager().exeCommonRoleVisitor(ownerId, false, new LoginManager.CommonRoleVisitor()
//				{
//					@Override
//					public boolean visit(Role role, Role sameUserRole)
//					{
//						role.addClanOre(Clan.CLAN_ORE_TYPE_IRON, xuantie);
//						role.addClanOre(Clan.CLAN_ORE_TYPE_HERB, caoyao);
//						return true;
//					}
//
//					@Override
//					public void onCallback(boolean success)
//					{
//
//					}
//				});
//			}
//		}
//	}
//
//	//放弃宗门任务
//	public void clanTaskDiscard(int taskId, int clanId)
//	{
//		SBean.DBClanMemberTask task = this.clanData.tasks.get(clanId);
//		if (taskId <= 0 || task == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_discardtask_res(GameData.PROTOCOL_OP_FAILED, 0));
//			return;
//		}
//		synchronized (this)
//		{
//			if (task.taskId != taskId || task.startTime <= 0)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_discardtask_res(GameData.PROTOCOL_OP_FAILED, 0));
//				return;
//			}
//		}
//		gs.getClanService().discardTask(this.id, taskId, clanId, task.useGenDisciple, new ClanService.ClanTaskDiscardCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int newTaskId)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						task.jydzs.clear();
//						task.needTime = 0;
//						task.startTime = 0;
//						task.useGenDisciple = 0;
//						task.frontTaskId = taskId;
//						Role.this.initClanTask(clanId, newTaskId);
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_discardtask_res(errCode, taskId));
//			}
//		});
//	}
//
//	//紫气阁->成员报告。同步宗门历史数据，任务与成员相关的。
//	public void syncClanHistory(int type, int clanId)
//	{
//		if (type <= 0 || clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_synchistory_res(GameData.emptyList()));
//			return;
//		}
//		gs.getClanService().syncClanHistory(this.id, type, clanId, new ClanService.ClanSyncHistoryCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.DBClanHistory> historys)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_synchistory_res(historys));
//			}
//		});
//	}
//
//	//做任务是需要消耗普通弟子的，宗门回复消耗掉的普通弟子
//	public void recoverGenDisciple()
//	{
//		gs.getClanService().recoverGenDisciple(this.id, new ClanService.RecoverGenDiscipleCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int genDisciple)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_recovergendisciple_res(errCode, genDisciple));
//			}
//		});
//	}
//
//
//
//	/////////////////////////////////////////宗门占矿//////////////////////////////////
//	
//	//宗门矿升级(药草，玄铁，村庄)
//	public void clanOreBuildUpLevel(int type, int level)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_ORE_BUILD_UPLEVEL);
//		tlogEvent.setArg(type, level);
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (type < Clan.CLAN_ORE_TYPE_IRON || type > Clan.CLAN_ORE_STATE_ROB || level <= 0 || clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_orebuilduplevel_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		SBean.ClanOccupyOreLvlCFGS levelCFGS = clanCFGS.occupyOre.oreLvl.get(level);
//		if (levelCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_orebuilduplevel_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		final SBean.DummyGoods good = GameData.getInstance().getClanUpLevelDummyGood(type, levelCFGS);
//		if (good != null)
//		{
//			synchronized (this)
//			{
//				if (!this.containsEnoughGameItem(good.id, good.count))
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_orebuilduplevel_res(GameData.PROTOCOL_OP_CLAN_ITEMLACK));
//					return;
//				}
//				this.delGameItem(good.id, good.count, tlogEvent.getGameItemRecords());
//			}
//		}else
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_orebuilduplevel_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		gs.getClanService().clanOreBuildUpLevel(this.id, type, level, new ClanService.ClanOreBuildUpLevelCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				synchronized (Role.this)
//				{
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS && good != null)
//					{
//						Role.this.addGameItem(GameData.getInstance().toGameItem(good.id, good.count), tlogEvent.getGameItemRecords());
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_orebuilduplevel_res(errCode));
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//	}
//
//	//同步宗门矿建筑的详细信息，同步占矿信息
//	public void syncClanOre(int clanId)
//	{
//		if (clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_syncore_res(GameData.emptyList()));
//			return;
//		}
//		gs.getClanService().syncClanOre(this.id, clanId, new ClanService.SyncClanOreCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.DBClanOre> ores)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_syncore_res(ores));
//			}
//		});
//	}
//
//	//宗门占矿
//	public void clanOreOccupy(int clanId, int type, Set<Integer> pets)
//	{
//		final SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || clanId <= 0 || type < Clan.CLAN_ORE_TYPE_IRON || type > Clan.CLAN_ORE_STATE_ROB || pets.size() <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupy_res(GameData.PROTOCOL_OP_FAILED, 0));
//			return;
//		}
//		synchronized (this)
//		{
//			int errCode = GameData.getInstance().checkCondClanOreOccupy(pets, clanId, type, clanCFGS.occupyOre.petLevel, this.getUseableVipLvl(), this.clanData.occupyOres, this.activePets);
//			if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupy_res(errCode, 0));
//				return;
//			}
//		}
//
//		gs.getClanService().clanOreOccupy(this.id, type, clanId, new ClanService.ClanOreOccupyCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				int nowTime = GameTime.getTime();
//				synchronized (Role.this)
//				{
//					Role.this.syncAddAttackPoint(nowTime);
//					if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//					{
//						Role.this.clanData.occupyOres.add(new SBean.DBOreRobTeam(nowTime, type, pets, 0, clanId, (byte) 1, 0));
//						Role.this.logDailyTask(GameData.DAILY_TASK_ID_OCCUPY_CLAN_ORE, 1);
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupy_res(errCode, nowTime));
//			}
//		});
//	}
//
//	//同步夺矿的攻击点数，自动回复，由相关操作触发
//	public void syncAddAttackPoint(int startTime)
//	{
//		if (this.clanData.data.attackPoint >= GameData.getInstance().getClanCFGS().robOre.pointUp)
//		{
//			return;
//		}
//		int attackPoint = (int) Math.floor((startTime - this.clanData.data.attackPointLastTime) / 3600);
//		if (attackPoint <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clan_add_attackpoint(this.clanData.data.attackPoint));
//			return;
//		}
//		this.clanData.data.attackPoint += attackPoint;
//		if (this.clanData.data.attackPoint > GameData.getInstance().getClanCFGS().robOre.pointUp)
//			this.clanData.data.attackPoint = GameData.getInstance().getClanCFGS().robOre.pointUp;
//
//		this.clanData.data.attackPointLastTime = startTime;
//		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clan_add_attackpoint(this.clanData.data.attackPoint));
//	}
//
//
//	//获取要夺取矿的信息，搜索到矿后需要服务器记录10分钟。这期间客户端可以获取到当前的这个矿
//	public SBean.DBOreRobTeam getOreRobTeam(int clanId, int type)
//	{
//		SBean.DBOreRobTeam oreRobTeam = null;
//		for (SBean.DBOreRobTeam ore : this.clanData.occupyOres)
//		{
//			if (ore.clanId == clanId && ore.oreType == type)
//			{
//				oreRobTeam = ore;
//			}
//		}
//		return oreRobTeam;
//	}
//
//	//删除要夺取的矿
//	private void removeOreRobTeam(int clanId, int type)
//	{
//		Iterator<SBean.DBOreRobTeam> it = this.clanData.occupyOres.iterator();
//		while(it.hasNext())
//		{
//			SBean.DBOreRobTeam ore = it.next();
//			if(ore.clanId == clanId && ore.oreType == type)
//			{
//				it.remove();
//			}
//		}
//	}
//
//	//添加矿
//	public int addClanOre(int type, int value)
//	{
//		int curOreValue = -1;
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ADD_CLAN_ORE);
//		tlogEvent.setArg(type, value);
//		if (type == Clan.CLAN_ORE_TYPE_IRON)
//		{
//			addClanXuantie(value, tlogEvent.getGameItemRecords());
//			curOreValue = getClanXuantie();
//		}
//		else if (type == Clan.CLAN_ORE_TYPE_HERB)
//		{
//			addClanYaocao(value, tlogEvent.getGameItemRecords());
//			curOreValue = getClanYaocao();
//		}
//		else if (type == Clan.CLAN_ORE_TYPE_THORPE)
//		{
//			this.addCoin(value, true, tlogEvent.getGameItemRecords());
//			curOreValue = Role.this.getCoin(true);
//		}
//		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
//		return curOreValue;
//	}
//
//	//矿发生改变通知客户端
//	public void syncAddOre(int type, int value)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SYNC_ADD_ORE);
//		tlogEvent.setArg(type, value);
//		if (type == Clan.CLAN_ORE_TYPE_IRON)
//		{
//			int add = addClanXuantie(value, tlogEvent.getGameItemRecords());
//			if (add > 0)
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_ore(type, value));
//		}
//		else if (type == Clan.CLAN_ORE_TYPE_HERB)
//		{
//			int add = addClanYaocao(value, tlogEvent.getGameItemRecords());
//			if (add > 0)
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_add_ore(type, value));
//		}
//		else if (type == Clan.CLAN_ORE_TYPE_THORPE)
//		{
//			Role.this.syncAddCoin(value, false, tlogEvent.getGameItemRecords());
//		}
//		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
//	}
//
//	//占矿完成
//	public void clanOreOccupyFinish(int clanId, int type)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_ORE_OCCUPY_FINISH);
//		tlogEvent.setArg(clanId, type);
//		if (clanId <= 0 || type < Clan.CLAN_ORE_TYPE_IRON || type > Clan.CLAN_ORE_TYPE_THORPE)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreoccupyfinish_res(GameData.PROTOCOL_OP_FAILED, 0, 0));
//			return;
//		}
//		synchronized (this)
//		{
//			if (! GameData.getInstance().checkCondClanOreOccupyFinish(clanId, type, this.clanData.occupyOres))
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreoccupyfinish_res(GameData.PROTOCOL_OP_FAILED, 0, 0));
//				return;
//			}
//		}
//
//		gs.getClanService().clanOreOccupyFinish(this.id, type, clanId, new ClanService.ClanOreOccupyFinishCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int clanLevel)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						int nowTime = GameTime.getTime();
//						SBean.DBOreRobTeam oreRobTeam = getOreRobTeam(clanId, type);
//						SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//						if (clanCFGS == null || oreRobTeam == null)
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupyfinish_res(GameData.PROTOCOL_OP_FAILED, 0, 0));
//							return;
//						}
//
//						SBean.ClanOccupyOreLvlCFGS levelCFGS = clanCFGS.occupyOre.oreLvl.get(clanLevel - 1);
//						if (levelCFGS == null)
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupyfinish_res(GameData.PROTOCOL_OP_FAILED, 0, 0));
//							return;
//						}
//
//						if (nowTime - oreRobTeam.startTime < clanCFGS.occupyOre.finishTime)
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupyfinish_res(GameData.PROTOCOL_OP_CLAN_CDTIME, 0, 0));
//							return;
//						}
//
//						int oreValue = GameData.getInstance().getClanOreBaseValue(type, clanLevel, oreRobTeam.harryCount);
//						int diamondValue = oreRobTeam.isFail > 0 ? GameRandom.getRandInt(clanCFGS.occupyOre.failDiamondDown, clanCFGS.occupyOre.faildiamondUp) : GameRandom.getRandInt(clanCFGS.occupyOre.successDiamondDown, clanCFGS.occupyOre.successDiamondUp);
//
//						Role.this.syncAddDiamond(diamondValue, false, tlogEvent.getGameItemRecords());
//						Role.this.syncAddOre(type, oreValue); //绑定false， true 非绑定
//						Role.this.removeOreRobTeam(clanId, type);
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupyfinish_res(errCode, oreValue, diamondValue));
//					}
//				}
//				else
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreoccupyfinish_res(errCode, -1, -1));
//				}
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//
//	}
//
//	//获取矿，内部获取数据函数
//	public SBean.DBOreRobTeamGlobal getOreRobTeamGlobal()
//	{
//		SBean.DBOreRobTeamGlobal oreInfo = null;
//		if (!this.clanData.occupyOres.isEmpty())
//		{
//			int index = GameRandom.getRandInt(0, this.clanData.occupyOres.size());
//			SBean.DBOreRobTeam oreTeam = this.clanData.occupyOres.get(index);
//			List<SBean.PetOverview> petList = new ArrayList<SBean.PetOverview>();
//			for (int petId : oreTeam.pets)
//			{
//				petList.add(this.getPetOverviewWithoutLock(petId));
//			}
//			oreInfo = new SBean.DBOreRobTeamGlobal(oreTeam.oreType, this.id, 0, oreTeam.clanId, this.name, oreTeam.startTime, this.transformLevel, this.roleProperties.getRoleFightPower(), this.level, petList, this.headIcon);
//		}
//		return oreInfo;
//	}
//
//	//添加夺取矿记录
//	public void addClanOreRecord(int oreType, int serverId, int roleId)
//	{
//		this.clanData.robOreRecords.add(new SBean.DBRobOreRecord(serverId, oreType, roleId, GameTime.getTime()));
//	}
//
//	//夺矿，搜索当前的占矿，随机搜索
//	public void clanSearchOre(int clanId)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_SEARCH_ORE);
//		tlogEvent.setArg(clanId);
//		int useCoin = GameData.getTimesCost(GameData.getInstance().getClanCFGS().robOre.searchCoin, this.clanData.data.daySearchCount + 1);
//		if (!this.canUseCoin(useCoin, false))
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(null));
//			return;
//		}
//
//		gs.getClanService().clanSearchOre(this.id, this.level, new ClanService.ClanSearchOreCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.DBOreRobTeamGlobal ore)
//			{
//				if (ore == null)
//				{
//					Integer memberId = gs.getLoginManager().getRandomLevelRole(Role.this.level - 1, Role.this.level + 1);
//					if (memberId == null || Role.this.id == memberId)
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(null));
//						return;
//					}
//					Role role = gs.getLoginManager().getOnGameRole(memberId);
//					if (role == null)
//					{
//						gs.getLoginManager().getRoleClanOre(memberId, new LoginManager.GetRoleClanOreCallback()
//						{
//							@Override
//							public void onCallback(SBean.DBOreRobTeamGlobal ore)
//							{
//								if (ore != null)
//								{
//									ore.serverId = gs.getConfig().id;
//									if (GameData.getInstance().checkClanOreValidity(ore.oreType, ore.serverId, ore.roleId, Role.this.clanData.robOreRecords))
//									{
//										Role.this.clanData.data.daySearchCount++;
//										Role.this.useCoin(useCoin, false, tlogEvent.getGameItemRecords());
//										//Role.this.initClanOreRobFight(ore);
//										ore.startTime = GameTime.getTime();
//										Role.this.initClanFightDataByOre(ore);
//										Role.this.clanFightData.clanId = clanId;
//										gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(ore));
//									}
//									else
//									{
//										gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(null));
//									}
//								}
//								else
//								{
//									gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(ore));
//								}
//
//								return;
//							}
//						});
//					}
//					else
//					{
//						SBean.DBOreRobTeamGlobal tmpOre = null;
//						if (!role.clanData.occupyOres.isEmpty())
//						{
//							tmpOre = role.getOreRobTeamGlobal();
//							tmpOre.serverId = gs.getConfig().id;
//							if (GameData.getInstance().checkClanOreValidity(tmpOre.oreType, tmpOre.serverId, tmpOre.roleId, Role.this.clanData.robOreRecords))
//							{
//								Role.this.clanData.data.daySearchCount++;
//								Role.this.useCoin(useCoin, false, tlogEvent.getGameItemRecords());
//								tmpOre.startTime = GameTime.getTime();
//								Role.this.initClanFightDataByOre(tmpOre);
//								Role.this.clanFightData.clanId = clanId;
//								gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(tmpOre));
//							}
//							else
//							{
//								gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(null));
//							}
//						}
//						else
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(null));
//						}
//					}
//				}
//				else
//				{
//					if (GameData.getInstance().checkClanOreValidity(ore.oreType, ore.serverId, ore.roleId, Role.this.clanData.robOreRecords))
//					{
//						Role.this.clanData.data.daySearchCount++;
//						Role.this.useCoin(useCoin, false, tlogEvent.getGameItemRecords());
//						//Role.this.initClanOreRobFight(ore);
//						ore.startTime = GameTime.getTime();
//						Role.this.initClanFightDataByOre(ore);
//						Role.this.clanFightData.clanId = clanId;
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(ore));
//					}
//					else
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_searchore_res(null));
//					}
//				}
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//			}
//		});
//	}
//
//	//客户端打开夺矿页面向服务器发送 查看是否有上次搜索到的矿， 搜索到的矿保存10分钟
//	public synchronized SBean.DBOreRobTeamGlobal syncLastSearchOre(int clanId)
//	{
//		this.changeClanAttackPoint();
//		SBean.DBOreRobTeamGlobal ore = null;
//		if (clanId != this.clanFightData.clanId)
//		{
//			this.clanFightData.oreEnemy = null;
//		}
//		else
//		{
//			if (this.clanFightData.oreEnemy != null)
//			{
//				if (GameTime.getTime() - this.clanFightData.oreEnemy.startTime < 10 * 60)
//				{
//					ore = this.clanFightData.oreEnemy;
//				}
//			}
//		}
//
//		return ore;
//	}
//
//	//获取自己当前的占矿信息
//	public void clanSyncSelfOccupyOre(int clanId)
//	{
//		synchronized (this)
//		{
//			Map<Integer, SBean.DBOreRobTeam> result = new TreeMap<Integer, SBean.DBOreRobTeam>();
//			for (SBean.DBOreRobTeam ore : this.clanData.occupyOres)
//			{
//				if(clanId == ore.clanId)
//					result.put(ore.oreType, ore);
//			}
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_syncselfoccupyore_res(result));
//		}
//	}
//
//	// 获取宗主的佣兵， 夺矿有借宗主的佣兵需求
//	public void clanOreOwnerPetSync(int clanId)
//	{
//		final SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreownerpetsync_res(GameData.PROTOCOL_OP_FAILED, null));
//			return;
//		}
//		gs.getClanService().clanOwnerPetSync(this.id, clanId, new ClanService.ClanOreOwnerPetSyncCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int roleId, List<SBean.PetOverview> pets)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					if (roleId == 0)//跨服
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreownerpetsync_res(errCode, pets));
//					}
//					else
//					//本服
//					{
//						Role role = gs.getLoginManager().getOnGameRole(roleId);
//						if (role != null)
//						{
//							List<SBean.PetOverview> petList = new ArrayList<SBean.PetOverview>();
//							synchronized (role)
//							{
//								role.activePets.values().stream().filter(pet -> pet.fightPet.level >= clanCFGS.occupyOre.petLevel).forEach(pet -> petList.add(role.getPetOverviewWithoutLock(pet.fightPet.id)));
//							}
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreownerpetsync_res(errCode, petList));
//						}
//						else
//						{
//							gs.getLoginManager().getRoleAndPetOverview(roleId, new LoginManager.GetRoleAndPetOverviewCallback()
//							{
//								@Override
//								public void onCallback(SBean.RoleOverview overview, List<SBean.PetOverview> petOverviews)
//								{
//									List<SBean.PetOverview> petList = new ArrayList<SBean.PetOverview>();
//									petOverviews.stream().filter(ov -> ov.level >= clanCFGS.occupyOre.petLevel).forEach(ov -> petList.add(ov));
//									gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreownerpetsync_res(errCode, petList));
//								}
//							});
//						}
//					}
//				}
//				else
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreownerpetsync_res(errCode, null));
//				}
//			}
//		});
//	}
//
//	// 借宗主的佣兵
//	public void clanOreBorrowPet(int clanId, int petId)
//	{
//		final SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || clanId <= 0 || petId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreborrowpet_res(GameData.PROTOCOL_OP_FAILED, -1));
//			return;
//		}
//
//		gs.getClanService().clanOreBorrowPet(this.id, clanId, petId, new ClanService.ClanOreBorrowPetCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int serverId, int roleId)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					if (roleId != 0)
//					{
//						Role role = gs.getLoginManager().getOnGameRole(roleId);
//						if (role != null)
//						{
//							synchronized (role)
//							{
//								SBean.DBPet pet = role.activePets.get(petId);
//								if (pet == null || pet.fightPet.level < clanCFGS.occupyOre.petLevel)
//								{
//									gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreborrowpet_res(GameData.PROTOCOL_OP_FAILED, -1));
//									return;
//								}
//								//Role.this.clanOreRobFight.ownerPet = petId;
//								//Role.this.clanOreRobFight.ownerId = roleId;
//								Role.this.clanFightData.ownerId = roleId;
//								Role.this.clanFightData.ownerPet = petId;
//								gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreborrowpet_res(GameData.PROTOCOL_OP_SUCCESS, petId));
//							}
//						}
//						else
//						{
//							gs.getLoginManager().getRoleAndPetOverview(roleId, new LoginManager.GetRoleAndPetOverviewCallback()
//							{
//								@Override
//								public void onCallback(SBean.RoleOverview overview, List<SBean.PetOverview> petOverviews)
//								{
//									int result = GameData.PROTOCOL_OP_FAILED;
//									if (petOverviews.size() > 0)
//									{
//										for (SBean.PetOverview petOverview : petOverviews)
//										{
//											if (petOverview.id == petId && petOverview.level >= clanCFGS.occupyOre.petLevel)
//											{
//												result = GameData.PROTOCOL_OP_SUCCESS;
//												//Role.this.clanOreRobFight.ownerPet = petId;
//												//Role.this.clanOreRobFight.ownerId = roleId;
//												Role.this.clanFightData.ownerId = roleId;
//												Role.this.clanFightData.ownerPet = petId;
//												break;
//											}
//										}
//									}
//									gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreborrowpet_res(result, petId));
//								}
//							});
//						}
//					}
//					else
//					{
//						//Role.this.clanOreRobFight.ownerPet = petId;
//						//Role.this.clanOreRobFight.ownerId = roleId;
//						Role.this.clanFightData.ownerId = roleId;
//						Role.this.clanFightData.ownerPet = petId;
//					}
//				}
//				else
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreborrowpet_res(errCode, -1));
//				}
//
//			}
//		});
//	}
//
//	//取消向宗主借的佣兵
//	public void clanOreCancelBorrowPet(int clanId, int petId)
//	{
//		if (clanId <= 0 || petId != this.clanFightData.ownerId)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_orecancelborrowpet_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		gs.getClanService().clanOreBorrowPet(this.id, clanId, petId, new ClanService.ClanOreBorrowPetCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, int serverId, int roleId)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					Role.this.clanFightData.ownerId = 0;
//					Role.this.clanFightData.ownerPet = 0;
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_orecancelborrowpet_res(errCode));
//			}
//		});
//	}
//
//
//	//夺矿开始，客户端触发
//	public void clanOreHarry(int clanId, int serverId, int memberId, int oreType, List<Integer> pets, int ownerPet)
//	{
//		final SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || this.clanFightData.oreEnemy == null || clanId <= 0 || memberId <= 0 || serverId <= 0 || oreType < Clan.CLAN_ORE_TYPE_IRON || oreType > Clan.CLAN_ORE_STATE_ROB)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		synchronized (this)
//		{
//			if (! GameData.getInstance().checkClanOreHarry(pets, ownerPet, clanCFGS.robOre.petLevel, this.activePets, this.clanFightData.ownerPet))
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//			if (this.clanData.data.attackPoint < clanCFGS.robOre.usePoint)
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//		}
//
//		gs.getClanService().clanOreHarry(this.id, clanId, serverId, memberId, oreType, new ClanService.ClanOreHarryCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int owner, int oreLevel, SBean.BattleArray ba)
//			{
//				if (errCode == GameData.PROTOCOL_OP_FAILED)
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreharry_res(errCode));
//					return;
//				}
//				Role.this.clanFightData.oreLevel = oreLevel;
//				final Set<Integer> petSet = new TreeSet<Integer>(pets);
//				if (ownerPet > 0)
//				{
//					Role.this.clanOreHarryOwnerPetFight(Role.this.clanFightData.ownerId, Role.this.clanFightData.ownerPet, memberId, petSet, clanId, oreType, serverId);
//				}
//				else
//				{
//					if (ba != null)
//					{
//						boolean ok = Role.this.startClanOreMapCopy(new TreeSet<Integer>(pets), null, null, ba);
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_SUCCESS));
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clanore_startattack_res(ok ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED));
//					}
//					else
//					{
//						gs.getLoginManager().getClanOreHarryEnemyFight(memberId, clanId, oreType, new LoginManager.GetClanOreHarryEnemyFightCallback()
//						{
//							@Override
//							public void onCallback(SBean.BattleArray ba)
//							{
//								if (ba == null)
//								{
//									gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_CLAN_ORE_OREEND));
//									return;
//								}
//								boolean ok = Role.this.startClanOreMapCopy(new TreeSet<Integer>(pets), null, null, ba);
//								gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_SUCCESS));
//								gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clanore_startattack_res(ok ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED));
//							}
//						});
//					}
//				}
//			}
//		});
//	}
//
//	//如果有借用的佣兵走此分支
//	public void clanOreHarryOwnerPetFight(int owner, int ownerPet, int memberId, Set<Integer> pets, int clanId, int oreType, int serverId)
//	{
//		gs.getLoginManager().getOnLoanPet(owner, ownerPet, new LoginManager.GetOnLoanPetCallback()
//		{
//
//			@Override
//			public void onCallback(SBean.FightPet ownerFightPet, SBean.PetHost ownerFightPetHost)
//			{
//				if (ownerFightPet == null || ownerFightPetHost == null)
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_FAILED));
//					return;
//				}
//				gs.getLoginManager().getClanOreHarryEnemyFight(memberId, clanId, oreType, new LoginManager.GetClanOreHarryEnemyFightCallback()
//				{
//
//					@Override
//					public void onCallback(SBean.BattleArray ba)
//					{
//						if (ba == null)
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_CLAN_ORE_OREEND));
//							return;
//						}
//						boolean ok = Role.this.startClanOreMapCopy(pets, ownerFightPet, ownerFightPetHost, ba);
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_oreharry_res(GameData.PROTOCOL_OP_SUCCESS));
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clanore_startattack_res(ok ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED));
//					}
//				});
//			}
//		});
//	}
//
//	//战斗开始 gameMap调用	
//	public synchronized void clanOreHarryFightStart(int startTime, Set<Integer> pets)
//	{
//		this.clanFightData.startTime = startTime;
//		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clanoremap_start());
//	}
//
//	//战斗结果数据 gameMap调用
//	public synchronized void clanOreHarryPopupResult(SBean.ClanOreBattleResult result)
//	{
//		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clanoremap_result(result.win, result.attack, result.defend));
//	}
//
//	//战斗结束数据 gameMap调用
//	public synchronized void clanOreHarryFightEnd(int endTime, boolean win, SBean.ClanOreBattleResult result)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_ORE_HARRY_FIGHT_END);
//		tlogEvent.setArg(endTime, this.clanFightData.oreLevel, win ? 1 : 0);
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		SBean.ClanOccupyOreLvlCFGS levelCFGS = clanCFGS.occupyOre.oreLvl.get(this.clanFightData.oreLevel - 1);
//		if (levelCFGS == null)
//			return;
//		this.clanData.data.attackPoint -= clanCFGS.robOre.usePoint;
//		//this.changeClanAttackPoint();
//		this.addClanOreRecord(this.clanFightData.oreEnemy.oreType, this.clanFightData.oreEnemy.serverId, this.clanFightData.oreEnemy.roleId);
//
//		final int oreBaseValue;
//		final float oreAddRate;
//		switch (this.clanFightData.oreEnemy.oreType)
//		{
//		case Clan.CLAN_ORE_TYPE_IRON:
//			oreBaseValue = clanCFGS.occupyOre.ironBaseValue;
//			oreAddRate = levelCFGS.ironAdditionRate;
//			break;
//		case Clan.CLAN_ORE_TYPE_HERB:
//			oreBaseValue = clanCFGS.occupyOre.herbBaseValue;
//			oreAddRate = levelCFGS.herbAdditionRate;
//			break;
//
//		case Clan.CLAN_ORE_TYPE_THORPE:
//			oreBaseValue = clanCFGS.occupyOre.thorpeBaseValue;
//			oreAddRate = levelCFGS.thorpeAdditionRate;
//			break;
//		default:
//			return;
//		}
//		final int oreValue;
//		final int diamondValue;
//		if (win)
//		{
//			int minute = (int) Math.ceil((int) Math.ceil((endTime - this.clanFightData.startTime) / 60) / 15);
//			oreValue = (int) (Math.ceil((int) Math.max(minute, 1) * oreBaseValue * (1 + oreAddRate) * clanCFGS.robOre.successRatio));
//			diamondValue = GameRandom.getRandInt(clanCFGS.robOre.diamondDown, clanCFGS.robOre.diamondDown);
//			//this.clanFightData.diamondValue = diamondValue;
//			//this.clanFightData.oreValue = oreValue;
//			this.syncAddDiamond(diamondValue, false, tlogEvent.getGameItemRecords());
//			this.syncAddOre(this.clanFightData.oreEnemy.oreType, oreValue);
//			this.clanFightData.win = 1;
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clanoremap_end(this.clanFightData.win, oreValue, this.clanFightData.oreEnemy.oreType, diamondValue));
//		}
//		else
//		{
//			this.clanFightData.win = 0;
//			oreValue = 0;
//			diamondValue = 0;
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clanoremap_end(0, 0, 0, 0));
//		}
//
//		gs.getLoginManager().exeCommonRoleVisitor(Role.this.clanFightData.oreEnemy.roleId, false, new LoginManager.CommonRoleVisitor()
//		{
//			@Override
//			public boolean visit(Role role, Role sameUserRole)
//			{
//				//role.clanOreHarryEnemySave(role, win, Role.this.clanOreRobFight.ore.oreType, Role.this.clanOreRobFight.ore.clanId, oreValue, diamondValue);
//				SBean.DBOreRobTeam oreRobTeam = role.getOreRobTeam(Role.this.clanFightData.oreEnemy.clanId, Role.this.clanFightData.oreEnemy.oreType);
//				if (oreRobTeam != null)
//				{
//					oreRobTeam.harryCount++;
//					oreRobTeam.isFail = win ? (byte) 1 : 0;
//				}
//
//				SBean.DBRobOreLog robOreLog = new SBean.DBRobOreLog(Role.this.name, Role.this.clanFightData.startTime, Role.this.clanFightData.oreEnemy.oreType, oreValue, diamondValue, oreRobTeam.isFail, (byte) 0);
//				if (role.clanData.robOreLogs.size() >= 10)
//					role.clanData.robOreLogs.remove(0);
//				role.clanData.robOreLogs.add(robOreLog);
//				Role.this.clanFightData.oreEnemy = null;
//				Role.this.clanFightData.ownerPet = 0;
//				Role.this.clanFightData.ownerId = 0;
//				Role.this.clanFightData.oreLevel = 0;
//				Role.this.clanFightData.startTime = 0;
//				return true;
//			}
//
//			@Override
//			public void onCallback(boolean success)
//			{
//
//			}
//		});
//		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
//	}
//
//	//初始化宗门战斗不存库数据  共享数据（夺矿与遭遇战）
//	private synchronized void initClanFightData()
//	{
//		this.clanFightData = new SBean.ClanFightCacheData(null, null, 0, 0, 0, 0, 0, 0, 0);
//	}
//
//	//初始化宗门之夺矿战
//	public synchronized boolean initClanFightDataByOre(SBean.DBOreRobTeamGlobal globalOre)
//	{
//		if (globalOre == null || this.clanFightData == null)
//			return false;
//		this.clanFightData.oreEnemy = globalOre.kdClone();
//		return true;
//	}
//
//	//初始化宗门之遭遇战
//	public synchronized boolean initClanFightDataByTask(SBean.DBTaskEnemy taskEnemy)
//	{
//		if (taskEnemy == null || this.clanFightData == null)
//			return false;
//		this.clanFightData.taskEnemy = taskEnemy.kdClone();
//		return true;
//	}
//
//	//夺矿成功后拿奖励， 没有使用，后来改成战斗结束后自动加奖励
//	public void clanOreHarryRewards()
//	{
//		int resule = GameData.PROTOCOL_OP_FAILED;
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || this.clanFightData == null || this.clanFightData.win <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreharryrewards_res(resule));
//			return;
//		}
//
//		if (GameTime.getTime() - this.clanFightData.startTime > clanCFGS.robOre.searchTime * 60)
//		{
//			resule = GameData.PROTOCOL_OP_CLAN_TIMEOUT;
//		}
//		else
//		{
//			//this.syncAddDiamond(this.clanFightData.diamondValue, true);
//			//this.syncAddOre(this.clanFightData.oreEnemy.oreType, this.clanFightData.oreValue);
//			resule = GameData.PROTOCOL_OP_SUCCESS;
//		}
//
//		//this.initClanOreFightData(null);
//		this.clanFightData.oreEnemy = null;
//		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_oreharryrewards_res(resule));
//	}
//
//	//购买行动力
//	public void clanBuyDoPower(int level)
//	{
//		final SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		final SBean.VipCFGS vipCFGS = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
//		if (clanCFGS == null || vipCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_buydopower_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		SBean.Counter counter;
//		synchronized (this)
//		{
//			if (this.clanData.data.dayBuyPowerCount >= vipCFGS.dayMaxBuyDopowerTimes)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_buydopower_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//			if (!this.canUseDiamond(clanCFGS.supplement.doPowerBuyDiamond.get(this.clanData.data.dayBuyPowerCount), true))
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_buydopower_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//			//this.useDiamond(clanCFGS.supplement.doPowerBuyDiamond.get(this.clanData.data.dayBuyPowerCount), true);
//			counter = this.lockDiamond(clanCFGS.supplement.doPowerBuyDiamond.get(this.clanData.data.dayBuyPowerCount), true);
//		}
//		gs.getClanService().clanBuyDoPower(this.id, level, new ClanService.ClanBuyDoPowerCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_BUY_DO_POWER);
//				tlogEvent.setArg(counter.fvalue, counter.rvalue);
//				synchronized (Role.this)
//				{
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						//Role.this.addDiamond(clanCFGS.supplement.doPowerBuyDiamond.get(Role.this.clanData.data.dayBuyPowerCount), true);
//						Role.this.useLockedDiamond(counter, true, tlogEvent.getGameItemRecords());
//					}
//					else
//					{
//						Role.this.clanData.data.dayBuyPowerCount++;
//						Role.this.useLockedDiamond(counter, false, tlogEvent.getGameItemRecords());
//					}
//				}
//				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_buydopower_res(errCode));
//			}
//		});
//	}
//
//	//获取精英弟子，和客户端约定的
//	public void clanGetEliteDisciple(int clanId)
//	{
//		gs.getClanService().clanGetEliteDisciple(this.id, clanId, new ClanService.ClanGetEliteDiscipleCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.DBClanEliteDisciple> eds)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getelitedisciple_res(eds));
//			}
//		});
//	}
//
//	//同步夺矿攻击点触发函数
//	public void changeClanAttackPoint()
//	{
//		synchronized (this)
//		{
//			syncAddAttackPoint(GameTime.getTime());
//		}
//	}
//
//	/*
//	 * public void initClanOreRobFight(SBean.DBOreRobTeamGlobal ore) {
//	 * this.clanOreRobFight = new SBean.ClanOreRobFightData(ore,0,0,0,0,0); }
//	 */
//
//	//获取宗门占矿记录信息
//	public synchronized List<SBean.DBRobOreLog> getClanRobOreLog()
//	{
//		List<SBean.DBRobOreLog> result = new ArrayList<SBean.DBRobOreLog>();
//		result.addAll(this.clanData.robOreLogs);
//		return result;
//	}
//
//	//被攻击后，领取赠送的攻击点
//	public synchronized int clanRobOreSuccessRewards()
//	{
//		List<SBean.DBRobOreLog> notGiveList = new ArrayList<SBean.DBRobOreLog>();
//		for (SBean.DBRobOreLog log : this.clanData.robOreLogs)
//		{
//			if (log.state == 0)
//				notGiveList.add(log);
//		}
//		if (notGiveList.size() <= 0)
//			return GameData.PROTOCOL_OP_FAILED;
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null)
//			return GameData.PROTOCOL_OP_FAILED;
//
//		this.clanData.data.attackPoint += clanCFGS.robOre.giveEnemyPoint * notGiveList.size();
//		for (SBean.DBRobOreLog log : notGiveList)
//		{
//			log.state = 1;
//		}
//		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_clan_add_attackpoint(this.clanData.data.attackPoint));
//		return GameData.PROTOCOL_OP_SUCCESS;
//	}
//
//	//获取宗门排行榜 gType服务器类型，同服和跨服排行， rankType排行榜类型 （正，邪， 女， 新）
//	public void getClanBaseRank(int gType, int clanId, int rankType)
//	{
//		if (clanId <= 0 || rankType <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getbaserank_res(GameData.emptyList()));
//			return;
//		}
//		gs.getClanService().getClanBaseRank(this.id, gType, clanId, rankType, new ClanService.ClanGetBaseRankCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.ClanRankBaseInfo> ranks)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getbaserank_res(ranks));
//			}
//		});
//	}
//	
//	// 通知宗门服务器修改宗门排行榜(等级，战力，魅力值)变化会调用此函数
//	public void modifyClanRank()
//	{
//		if(this.clanData.data.isInClan != 1)
//			return ;
//		int fightPower = this.roleProperties.getRoleFightPower();
//		//女宗的标志位使用新加的字段 this.clanData.data.isWomanClan
//		int charm = this.clanData.data.isWomanClan == 1 ? this.friend.getCharm() : Clan.CLAN_DEFAULT_RANK_CHARM;
//		gs.getClanService().modifyClanRank(this.id, this.level, fightPower, charm, new ClanService.ClanModifyRankCallback(){
//
//			@Override
//			public void onCallback(int errCode) {
//				
//			}
//		});
//	}
//
//	//-----------------------------------------------------------------------------------------------------------------------
//
//	public synchronized SBean.DBClanBattleData clanGetBattleTeam()
//	{
//		return clanData.battle;
//	}
//
//	//宗门战之宗门迁移
//	public void clanMovePosition()
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_moveposition_res(GameData.PROTOCOL_OP_FAILED, 0, 0));
//			return;
//		}
//		if (this.clanData.clanBattleData != null && (this.clanData.clanBattleData.battleType != 0 || this.clanData.clanBattleData.defend.size() > 0))
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_moveposition_res(GameData.PROTOCOL_OP_CLAN_BATTLEING, 0, 0));
//			return;
//		}
//		SBean.Counter counter;
//		final int diamond = GameData.getTimesCost(clanCFGS.others.moveCost, this.clanData.data.dayMoveCount + 1);
//		synchronized (this)
//		{
//			if (!this.canUseDiamond(diamond, false))
//			{
//				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_moveposition_res(GameData.PROTOCOL_OP_CLAN_DIAMOND, 0, 0));
//				return;
//			}
//			counter = this.lockDiamond(diamond, false);
//			this.clanData.data.dayMoveCount++;
//		}
//		gs.getClanService().clanMovePosition(this.id, new ClanService.ClanMovePositionCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int x, int y)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_moveposition_res(errCode, x, y));
//				synchronized (Role.this)
//				{
//					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_MOVE_POSITION);
//					if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//					{
//						tlogEvent.setArg(diamond, counter.fvalue, counter.rvalue, Role.this.clanData.data.dayMoveCount);
//						Role.this.useLockedDiamond(counter, true, tlogEvent.getGameItemRecords());
//						Role.this.clanData.data.dayMoveCount--;
//					}
//					else
//					{
//						tlogEvent.setArg(diamond, counter.fvalue, counter.rvalue);
//						Role.this.useLockedDiamond(counter, false, tlogEvent.getGameItemRecords());
//					}
//					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
//				}
//			}
//		});
//	}
//
//	//宗门战上阵攻击队伍
//	public void setClanAttackTeam(Map<Integer, Integer> pets)
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || pets.size() <= 0 || pets.size() > clanCFGS.fightTeam.teamSize)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setattackteam_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		if (this.clanData.clanBattleData != null)
//		{
//			if (this.clanData.clanBattleData.battleType == Clan.CLAN_BATTLE_TYPE_ATTACK)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setattackteam_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//		}
//		synchronized (this)
//		{
//			for (Map.Entry<Integer, Integer> entry : pets.entrySet())
//			{
//				int pos = entry.getKey();
//				if (pos <= 0 || pos > clanCFGS.fightTeam.teamSize)
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setattackteam_res(GameData.PROTOCOL_OP_FAILED));
//					return;
//				}
//				int petId = entry.getValue();
//				if (petId > 0)
//				{
//					SBean.DBPet pet = this.activePets.get(petId);
//					if (pet == null || pet.fightPet.level < GameData.getInstance().getClanCFGS().fightTeam.petMinLvl || this.clanData.battle.defendPet.containsValue(petId))
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setattackteam_res(GameData.PROTOCOL_OP_FAILED));
//						return;
//					}
//				}
//			}
//		}
//		gs.getClanService().setAttackTeam(this.id, pets, new ClanService.ClanSetAttackTeamCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						for (Map.Entry<Integer, Integer> entry : pets.entrySet())
//						{
//							if (entry.getValue() == 0)
//								Role.this.clanData.battle.attackPet.remove(entry.getKey());
//							else
//								Role.this.clanData.battle.attackPet.put(entry.getKey(), entry.getValue());
//						}
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setattackteam_res(errCode));
//			}
//		});
//	}
//
//	//宗门战上阵防守队伍
//	public void setClanDefendTeam(Map<Integer, Integer> pets)
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || pets.size() <= 0 || pets.size() > clanCFGS.fightTeam.teamSize)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setdefendteam_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		synchronized (this)
//		{
//			for (Map.Entry<Integer, Integer> entry : pets.entrySet())
//			{
//				int pos = entry.getKey();
//				if (pos <= 0 || pos > clanCFGS.fightTeam.teamSize)
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setdefendteam_res(GameData.PROTOCOL_OP_FAILED));
//					return;
//				}
//				int petId = entry.getValue();
//				if (petId > 0)
//				{
//					SBean.DBPet pet = this.activePets.get(petId);
//					if (pet == null || pet.fightPet.level < GameData.getInstance().getClanCFGS().fightTeam.petMinLvl || this.clanData.battle.attackPet.containsValue(petId))
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setdefendteam_res(GameData.PROTOCOL_OP_FAILED));
//						return;
//					}
//				}
//			}
//		}
//		gs.getClanService().setDefendTeam(this.id, pets, new ClanService.ClanSetDefendTeamCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						for (Map.Entry<Integer, Integer> entry : pets.entrySet())
//						{
//							if (entry.getValue() == 0)
//								Role.this.clanData.battle.defendPet.remove(entry.getKey());
//							else
//								Role.this.clanData.battle.defendPet.put(entry.getKey(), entry.getValue());
//						}
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_setdefendteam_res(errCode));
//			}
//		});
//	}
//
//	//获取周围宗门的敌对和友善宗门
//	public void getNearbyClan()
//	{
//		gs.getClanService().getNearbyClan(this.id, new ClanService.GetNearbyClanCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.ClanBattleInfoRes selfClan, SBean.ClanBattleInfoRes enemyClan)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getnearbyclan_res(selfClan, enemyClan));
//			}
//		});
//	}
//
//	//宗门战寻找对手
//	public void findEnemyClan(int clanId)
//	{
//		if (clanId <= 0 || this.clanData.clanBattleData == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_findenemy_res(GameData.emptyList()));
//			return;
//		}
//		gs.getClanService().clanFindEnemy(this.id, clanId, new ClanService.ClanFindEnemyCallback()
//		{
//			@Override
//			public void onCallback(int errCode, List<SBean.ClanBattleInfoRes> clans)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_findenemy_res(clans));
//			}
//		});
//	}
//
//	//宗门战获取敌方战斗信息(error here)
//	public void clanBattleGetEnemy(int clanId)
//	{
//		if (clanId <= 0 || this.clanData.clanBattleData == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getenemy_res(null, null, null, 0, 0));
//			return;
//		}
//		List<SBean.PetOverview> selfPets = new ArrayList<SBean.PetOverview>();
//		synchronized (this)
//		{
//			for (int petId : this.clanData.battle.attackPet.values())
//			{
//				if (!this.activePets.containsKey(petId))
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getenemy_res(null, null, null, 0, 0));
//					return;
//				}
//				selfPets.add(this.getPetOverviewWithoutLock(petId));
//			}
//		}
//		final int xuantie = this.clanData.data.xuantie;
//		final int yaocao = this.clanData.data.yaocao;
//
//		gs.getClanService().clanGetEnemy(this.id, clanId, new ClanService.ClanGetEnemyCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int ownerId, List<SBean.PetOverview> enemyPets, SBean.RoleOverview overview)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					if (ownerId > 0)
//					{
//						gs.getLoginManager().getClanBattleEnemy(ownerId, new LoginManager.GetClanBattleEnemyCallback()
//						{
//							@Override
//							public void onCallback(List<SBean.PetOverview> enemyPets, SBean.RoleOverview overview)
//							{
//								if (enemyPets == null)
//									gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getenemy_res(null, null, null, 0, 0));
//								else
//									gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getenemy_res(overview, selfPets, enemyPets, xuantie, yaocao));
//							}
//						});
//					}
//					else // 使用onCallback中的数据。此时的数据为跨其它gs取得的Role数据。标记ownerId = 0或者ownerId < 0
//					{
//						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getenemy_res(overview, selfPets, enemyPets, xuantie, yaocao));
//					}
//				}
//				else
//				{
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_getenemy_res(null, null, null, 0, 0));
//				}
//			}
//		});
//	}
//
//	private SBean.ClanBattleInfo initClanBattleInfo()
//	{
//		return new SBean.ClanBattleInfo(0, "", "", 0, 0, 0, 0, 0, 0, 0, 0, new TreeMap<Integer, Integer>(), 0);
//	}
//
//	//初始化宗门战数据
//	public synchronized void initClanBattleData()
//	{
//		this.clanData.clanBattleData = new SBean.ClanBattleCacheData(0, new ArrayList<Integer>(), 0, initClanBattleInfo(), 0, 0, 0, 0, 0, 0, initClanBattleInfo(), initClanBattleInfo(), new HashMap<Integer, SBean.ClanBattleDefendDesc>(), new HashMap<Integer, SBean.ClanBattleHelpDesc>(), new ArrayList<SBean.PetOverview>(), 0);
//
//	}
//
//	//宗门战进攻,要进攻的宗门id
//	public void clanBattleAttack(int clanId)
//	{
//		Map<Integer, SBean.PetOverview> petsMap = new TreeMap<Integer, SBean.PetOverview>();
//		synchronized (this)
//		{
//			if (clanId <= 0 || this.clanData.battle.attackPet.size() <= 0 || this.clanData.clanBattleData == null)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleattack_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//			if (this.clanData.clanBattleData.battleType == Clan.CLAN_BATTLE_TYPE_ATTACK)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleattack_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//			for (Map.Entry<Integer, Integer> entry : this.clanData.battle.attackPet.entrySet())
//			{
//				petsMap.put(entry.getKey(), this.getPetOverviewWithoutLock(entry.getValue()));
//			}
//		}
//		// 发送到宗门服务器，查找我攻击宗门的宗主信息
//		gs.getClanService().clanBattleAttack(this.id, clanId, petsMap, this.level, (int) this.BWType, new ClanService.ClanBattleAttackCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int cdTime, SBean.ClanBattleInfo self, SBean.ClanBattleInfo enemy, List<Integer> value, List<SBean.PetOverview> pets)
//			{
//				synchronized (Role.this)
//				{
//					if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//					{
//						Role.this.clanData.clanBattleData.helpClan = 0;
//						Role.this.clanData.clanBattleData.attackTime = GameTime.getTime();
//						Role.this.clanData.clanBattleData.cdTime = cdTime; // delt seconds
//						Role.this.clanData.clanBattleData.attack = enemy; // 我攻击的人
//						Role.this.clanData.clanBattleData.selfInfo = self;
//						Role.this.clanData.clanBattleData.selfInfo.pets.putAll(Role.this.clanData.battle.attackPet);
//						Role.this.clanData.clanBattleData.prestige = value.get(0);
//						Role.this.clanData.clanBattleData.xuantie = value.get(1);
//						Role.this.clanData.clanBattleData.yaocao = value.get(2);
//						Role.this.clanData.clanBattleData.battleType = Clan.CLAN_BATTLE_TYPE_ATTACK;
//						Role.this.clanData.clanBattleData.enemyPets.addAll(pets);// 被攻击方的佣兵
//					}
//				} 
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleattack_res(errCode));
//			}
//		});
//	}
//
//	// 刷新宗门战数据中的进攻、防守、求援 (per minute)
//	public synchronized void onClanBattleDataRefresh()
//	{
//		if (this.clanData.clanBattleData == null)
//			return;
//		SBean.ClanCFGS cfg = GameData.getInstance().getClanCFGS();
//		if (this.clanData.clanBattleData.battleType == Clan.CLAN_BATTLE_TYPE_ATTACK)
//		{
//			if (GameTime.getTime() - this.clanData.clanBattleData.attackTime - this.clanData.clanBattleData.cdTime > cfg.normalBattle.expiredTime)
//			{
//				if (this.clanData.clanBattleData.isInBattleMap == 0)
//				{
//					addClanBattleAttackLog(SBean.DBClanBattleLog.EventAttackTimeout, this.clanData.clanBattleData.attack.clanName, this.clanData.clanBattleData.attack.bwType, (byte) -1, 0, 0, 0, "", (byte) -1, null);
//					this.clanData.clanBattleData.attack = initClanBattleInfo();
//					this.clanData.clanBattleData.battleType = 0;
//					this.clanData.clanBattleData.attackTime = 0;
//					this.clanData.clanBattleData.cdTime = 0;
//					this.clanData.clanBattleData.prestige = 0;
//					this.clanData.clanBattleData.xuantie = 0;
//					this.clanData.clanBattleData.yaocao = 0;
//					this.clanData.clanBattleData.enemyPets.clear();
//				}
//			}
//		}
//		if (this.clanData.clanBattleData.defend.size() > 0)
//		{
//			Iterator<Map.Entry<Integer, SBean.ClanBattleDefendDesc>> it = this.clanData.clanBattleData.defend.entrySet().iterator();
//			while (it.hasNext())
//			{
//				Map.Entry<Integer, SBean.ClanBattleDefendDesc> entry = it.next();
//				SBean.ClanBattleDefendDesc value = entry.getValue();
//				if (GameTime.getTime() - value.attackTime - value.cdTime > cfg.normalBattle.expiredTime)
//				{
//					addClanBattleDefendLog(SBean.DBClanBattleLog.EventDefendTimeout, value.defendInfo.clanName, value.defendInfo.bwType, (byte) -1, 0, 0, 0, "", (byte) -1, null);
//					it.remove();
//				}
//			}
//		}
//		if (this.clanData.clanBattleData.help.size() > 0)
//		{
//			Iterator<Map.Entry<Integer, SBean.ClanBattleHelpDesc>> it = this.clanData.clanBattleData.help.entrySet().iterator();
//			while (it.hasNext())
//			{
//				Map.Entry<Integer, SBean.ClanBattleHelpDesc> entry = it.next();
//				SBean.ClanBattleHelpDesc value = entry.getValue();
//				if (GameTime.getTime() - value.attackTime - value.cdTime > cfg.normalBattle.expiredTime)
//				{
//					it.remove();
//				}
//			}
//		}
//	}
//
//	//宗门战军情-进攻
//	public synchronized SBean.ClanBattleProcessAttack clanAttackProcess()
//	{
//		onClanBattleDataRefresh();
//		if (this.clanData.clanBattleData == null)
//			return null;
//		if (this.clanData.clanBattleData.attackTime <= 0)
//			return null;
//		return new SBean.ClanBattleProcessAttack(this.clanData.clanBattleData.attack, this.clanData.clanBattleData.attackTime + this.clanData.clanBattleData.cdTime, this.clanData.clanBattleData.prestige, this.clanData.clanBattleData.xuantie, this.clanData.clanBattleData.yaocao);
//	}
//
//	//宗门战军情-敌情
//	public synchronized Map<Integer, SBean.ClanBattleDefendDesc> clanDefendProcess()
//	{
//		onClanBattleDataRefresh();
//		if (this.clanData.clanBattleData == null)
//			return null;
//		if (this.clanData.clanBattleData.defend.size() == 0)
//			return null;
//
//		return this.clanData.clanBattleData.defend;
//	}
//
//	//宗门战军情-支援
//	public synchronized Map<Integer, SBean.ClanBattleHelpDesc> clanHelpProcess()
//	{
//		onClanBattleDataRefresh();
//		if (this.clanData.clanBattleData == null)
//			return null;
//		if (this.clanData.clanBattleData.help.size() == 0)
//			return null;
//
//		return this.clanData.clanBattleData.help;
//	}
//
//	// 宗门战侦查，当有人进攻我时可以侦查对方战斗队伍
//	public synchronized void clanBattleKeek(int clanID)
//	{
//		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_BATTLE_KEEK);
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (clanCFGS == null || this.clanData.clanBattleData == null)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_battlekeek_res(GameData.PROTOCOL_OP_FAILED, GameData.emptyList(), GameData.emptyList(), null));
//			return;
//		}
//		if (!this.canUseDiamond(clanCFGS.normalBattle.keekDiamond, false))
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_battlekeek_res(GameData.PROTOCOL_OP_NEED_DIAMOND_FAILD, GameData.emptyList(), GameData.emptyList(), null));
//			return;
//		}
//		int nowTime = GameTime.getTime();
//		SBean.ClanBattleDefendDesc info = this.clanData.clanBattleData.defend.get(clanID);
//		if (info == null)
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_battlekeek_res(GameData.PROTOCOL_OP_CLAN_SEEK_ENEMY_CANCEL, GameData.emptyList(), GameData.emptyList(), null));
//			return;
//		}
//		if (nowTime - info.attackTime - info.cdTime > clanCFGS.normalBattle.expiredTime)
//		{
//			this.clanData.clanBattleData.defend.remove(clanID);
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_battlekeek_res(GameData.PROTOCOL_OP_CLAN_SEEK_TIMEOUT, GameData.emptyList(), GameData.emptyList(), null));
//			return;
//		}
//
//		List<SBean.PetOverview> selfPets = new ArrayList<SBean.PetOverview>();
//		for (int petId : this.clanData.battle.defendPet.values())
//		{
//			selfPets.add(this.getPetOverviewWithoutLock(petId));
//		}
//		List<SBean.PetOverview> enemyPets = new ArrayList<SBean.PetOverview>();
//		tlogEvent.setArg(clanCFGS.normalBattle.keekDiamond);
//
//		if (info.isKeek == 1)
//		{
//			enemyPets.addAll(info.enemyPets);
//		}
//		else
//		{
//			enemyPets.addAll(info.enemyPets);
//			this.useDiamond(clanCFGS.normalBattle.keekDiamond, false, tlogEvent.getGameItemRecords());
//			info.isKeek = 1;
//		}
//
//		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.clan_battlekeek_res(GameData.PROTOCOL_OP_SUCCESS, selfPets, enemyPets, info.defendInfo));
//		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
//	}
//
//	//宗门战求援,clanID 进攻我的宗门ID
//	public synchronized void clanBattleSeekhelp(int clanID)
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		int nowTime = GameTime.getTime();
//		if (this.clanData.clanBattleData == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleseekhelp_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		synchronized (this)
//		{
//			SBean.ClanBattleDefendDesc info = this.clanData.clanBattleData.defend.get(clanID);
//			if (info == null)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleseekhelp_res(GameData.PROTOCOL_OP_FAILED));
//				return;
//			}
//			if (info.isSeekhelp == 1)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleseekhelp_res(GameData.PROTOCOL_OP_CLAN_BATTLE_SEEKHELP_FIN));
//				return;
//			}
//			if (info.cdTime - (nowTime - info.attackTime) < clanCFGS.battleHelp.qyRemainTime)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleseekhelp_res(GameData.PROTOCOL_OP_CLAN_BATTLE_CD_FIN));
//				return;
//			}
//		}
//		gs.getClanService().clanBattleSeekhelp(this.id, new ClanService.ClanBattleSeekhelpCallback()
//		{
//
//			@Override
//			public void onCallback(int errCode, List<Integer> roles, SBean.ClanBattleInfo selfInfo)
//			{
//				Iterator<Integer> iter = roles.iterator();
//				while (iter.hasNext())
//				{
//					if (iter.next() == Role.this.id)
//					{
//						iter.remove();
//					}
//				}
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						SBean.ClanBattleDefendDesc info = Role.this.clanData.clanBattleData.defend.get(clanID);
//						if (info == null)
//						{
//							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleseekhelp_res(GameData.PROTOCOL_OP_FAILED));
//							return;
//						}
//						Role.this.clanData.clanBattleData.seekRoles = new ArrayList<Integer>();
//						Role.this.clanData.clanBattleData.seekRoles.addAll(roles);
//						info.isSeekhelp = 1;
//						Role.this.clanData.clanBattleData.selfInfo = selfInfo;//同步到被攻击者role的self信息
//					}
//					for (int rId : roles)
//					{
//						//同步求援到的人的信息
//						Role role = gs.getLoginManager().getOnGameRole(rId);
//						if(role != null)
//						{
//							synchronized (role)
//							{
//								if (role != null && rId != Role.this.id)
//								{
//									if (role.clanData.clanBattleData == null)
//										role.initClanBattleData();
//
//									SBean.ClanBattleHelpDesc desc = new SBean.ClanBattleHelpDesc();
//									desc.attack = Role.this.clanData.clanBattleData.defend.get(clanID).defendInfo;
//									desc.defend = Role.this.clanData.clanBattleData.selfInfo;
//									desc.attackTime = Role.this.clanData.clanBattleData.defend.get(clanID).attackTime;
//									desc.cdTime = Role.this.clanData.clanBattleData.defend.get(clanID).cdTime;
//	
//									if (!role.clanData.clanBattleData.help.containsKey(clanID))
//										role.clanData.clanBattleData.help.put(clanID, desc);
//									int defend = 0;
//									int attackTime = 0;
//									int help = 1;
//									if(role.clanData.clanBattleData.battleType != Clan.CLAN_BATTLE_TYPE_ATTACK && role.clanData.clanBattleData.defend.size() == 0 )
//										gs.getRPCManager().sendStrPacket(role.netsid, new SBean.clan_syncbattle(attackTime, defend, help));
//								}
//							}
//						}
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battleseekhelp_res(errCode));
//			}
//		});
//	}
//
//	//宗门战支援(客户端没有请求过这个协议)
//	public void clanBattleHelp(int clanId)
//	{
//		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelp_res(GameData.PROTOCOL_OP_FAILED));
//		//		if(this.clanData.battle.defendPet.size() <= 0 || this.clanData.clanBattleData == null)
//		//		{
//		//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelp_res(GameData.PROTOCOL_OP_FAILED));
//		//			return;
//		//		}
//		//		if(this.clanData.battle.dayHelpCount >= 3 || !this.clanData.clanBattleData.help.containsKey(clanId))
//		//		{
//		//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelp_res(GameData.PROTOCOL_OP_CLAN_BATTLE_HELPCOUNT_FIN));
//		//			return;
//		//		}
//		//		if(this.clanData.clanBattleData.battleType == Clan.CLAN_BATTLE_TYPE_ATTACK || this.clanData.clanBattleData.defend.size() > 0)
//		//		{
//		//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelp_res(GameData.PROTOCOL_OP_FAILED));
//		//			return;
//		//		}
//		//		int nowTime = GameTime.getTime();
//		//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		//		SBean.ClanBattleHelpDesc desc = this.clanData.clanBattleData.help.get(clanId);
//		//		if(desc.cdTime - (nowTime - desc.attackTime) < clanCFGS.battleHelp.qyRemainTime)
//		//		{
//		//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelp_res(GameData.PROTOCOL_OP_CLAN_BATTLE_CD_FIN));
//		//			return;
//		//		}
//		//		gs.getClanService().clanBattleHelp(this.id, clanId, this.clanData.battle.defendPet, new ClanService.ClanBattleHelpCallback() {
//		//			@Override
//		//			public void onCallback(int errCode, SBean.ClanBattleInfo attack, SBean.ClanBattleInfo defend)
//		//			{
//		//				if(errCode == GameData.PROTOCOL_OP_SUCCESS)
//		//				{
//		//					//支援战
//		//					Role.this.clanData.battle.dayHelpCount += 1;
//		////					Role.this.clanData.clanBattleData.attack = attack;
//		////					Role.this.clanData.clanBattleData.defend = defend;
//		////					Role.this.clanData.clanBattleData.battleType = Clan.CLAN_BATTLE_TYPE_HELP;
//		////					Role.this.clanData.clanBattleData.help = null;
//		////					Role.this.clanData.clanBattleData.attackTime = GameTime.getTime();
//		//				}
//		//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelp_res(errCode));
//		//			}
//		//		});
//	}
//
//	//支援战开始战斗
//	public void clanBattleHelpFightStart(int clanID)
//	{
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		if (this.clanData.clanBattleData == null || this.clanData.battle.dayHelpCount >= clanCFGS.battleHelp.battleHelpTimes)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelpfightstart_res(GameData.PROTOCOL_OP_CLAN_BATTLE_HELPCOUNT_FIN));
//			return;
//		}
//		if (this.clanData.clanBattleData.battleType == Clan.CLAN_BATTLE_TYPE_ATTACK || this.clanData.clanBattleData.defend.size() > 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelpfightstart_res(GameData.PROTOCOL_OP_CLAN_BATTLE_HELPED_EDFENDED));
//			return;
//		}
//		if (!this.clanData.clanBattleData.help.containsKey(clanID))
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelpfightstart_res(GameData.PROTOCOL_OP_CLAN_SEEK_ENEMY_CANCEL));
//			return;
//		}
//		SBean.ClanBattleHelpDesc desc = this.clanData.clanBattleData.help.get(clanID);
//
//		if (desc.cdTime - (GameTime.getTime() - desc.attackTime) < clanCFGS.battleHelp.zyRemainTime)
//		{
//			this.clanData.clanBattleData.help.remove(clanID);
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelpfightstart_res(GameData.PROTOCOL_OP_CLAN_BATTLE_HELP_TIMEOUT));
//			return;
//		}
//		SBean.GlobalRoleId globalRoleId = new SBean.GlobalRoleId(desc.attack.gsid, desc.attack.ownerId);
//		gs.getClanService().clanBattleHelpFightStart(this.id, globalRoleId, clanID, new ClanService.ClanBattleHelpFightStartCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.BattleArray ba, SBean.ClanBattleInfo selfInfo)
//			{
//				if (errCode != GameData.PROTOCOL_OP_SUCCESS)
//				{
//					Role.this.clanData.clanBattleData.help.remove(clanID);
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelpfightstart_res(errCode));
//					return;
//				}
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.clanData.clanBattleData.helpClan = clanID;//支援者，攻击者的宗门ID
//						Role.this.clanData.battle.dayHelpCount += 1;
//						Role.this.clanData.clanBattleData.selfInfo = selfInfo;
//					}
//					startClanBattleHelpMapCopy(new TreeSet<Integer>(Role.this.clanData.battle.attackPet.values()), ba);
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlehelpfightstart_res(GameData.PROTOCOL_OP_SUCCESS));
//				}
//			}
//		});
//	}
//
//	//支援战战斗结束
//	public synchronized void onClanBattleHelpFightEnd(int time, boolean win, SBean.ClanBattleHelpResult result)
//	{
//		int prestige = 0;
//		int attackClanId = 0;
//		int defendClanId = 0;
//		int defendGsId = 0;
//		int selfClanId = this.clanData.clanBattleData.selfInfo.clanId;
//		SBean.ClanCFGS clanCFGS = GameData.getInstance().getClanCFGS();
//		SBean.ClanBattleHelpDesc desc = this.clanData.clanBattleData.help.get(this.clanData.clanBattleData.helpClan);
//		int winType = win ? SBean.DBClanBattleLog.EventAttackSelfHelpWin : SBean.DBClanBattleLog.EventAttackSelfHelpFail;
//		if (desc != null)
//		{
//			SBean.ClanBattleHelpEnemyLevelCFGS levelCFGS = clanCFGS.battleHelp.enemyLevel.get(desc.attack.lvl);
//			prestige = levelCFGS.prestige;
//			addClanBattleAttackLog(winType, desc.attack.clanName, desc.attack.bwType, (byte) (-1), prestige, 0, 0, desc.defend.clanName, (byte) (win ? 1 : 0), null);
//			attackClanId = desc.attack.clanId;//攻击方
//			defendClanId = desc.defend.clanId;
//			defendGsId = desc.defend.gsid;
//		}
//
//		this.clanData.clanBattleData.help.remove(this.clanData.clanBattleData.helpClan);
//		this.clanData.clanBattleData.helpClan = 0;
//		this.clanData.clanBattleData.battleType = 0;
//		//支援战结束，通知扣除声望
//		gs.getClanService().clanBattleHelpFightEnd(this.id, prestige, selfClanId, attackClanId, defendClanId, defendGsId, win ? 1 : 0, result.defend, new ClanService.ClanBattleHelpFightEndCallback()
//		{
//			@Override
//			public void onCallback(int errCode, int prestige)
//			{
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_clanbattlehelpmap_end(win ? 1 : 0, prestige, 0, 0));
//			}
//		});
//	}
//
//	//宗门战攻击方战报
//	public synchronized void addClanBattleAttackLog(int event, String clanName, int clanType, byte win, int value1, int value2, int value3, String helpClanName, byte helpClanWin, SBean.ClanBattleLogDesc desc)
//	{
//		if (this.clanData.attackLog.size() >= 20)
//		{
//			this.clanData.attackLog.remove(0);
//		}
//		int id = this.clanData.attackLog.size() + 1;// useless
//		SBean.DBClanBattleLog attackLog = new SBean.DBClanBattleLog(id, event, GameTime.getTime(), clanName, clanType, win, value1, value2, value3, helpClanName, helpClanWin, desc);
//		this.clanData.attackLog.add(attackLog);
//	}
//
//	//宗门战防守方战报
//	public synchronized void addClanBattleDefendLog(int event, String clanName, int clanType, byte win, int value1, int value2, int value3, String helpClanName, byte helpClanWin, SBean.ClanBattleLogDesc desc)
//	{
//		if (this.clanData.defendLog.size() >= 20)
//		{
//			this.clanData.defendLog.remove(0);
//		}
//		int id = this.clanData.defendLog.size() + 1;
//		SBean.DBClanBattleLog defendLog = new SBean.DBClanBattleLog(id, event, GameTime.getTime(), clanName, clanType, win, value1, value2, value3, helpClanName, helpClanWin, desc);
//		this.clanData.defendLog.add(defendLog);
//	}
//
//	//客户端获取战报
//	public synchronized List<SBean.DBClanBattleLog> getClanBattleLog(int type)
//	{
//		List<SBean.DBClanBattleLog> logs = new ArrayList<SBean.DBClanBattleLog>();
//		if (type == 1)
//			logs.addAll(this.clanData.attackLog);
//		else
//			logs.addAll(this.clanData.defendLog);
//		return logs;
//	}
//
//	//宗门战时间到期，宗门战开始战斗
//	public void clanBattleFightStart()
//	{
//		onClanBattleDataRefresh();
//		if (this.clanData.clanBattleData.battleType != Clan.CLAN_BATTLE_TYPE_ATTACK || this.clanData.clanBattleData.isInBattleMap == 1)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlefightstart_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		SBean.GlobalRoleId enemyRole = new SBean.GlobalRoleId(this.clanData.clanBattleData.attack.gsid, this.clanData.clanBattleData.attack.ownerId);
//		gs.getClanService().clanBattleFightStart(this.id, enemyRole, new ClanService.ClanBattleFightStartCallback()
//		{
//			@Override
//			public void onCallback(int errCode, SBean.BattleArray battleArray, int roleLvl)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					Role.this.clanData.clanBattleData.attackRoleLvl = roleLvl;
//					Role.this.clanData.clanBattleData.isInBattleMap = 1;//标志位，此时对进攻不做每分钟清理
//					startClanBattleMapCopy(new TreeSet<Integer>(Role.this.clanData.battle.attackPet.values()), battleArray, true);
//					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clanbattle_startattack_res(GameData.PROTOCOL_OP_SUCCESS));
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlefightstart_res(errCode));
//			}
//		});
//	}
//
//	//宗门战战斗结束
//	public synchronized void onClanBattleFightEnd(int endTime, boolean win, SBean.ClanBattleResult result)
//	{
//		//通知扣除材料
//		int prestige = 0;
//		SBean.ClanBattleLogDesc desc = new SBean.ClanBattleLogDesc();
//		desc.attack = this.clanData.clanBattleData.selfInfo;
//		desc.defend = this.clanData.clanBattleData.attack;
//		desc.attackRoleLvl = this.level;
//		desc.defendRoleLvl = this.clanData.clanBattleData.attackRoleLvl;
//		List<SBean.PetOverview> selfPets = new ArrayList<SBean.PetOverview>();
//		for (int petId : this.clanData.battle.attackPet.values())
//		{
//			selfPets.add(this.getPetOverviewWithoutLock(petId));
//		}
//		desc.attackPets = selfPets;
//		desc.defendPets = this.clanData.clanBattleData.enemyPets;
//		if (win)
//		{
//			this.syncAddOre(Clan.CLAN_ORE_TYPE_IRON, this.clanData.clanBattleData.xuantie);
//			this.syncAddOre(Clan.CLAN_ORE_TYPE_HERB, this.clanData.clanBattleData.yaocao);
//			prestige = this.clanData.clanBattleData.prestige;
//
//			addClanBattleAttackLog(SBean.DBClanBattleLog.EventAttackWin, this.clanData.clanBattleData.attack.clanName, this.clanData.clanBattleData.attack.bwType, (byte) (win ? 1 : 0), prestige, this.clanData.clanBattleData.xuantie, this.clanData.clanBattleData.yaocao, "", (byte) (-1), desc);
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_clanbattlemap_end(win ? 1 : 0, prestige, this.clanData.clanBattleData.xuantie, this.clanData.clanBattleData.yaocao));
//		}
//		else
//		{
//			addClanBattleAttackLog(SBean.DBClanBattleLog.EventAttackFail, this.clanData.clanBattleData.attack.clanName, this.clanData.clanBattleData.attack.bwType, (byte) (win ? 1 : 0), prestige, this.clanData.clanBattleData.xuantie, this.clanData.clanBattleData.yaocao, "", (byte) (-1), desc);
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_clanbattlemap_end(win ? 1 : 0, 0, 0, 0));
//		}
//		SBean.GlobalRoleId enemyRole = new SBean.GlobalRoleId(this.clanData.clanBattleData.attack.gsid, this.clanData.clanBattleData.attack.ownerId);
//
//		// 通知被攻击的role添加防守战报
//		gs.getClanService().clanBattleFightEnd(this.id, enemyRole, prestige, win ? 1 : 0, this.clanData.clanBattleData.selfInfo.clanId, desc, new ClanService.ClanBattleFightEndCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						Role.this.clanData.clanBattleData.isInBattleMap = 0;
//						Role.this.clanData.clanBattleData.helpClan = 0;
//						Role.this.clanData.clanBattleData.battleType = 0;
//						Role.this.clanData.clanBattleData.attack = initClanBattleInfo();
//						Role.this.clanData.clanBattleData.enemyPets = new ArrayList<SBean.PetOverview>();
//						Role.this.clanData.clanBattleData.attackTime = 0;
//						Role.this.clanData.clanBattleData.cdTime = 0;
//						Role.this.clanData.clanBattleData.enemyPets.clear();
//					}
//				}
//			}
//		});
//	}
//
//	//发起宗门战后可以撤退
//	public synchronized void clanBattleFightExit()
//	{
//		if (this.clanData.clanBattleData == null)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlefightexit_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		if (this.clanData.clanBattleData.battleType != Clan.CLAN_BATTLE_TYPE_ATTACK || this.clanData.clanBattleData.attack.clanId <= 0)
//		{
//			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlefightexit_res(GameData.PROTOCOL_OP_FAILED));
//			return;
//		}
//		SBean.GlobalRoleId enemyRole = new SBean.GlobalRoleId(this.clanData.clanBattleData.attack.gsid, this.clanData.clanBattleData.attack.ownerId);
//		gs.getClanService().clanBattleFightExit(this.id, enemyRole, this.clanData.clanBattleData.selfInfo.clanId, new ClanService.ClanBattleFightExitCallback()
//		{
//			@Override
//			public void onCallback(int errCode)
//			{
//				if (errCode == GameData.PROTOCOL_OP_SUCCESS)
//				{
//					synchronized (Role.this)
//					{
//						//Role.addClanBattleAttackLog();
//						Role.this.clanData.clanBattleData.helpClan = 0;
//						Role.this.clanData.clanBattleData.battleType = 0;
//						Role.this.clanData.clanBattleData.attack = initClanBattleInfo();
//						Role.this.clanData.clanBattleData.enemyPets = new ArrayList<SBean.PetOverview>();
//						Role.this.clanData.clanBattleData.attackTime = 0;
//						Role.this.clanData.clanBattleData.cdTime = 0;
//						Role.this.clanData.clanBattleData.enemyPets.clear();
//					}
//				}
//				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.clan_battlefightexit_res(errCode));
//			}
//		});
//	}

	//////////////////////////////////////////////////生产系统-脱离宗门的独立模块//////////////////////////////////////////////////
	public SBean.DBProduceData initProduceData()
	{
		SBean.ProduceCFGS pCfg = GameData.getInstance().getProduceCFGS();
		return new SBean.DBProduceData(new HashSet<Integer>() ,1, 0, pCfg.spMax, 0, 0);
	}
	
	public synchronized void produceWorkShopSync()
	{
		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.produce_workshopsync_res(this.produce.kdClone(), fusionData.fusionPoint));
	}

	public int produceCreateNewRecipe(int reelID)
	{
		return this.useItemAsRecipeReel(reelID);
	}

	public synchronized int produceTryProduce(int recipeID)
	{
		final SBean.ProduceRecipeCFGS prCfg = GameData.getInstance().getProduceRecipeCFGS(recipeID);
		if (prCfg == null || recipeID <= 0 || !this.checkCanProduce(prCfg) || (!this.produce.recipes.contains(recipeID) && !GameData.getInstance().getCommonCFG().produce.contains(recipeID)))
			return GameData.PROTOCOL_OP_FAILED;
		
		//checkCanProduce 判断了包满
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_PRODUCE);
		tlogEvent.setArg( recipeID);
		this.delGameItems(prCfg.input, tlogEvent.getGameItemRecords());
		
		GameData.LevelExp l = GameData.getInstance().getAddProduceExpLvlExp(Role.this.produce.produceLvl, Role.this.produce.produceExp, prCfg.gainExp);
		this.produce.produceLvl = l.level;
		this.produce.produceExp = (int) l.exp;

		SBean.GameItem gi = GameData.getInstance().toGameItem(prCfg.output.id, prCfg.output.count);
		this.syncAddGameItem(gi, tlogEvent);
		this.logTaskScheduleData(GameData.SCHEDULE_TYPE_PRODUCE);
		gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
		gs.getTLogger().logProduceProduce(this, recipeID, prCfg.output.id, prCfg.output.count);
		testChallengeTask(GameData.CHALLENGE_TASK_ID_PRODUCE_LEVEL, 0);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private boolean checkCanProduce(SBean.ProduceRecipeCFGS prCfg)
	{
		if (this.produce.produceLvl < prCfg.produceLvlReq)
			return false;

		if (!this.canAddGameItem(prCfg.output.id, prCfg.output.count))
			return false;

		if (!this.containsEnoughGameItems(prCfg.input))
			return false;

		return true;
	}

	public synchronized void produceSplit(int id, String guid)
	{
		if (!this.containsEquip(id, guid))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_split_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}

		final SBean.EquipCFGS equipCfg = GameData.getInstance().getEquipCFG(id);
		if (equipCfg == null || equipCfg.canSplit == 0 || !this.canUseSplitSp(equipCfg.splitNeedSP) || !this.canAddGameItems(equipCfg.splitOutput))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_split_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_SPLIT);
		tlogEvent.setArg(id);
		tlogEvent.setArg(guid);
		Role.this.useSplitSp(equipCfg.splitNeedSP, tlogEvent.getGameItemRecords());
		Role.this.delEquip(id, guid, tlogEvent.getGameItemRecords());
        logTaskScheduleData(GameData.SCHEDULE_TYPE_SELL_EQUIPS);
		List<SBean.GameItem> gis = GameData.getInstance().toGameItems(equipCfg.splitOutput);
		Role.this.syncAddGameItems(gis, tlogEvent);
		gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.produce_split_res(GameData.PROTOCOL_OP_SUCCESS));
	     
		gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
		gs.getTLogger().logProduceSplit(Role.this, id, id, 1);
	}
	
    public synchronized void produceFusion(List<DummyGoods> consumeItems)
    {
        if (!GameData.getInstance().checkFusionOpen(level))
        {
            gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_fusion_res(GameData.PROTOCOL_OP_FAILED, new ArrayList<>()));
            return;
        }
        
        if (!this.containsEnoughGameItems(consumeItems))
        {
            gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_fusion_res(GameData.PROTOCOL_OP_FAILED, new ArrayList<>()));
            return;
        }
        
        int allFusionPoint = 0;
        for (DummyGoods good : consumeItems)
        {
            CellItem ci = bag.getCellItem(good.id);
            FusionableItem fi = ci.getUseable().useAsFusionableItem();
            if (fi==null || fi.getFusionPoint() <= 0)
            {
	            gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_fusion_res(GameData.PROTOCOL_OP_FAILED, new ArrayList<>()));
	            return;
            }
            
            allFusionPoint += fi.getFusionPoint() * good.count;
        }
        
        final int fullPoint = GameData.getInstance().getFullFusionPoint();
        int fusionTimes = (allFusionPoint + this.fusionData.fusionPoint) / fullPoint;
        int fusionPoint = (allFusionPoint + this.fusionData.fusionPoint) % fullPoint;
        int costEnergy = fusionTimes * GameData.getInstance().getCostSplitSPPerFusion();
        
        if (!canUseSplitSp(costEnergy))
        {
	        gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_fusion_res(GameData.PROTOCOL_OP_FAILED, new ArrayList<>()));
	        return;
        }
        
        if(this.bag.getCanUseSize()<fusionTimes)
        {
	        gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_fusion_res(GameData.PROTOCOL_OP_BAG_NOT_ENOUGH_CELLS, new ArrayList<>()));
	        return;
        }
        
        Map<Integer, Integer> rewardsMap = GameData.getInstance().getFusionRewardsDrop(level, fusionTimes);
        if (!canAddGameItems(rewardsMap))
        {
	        gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_fusion_res(GameData.PROTOCOL_OP_BAG_NOT_ENOUGH_CELLS, new ArrayList<>()));
	        return;
        }
        
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PRODUCE_FUSION);
        this.useSplitSp(costEnergy, tlogEvent.getGameItemRecords());
        List<SBean.GameItem> rewards = GameData.getInstance().toGameItems(rewardsMap);
        this.delGameItems(consumeItems, tlogEvent.getGameItemRecords());
        this.syncAddGameItems(rewards, tlogEvent);
        this.fusionData.fusionPoint = fusionPoint;
        this.fusionData.fusionTimes += fusionTimes;
        
	    gs.getRPCManager().sendStrPacket(this.netsid, new SBean.produce_fusion_res(GameData.PROTOCOL_OP_SUCCESS, rewards));
        gs.getTLogger().logRoleEventFlow(this, tlogEvent);
    }

    public synchronized boolean produceSplitSPBuy(int times)
	{
		if (this.produce.splitSP >= GameData.getInstance().getProduceCFGS().spMax)
			return false;

		if (times != this.produce.dayBuyTimes + 1 || times > GameData.DIAMOND_REFRESH_MAX_TIMES)
			return false;

		int cost = GameData.getTimesCost(GameData.getInstance().getProduceCFGS().costStones, times);
		if (!this.canUseDiamond(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLAN_SPLIT_SP_BUY);
		tlogEvent.setArg(times, cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.syncAddSplitSP(GameData.getInstance().getProduceCFGS().buySP, tlogEvent);
		this.produce.dayBuyTimes++;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	//////////////////////////////////////////////////生产系统 end//////////////////////////////////////////////////
	
	////////////////////////////////// 师徒  //////////////////////////////////////
	
	public int addMasterPoint(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.master.point += value;
		this.master.historyPoint += value;
		records.addProduce(GameData.COMMON_ITEM_ID_MASTER_POINT, value, this.master.point);
		return value;
	}
	
	public int addMasterReputation(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		this.master.reputation += value;
		masterUpdateReputationRank();
		records.addProduce(GameData.COMMON_ITEM_ID_MASTER_REPUTATION, value, this.master.reputation);
		return value;
	}
	
	public void masterUpdateReputationRank()
	{
		gs.getRankManager().tryUpdateRoleRank(
				GameData.RANK_TYPE_ROLE_MASTER_REPUTATION, 
				new SBean.RankRole(this.getRoleOverviewWithoutLock(), 
						this.master.reputation));		
	}
	
	public boolean masterTestNotice()
	{
		synchronized( this )
		{
			return ! master.applyList.isEmpty()
					|| ! master.betrayList.isEmpty()
					|| ! master.graduateReqList.isEmpty();
		}
	}
	
	int useMasterPoint(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = Math.min(this.master.point, value);
		this.master.point -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_MASTER_POINT, use, this.master.point);
		return use;
	}
	
	int useMasterReputation(int value, TLogger.GameItemRecords records)
	{
		if (value <= 0)
			return 0;
		int use = Math.min(this.master.reputation, value);
		this.master.reputation -= use;
		records.addConsume(GameData.COMMON_ITEM_ID_MASTER_REPUTATION, use, this.master.reputation);
		return use;
	}
	
	boolean canUseMasterPoint(int value)
	{
		return this.master.point >= value;
	}
	
	boolean canUseMasterReputation(int value)
	{
		return this.master.reputation >= value;
	}
	
	// 师徒商店
	public synchronized void syncMasterShopInfo()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.master_shopsync_res(this.syncShopInfo(GameData.SHOP_TYPE_MASTER), 
				this.master.point));
	}

	public SBean.ShopInfo userRefreshMasterShop(int times, int isSecondType)
	{
		return this.userRefreshShop(GameData.SHOP_TYPE_MASTER, times, isSecondType);
	}

	public boolean buyMasterShopGoogs(int seq)
	{
		return this.buyShopGoogs(GameData.SHOP_TYPE_MASTER, seq);
	}
	
	public void masterLogGraduateTaskWithoutLock(int taskType, int val)
	{
		{
			if( master.master <= 0 || val <= 0)
				return;
			SBean.DBMasterTask task = null;
			for(SBean.DBMasterTask e : master.tasks)
			{
				if( e.taskType == taskType )
				{
					task = e;
					break;
				}
			}
			if( task != null )
				task.taskProgress += val;
			else
				master.tasks.add(new SBean.DBMasterTask(taskType, val));
		}
	}
	
	public void masterReqMasterInfo(int sid)
	{
		SBean.master_info_res res = new SBean.master_info_res();
		res.retCode = GameData.PROTOCOL_OP_MASTER_OK;
		res.masterAnnounce = gs.getMasterManager().getAnnounce(id);
		synchronized( this )
		{
			if( master.apprentices.size() > 0 )
				master.master = 0;
			res.masterRoleID = master.master;
			res.apprenticeCount = master.apprentices.size();
			res.point = master.point;
			res.reputation = master.reputation;
			res.lastDismissTime = master.lastDismissTime;
			res.lastBetrayTime = master.lastBetrayTime;
			res.lastReqGraduateTime = master.lastGraduateRequestTime;
		}
		if( res.masterRoleID > 0 )
			gs.getMasterManager().onMasterInfoReq(sid, res.masterRoleID, this.id, res);
		else if( res.apprenticeCount > 0 )
			gs.getMasterManager().onMasterInfoReq(sid, this.id, this.id, res);
		else
			gs.getRPCManager().sendStrPacket(sid, res);
	}
	
	public List<SBean.DBMasterTask> masterGetTasks()
	{
		synchronized( this )
		{
			return new ArrayList<SBean.DBMasterTask>(master.tasks);
		}
	}
	
	public void masterRemoveBetrayMsg(int appRoleID)
	{
		synchronized( this )
		{
			Iterator<SBean.DBMasterNotice> iter = master.betrayList.iterator();
			while( iter.hasNext() )
			{
				if( iter.next().roleID == appRoleID )
				{
					iter.remove();
				}
			}
		}
	}
	
	public void masterListApprentices(final int sid)
	{
		List<Integer> appIDs = new ArrayList<>();
		synchronized( this )
		{
			appIDs.addAll(master.apprentices);
		}
		final SBean.master_list_apprentice_res res = new SBean.master_list_apprentice_res(
				GameData.PROTOCOL_OP_MASTER_OK,
				new ArrayList<>()
				);
		if( appIDs.isEmpty() )
		{
			gs.getRPCManager().sendStrPacket(sid, res);
			return;
		}
		gs.getLoginManager().readRoles(appIDs, list->
		{
			if( list != null )
			{
				list.forEach(role->
				{
					if( role != null )
						res.apprentices.add(role.getApprenticeDetail());
				});
			}
			gs.getRPCManager().sendStrPacket(sid, res);
		});
	}
	
	public void masterListMsg(final int sid)
	{
		final SBean.master_msg_list_res res = new SBean.master_msg_list_res(
				GameData.PROTOCOL_OP_MASTER_OK, new ArrayList<SBean.MasterApplyEntry>(),
					new ArrayList<SBean.MasterApplyEntry>(),new ArrayList<SBean.MasterApplyEntry>());
		final List<SBean.DBMasterApply> appList = new ArrayList<>();
		final List<SBean.DBMasterNotice> betrayList = new ArrayList<>();
		final List<SBean.DBMasterGraduateReq> graReqList = new ArrayList<>();
		
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			appList.addAll(master.applyList);
			master.betrayList.removeIf(notice->notice.eventTime + cfg.maxBetrayMsgReserveTime < now);
			betrayList.addAll(master.betrayList);
			graReqList.addAll(master.graduateReqList);
		}
		final Set<Integer> set = new HashSet<>();
		appList.forEach(app->set.add(app.roleID));
		betrayList.forEach(app->set.add(app.roleID));
		graReqList.forEach(app->set.add(app.roleID));
		if( set.isEmpty() )
		{
			gs.getRPCManager().sendStrPacket(sid, res);
			return;
		}
		// TODO
		List<Integer> roleIDs = new ArrayList<>(set);
		final Map<Integer, SBean.RoleOverview> roles = new HashMap<>();
		gs.getLoginManager().readRoleBriefs(roleIDs, briefs->
		{
			if( briefs != null)
			{
				briefs.stream().forEach(brief->
				{
					if( brief != null )
					{
						roles.put(brief.id, brief);
					}
				});
			}
			appList.stream().forEach(app->
			{
				SBean.RoleOverview brief = roles.get(app.roleID);
				if( brief != null )
					res.applyList.add(new SBean.MasterApplyEntry(brief, app.applyTime));
			});
			betrayList.stream().forEach(app->
			{
				SBean.RoleOverview brief = roles.get(app.roleID);
				if( brief != null )
					res.betrayList.add(new SBean.MasterApplyEntry(brief, app.eventTime));
			});
			graReqList.stream().forEach(app->
			{
				SBean.RoleOverview brief = roles.get(app.roleID);
				if( brief != null )
					res.graduateReqList.add(new SBean.MasterApplyEntry(brief, app.applyTime));
			});
			gs.getRPCManager().sendStrPacket(sid, res);
		});
	}
	
	public void masterAddMapReward(int mapID, Set<Integer> members)
	{
		SBean.MapCopyCFGS mapCfg = GameData.getInstance().getMapCopyCFGS(mapID);
		if( mapCfg == null )
			return;
		if( members == null || members.isEmpty() )
			return;
		
		boolean bApprentice = false;
		{
			if( master.master > 0 && members.contains(master.master) )
			{
				bApprentice = true;
			}
		}
		if(!bApprentice)
			return;
		
		if( mapCfg.difficulty == GameData.MAPCOPY_DIFFICULT_MASTER )
			masterLogGraduateTaskWithoutLock(GameData.MASTER_GRADUATE_TASK_MASTER_DUNGEON, 1);
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ON_NORMAL_MAP_END);

		tlogEvent.setArg(mapCfg.masterApprenticePoint);
		gs.getLoginManager().addNormalTaskEvent(() ->
		{
			gs.getLoginManager().exeCommonRoleVisitor(master.master, false, new LoginManager.CommonRoleVisitor()
			{

				@Override
				public boolean visit(Role role, Role sameUserRole)
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ON_NORMAL_MAP_END);
					tlogEvent.setArg(mapCfg.masterMasterPoint, mapCfg.masterMasterReputation);
					role.syncAddGameItem(GameData.getInstance().toGameItem(GameData.COMMON_ITEM_ID_MASTER_POINT, mapCfg.masterMasterPoint), tlogEvent);
					role.syncAddGameItem(GameData.getInstance().toGameItem(GameData.COMMON_ITEM_ID_MASTER_REPUTATION, mapCfg.masterMasterReputation), tlogEvent);
					gs.getTLogger().logRoleEventFlow(role, tlogEvent);
					return false;
				}

				@Override
				public void onCallback(boolean success)
				{
				}
			});
		});
		this.syncAddGameItem(GameData.getInstance().toGameItem(GameData.COMMON_ITEM_ID_MASTER_POINT, mapCfg.masterApprenticePoint), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}
	
	public int masterAddApply(final int applyRoleID)
	{
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			if( applyRoleID <= 0 || applyRoleID == id )
			return GameData.PROTOCOL_OP_MASTER_FAIL;
			if( level < cfg.minMasterLvl )
				return GameData.PROTOCOL_OP_MASTER_MASTER_LEVEL;
			if( master.master > 0 )
				return GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			if( master.apprentices.size() >= cfg.maxApprenticeCount )
				return GameData.PROTOCOL_OP_MASTER_TOO_MANY_APPRENTICE;
			
			if( master.applyList.stream().anyMatch(apply->{
				if( apply.roleID==applyRoleID )
				{
					apply.applyTime = now;
					return true;
				}
				return false;
				}
			) )
			{
				return GameData.PROTOCOL_OP_MASTER_OK;
			}
			
			if( master.applyList.size() >= cfg.maxApplyMsgCount )
				return GameData.PROTOCOL_OP_MASTER_TOO_MANY_MSG;
			if( master.lastDismissTime + cfg.dismissCoolTime >= now )
				return GameData.PROTOCOL_OP_MASTER_DISMISS_COOL;
			master.applyList.add(new SBean.DBMasterApply(applyRoleID, now, now));
		}
		return GameData.PROTOCOL_OP_MASTER_OK;
	}
	
	public int masterOnMasterAccept(int masterID)
	{
		final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		synchronized( this )
		{
			if( masterID <= 0 || masterID == id )
				return GameData.PROTOCOL_OP_MASTER_FAIL;
			if( level < cfg.minApprenticeLvl || level > cfg.maxApprenticeLvl )
				return GameData.PROTOCOL_OP_MASTER_APPRENTICE_LEVEL;
			if( master.master > 0 )
				return GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			if( master.lastBetrayTime + cfg.betrayCoolTime >= GameTime.getTime() )
				return GameData.PROTOCOL_OP_MASTER_BETRAY_COOL;
			
			master.master = masterID;
			master.tasks.clear();
			this.masterNoticeBrief();
		}
		return GameData.PROTOCOL_OP_MASTER_OK;
	}
	
	public int masterOnPassiveAcceptOffer(final int appID)
	{
		final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			if( this.level < cfg.minMasterLvl )
				return GameData.PROTOCOL_OP_MASTER_MASTER_LEVEL;
			else if( this.master.master > 0 )
				return GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( this.master.apprentices.size() >= cfg.maxApprenticeCount )
				return GameData.PROTOCOL_OP_MASTER_TOO_MANY_APPRENTICE;
			else if( this.master.lastDismissTime + cfg.dismissCoolTime >= now )
				return GameData.PROTOCOL_OP_MASTER_DISMISS_COOL;
			else if( this.master.apprentices.stream().anyMatch(app->app == appID) )
				return GameData.PROTOCOL_OP_MASTER_APPRENTICE_EXIST;	
		}
		return GameData.PROTOCOL_OP_MASTER_OK;
	}
	
	public int masterOnAcceptOfferConfirm(int masterID)
	{
		final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			if( masterID <= 0 || masterID == id )
				return GameData.PROTOCOL_OP_MASTER_FAIL;
			else if( level < cfg.minApprenticeLvl || level > cfg.maxApprenticeLvl )
				return GameData.PROTOCOL_OP_MASTER_APPRENTICE_LEVEL;
			else if( master.master > 0 )
				return GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( master.lastBetrayTime + cfg.betrayCoolTime >= now )
				return GameData.PROTOCOL_OP_MASTER_BETRAY_COOL;
		
			master.master = masterID;
			master.tasks.clear();
			this.masterNoticeBrief();
		}
		return GameData.PROTOCOL_OP_MASTER_OK;
	}
	
	public int masterOnAcceptConfirm(int appID, boolean[] appCount)
	{
		final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		synchronized( this )
		{
			if( this.level < cfg.minMasterLvl )
				return GameData.PROTOCOL_OP_MASTER_MASTER_LEVEL;
			else if( this.master.master > 0 )
				return GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( this.master.apprentices.size() >= cfg.maxApprenticeCount )
				return GameData.PROTOCOL_OP_MASTER_TOO_MANY_APPRENTICE;
			else if( this.master.lastDismissTime + cfg.dismissCoolTime >= GameTime.getTime() )
				return GameData.PROTOCOL_OP_MASTER_DISMISS_COOL;
			else if( this.master.apprentices.stream().anyMatch(app->app == appID) )
				return GameData.PROTOCOL_OP_MASTER_APPRENTICE_EXIST;
		
			master.applyList.removeIf(apply->apply.roleID == appID);
			master.apprentices.add(appID);
			appCount[0] = master.apprentices.size() >= cfg.maxApprenticeCount;
			this.masterNoticeBrief();
		}
		return GameData.PROTOCOL_OP_MASTER_OK;
	}
	
	
	
	public boolean masterOnPassiveBetray(final int appID)
	{
		boolean bFound = false;
		int now = GameTime.getTime();
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		synchronized( this )
		{
			if( master.apprentices.removeIf(apprenticeID->apprenticeID == appID))
			{
				bFound = true;
				master.graduateReqList.removeIf(req->req.roleID == appID);
				master.betrayList.removeIf(notice->notice.eventTime + cfg.maxBetrayMsgReserveTime < now);
				master.betrayList.add(new SBean.DBMasterNotice(appID, GameTime.getTime()));
				this.masterNoticeBrief();
			}
		}
		
		return bFound;
	}
	
	public boolean masterOnPassiveReqGraduate(final int appID, boolean[] timeout)
	{
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			if( ! master.apprentices.stream().anyMatch(appid->appid==appID) )
				return false;
			master.graduateReqList.removeIf(req->req.applyTime 
					+ cfg.autoAcceptGraduateTime 
					+ cfg.autoAcceptGraduateTime
					+ cfg.autoAcceptGraduateTime
					< now && req.roleID != appID);
			boolean bFound = false;
			for(SBean.DBMasterGraduateReq req : master.graduateReqList)
			{
				if( req.roleID == appID )
				{
					req.applyTime = now;
					bFound = true;
					if( req.firstApplyTime + cfg.autoAcceptGraduateTime < now )
						timeout[0] = true;
				}
			}
			if( timeout[0] )
			{
				master.graduateReqList.removeIf(app->app.roleID == appID);
				master.apprentices.removeIf(app->app == appID);
			}
			else if( ! bFound )
				master.graduateReqList.add(new SBean.DBMasterGraduateReq(appID, now, now));
		}
		return true;
	}
	
	private int masterGetScore()
	{
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		AtomicInteger score = new AtomicInteger(0);
		master.tasks.stream().forEach(task->
		{
			SBean.MasterGraduateTaskCFGS tcfg = cfg.graduateTasks.get(task.taskType);
			if( tcfg != null && task.taskProgress >= tcfg.target )
				score.addAndGet(tcfg.score);
		});
		return score.get();
	}
	
	public void masterActiveReqGraduate(final int sid)
	{
		SBean.master_graduate_res res = new SBean.master_graduate_res(GameData.PROTOCOL_OP_MASTER_OK);
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		int masterID = 0;
		synchronized( this )
		{
			if( master.master <= 0 )
				res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
			else if( level < cfg.minGraduateLvl )
				res.retCode = GameData.PROTOCOL_OP_MASTER_GRADUATE_LEVEL;
			else if( master.lastGraduateRequestTime + cfg.reqGraduateCoolTime > now )
				res.retCode = GameData.PROTOCOL_OP_MASTER_REQ_GRADUATE_COOL;
			else
			{
				masterID = master.master;
				if( masterGetScore() < cfg.minGraduateScore )
					res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
				else
					master.lastGraduateRequestTime = now;
			}
		}
		gs.getRPCManager().sendStrPacket(sid, res);
		if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK )
			return;
		final int appID = this.id;
		final int mID = masterID;
		gs.getLoginManager().exeCommonRoleVisitor(masterID, false, new LoginManager.CommonRoleVisitor() {
			
			boolean[] timeout = new boolean[1];
			String masterName = null;
			@Override
			public boolean visit(Role role, Role sameUserRole) {
				if( role != null ) masterName = role.name;
				return role != null && role.masterOnPassiveReqGraduate(appID, timeout);
			}
			
			@Override
			public void onCallback(boolean success) {
				if( timeout[0] && masterName != null)
				{
					masterAgreeGraduate(gs, mID, masterName, appID);
				}
			}
		});
	}
	
	public static void masterAgreeGraduate(final GameServer gs, final int masterID, final String masterName, final int appID)
	{
		gs.getLoginManager().exeCommonRoleVisitor(appID, true, new LoginManager.CommonRoleVisitor() {
			
			String appName = null;
			int score = -1;
			
			@Override
			public boolean visit(Role role, Role sameUserRole) {
				if( role == null )
					return false;
				score = role.masterOnPassiveGraduate(masterID);
				if( score < 0 )
					return false;
				
				appName = role.name;
				return true;
			}
			
			@Override
			public void onCallback(boolean success) {
				if( success && appName != null && score >= 0 )
				{
					final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
					
					List<SBean.GameItem> attM = GameData.getInstance().toGameItems(cfg.graduateMasterRewards);
					gs.getLoginManager().sysSendMail(masterID
							, MailBox.SysMailType.MasterGraduateMasterReward
							, MailBox.MAX_RESERVE_TIME
							, appID + "|" + appName
							, attM
							, new ArrayList<>());
					
					List<SBean.DummyGoods> lvlGoods = null;
					
					for(SBean.MasterGraduateRewardCFGS lvlCfgs : cfg.graduateApprenticeRewards )
					{
						if( lvlCfgs.minScore > score )
							break;
						
						lvlGoods = lvlCfgs.rewards;
					}
					
					if( lvlGoods != null )
					{
						List<SBean.GameItem> attA = GameData.getInstance().toGameItems(lvlGoods);
						gs.getLoginManager().sysSendMail(appID
							, MailBox.SysMailType.MasterGraduateApprenticeReward
							, MailBox.MAX_RESERVE_TIME
							, masterID + "|" + masterName
							, attA
							, new ArrayList<>());
					}
				}
			}
		});
	}
	
	public void masterActiveBetray(final int sid)
	{
		final SBean.master_betray_res res = new SBean.master_betray_res(GameData.PROTOCOL_OP_MASTER_FAIL);
		int masterID = 0;
		synchronized( this )
		{
			if( master.master > 0 )
			{
				masterID = master.master;
				res.retCode = GameData.PROTOCOL_OP_MASTER_OK;
				master.master = 0;
				master.historyPoint = 0;
				master.tasks.clear();
				master.lastBetrayTime = GameTime.getTime();
				this.masterNoticeBrief();
			}
			else
				res.retCode = GameData.PROTOCOL_OP_MASTER_MASTER_NOT_EXIST;
		}
		gs.getRPCManager().sendStrPacket(sid, res);
		if( masterID == 0 )
			return;
		onlineSave(GameTime.getTime());
		final int appID = this.id;
		gs.getLoginManager().exeCommonRoleVisitor(masterID, true, new LoginManager.CommonRoleVisitor() {
			
			@Override
			public boolean visit(Role role, Role sameUserRole) {
				return role != null && role.masterOnPassiveBetray(appID);
			}
			
			@Override
			public void onCallback(boolean success) {
				// TODO
			}
		});
	}
	
	public boolean masterOnPassiveDismiss(final int masterID)
	{
		synchronized( this )
		{
			if( master.master == masterID )
			{
				master.master = 0;
				master.historyPoint = 0;
				master.tasks.clear();
				this.masterNoticeBrief();
				return true;
			}
		}
		return false;
	}
	
	public void masterActiveDismiss(final int sid, final int appID)
	{
		final SBean.master_dismiss_res res = new SBean.master_dismiss_res(appID, GameData.PROTOCOL_OP_MASTER_FAIL);
		final int masterID = id;
		final String masterName = name;
		synchronized( this )
		{
			if( master.apprentices.removeIf(app->app == appID) )
			{
				master.graduateReqList.removeIf(req->req.roleID == appID);
				res.retCode = GameData.PROTOCOL_OP_MASTER_OK;
				master.lastDismissTime = GameTime.getTime();
				this.masterNoticeBrief();
			}	
			else
				res.retCode = GameData.PROTOCOL_OP_MASTER_APPRENTICE_NOT_EXIST;
		}
		
		gs.getRPCManager().sendStrPacket(sid, res);
		if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK )
			return;
		onlineSave(GameTime.getTime());
		gs.getLoginManager().sysSendMail(appID
				, MailBox.SysMailType.MasterDismiss
				, MailBox.MAX_RESERVE_TIME
				, masterID + "|" + masterName
				, new ArrayList<>()
				, new ArrayList<>());
		gs.getMasterManager().masterDismiss(true, masterID, appID);
	}	
	
	public int masterOnPassiveGraduate(final int masterID)
	{
		final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		synchronized( this )
		{
			if( master.master == masterID )
			{
				int score = masterGetScore();
				if( score < cfg.minGraduateScore )
					return -1;
					
				master.master = 0;
				master.historyPoint = 0;
				this.masterNoticeBrief();
				return score;
			}
		}
		return -1;
	}
	
	public void masterActiveAgreeGraduate(final int sid, final SBean.master_agree_graduate_req req)
	{
		final SBean.master_agree_graduate_res res = new SBean.master_agree_graduate_res(
				GameData.PROTOCOL_OP_MASTER_OK, req.targetRoleID, req.agree);
		
		synchronized( this )
		{
			if( ! master.graduateReqList.removeIf(reqe->reqe.roleID == req.targetRoleID) )
				res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
			else if( ! master.apprentices.stream().anyMatch(app->app == req.targetRoleID) )
				res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
			else if( req.agree )
			{
				master.apprentices.removeIf(app->app == req.targetRoleID);
				this.masterNoticeBrief();
			}
		}
		
		gs.getRPCManager().sendStrPacket(sid, res);
		if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK )
			return;
		
		final int masterID = this.id;
		final String masterName = this.name;
		
		if( ! res.agree )
		{
			gs.getLoginManager().sysSendMail(req.targetRoleID
				, MailBox.SysMailType.MasterRefuseGraduate
				, MailBox.MAX_RESERVE_TIME
				, masterID + "|" + masterName
				, new ArrayList<>()
				, new ArrayList<>());
			return;
		}
		
		onlineSave(GameTime.getTime());
		
		masterAgreeGraduate(gs, masterID, masterName, req.targetRoleID);
	}
	
	public void masterAcceptOffer(final int sid, final int masterID)
	{
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		final SBean.master_accept_offer_res res = new SBean.master_accept_offer_res(
				GameData.PROTOCOL_OP_MASTER_OK, masterID); 
		synchronized( this )
		{
			if( masterID <= 0 || masterID == id )
				res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
			else if( level < cfg.minApprenticeLvl || level > cfg.maxApprenticeLvl )
				res.retCode = GameData.PROTOCOL_OP_MASTER_APPRENTICE_LEVEL;
			else if( master.master > 0 )
				res.retCode = GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( master.lastBetrayTime + cfg.betrayCoolTime >= now )
				res.retCode = GameData.PROTOCOL_OP_MASTER_BETRAY_COOL;
		}
		final int appID = this.id;
		if( res.retCode == GameData.PROTOCOL_OP_MASTER_OK
				&& ! gs.getMasterManager().removeOfferReq(masterID, appID) )
			res.retCode = GameData.PROTOCOL_OP_MASTER_OFFER_NOT_EXIST;
		if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK )
		{
			gs.getRPCManager().sendStrPacket(sid, res);
			return;
		}
		
		gs.getLoginManager().exeCommonRoleVisitor(masterID, true, new LoginManager.CommonRoleVisitor() {
			
			boolean[] appFull = new boolean[1];
			@Override
			public boolean visit(Role role, Role sameUserRole) {
				if( role != null )
				{
					res.retCode = role.masterOnAcceptConfirm(appID, appFull);
				}
				else
					res.retCode = GameData.PROTOCOL_OP_MASTER_NOT_FOUND;
				return res.retCode == GameData.PROTOCOL_OP_MASTER_OK;
			}
			
			@Override
			public void onCallback(boolean success) {
				if( ! success )
					res.retCode = GameData.PROTOCOL_OP_MASTER_NOT_FOUND;
				if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK)
					gs.getRPCManager().sendStrPacket(sid, res);
				else
				{
					if( appFull[0] )
						gs.getMasterManager().removeAnnounce(masterID);
					gs.getMasterManager().masterAcceptOfferConfirm(sid, appID, masterID, res);
				}
			}
		});
	}
	
	public int masterCanAcceptApply()
	{
		final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			if( this.level < cfg.minMasterLvl )
				return GameData.PROTOCOL_OP_MASTER_MASTER_LEVEL;
			else if( this.master.master > 0 )
				return GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( this.master.apprentices.size() >= cfg.maxApprenticeCount )
				return GameData.PROTOCOL_OP_MASTER_TOO_MANY_APPRENTICE;
			else if( this.master.lastDismissTime + cfg.dismissCoolTime >= now )
				return GameData.PROTOCOL_OP_MASTER_DISMISS_COOL;
		}
		return GameData.PROTOCOL_OP_MASTER_OK;
	}
	
	public void masterAcceptApply(final int sid, final SBean.master_accept_apply_req req)
	{
		final SBean.master_accept_apply_res res = new SBean.master_accept_apply_res(
				GameData.PROTOCOL_OP_MASTER_OK, req.targetRoleID, req.accept);
		boolean bRemove = false;
		synchronized( this )
		{
			bRemove = master.applyList.removeIf(app->app.roleID == req.targetRoleID);
		}
		if( ! req.accept )
		{
			gs.getRPCManager().sendStrPacket(sid, res);
			if( bRemove )
				gs.getMasterManager().noticeAcceptApply(req.targetRoleID, this.id, this.name, false);
			return;
		}
		final SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			if( this.level < cfg.minMasterLvl )
				res.retCode = GameData.PROTOCOL_OP_MASTER_MASTER_LEVEL;
			else if( this.master.master > 0 )
				res.retCode = GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( this.master.apprentices.size() >= cfg.maxApprenticeCount )
				res.retCode = GameData.PROTOCOL_OP_MASTER_TOO_MANY_APPRENTICE;
			else if( this.master.lastDismissTime + cfg.dismissCoolTime >= now )
				res.retCode = GameData.PROTOCOL_OP_MASTER_DISMISS_COOL;
			else if( ! this.master.applyList.stream().anyMatch(app->app.roleID == req.targetRoleID) )
				res.retCode = GameData.PROTOCOL_OP_MASTER_NOT_FOUND;
			else if( this.master.apprentices.stream().anyMatch(appID->appID == req.targetRoleID) )
				res.retCode = GameData.PROTOCOL_OP_MASTER_APPRENTICE_EXIST;
		}
		if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK )
		{
			gs.getRPCManager().sendStrPacket(sid, res);
			return;
		}
		final int masterID = this.id;
		final String masterName = this.name;
		gs.getLoginManager().exeCommonRoleVisitor(req.targetRoleID, true, new LoginManager.CommonRoleVisitor() {
			
			@Override
			public boolean visit(Role role, Role sameUserRole) {
				if( role != null )
				{
					res.retCode = role.masterOnMasterAccept(masterID);
				}
				else
					res.retCode = GameData.PROTOCOL_OP_MASTER_NOT_FOUND;
				return res.retCode == GameData.PROTOCOL_OP_MASTER_OK;
			}
			
			@Override
			public void onCallback(boolean success) {
				if( ! success )
					res.retCode = GameData.PROTOCOL_OP_MASTER_NOT_FOUND;
				if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK)
					gs.getRPCManager().sendStrPacket(sid, res);
				else
					gs.getMasterManager().masterAcceptApplyConfirm(sid, masterID, masterName, req, res);
			}
		});
	}
	
	public int masterOnPassiveOffer(final SBean.master_offer_notice notice)
	{
		if( notice == null || netsid == 0 )
			return GameData.PROTOCOL_OP_MASTER_NOT_FOUND;;
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		synchronized( this )
		{
			if( level < cfg.minApprenticeLvl || level > cfg.maxApprenticeLvl )
				return GameData.PROTOCOL_OP_MASTER_APPRENTICE_LEVEL;
			else if( master.master > 0 )
				return GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( master.lastBetrayTime + cfg.betrayCoolTime >= GameTime.getTime() )
				return GameData.PROTOCOL_OP_MASTER_BETRAY_COOL;
		}
		gs.getRPCManager().sendStrPacket(netsid, notice);
		return GameData.PROTOCOL_OP_MASTER_OK;
	}
	
	public void masterOfferReq(final int sid, final int appID)
	{
		SBean.master_offer_res res = new SBean.master_offer_res(GameData.PROTOCOL_OP_MASTER_OK, appID);
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		int now = GameTime.getTime();
		synchronized( this )
		{
			if( appID <= 0 || appID == this.id )
				res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
			else if( this.level < cfg.minMasterLvl )
				res.retCode = GameData.PROTOCOL_OP_MASTER_MASTER_LEVEL;
			else if( this.master.master > 0 )
				res.retCode = GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( this.master.apprentices.size() >= cfg.maxApprenticeCount )
				res.retCode = GameData.PROTOCOL_OP_MASTER_TOO_MANY_APPRENTICE;
			else if( this.master.lastDismissTime + cfg.dismissCoolTime >= now )
				res.retCode = GameData.PROTOCOL_OP_MASTER_DISMISS_COOL;
			else if( this.master.apprentices.stream().anyMatch(app->app == appID) )
				res.retCode = GameData.PROTOCOL_OP_MASTER_APPRENTICE_EXIST;
		}
		
		if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK )
		{
			gs.getRPCManager().sendStrPacket(sid, res);
			return;
		}
		
		Role roleApp = gs.getLoginManager().getOnGameRole(appID);
		if( roleApp == null )
		{
			res.retCode = GameData.PROTOCOL_OP_MASTER_NOT_FOUND;
			gs.getRPCManager().sendStrPacket(sid, res);
			return;
		}
		res.retCode = roleApp.masterOnPassiveOffer(new SBean.master_offer_notice(this.getMasterDetail()));
		if( res.retCode == GameData.PROTOCOL_OP_MASTER_OK )
		{
			gs.getMasterManager().logOfferReq(this.id, appID);
		}
		gs.getRPCManager().sendStrPacket(sid, res);		
	}
	
	public void masterApplyReq(final int sid, final int masterID)
	{
		SBean.master_apply_res res = new SBean.master_apply_res(GameData.PROTOCOL_OP_MASTER_OK, masterID);
		SBean.MasterCFGS cfg = GameData.getInstance().getMasterCFGS();
		synchronized( this )
		{
			if( masterID <= 0 || masterID == id )
				res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
			else if( level < cfg.minApprenticeLvl || level > cfg.maxApprenticeLvl )
				res.retCode = GameData.PROTOCOL_OP_MASTER_APPRENTICE_LEVEL;
			else if( master.master > 0 )
				res.retCode = GameData.PROTOCOL_OP_MASTER_MASTER_EXIST;
			else if( master.lastBetrayTime + cfg.betrayCoolTime >= GameTime.getTime() )
				res.retCode = GameData.PROTOCOL_OP_MASTER_BETRAY_COOL;
		}
		if( res.retCode != GameData.PROTOCOL_OP_MASTER_OK)
		{
			gs.getRPCManager().sendStrPacket(sid, res);
			return;
		}
		final SBean.ApprenticeDetail detail = this.getApprenticeDetail();
		final int applyRoleID = id;
		gs.getLoginManager().exeCommonRoleVisitor(masterID, false, new LoginManager.CommonRoleVisitor() {
			
			@Override
			public boolean visit(Role role, Role sameUserRole) {
				// TODO Auto-generated method stub
				res.retCode = role.masterAddApply(applyRoleID);
				return res.retCode == GameData.PROTOCOL_OP_MASTER_OK;
			}
			
			@Override
			public void onCallback(boolean success) {
				if( ! success )
					res.retCode = GameData.PROTOCOL_OP_MASTER_FAIL;
				gs.getRPCManager().sendStrPacket(sid, res);
				if( res.retCode == GameData.PROTOCOL_OP_MASTER_OK )
					gs.getMasterManager().noticeApply(masterID, detail);
			}
		});
	}
	////////////////////////////////// 师徒 end //////////////////////////////////////
	
	///////////////////////////////////////////////////竞技场 /////////////////////////////////////////////////////

	// 竞技场
	public class RoleArena
	{
		SBean.DBRoleArenaData roleArenaData;
		Map<Integer, Integer> arenaCurrentEnemies;//rank -> role

		RoleArena()
		{
		}

		RoleArena fromDBData(SBean.DBRoleArenaData roleArenaData)
		{
			this.roleArenaData = roleArenaData;
			this.arenaCurrentEnemies = new TreeMap<Integer, Integer>();

			return this;
		}

		//bwarena
		boolean canUseBWArenaScore(int value)
		{
			return this.roleArenaData.bwarena.rewardScore >= value;
		}

		int useBWArenaScore(int value)
		{
			int use = this.roleArenaData.bwarena.rewardScore > value ? value : this.roleArenaData.bwarena.rewardScore;
			this.roleArenaData.bwarena.rewardScore -= use;
			return use;
		}

		int canEnterBWArena(int targetID)
		{
			SBean.BWArenaBaseCFGS baseCfg = GameData.getInstance().getBWArenaCFGS().base;
			if (this.roleArenaData.bwarena.rewardScore >= baseCfg.rewardScoreReq)
				return GameData.PROTOCOL_OP_FAILED;

			if (this.roleArenaData.bwarena.timesUsed >= (this.roleArenaData.bwarena.timesBuy + baseCfg.dayEnterTimes) || !isBWArenaInOpenTime(baseCfg))
				return GameData.PROTOCOL_OP_FAILED;

			Integer score = this.roleArenaData.bwarena.curEnemies.get(targetID);
			if (score == null || score != 0)
				return GameData.PROTOCOL_OP_BWARENA_ENEMY_NOT_EXIT;

			return GameData.PROTOCOL_OP_SUCCESS;
		}

		boolean isBWArenaInOpenTime(SBean.BWArenaBaseCFGS baseCfg)
		{
			return GameData.isMapCopyInOpenTime(baseCfg.startTime, baseCfg.endTime);
		}

		boolean addBWArenaExp(int exp)
		{
			GameData.LevelExp lvlExp = GameData.getInstance().getAddBWArenaExpLvlExp(this.roleArenaData.bwarena.lvl, this.roleArenaData.bwarena.exp, exp);
			boolean lvlChange = lvlExp.level > this.roleArenaData.bwarena.lvl;
			if (lvlChange)
			{
				this.roleArenaData.bwarena.lvl = lvlExp.level;
				Role.this.refreshBwArenaEnemiesImpl();
			}
			this.roleArenaData.bwarena.exp = (int) lvlExp.exp;
			return lvlChange;
		}
	}

	public class RoleClimbTower
	{
		SBean.DBClimbTower roleClimbTowerData;
		Map<Integer, SBean.DBClimbTowerRecordData> roleClimbTowerRecordData;
		
		Map<Integer, SBean.DBClimbTowerFame> roleClimbTowerFameData;
		//super arena

		RoleClimbTower()
		{
		}

		RoleClimbTower fromDBData(SBean.DBClimbTower roleClimbTowerData, Map<Integer, SBean.DBClimbTowerRecordData> roleClimbTowerRecordData, Map<Integer, SBean.DBClimbTowerFame> roleClimbTowerFame)
		{
			this.roleClimbTowerData = roleClimbTowerData;
			this.roleClimbTowerRecordData = roleClimbTowerRecordData;
			this.roleClimbTowerFameData = roleClimbTowerFame;
			return this;
		}

		//bwarena
//		boolean canUseBWArenaScore(int value)
//		{
//			return this.roleArenaData.bwarena.rewardScore >= value;
//		}
//
//		int useBWArenaScore(int value)
//		{
//			int use = this.roleArenaData.bwarena.rewardScore > value ? value : this.roleArenaData.bwarena.rewardScore;
//			this.roleArenaData.bwarena.rewardScore -= use;
//			return use;
//		}
//
//		int canEnterBWArena(int targetID)
//		{
//			SBean.BWArenaBaseCFGS baseCfg = GameData.getInstance().getBWArenaCFGS().base;
//			if (this.roleArenaData.bwarena.rewardScore >= baseCfg.rewardScoreReq)
//				return GameData.PROTOCOL_OP_FAILED;
//
//			if (this.roleArenaData.bwarena.timesUsed >= (this.roleArenaData.bwarena.timesBuy + baseCfg.dayEnterTimes) || !isBWArenaInOpenTime(baseCfg))
//				return GameData.PROTOCOL_OP_FAILED;
//
//			Integer score = this.roleArenaData.bwarena.curEnemies.get(targetID);
//			if (score == null || score != 0)
//				return GameData.PROTOCOL_OP_BWARENA_ENEMY_NOT_EXIT;
//
//			return GameData.PROTOCOL_OP_SUCCESS;
//		}
//
//		boolean isBWArenaInOpenTime(SBean.BWArenaBaseCFGS baseCfg)
//		{
//			return GameData.isMapCopyInOpenTime(baseCfg.startTime, baseCfg.endTime);
//		}
//
//		boolean addBWArenaExp(int exp)
//		{
//			GameData.LevelExp lvlExp = GameData.getInstance().getAddBWArenaExpLvlExp(this.roleArenaData.bwarena.lvl, this.roleArenaData.bwarena.exp, exp);
//			boolean lvlChange = lvlExp.level > this.roleArenaData.bwarena.lvl;
//			if (lvlChange)
//			{
//				this.roleArenaData.bwarena.lvl = lvlExp.level;
//				Role.this.refreshBwArenaEnemiesImpl();
//			}
//			this.roleArenaData.bwarena.exp = lvlExp.exp;
//			return lvlChange;
//		}
	}

	public void notifyArenaAttacked()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.arena_attacked());
	}
	
	private void dayRefreshArena()
	{
		this.arenaInfo.roleArenaData.normal.timesBuy = 0;
		this.arenaInfo.roleArenaData.normal.timesUsed = 0;
		this.arenaInfo.roleArenaData.normal.score = 0;
		this.arenaInfo.roleArenaData.normal.rewardScores.clear();
	}

	// 竞技场商店
	public synchronized void syncArenaShopInfo()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.arena_shopsync_res(this.syncShopInfo(GameData.SHOP_TYPE_ARENA), this.arenaInfo.roleArenaData.normal.point));
	}

	public SBean.ShopInfo userRefreshArenaShop(int times, int isSecondType)
	{
		return this.userRefreshShop(GameData.SHOP_TYPE_ARENA, times, isSecondType);
	}

	public boolean buyArenaShopGoogs(int seq)
	{
		return this.buyShopGoogs(GameData.SHOP_TYPE_ARENA, seq);
	}

	public void syncArenaInfo()
	{
		gs.getArenaManager().getRoleArenaInfo(this);
	}

	public synchronized SBean.ArenaStateInfo getArenaInfo(int rankNow, Map<Integer, SBean.BattleEnemyOverview> enemies)
	{
		if (rankNow < this.arenaInfo.roleArenaData.normal.bestRank)
			this.arenaInfo.roleArenaData.normal.bestRank = rankNow;

		SBean.ArenaStateInfo arenaInfo = new SBean.ArenaStateInfo(this.arenaInfo.roleArenaData.normal.point, rankNow, this.arenaInfo.roleArenaData.normal.bestRank, this.arenaInfo.roleArenaData.normal.timesUsed, this.arenaInfo.roleArenaData.normal.timesBuy, this.arenaInfo.roleArenaData.normal.lastFightTime, new ArrayList<>(this.arenaInfo.roleArenaData.normal.defencePets), enemies, this.testArenaScoreReward() ? 1 : 0, this.arenaInfo.roleArenaData.normal.hideDefence);
		return arenaInfo;
	}
	
	public void getArenaDefencePetsBattleArray(int roleId, int roleRank)
	{
		gs.getLoginManager().getRoleArenaDefenceBattleArrayOverview(roleId, roleRank, (o, hideDefence)->
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.arena_defencepets_res(o == null ? GameData.emptyList() : o.pets, hideDefence));
			});
	}

	public void refreshArenaEnemies()
	{
		gs.getArenaManager().roleRefreshArenaEnemies(this);
	}

	public synchronized void changeArenaEnemies(Map<Integer, SBean.BattleEnemyOverview> oveviews)
	{
		this.arenaInfo.arenaCurrentEnemies.clear();
		for (Map.Entry<Integer, SBean.BattleEnemyOverview> e : oveviews.entrySet())
			this.arenaInfo.arenaCurrentEnemies.put(e.getKey(), e.getValue().roleSocial.role.id);
	}

	public synchronized boolean setArenaDefencePets(List<Integer> pets)
	{
		if (!checkArenaPetsValid(pets))
			return false;

		this.arenaInfo.roleArenaData.normal.defencePets = pets;
		return true;
	}

	private boolean checkArenaPetsValid(List<Integer> pets)
	{
		Set<Integer> check = new HashSet<>();
		if (pets.size() > GameData.PET_TYPE_ARENA_MAX_USE)
			return false;

		for (int pid : pets)
		{
			if (!this.activePets.containsKey(pid) && !check.add(pid))
				return false;
		}

		return true;
	}

	public void syncArenaRankList()
	{
		gs.getArenaManager().roleSyncRanks(this);
	}

	public synchronized boolean arenaResetCool()
	{
		int cost = GameData.getInstance().getArenaCFGS().stoneRefresh;
		if (!this.canUseDiamond(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ARENA_RESET_COOL);
		tlogEvent.setArg(cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.arenaInfo.roleArenaData.normal.lastFightTime = 0;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean arenaBuyTimes(int timesBuy)
	{
		if (this.arenaInfo.roleArenaData.normal == null)
			return false;

		if (timesBuy != this.arenaInfo.roleArenaData.normal.timesBuy + 1)
			return false;

		SBean.VipCFGS vipcfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipcfg == null || timesBuy > vipcfg.dayMaxBuyArenaFight)
			return false;

		int cost = GameData.getTimesCost(GameData.getInstance().getArenaCFGS().timesPrice, timesBuy);
		if (!this.canUseDiamond(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ARENA_BUY_TIMES);
		tlogEvent.setArg(timesBuy, cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.arenaInfo.roleArenaData.normal.timesBuy = timesBuy;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	boolean checkCanStartArenaMapCopy(List<Integer> pets, int trid, int trank)
	{
		if (!this.checkArenaPetsValid(pets))
			return false;

		if(this.isMulRolesState())
			return false;
		
		Integer searchEnemyRid = this.arenaInfo.arenaCurrentEnemies.get(trank);
		if (searchEnemyRid == null || searchEnemyRid != trid)
			return false;

		SBean.ArenaCFGS cfg = GameData.getInstance().getArenaCFGS();
		if (cfg == null || this.level < cfg.lvlReq || (this.arenaInfo.roleArenaData.normal.lastFightTime + cfg.coolTime) > GameTime.getTime())
			return false;

		if (this.arenaInfo.roleArenaData.normal.timesUsed >= cfg.freeTimes + this.arenaInfo.roleArenaData.normal.timesBuy)
			return false;
		return true;
	}

	public void startArenaBattle(int srank, List<Integer> pets, int trid, int trank)
	{
		gs.getArenaManager().roleStartArenaBattle(this, srank, new ArrayList<>(pets), trid, trank);
	}

	public synchronized void arenaAddLog(SBean.DBRoleArenaLog log)
	{
		this.arenaInfo.roleArenaData.normal.logs.add(log);
		if (this.arenaInfo.roleArenaData.normal.logs.size() > 10)
			this.arenaInfo.roleArenaData.normal.logs.subList(0, this.arenaInfo.roleArenaData.normal.logs.size() - 10).clear();
	}

	public void syncArenaLogs()
	{
		gs.getArenaManager().clearAttacked(this);
	}
	
	public synchronized void notifyRoleArenaLogs()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.arena_log_res(Stream.clone(this.arenaInfo.roleArenaData.normal.logs)));
	}
	
	public synchronized void syncArenaScore()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.arena_scoresync_res(this.arenaInfo.roleArenaData.normal.score, new ArrayList<Integer>(this.arenaInfo.roleArenaData.normal.rewardScores)));
	}

	private boolean testArenaScoreReward()
	{
		for (int score : GameData.getInstance().getArenaCFGS().scoreRewards.keySet())
		{
			if (this.arenaInfo.roleArenaData.normal.score < score)
				continue;

			if (this.arenaInfo.roleArenaData.normal.rewardScores.contains(score))
				continue;

			return true;
		}

		return false;
	}

	public synchronized boolean takeArenaScoreReward(int score)
	{
		if (this.arenaInfo.roleArenaData.normal.score < score)
			return false;

		if (this.arenaInfo.roleArenaData.normal.rewardScores.contains(score))
			return false;

		this.arenaInfo.roleArenaData.normal.rewardScores.add(score);

		SBean.ArenaRewardCFGS scoreReward = GameData.getInstance().getArenaCFGS().scoreRewards.get(score);

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_ARENA_SCORE_REWARD);
		tlogEvent.setArg(score);
		if (scoreReward != null)
		{
			if (scoreReward.money > 0)
				this.syncAddCoin(scoreReward.money, false, tlogEvent);

			if (scoreReward.stone > 0)
				this.syncAddDiamond(scoreReward.stone, false, tlogEvent);

			if (scoreReward.point > 0)
				this.syncAddArenaPoint(scoreReward.point, tlogEvent);

			if (scoreReward.items.size() > 0)
				this.syncAddGameItems(GameData.getInstance().toGameItems(scoreReward.items), tlogEvent);
		}

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	void onArenaReward(int rank)
	{
		update1V1ArenaTop500(rank);
		if(rank <= 50)
			gs.getTLogger().logArenaRank(this, rank);
	}
	
	void update1V1ArenaTop500(int rank)
	{
		if (rank <= 500)
		{
			this.arenaInfo.roleArenaData.normal.curTop500Days++;
			if (this.arenaInfo.roleArenaData.normal.curTop500Days > this.arenaInfo.roleArenaData.normal.top500Days)
			{
				this.arenaInfo.roleArenaData.normal.top500Days = this.arenaInfo.roleArenaData.normal.curTop500Days;
				testChallengeTask(GameData.CHALLENGE_TASK_ID_NORMALARENA_TOP100, 0);
			}
		}
		else
			this.arenaInfo.roleArenaData.normal.curTop500Days = 0;
	}

	//用的实际的VIP等级
	public synchronized int setArenaDefenceHide(byte hide)
	{
		if(this.arenaInfo.roleArenaData.normal.hideDefence == hide)
			return GameData.PROTOCOL_OP_FAILED;
		
		if(this.share.getVipLevel() < GameData.getInstance().getArenaCFGS().hideDefenceVipReq)
			return GameData.PROTOCOL_OP_FAILED; 
		
		this.arenaInfo.roleArenaData.normal.hideDefence = (byte) (hide == 0 ? 0 : 1);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized byte getArenaDefenceHide()
	{
		return this.arenaInfo.roleArenaData.normal.hideDefence; 
	}
	
	/////////////////////////////////4v4竞技场 ///////////////////////
	void dayRefreshSuperArena(int nowday)
	{
		for(SBean.SuperArenaLog e: this.arenaInfo.roleArenaData.superarena.logs.values())
		{
			e.dayEnterTimes = 0;
			e.dayFailedStreak = 0;
			e.dayHonor = 0;
		}
	}
	
	synchronized int getSuperArenaDayEnterTimes(int arenaType)
	{
		SBean.SuperArenaLog log = this.arenaInfo.roleArenaData.superarena.logs.get(arenaType);
		if(log != null)
			return log.dayEnterTimes;
		
		return 1;
	}
	
	private int getSuperArenaTotalJoinTimes()
	{
	    final int totalTimes[] = {0};
	    this.arenaInfo.roleArenaData.superarena.logs.forEach( (logType, logs) -> {
	        totalTimes[0] += logs.enterTimes;
	    });
	    
	    return totalTimes[0];
	}

    private int getForceWarJoinTimes()
    {
		return this.forceWarInfo.forcewar.log.enterTimes;
    }

	// 会武场商店
	public synchronized void syncSuperArenaShopInfo()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.superarena_shopsync_res(this.syncShopInfo(GameData.SHOP_TYPE_SUPERARENA), this.arenaInfo.roleArenaData.superarena.point));
	}

	public SBean.ShopInfo userRefreshSuperArenaShop(int times, int isSecondType)
	{
		return this.userRefreshShop(GameData.SHOP_TYPE_SUPERARENA, times, isSecondType);
	}

	public boolean buySuperArenaShopGoogs(int seq)
	{
		return this.buyShopGoogs(GameData.SHOP_TYPE_SUPERARENA, seq);
	}

	void syncSuperArenaInfo()
	{
		int rank = gs.getRankManager().getRoleSnapshotRank(GameData.RANK_TYPE_SUPER_ARENA_WEEK, this.id);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.superarena_sync_res(this.getSuperArenaInfo(rank)));
	}
	
	private synchronized SBean.SuperArenaInfo getSuperArenaInfo(int weekRank)
	{
		if(this.level < GameData.getInstance().getSuperArenaCFGS().needLvl)
			return null;
		
		return new SBean.SuperArenaInfo(this.arenaInfo.roleArenaData.superarena.point, 
										weekRank,
										Stream.clone(this.arenaInfo.roleArenaData.superarena.logs),
										new HashSet<>(this.arenaInfo.roleArenaData.superarena.pets));
	}

	public synchronized boolean setSuperArenaPets(Set<Integer> pets)
	{
		if(!checkSuperArenaPetsValid(pets))
			return false;
		
		this.arenaInfo.roleArenaData.superarena.pets = pets;
		return true;
	}
	
	boolean checkSuperArenaPetsValid(Set<Integer> pets)
	{
		if(pets.size() > GameData.PET_TYPE_SUPERARENA_MAX_USE)
			return false;
		
		for(int pid: pets)
		{
			if(!this.activePets.containsKey(pid))
				return false;
		}
		
		return true;
	}
	
	boolean isSuperArenaMatchTimeOut()
	{
		return GameTime.getTime() - this.superarenaJoinTime >= GameData.getInstance().getSuperArenaCFGS().maxMatchTime;
	}
	
	void singleJoinSuperArena(int type)
	{
		synchronized (this)
		{
			if (this.isInTeam() || this.isInMulRolesActivity() || this.isMulRolesState())
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.superarena_singlejoin_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			
			SBean.SuperArenaTypeCFGS typeCfg = GameData.getInstance().getSuperArenaTypeCFG(type);
			if (typeCfg == null || this.level < typeCfg.needLvl || (gs.getOpenDay() + 1) < GameData.getInstance().getSuperArenaCFGS().openDay || !GameData.isSuperArenaInOpenTime(typeCfg))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.superarena_singlejoin_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}
		
		int grade = GameData.getInstance().getSuperArenaGrade(type, this.level);
		gs.getFightService().singleJoinSuperArenaImpl(this.getSuperArenaJoinInfo(type), type, grade, ok -> {
			if(ok > 0)
			{
				this.superarenaState = GameData.SUPERARENA_JOIN_SINGLE;
				this.superarenaJoinType = type;
				this.superarenaJoinGrade = grade;
				this.superarenaJoinTime = GameTime.getTime();
				gs.getFightService().addSuperArenaJoinRole(this.id);
			}
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.superarena_singlejoin_res(ok));
			gs.getTLogger().logSuperArenaFlow(Role.this, 0, type, TLog.ARENAEVENT_APPLY, 0);
		});
	}
	
	synchronized void clearSuperArenaState()
	{
		this.superarenaState = 0;
		this.superarenaJoinTime = 0;
		this.superarenaJoinType = 0;
		this.superarenaJoinGrade = 0;
		gs.getFightService().delSuperArenaJoinRole(this.id);
	}
	
	void teamJoinSuperArena(int type)
	{
		synchronized (this)
		{
			if (!this.isInARoom() || this.isInMRoom() || this.isInFRoom() || this.isInJoinState() || this.isMulRolesState())
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.superarena_teamjoin_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}

		gs.getArenaRoomManager().teamJoinMatch(this, type);
		gs.getTLogger().logSuperArenaFlow(this, 1, type, TLog.ARENAEVENT_APPLY, 1);
	}

	public interface SuperArenaQuitCallBack
	{
		void onCallback(int ok);
	}
	
	void superarenaQuit(SuperArenaQuitCallBack callback)
	{
		if (this.superarenaState == GameData.SUPERARENA_JOIN_SINGLE)
			singleJoinQuit(callback);
		else if (this.superarenaState == GameData.SUPERARENA_JOIN_TEAM)
			teamJoinQuit(callback);
		else if(callback != null)
			callback.onCallback(GameData.PROTOCOL_OP_FAILED);
	}

	void singleJoinQuit(SuperArenaQuitCallBack callback)
	{
		gs.getFightService().singleQuitSuperArenaImpl(this.id, this.superarenaJoinType, this.superarenaJoinGrade, ok -> {
			if(ok > 0)
				this.clearSuperArenaState();
			
			if(callback != null)
				callback.onCallback(ok);
		});
	}

	void teamJoinQuit(SuperArenaQuitCallBack callback)
	{
		gs.getArenaRoomManager().quitMatch(this, this.arenaroom, callback);
	}

	int getMatchPower(int superArenaType)
	{
		return (int) (this.roleProperties.getRoleFightPower() * (0.5f + getSuperArenaWinRate(superArenaType))); //TODO get cfg
	}

	float getSuperArenaWinRate(int superArenaType)
	{
		SBean.SuperArenaLog log = this.arenaInfo.roleArenaData.superarena.logs.get(superArenaType);
		return log == null ? 0 : (float) log.winTimes / (float) log.enterTimes;
	}
	
	synchronized void superArenaMatchResult(int result)
	{
		this.clearSuperArenaState();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.superarena_join(result));
	}
	
	public void onSuperArenaEnd(int addHonor, int arenaType, int rankClearTime)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ON_SUPER_ARENA_END);
		tlogEvent.setArg(addHonor);
		if (addHonor > 0)
			this.syncAddSuperArenaPoint(addHonor, tlogEvent);

		//周荣誉
		SBean.SuperArenaLog log = this.arenaInfo.roleArenaData.superarena.logs.get(arenaType);
		if (this.arenaInfo.roleArenaData.superarena.rankClearTime != rankClearTime)
		{
			this.arenaInfo.roleArenaData.superarena.weekHonor = addHonor;
		}
		else
		{
			this.arenaInfo.roleArenaData.superarena.weekHonor += addHonor;
		}
		this.arenaInfo.roleArenaData.superarena.rankClearTime = rankClearTime;
		if(log != null)
			log.dayHonor += addHonor;
		
		if (addHonor > 0)
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}
	
	///////////4v4竞技场 room ///////////
	private int getARoomID()
	{
		return this.arenaroom.id;
	}

	private SBean.ARoom getARoom()
	{
		if (this.superarenaState == GameData.SUPERARENA_JOIN_SINGLE)
			return new SBean.ARoom(0, 0, 0, 0, new ArrayList<Integer>());

		return this.arenaroom.kdClone();
	}

	boolean isInARoom()
	{
		return this.arenaroom.id > 0;
	}

	private boolean isARoomLeader()
	{
		return this.arenaroom.id > 0 && this.arenaroom.leader == this.id;
	}

	private boolean isNotInARoomOrARoomFull()
	{
		return (this.arenaroom.id <= 0 || this.arenaroom.members.size() >= GameData.getInstance().getSuperArenaNeedMember(this.arenaroom.type));
	}

	private boolean isInARoomAndRoleBeInvited(int rid)
	{
		return this.arenaroom.id > 0 && this.aroomInvites.contains(rid);
	}

	private boolean isRoleInMyARoom(int rid)
	{
		return this.arenaroom.members.contains(rid);
	}

	private synchronized int testCanEnterARoom(int arenaType, int grade)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isMulRolesState())
			return GameData.PROTOCOL_OP_FAILED;

		if (GameData.getInstance().getSuperArenaGrade(arenaType, this.level) != grade)
			return GameData.PROTOCOL_OP_AROOM_ROLE_GRADE_FAIL;

		if (this.isInMulRolesActivity())
			return GameData.PROTOCOL_OP_AROOM_ALREADY_IN_ROOM;

		if(this.isInJoinState())
			return GameData.PROTOCOL_OP_FAILED;
		
//		if (this.superarenaState != 0)
//			return GameData.PROTOCOL_OP_AROOM_ROLE_MATCHING;

		return GameData.PROTOCOL_OP_SUCCESS;
	}

	// 房间更换房主
	synchronized void onARoomLeaderChange(Role newLeader)
	{
		this.arenaroom.leader = newLeader.id;
		if (this.superarenaState != GameData.SUPERARENA_JOIN_SINGLE)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.aroom_change_leader(newLeader.id, newLeader.name));
	}

	// 自己离开或房间其他人离开
	synchronized void onARoomMemberLeave(Role member)
	{
		if (member.id == this.id)
		{
			this.clearARoom();
		}
		else
		{
			this.arenaroom.members.remove(Integer.valueOf(member.id));
		}

		if (member.superarenaState != GameData.SUPERARENA_JOIN_SINGLE)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.aroom_leave(member.id, member.name));
	}

	public void clearARoom()
	{
		this.arenaroom.id = 0;
		this.arenaroom.leader = 0;
		this.arenaroom.members.clear();
		this.arenaroom.type = 0;
		this.aroomInvites.clear();
	}

	// 自己或队友被踢
	synchronized void onARoomMemberKicked(Role member)
	{
		if (member.id == this.id)
		{
			this.clearARoom();
		}
		else
		{
			this.arenaroom.members.remove(Integer.valueOf(member.id));
		}

		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.aroom_kick(member.id, member.name));
	}

	// 自己加入房间
	synchronized void onSelfJoinARoom(SBean.ARoom room)
	{
		this.arenaroom = room;
		this.aroomInvites.clear();
		if (this.superarenaState != GameData.SUPERARENA_JOIN_SINGLE)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.aroom_sync(room));
	}

	// 新人加入房间
	synchronized void onNewMemberJoinARoom(Role newMember)
	{
		this.arenaroom.members.add(newMember.id);
		if (this.superarenaState != GameData.SUPERARENA_JOIN_SINGLE)
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.aroom_join(newMember.id, newMember.name));
	}

	int aroomNewCreate(int type)
	{
		SBean.SuperArenaTypeCFGS typeCfg = GameData.getInstance().getSuperArenaTypeCFG(type);
		if (typeCfg == null || this.level < typeCfg.needLvl || (gs.getOpenDay() + 1) < GameData.getInstance().getSuperArenaCFGS().openDay || !GameData.isSuperArenaInOpenTime(typeCfg))
			return GameData.PROTOCOL_OP_FAILED;

		Set<Integer> members = new HashSet<>();
		int grade = 0;
		synchronized (this)
		{
			grade = GameData.getInstance().getSuperArenaGrade(type, this.level);
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;

			if (this.isInMulRolesActivity())
				return GameData.PROTOCOL_OP_AROOM_ALREADY_IN_ROOM;

			if (!this.isTeamLeader())
				return GameData.PROTOCOL_OP_FAILED;
			
			members.addAll(this.team.members);
		}
		
		Set<Role> suitMembers = new HashSet<>();
		for (int rid : members)
		{
			if (rid != this.id)
			{
				Role iRole = gs.getLoginManager().getOnGameRole(rid);
				if (iRole == null)
					return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;
				
				synchronized(iRole)
				{
					int error = iRole.testCanEnterARoom(type, grade);
					if (error <= 0)
						return error;

					suitMembers.add(iRole);
				}
			}
		}
		
		int roomID = gs.getArenaRoomManager().createArenaRoom(this, type);
		if (roomID <= 0)
			return roomID;

		suitMembers.forEach(role ->
		{
			this.aroomInvites.add(role.id);
			gs.getRPCManager().sendStrPacket(role.netsid, new SBean.aroom_invite_forward(this.id, this.name, type, roomID));
		});

		return GameData.PROTOCOL_OP_SUCCESS;
	}

	// 邀请者必须在房间，是否为队长都可以邀请，不同于队伍，被邀请者无任何要求和限制
	public int aroomInvite(int invitedRoleID)
	{
		SBean.SuperArenaTypeCFGS typeCfg = GameData.getInstance().getSuperArenaTypeCFG(this.arenaroom.type);
		if (typeCfg == null || !GameData.isSuperArenaInOpenTime(typeCfg))
			return GameData.PROTOCOL_OP_FAILED;

		if (invitedRoleID == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role iRole = gs.getLoginManager().getOnGameRole(invitedRoleID);
		if (iRole == null)
			return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;
		
		synchronized (this)
		{
			if(this.isInJoinState())
				return GameData.PROTOCOL_OP_FAILED;
			
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;

			if (this.isNotInARoomOrARoomFull())
				return GameData.PROTOCOL_OP_AROOM_ROOM_FULL;

			this.aroomInvites.add(invitedRoleID);
		}

		synchronized (iRole)
		{
			int error = iRole.testCanEnterARoom(this.arenaroom.type, this.arenaroom.grade);
			if (error <= 0)
				return error;

			if (iRole.level < typeCfg.needLvl)
				return GameData.PROTOCOL_OP_AROOM_ROLE_LEVEL_FAIL;
		}

		gs.getRPCManager().sendStrPacket(iRole.netsid, new SBean.aroom_invite_forward(this.id, this.name, this.arenaroom.type, this.arenaroom.id));
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	// 玩家被邀请后弹框的选择结果
	public int aroomInvitedby(int inviteStartRoleID, int roomID, int accept)
	{
		if (inviteStartRoleID == this.id)
			return GameData.PROTOCOL_OP_FAILED;

		Role sRole = gs.getLoginManager().getOnGameRole(inviteStartRoleID);
		if (accept == 0)
		{
			if (sRole != null)
				gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.aroom_invite_refuse(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (accept == -1)
		{
			if (sRole != null)
				gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.aroom_invite_busy(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}

		if (sRole == null)
			return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;

		synchronized (sRole)
		{
			if (!sRole.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;

			if (!sRole.isInARoomAndRoleBeInvited(this.id))
				return GameData.PROTOCOL_OP_FAILED;

			if (sRole.getARoomID() != roomID)
				return GameData.PROTOCOL_OP_FAILED;
			
			if(sRole.isInJoinState())
				return GameData.PROTOCOL_OP_AROOM_ROLE_MATCHING;
		}

		synchronized (this)
		{
			int error = this.testCanEnterARoom(sRole.arenaroom.type, sRole.arenaroom.grade);
			if (error <= 0)
				return error;
		}

		Role.MultipleRoles mr = new Role.MultipleRoles(sRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;

			return gs.getArenaRoomManager().addRoomMember(inviteStartRoleID, sRole.arenaroom.grade, sRole.arenaroom.type, this);
		}
		finally
		{
			mr.unlock();
		}
	}

	// 房主踢人
	public int aroomKick(int kickedRoleID)
	{
		if (kickedRoleID == this.id)
			return GameData.PROTOCOL_OP_FAILED;

		Role kickedRole = gs.getLoginManager().getOnGameRole(kickedRoleID);
		if (kickedRole == null)
			return GameData.PROTOCOL_OP_FAILED;

		synchronized (this)
		{
			if (!this.isARoomLeader() || !this.isRoleInMyARoom(kickedRoleID))
				return GameData.PROTOCOL_OP_FAILED;
		}

		Role.MultipleRoles mr = new Role.MultipleRoles(kickedRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;

			return gs.getArenaRoomManager().kickRoomMember(this, kickedRole, this.arenaroom.type) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}

	public int leaveARoom()
	{
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap() || !this.isInARoom())
				return GameData.PROTOCOL_OP_FAILED;
		}

		return gs.getArenaRoomManager().roomMemberLeave(this, this.arenaroom.type, this.superarenaJoinTime > 0) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
	}

	public int aroomChangeLeader(int newLeader)
	{
		if (newLeader == this.id)
			return GameData.PROTOCOL_OP_FAILED;

		Role newLeaderRole = gs.getLoginManager().getOnGameRole(newLeader);
		if (newLeaderRole == null)
			return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;

		synchronized (this)
		{
			if (!this.isARoomLeader())
				return GameData.PROTOCOL_OP_FAILED;

			if (!this.isRoleInMyARoom(newLeader))
				return GameData.PROTOCOL_OP_FAILED;
		}

		Role.MultipleRoles mr = new Role.MultipleRoles(this, newLeaderRole);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;
			return gs.getArenaRoomManager().aroomChangeLeader(this, newLeaderRole, this.arenaroom.type) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}

	public List<SBean.RoleOverview> queryARoomRoles()
	{
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap() || this.arenaroom.id == 0)
				return GameData.emptyList();
		}

		return gs.getArenaRoomManager().getRoleRoomRoles(this.id, this.arenaroom.grade, this.arenaroom.type, this.superarenaState != 0);
	}

	void queryARoomRole(int qRid)
	{
		Role role = gs.getLoginManager().getOnGameRole(qRid);
		if (role != null)
		{
			synchronized (role)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.aroom_member_overview(role.getRoleOverview(), role.netsid));
			}
		}
	}

	void notifyARoomMemberUpdateConnectionState(int state)
	{
		if (this.arenaroom.id > 0)
		{
			for (int rid : this.arenaroom.members)
			{
				if (rid != this.id)
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.aroom_member_connection(this.id, state));
					}
				}
			}
		}
	}

	void notifyARoomMemberUpdateOverview()
	{
		if (this.arenaroom.id > 0)
		{
			SBean.RoleOverview overview = this.getRoleOverview();
			for (int rid : this.arenaroom.members)
			{
				//if (rid != this.id)//客户端MyTeam UI弹出框中包含自己的信息，也需要通过此消息通知更新
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.aroom_member_overview(overview, this.netsid));
					}
				}
			}
		}
	}

	///////////////////////////////////////////////////正邪道场/////////////////////////////////////////////////////
	public void syncBWArenaInfo()
	{
		gs.getBWArenaManager().syncRoleBWArenaInfo(this);
	}

	public synchronized SBean.BWArenaInfo getBWArenaInfo(int selfRank, Map<Integer, SBean.BattleArrayOverview> overviews, Map<Integer, Integer> bwarenalvls)
	{
		SBean.BWArenaInfo info = new SBean.BWArenaInfo(selfRank, this.arenaInfo.roleArenaData.bwarena.timesUsed, this.arenaInfo.roleArenaData.bwarena.timesBuy, 
													   this.arenaInfo.roleArenaData.bwarena.timesRefresh, new HashSet<>(this.arenaInfo.roleArenaData.bwarena.pets), 
													   this.arenaInfo.roleArenaData.bwarena.lvl, this.arenaInfo.roleArenaData.bwarena.exp, 
													   this.arenaInfo.roleArenaData.bwarena.rewardScore, new ArrayList<>());

		int highScore = GameData.getInstance().getBWArenaCFGS().base.winScore.get(0);
		int sameScore = GameData.getInstance().getBWArenaCFGS().base.winScore.get(1);
		for (Map.Entry<Integer, Integer> e : this.arenaInfo.roleArenaData.bwarena.curEnemies.entrySet())
		{
			int rid = e.getKey();
			SBean.BattleArrayOverview ov = overviews.get(rid);
			if (ov != null)
			{
				int score = e.getValue();
				int win = -1;
				if (score != 0)
				{
//					ov.pets = GameData.emptyMap();
					win = score > 0 ? 1 : 0;
				}
				else
				{
					score = this.arenaInfo.roleArenaData.bwarena.lvl < bwarenalvls.getOrDefault(rid, 0) ? highScore : sameScore;
				}

				score = Math.abs(score);
				if (score == highScore)
					info.enemies.add(new SBean.BWArenaArrayOverview(ov, score, win));
				else
					info.enemies.add(0, new SBean.BWArenaArrayOverview(ov, score, win));
			}
		}

		return info;
	}

	private void dayRefreshBWArena()
	{
		this.arenaInfo.roleArenaData.bwarena.timesBuy = 0;
		this.arenaInfo.roleArenaData.bwarena.timesUsed = 0;
		this.arenaInfo.roleArenaData.bwarena.timesRefresh = 0;
	}

	public boolean setBwArenaPets(Set<Integer> pets)
	{
		if (!checkBWArenaPetsValid(pets))
			return false;

		this.arenaInfo.roleArenaData.bwarena.pets = pets;
		return true;
	}

	private boolean checkBWArenaPetsValid(Set<Integer> pets)
	{
		SBean.BWArenaLvlCFGS lvlCfg = GameData.getInstance().getBWArenaLvlCFGS(this.arenaInfo.roleArenaData.bwarena.lvl);
		if (lvlCfg == null || pets.size() > lvlCfg.petCount)
			return false;

		for (int pid : pets)
		{
			if (!this.activePets.containsKey(pid))
				return false;
		}

		return true;
	}

	public void refreshBwArenaEnemies()
	{
		int diamondRefresh = GameData.getInstance().getBWArenaCFGS().base.diamondRefresh;
		if (this.arenaInfo.roleArenaData.bwarena.timesRefresh + 1 > GameData.DIAMOND_REFRESH_MAX_TIMES || !this.canUseDiamond(diamondRefresh, false))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.bwarena_refresh_res(null));
			return;
		}
		
		Map<Integer, Integer> oldEnemies = new HashMap<>(this.arenaInfo.roleArenaData.bwarena.curEnemies);
		this.refreshBwArenaEnemiesImpl();
		gs.getLoginManager().getBWArenaBattleArrayOverviews(this.arenaInfo.roleArenaData.bwarena.curEnemies.keySet(), (overviews, bwarenalvls) ->
		{
			if(this.arenaInfo.roleArenaData.bwarena.curEnemies.isEmpty())
			{
				this.arenaInfo.roleArenaData.bwarena.curEnemies = oldEnemies;
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.bwarena_refresh_res(GameData.emptyList()));
				return;
			}
			
			List<SBean.BWArenaArrayOverview> enemyOverviews = new ArrayList<>();
			int highScore = GameData.getInstance().getBWArenaCFGS().base.winScore.get(0);
			int sameScore = GameData.getInstance().getBWArenaCFGS().base.winScore.get(1);
			for (Map.Entry<Integer, Integer> e : this.arenaInfo.roleArenaData.bwarena.curEnemies.entrySet())
			{
				int rid = e.getKey();
				SBean.BattleArrayOverview ov = overviews.get(rid);
				if (ov != null)
				{
					int score = e.getValue();
					int win = -1;
					if (score != 0)
					{
						ov.pets = GameData.emptyMap();
						win = score > 0 ? 1 : 0;
					}
					else
					{
						score = this.arenaInfo.roleArenaData.bwarena.lvl < bwarenalvls.getOrDefault(rid, 0) ? highScore : sameScore;
					}

					if (Math.abs(score) == highScore)
						enemyOverviews.add(new SBean.BWArenaArrayOverview(ov, score, win));
					else
						enemyOverviews.add(0, new SBean.BWArenaArrayOverview(ov, score, win));
				}
			}

			if (!this.arenaInfo.roleArenaData.bwarena.curEnemies.isEmpty())
			{
				TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BWARENA_REFRESH_ENEMY);
				tlogEvent.setArg(diamondRefresh);
				this.arenaInfo.roleArenaData.bwarena.timesRefresh++;
				this.useDiamond(diamondRefresh, false, tlogEvent.getGameItemRecords());
				gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			}
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.bwarena_refresh_res(enemyOverviews));
		});
	}

	public void refreshBwArenaEnemiesImpl()
	{
		Set<Integer> enemies = new HashSet<>();
		Set<Integer> curEnemies = new HashSet<>(this.arenaInfo.roleArenaData.bwarena.curEnemies.keySet());
		this.arenaInfo.roleArenaData.bwarena.curEnemies.clear();
		enemies.addAll(gs.getBWArenaManager().getBWArenaEnemies(this.id, this.arenaInfo.roleArenaData.bwarena.lvl, this.BWType, GameData.BWARENA_SAME_LEVEL_COUNT, curEnemies));
		curEnemies.addAll(enemies);
		enemies.addAll(gs.getBWArenaManager().getBWArenaEnemies(this.id, this.arenaInfo.roleArenaData.bwarena.lvl + 1, this.BWType, GameData.BWARENA_HIGH_LEVEL_COUNT, curEnemies));
		for (int rid : enemies)
			this.arenaInfo.roleArenaData.bwarena.curEnemies.put(rid, 0);
	}

	public void initBWArenaPet()
	{
		this.arenaInfo.roleArenaData.bwarena.pets.clear();
		SBean.BWArenaLvlCFGS lvlCfg = GameData.getInstance().getBWArenaLvlCFGS(1);
		if (lvlCfg == null)
			return;

		TreeMap<Long, Integer> pets = new TreeMap<>();
		for (SBean.DBPet dbPet : this.activePets.values())
			pets.put(GameData.getLongTypeValue(dbPet.fightPet.fightPower, dbPet.fightPet.id), dbPet.fightPet.id);

		for (int pid : pets.descendingMap().values())
		{
			this.arenaInfo.roleArenaData.bwarena.pets.add(pid);
			if (this.arenaInfo.roleArenaData.bwarena.pets.size() >= lvlCfg.petCount)
				break;
		}
	}

	public synchronized boolean buyBWArenaTimes(int times)
	{
		SBean.VipCFGS vipCfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipCfg == null || times > vipCfg.bwarenaDayBuyTiems || times != this.arenaInfo.roleArenaData.bwarena.timesBuy + 1 || times > GameData.DIAMOND_REFRESH_MAX_TIMES)
			return false;

		int cost = GameData.getTimesCost(GameData.getInstance().getBWArenaCFGS().base.diamondBuys, times);
		if (!this.canUseDiamond(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BWARENA_BUY_TIMES);
		tlogEvent.setArg(cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.arenaInfo.roleArenaData.bwarena.timesBuy++;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public boolean takeBWArenaScoreReward()
	{
		SBean.BWArenaLvlCFGS lvlCfg = GameData.getInstance().getBWArenaLvlCFGS(this.arenaInfo.roleArenaData.bwarena.lvl);
		if (lvlCfg == null)
			return false;

		int scoreReq = GameData.getInstance().getBWArenaCFGS().base.rewardScoreReq;
		if (!this.arenaInfo.canUseBWArenaScore(scoreReq))
			return false;

		this.arenaInfo.useBWArenaScore(scoreReq);
		SBean.GameItem gi = this.BWType == 1 ? GameData.getInstance().toGameItem(lvlCfg.whiteScoreReward.id, lvlCfg.whiteScoreReward.count) : GameData.getInstance().toGameItem(lvlCfg.blackScoreReward.id, lvlCfg.blackScoreReward.count);

		if (!this.canAddGameItem(gi.id, gi.count))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BWARENA_TAKE_SCORE_REWARD);
		tlogEvent.setArg(gi.count);
		this.syncAddGameItem(gi, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized void bwarenaAddLog(SBean.DBRoleArenaLog log)
	{
		this.arenaInfo.roleArenaData.bwarena.logs.add(log);
		if (this.arenaInfo.roleArenaData.bwarena.logs.size() > 10)
			this.arenaInfo.roleArenaData.bwarena.logs.subList(0, this.arenaInfo.roleArenaData.bwarena.logs.size() - 10).clear();
	}

	public List<SBean.BWArenaRankRole> getBWArenaRanks(int BWType, int index, int len)
	{
		if (BWType == 1)
			return gs.getBWArenaManager().getWhiteRanksSnapshot(index, len);
		else
			return gs.getBWArenaManager().getBlackRanksSnapshot(index, len);
	}

	public List<SBean.DBRoleArenaLog> getBWArenaLog()
	{
		return this.arenaInfo.roleArenaData.bwarena.logs;
	}

	public boolean addBWArenaExp(int exp)
	{
		return this.arenaInfo.addBWArenaExp(exp);
	}
	
	public synchronized SBean.BWArenaRankRole getBWArenaRankRole()
	{
		return new SBean.BWArenaRankRole(this.getRoleSocialWithoutLock(), this.arenaInfo.roleArenaData.bwarena.lvl, this.arenaInfo.roleArenaData.bwarena.rankScore);
	}
	
	public synchronized int onBWArenaEndImpl(int addScore, int newLastScoreClearWeek)
	{
		this.arenaInfo.roleArenaData.bwarena.rewardScore += addScore;
		if (newLastScoreClearWeek != this.arenaInfo.roleArenaData.bwarena.lastScoreClearWeek)
		{
			this.arenaInfo.roleArenaData.bwarena.rankScore = addScore;
			this.arenaInfo.roleArenaData.bwarena.lastScoreClearWeek = newLastScoreClearWeek;
		}
		else
		{
			this.arenaInfo.roleArenaData.bwarena.rankScore += addScore;
		}
		
		return this.arenaInfo.roleArenaData.bwarena.rankScore;
	}
	
	public synchronized boolean isWhite()
	{
		return this.BWType == 1;
	}
	
	public void updateBWAreneEnemies(int targetID, int winScore)
	{
		if (this.arenaInfo.roleArenaData.bwarena.curEnemies.containsKey(targetID))
		{
			this.arenaInfo.roleArenaData.bwarena.curEnemies.put(targetID, winScore);
			this.updateBWAreneEnemies();
		}
	}

	public void updateBWAreneEnemies()
	{
		int count = 0;
		for (int score : this.arenaInfo.roleArenaData.bwarena.curEnemies.values())
		{
			if (score != 0)
				count++;
		}

		if (count >= 3 || count == this.arenaInfo.roleArenaData.bwarena.curEnemies.size())
			this.refreshBwArenaEnemiesImpl();
	}

	///////////////////////////////////////////////////竞技场 end/////////////////////////////////////////////////////

	///////////////////////////////////////////////////世界boss/////////////////////////////////////////////////////
	//boss来袭
	synchronized boolean checkCanWalkToBoss(int bossID)
	{
		if (!this.gameMapContext.isInWorldMap())
			return false;

		SBean.WorldBossCFGS cfg = GameData.getInstance().getWorldBossCFGS(bossID);
		if (cfg == null)
			return false;

		SBean.MonsterCFGS monsterCfg = GameData.getInstance().getMonsterCFGS(cfg.base.monsterID);
		if (monsterCfg == null)
			return false;

		int bossLvl = monsterCfg.level;
		if (bossLvl > this.level + BossManager.BOSS_DANGEROUS_LEVEL)
			return false;

		return true;
	}

	synchronized boolean resetTransTime()
	{
		int cost = GameData.getInstance().getCommonCFG().activity.resetDiamond;
		if (!this.canUseDiamond(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_RESET_TRANS_TIME);
		tlogEvent.setArg(cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.nextTransToBossTime = 0;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	boolean checkCanTransToBoss(int bossID, int seq)
	{
		SBean.MapLocation mapLocation = null;
		synchronized(this)
		{
			if (!this.gameMapContext.isInWorldMap() || this.mulRolesLock > 0 || this.isMulRolesMember())
				return false;

			int now = GameTime.getTime();
			if (this.nextTransToBossTime > now)
				return false;

			SBean.WorldBossCFGS cfg = GameData.getInstance().getWorldBossCFGS(bossID);
			if (cfg == null)
				return false;

			SBean.MonsterCFGS monsterCfg = GameData.getInstance().getMonsterCFGS(cfg.base.monsterID);
			if (monsterCfg == null)
				return false;

			int bossLvl = monsterCfg.level;
			if (bossLvl > this.level + BossManager.BOSS_DANGEROUS_LEVEL)
				return false;

			int itemID = GameData.getInstance().getCommonCFG().activity.transItemID;
			boolean freeTrans = GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).freeTransfrom == 1;
			if (!freeTrans && !this.containsEnoughGameItem(itemID, 1))
				return false;
			
			mapLocation = GameData.getInstance().getWorldBossMapLocation(bossID, seq);
			if (mapLocation == null)
				return false;

			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CHECK_CAN_TRANS_TO_BOSS);
			tlogEvent.setArg(bossID, seq);
			if (!freeTrans)
				this.delGameItem(itemID, 1, tlogEvent.getGameItemRecords());
			SBean.CommonCFGS commonCfg = GameData.getInstance().getCommonCFG();
			int cd = commonCfg.activity.bossTransCD;
			this.nextTransToBossTime = now + cd;
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(mapLocation, BossManager.BOSS_CREATE_WORLD_LINE);
				this.gameMapContext.roleChangeMap();
				return true;
			}
		}

		this.mulRolesChangeMap(mapLocation, BossManager.BOSS_CREATE_WORLD_LINE);
		return true;
	}

	///////////////////////////////////////////////////世界boss end/////////////////////////////////////////////////////

	////////////////////////////////////////////////////好友///////////////////////////////////////////////////////////
	public static class Flower
	{
		final int maxCnt;
		final int showCnt;
		Map<Integer, Integer> flowers = new HashMap<>();
		TreeSet<Long> ranks = new TreeSet<>();
		int minValue;

		public Flower(int maxCnt, int showCnt)
		{
			this.maxCnt = maxCnt;
			this.showCnt = showCnt;
		}

		Flower updateFlowerRank(Set<Long> ranks)
		{
			this.ranks.addAll(ranks);

			minValue = Integer.MAX_VALUE;
			this.flowers.clear();
			for (Long rankValue : this.ranks)
			{
				int roleID = getRoleID(rankValue);
				int cnt = getFlowerCnt(rankValue);
				this.flowers.put(roleID, cnt);
				if (cnt < minValue)
					minValue = cnt;
			}

			minValue = minValue == Integer.MAX_VALUE ? 0 : minValue;
			return this;
		}

		public static long getRankValue(int count, int rid)
		{
			return ((long) count << 32) | ((long) rid & 0xffffffffL);
		}

		public static int getRoleID(long value)
		{
			return (int) (value & 0xffffffffL);
		}

		public static int getFlowerCnt(long value)
		{
			return (int) ((value >> 32) & 0xffffffffL);
		}

		public static List<SBean.FlowerLog> getFlowerLog(Set<Long> ranks, int showCnt)
		{
			TreeSet<Long> realRanks = null;
			if(ranks instanceof TreeSet)
			{
				realRanks = TreeSet.class.cast(ranks);
			}
			else
			{
				realRanks = new TreeSet<>(ranks);
			}
			
			if (realRanks == null || realRanks.isEmpty())
				return GameData.emptyList();

			List<SBean.FlowerLog> log = new ArrayList<>();
			for (Long flower : realRanks.descendingSet())
			{
				log.add(new SBean.FlowerLog(getRoleID(flower), getFlowerCnt(flower)));
				if (log.size() == showCnt)
					break;
			}

			return log;
		}

		public List<SBean.FlowerLog> getFlowerRank()
		{
			return getFlowerLog(this.ranks, this.showCnt);
		}

		void tryUpdateFlowerRank(int rid, int count)
		{
			int newCnt = this.flowers.getOrDefault(rid, 0) + count;
			if (removeRole(rid) || newCnt > minValue || ranks.size() < maxCnt)
			{
				this.addNewRole(rid, newCnt);
				this.tryRemoveLastRank();
				this.tryUpdateMinValue();
			}
		}

		boolean removeRole(int rid)
		{
			Integer oldCnt = this.flowers.remove(rid);
			if (oldCnt != null)
			{
				long oldRankValue = getRankValue(oldCnt, rid);
				ranks.remove(oldRankValue);
				return true;
			}

			return false;
		}

		void addNewRole(int rid, int count)
		{
			if (this.flowers.putIfAbsent(rid, count) == null)
			{
				long newRankValue = getRankValue(count, rid);
				ranks.add(newRankValue);
			}
		}

		private void tryRemoveLastRank()
		{
			if (ranks.size() > maxCnt)
			{
				Long lastRankValue = ranks.pollFirst();
				if (lastRankValue != null)
				{
					int rid = getRoleID(lastRankValue);
					flowers.remove(rid);
				}
			}
		}

		private void tryUpdateMinValue()
		{
			if (!ranks.isEmpty())
			{
				Long minRankValue = ranks.first();
				if (minRankValue != null)
				{
					minValue = getFlowerCnt(minValue);
				}
			}
		}
	}

	class RoleFriend
	{
		public static final int RECOMMOND_FRIEND_CNT = 6;

		private SBean.DBFriendData friendData;
		private TreeMap<Integer, Integer> t2e = new TreeMap<>();			//killTime 2 enemy
		
		private Map<Integer, SBean.FriendOverview> friendsOverview;
		private Map<Integer, SBean.RoleOverview> blackListOverview;
		private List<Integer> dLevels;

		private int charmLvl;

		private TreeSet<Integer> justFans = new TreeSet<>();
		//		private TreeSet<Integer> eachFans = new TreeSet<>();
		private Integer lastFansKey;

		private Flower acceptFlower;
		private Flower giveFlower;

		RoleFriend()
		{
			dLevels = new ArrayList<>();
			dLevels.add(0);
			for (int i = 1; i <= 5; i++)
			{
				dLevels.add(i);
				dLevels.add(-i);
			}
		}

		RoleFriend fromDB(SBean.DBFriendData dbFriendData)
		{
			this.friendData = dbFriendData;
			this.charmLvl = GameData.getInstance().getCharmLvl(this.friendData.charm);
			this.friendsOverview = new TreeMap<Integer, SBean.FriendOverview>();
			this.blackListOverview = new TreeMap<Integer, SBean.RoleOverview>();
			for (Integer rid : this.friendData.fans)
			{
				if (!this.friendData.friends.containsKey(rid))
					this.justFans.add(rid);
			}
			if (!this.justFans.isEmpty())
				this.lastFansKey = this.justFans.first();

			SBean.CommonFlowerCFGS flowerCfg = GameData.getInstance().getCommonCFG().flower;
			this.acceptFlower = new Flower(flowerCfg.acceptMaxCount, flowerCfg.acceptShowCount).updateFlowerRank(this.friendData.acceptFlower);
			this.giveFlower = new Flower(flowerCfg.giveMaxCount, flowerCfg.giveShowCount).updateFlowerRank(this.friendData.giveFlower);
			
			for(Map.Entry<Integer, Integer> e: dbFriendData.enemys.entrySet())
				this.t2e.put(e.getValue(), e.getKey());
			
			return this;
		}

		SBean.DBFriendData toDB()
		{
			this.friendData.acceptFlower = this.acceptFlower.ranks;
			this.friendData.giveFlower = this.giveFlower.ranks;
			return this.friendData.kdClone();
		}

		int getAccecptFlower(int rid)
		{
			return this.acceptFlower.flowers.getOrDefault(rid, 0);
		}

		void addAccecptFlowers(int rid, int count)
		{
			this.acceptFlower.tryUpdateFlowerRank(rid, count);
		}

		List<SBean.FlowerLog> getAcceptFlowerRank()
		{
			return this.acceptFlower.getFlowerRank();
		}

		int getGiveFlower(int rid)
		{
			return this.giveFlower.flowers.getOrDefault(rid, 0);
		}

		void addGiveFlowers(int rid, int count)
		{
			this.giveFlower.tryUpdateFlowerRank(rid, count);
		}

		List<SBean.FlowerLog> getGiveFlowerRank()
		{
			return this.giveFlower.getFlowerRank();
		}

		void clear()
		{
			this.friendData.dayVitTakeTimes = 0;
			this.friendData.sendVitRoles.clear();
		}

		String getPersonalMsg()
		{
			return this.friendData.personalMsg;
		}

		void setPersonalMsg(String msg)
		{
			this.friendData.personalMsg = msg;
		}

		int getDayVitTakeTimes()
		{
			return this.friendData.dayVitTakeTimes;
		}

		void setDayVitTakeTimes(int times)
		{
			this.friendData.dayVitTakeTimes = times;
		}

		int getVitLvl()
		{
			return this.friendData.vitLvl;
		}

		int getVitExp()
		{
			return this.friendData.vitExp;
		}

		boolean addVitExp(int exp)
		{
			GameData.LevelExp lvlExp = GameData.getInstance().getAddFriendLvlExp(this.friendData.vitLvl, this.friendData.vitExp, exp);
			boolean lvlChange = lvlExp.level > this.friendData.vitLvl;
			if (lvlChange)
			{
				this.friendData.vitLvl = lvlExp.level;
			}
			this.friendData.vitExp = (int) lvlExp.exp;
			return lvlChange;
		}

		int getCharm()
		{
			return this.friendData.charm;
		}

		void addCharm(int value)
		{
			this.friendData.charm += value;
			int newCharmLvl = GameData.getInstance().getCharmLvl(this.friendData.charm);
			if (this.charmLvl < newCharmLvl)
			{
				for(int old = this.charmLvl; old < newCharmLvl; old++)
				{
					final SBean.CharmCFGS oldCfg = GameData.getInstance().getCharmCFGS(old);
					if (oldCfg != null)
						Role.this.delRoleTitle(Role.this.gender == 1 ? oldCfg.maleTitle : oldCfg.femaleTitle);
				}

				this.charmLvl = newCharmLvl;
				final SBean.CharmCFGS newcfg = GameData.getInstance().getCharmCFGS(newCharmLvl);
				if (newcfg != null)
					Role.this.addRoleTitle(Role.this.gender == 1 ? newcfg.maleTitle : newcfg.femaleTitle);
			}
		}

		int getCurFriendCnt()
		{
			return this.friendData.friends.size();
		}

		int getCurBlackListCnt()
		{
			return this.friendData.blacklist.size();
		}

		boolean isFans(int rid)
		{
			return this.friendData.fans.contains(rid);
		}

		void addFans(int rid)
		{
			this.friendData.fans.add(rid);
			if (!this.friendData.friends.containsKey(rid))
				this.justFans.add(rid);
		}

		void delFans(int rid)
		{
			this.friendData.fans.remove(rid);
			this.justFans.remove(rid);
		}

		public Set<Integer> getRandomFans()
		{
			if (this.justFans.size() <= RoleFriend.RECOMMOND_FRIEND_CNT)
				return new TreeSet<>(this.justFans);

			this.lastFansKey = this.lastFansKey == null ? this.justFans.first() : this.lastFansKey;
			if (this.lastFansKey == null)
				return new GameData.EmptySet<>();

			Set<Integer> rFans = new TreeSet<>();
			SortedSet<Integer> sortedFans = getSortedFans(this.lastFansKey, this.justFans.first());
			setRandomFans(sortedFans, rFans);

			if (rFans.size() < RoleFriend.RECOMMOND_FRIEND_CNT && this.justFans.first() != null)
			{
				this.lastFansKey = this.justFans.first();
				sortedFans = this.justFans.tailSet(this.lastFansKey);
				setRandomFans(sortedFans, rFans);
			}

			return rFans;
		}

		private void setRandomFans(SortedSet<Integer> sortedFans, Set<Integer> rFans)
		{
			for (Integer rid : sortedFans)
			{
				this.lastFansKey = rid;
				rFans.add(rid);

				if (rFans.size() == RoleFriend.RECOMMOND_FRIEND_CNT)
					break;
			}

		}

		SortedSet<Integer> getSortedFans(Integer fromKey, Integer firstKey)
		{
			if (this.justFans.tailSet(fromKey).isEmpty() && firstKey != null)
				return this.justFans.tailSet(firstKey);

			return this.justFans.tailSet(fromKey);
		}

		void addBlackList(int fid, SBean.RoleOverview overview)
		{
			this.friendData.blacklist.put(fid, GameTime.getTime());
			this.blackListOverview.put(fid, overview);
		}

		void addFriend(int fid, SBean.DBFriend dbFriend, SBean.FriendOverview overview)
		{
			this.friendData.friends.put(fid, dbFriend);
			this.friendsOverview.put(fid, overview);
			this.justFans.remove(fid);
			if (this.friendData.friends.size() > this.friendData.historyMaxFriends)
				this.friendData.historyMaxFriends = this.friendData.friends.size();
		}

		void delFriend(int fid)
		{
			this.friendData.friends.remove(fid);
			this.friendsOverview.remove(fid);
			if (this.friendData.fans.contains(fid))
				this.justFans.add(fid);
		}

		void delBlackList(int fid)
		{
			this.friendData.blacklist.remove(fid);
			this.blackListOverview.remove(fid);
		}

		SBean.DBFriend getFriend(int rid)
		{
			return this.friendData.friends.get(rid);
		}

		Integer getBlackList(int rid)
		{
			return this.friendData.blacklist.get(rid);
		}

		Map<Integer, Integer> getAllBlackList()
		{
			return this.friendData.blacklist;
		}

		public Collection<Integer> getAllFriendsRoleID()
		{
			return this.friendData.friends.keySet();
		}

		public Set<Integer> getBlackListIds()
		{
			return this.friendData.blacklist.keySet();
		}
		
		public Map<Integer, SBean.DBFriend> getAllFriendsInfos()
		{
			return this.friendData.friends;
		}

		Map<Integer, SBean.FriendOverview> getFriendOverviews()
		{
			return this.friendsOverview;
		}

		Map<Integer, SBean.RoleOverview> getBlackListOverviews()
		{
			return this.blackListOverview;
		}

		public void updateBlackListOverview(Collection<SBean.RoleOverview> overviews)
		{
			for (SBean.RoleOverview e : overviews)
			{
				if (this.friendData.blacklist.containsKey(e.id))
					this.blackListOverview.put(e.id, e);
			}
		}

		public void updateFriendsOverview(Collection<SBean.FriendOverview> overviews)
		{
			for (SBean.FriendOverview e : overviews)
			{
				if (this.friendData.friends.containsKey(e.overview.id))
					this.friendsOverview.put(e.overview.id, e);
			}
		}

		Map<Integer, SBean.FriendInfo> getFriendInfos(List<SBean.FriendOverview> overviews)
		{
			Map<Integer, SBean.FriendInfo> infos = new TreeMap<>();
			for (SBean.FriendOverview fov : overviews)
			{
				SBean.DBFriend dbFriend = getFriend(fov.overview.id);
				if (dbFriend == null)
					continue;

				this.friendsOverview.put(fov.overview.id, fov);
				infos.put(fov.overview.id, new SBean.FriendInfo(dbFriend.focusValue, dbFriend.addTime, this.friendData.sendVitRoles.contains(fov.overview.id) ? 1 : 0, dbFriend.receiveVit, this.isFans(fov.overview.id) ? 1 : 0, fov));
			}
			return infos;
			//			return this.friendData.friends.entrySet().stream().collect(Collectors.toMap(e -> e.getKey(), e -> new SBean.FriendInfo(e.getValue(), this.isFans(e.getKey()) ? 1 : 0)));
		}

		void initBlackListInfos()
		{
			if (this.getBlackListIds().isEmpty())
				return;
			if (this.blackListOverview.isEmpty())
			{
				gs.getLoginManager().getRoleOverviews(this.getBlackListIds(), overviews ->
				{
					this.blackListOverview = overviews;
				});
			}
		}

		boolean canSendVit(int fid)
		{
			return !this.friendData.sendVitRoles.contains(fid);
		}

		void addToSendVitRoles(int fid)
		{
			this.friendData.sendVitRoles.add(fid);
		}

		boolean removeEnemy(int rid)
		{
			Integer killTime = this.friendData.enemys.remove(rid);
			if(killTime != null)
				this.t2e.remove(killTime);
			
			return killTime != null;
		}
		
		void addEnemy(int rid)
		{
			Integer oldTime = this.friendData.enemys.remove(rid);
			int now = GameTime.getTime();
			this.friendData.enemys.put(rid, now);
			this.t2e.put(now, rid);
			if(oldTime != null)
				this.t2e.remove(oldTime);
			
			if(this.friendData.enemys.size() > GameData.getInstance().getCommonCFG().friend.maxEnemies)
			{
				Map.Entry<Integer, Integer> first = this.t2e.pollFirstEntry();
				if(first != null)
					this.friendData.enemys.remove(first.getValue());
			}
		}
		
		Map<Integer, Integer> getEnemies()
		{
			return this.friendData.enemys;
		}

		public Set<Integer> getRandomLevelRoles(int count)
		{
			Set<Integer> notMatchRids = new TreeSet<>(this.friendData.fans);
			notMatchRids.addAll(this.friendData.friends.keySet());
			notMatchRids.add(Role.this.id);

			Set<Integer> recommondRids = new TreeSet<>();
			for (int dLvl : this.dLevels)
			{
				gs.getLoginManager().getRandomLevelRoles(dLvl + Role.this.level, notMatchRids, recommondRids, count);
				if (recommondRids.size() >= count)
					break;
			}

			if (recommondRids.size() < count)
				gs.getLoginManager().getRandomLevelRoles(notMatchRids, recommondRids, count - recommondRids.size());

			return recommondRids;
		}

	}

	RoleFriend createFriendData()
	{
		return new RoleFriend().fromDB(new SBean.DBFriendData(new TreeMap<Integer, SBean.DBFriend>(), new TreeSet<Integer>(), new TreeSet<Integer>(), new TreeMap<Integer, Integer>(), 0, 1, 0, "", new TreeSet<Long>(), new TreeSet<Long>(), 0, 0, new TreeMap<Integer, Integer>()));
	}

	//同步好友数据
	public void syncFriendData()
	{
		gs.getLoginManager().getFriendOverviews(this.friend.getAllFriendsRoleID(), overviews ->
		{
			synchronized (Role.this)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_sync_res(this.friend.getFriendInfos(overviews), 
																						this.friend.getDayVitTakeTimes(), 
																						this.friend.getVitLvl(), 
																						this.friend.getVitExp(), 
																						this.friend.getPersonalMsg(), 
																						this.friend.getCharm()));
			}
		});
	}

	//获取加我为好友的列表， 不包含互相为好友
	public void syncPlusFriends()
	{
		Set<Integer> fans = GameData.emptySet();
		synchronized (this)
		{
			fans = this.friend.getRandomFans();
		}

		gs.getLoginManager().getRoleOverviews(fans, overviews ->
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_pluslist_res(overviews.values().stream().collect(Collectors.toList())));
		});
	}

	//获取系统推荐的好友
	public void getSysRecommends()
	{
		Set<Integer> recommonds = GameData.emptySet();
		synchronized (this)
		{
			recommonds = this.friend.getRandomLevelRoles(RoleFriend.RECOMMOND_FRIEND_CNT);
		}

		gs.getLoginManager().getRoleOverviews(recommonds, overviews ->
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_recommend_res(overviews.values().stream().collect(Collectors.toList())));
		});
	}

	//加好友
	public void addFriend(int rid)
	{
		synchronized (this)
		{
			if (rid <= 0 || rid == this.id || this.friend.getFriend(rid) != null)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_add_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			
			if(this.friend.getCurFriendCnt() >= GameData.getInstance().getCommonCFG().friend.maxCount)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_add_res(GameData.PROTOCOL_OP_FRIEND_FULL));
				return;
			}
			
			if(this.friend.getBlackListIds().contains(rid))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_add_res(GameData.PROTOCOL_OP_IN_BLACK_LIST));
				return;
			}
		}

		gs.getLoginManager().exeCommonRoleVisitor(rid, false, new LoginManager.CommonRoleVisitor()
		{
			SBean.FriendOverview overview = null;
			int netsId = 0;
			boolean inBlackList = false;

			@Override
			public boolean visit(Role role, Role sameUserRole)
			{
				role.friend.addFans(Role.this.id);
				inBlackList = role.friend.getBlackListIds().contains(Role.this.id);
				overview = role.getFriendOverview();
				netsId = role.netsid;
				return true;
			}

			@Override
			public void onCallback(boolean success)
			{
				synchronized (Role.this)
				{
					if (!inBlackList && success && overview != null)
					{
						Role.this.friend.addFriend(rid, new SBean.DBFriend(GameData.getInstance().getCommonCFG().friend.focusDefault, GameTime.getTime(), (byte) 0), overview);
						gs.getRPCManager().sendStrPacket(netsId, new SBean.friend_add_push(Role.this.id, Role.this.name));
					}
				}
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.friend_add_res(inBlackList ? GameData.PROTOCOL_OP_IN_ROLE_BLACK_LIST : (success ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED)));
			}
		});
	}
	
	public synchronized void syncBlackList()
	{
		this.friend.initBlackListInfos();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.blacklist_sync_res(Stream.clone(this.friend.getBlackListOverviews()), new HashMap<>(this.friend.getAllBlackList())));
	}

	//加黑名单
	public void addBlackList(int rid)
	{
		synchronized (this)
		{
			if (rid <= 0 || rid == this.id || this.friend.getBlackList(rid) != null)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.blacklist_add_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			
			if(this.friend.getCurBlackListCnt() >= GameData.getInstance().getCommonCFG().friend.maxBlackList)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.blacklist_add_res(GameData.PROTOCOL_OP_FRIEND_FULL));
				return;
			}
		}

		gs.getLoginManager().exeCommonRoleVisitor(rid, false, new LoginManager.CommonRoleVisitor()
		{
			SBean.RoleOverview overview = null;
			@Override
			public boolean visit(Role role, Role sameUserRole)
			{
				role.friend.delFans(Role.this.id);
				overview = role.getRoleOverview();
				return true;
			}

			@Override
			public void onCallback(boolean success)
			{
				synchronized (Role.this)
				{
					if (success && overview != null)
					{
						Role.this.friend.delFriend(rid);
						Role.this.friend.addBlackList(rid, overview);
					}
				}
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.blacklist_add_res(success ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED));
			}
		});
	}

	//搜索好友，按好友的名字搜索
	public synchronized void searchFriend(String searchName)
	{
		if (searchName.isEmpty())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_search_res(null));
			return;
		}

		gs.getLoginManager().getRoleIdByRoleName(searchName.trim(), new LoginManager.GetRoleIdByRoleNameCallback()
		{
			@Override
			public void onCallback(String roleName, Integer roleId)
			{
				if (roleId != null)
				{
					gs.getLoginManager().getRoleOverview(roleId, new LoginManager.GetRoleOverviewCallback()
					{
						@Override
						public void onCallback(SBean.RoleOverview overview)
						{
							gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.friend_search_res(overview));
						}
					});
				}
				else
				{
					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.friend_search_res(null));
				}
			}
		});
	}

	//删除好友
	public void deleteFriend(int friendId)
	{
		synchronized (this)
		{
			SBean.DBFriend friend = this.friend.getFriend(friendId);
			if (friend == null)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_delete_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}

		gs.getLoginManager().exeCommonRoleVisitor(friendId, false, new LoginManager.CommonRoleVisitor()
		{
			@Override
			public boolean visit(Role role, Role sameUserRole)
			{
				role.friend.delFans(Role.this.id);
				return true;
			}

			@Override
			public void onCallback(boolean success)
			{
				synchronized (Role.this)
				{
					Role.this.friend.delFriend(friendId);
				}

				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.friend_delete_res(GameData.PROTOCOL_OP_SUCCESS));
			}
		});
	}
	
	//删除黑名单
	public int deleteBlackList(int friendId)
	{
		synchronized (this)
		{
			Integer friend = this.friend.getBlackList(friendId);
			if (friend == null)
			{
				return GameData.PROTOCOL_OP_FAILED;
			}
			this.friend.delBlackList(friendId);
			return GameData.PROTOCOL_OP_SUCCESS;
		}
	}

	//好友列表每日刷新，赠送和收取的体力
	private void dayRefreshFriends()
	{
		this.friend.clear();
	}
	
	public void giveFriendsVit(Set<Integer> friends)
	{
		if(friends.isEmpty())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_giveallvits_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		
		synchronized(this)
		{
			for(int fid: friends)
			{
				SBean.DBFriend friend = this.friend.getFriend(fid);
				if(friend == null)
				{
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_giveallvits_res(GameData.PROTOCOL_OP_NOT_FRIEND));
					return;
				}
				
				if (!this.friend.canSendVit(fid))
				{
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_giveallvits_res(GameData.PROTOCOL_OP_FRIEND_REPEAT));
					return;
				}
				
				if(!this.friend.isFans(fid))
				{
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_giveallvits_res(GameData.PROTOCOL_OP_NOT_EACH_FRIEND));
					return;
				}
			}
		}
		
		for(int fid: friends)
		{
			giveFriendVitImpl(fid, null);
		}
		gs.getTLogger().logRoleFriendInteractionFlow(this, TLog.INTERACTION_TYPE_SEND_VIT, friends.size());
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_giveallvits_res(GameData.PROTOCOL_OP_SUCCESS));
	}
	
	interface GiveFriendVitCallBack
	{
		void onCallback(boolean success);
	}
	//赠送好友体力
	public void giveFriendVit(int friendId, GiveFriendVitCallBack callback)
	{
		synchronized (this)
		{
			SBean.DBFriend friend = this.friend.getFriend(friendId);
			if (friend == null)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_givevit_res(GameData.PROTOCOL_OP_NOT_FRIEND));
				return;
			}

			if (!this.friend.canSendVit(friendId))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_givevit_res(GameData.PROTOCOL_OP_FRIEND_REPEAT));
				return;
			}
			
			if(!this.friend.isFans(friendId))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_givevit_res(GameData.PROTOCOL_OP_NOT_EACH_FRIEND));
				return;
			}
		}

		gs.getTLogger().logRoleFriendInteractionFlow(this, TLog.INTERACTION_TYPE_SEND_VIT, 1);
		giveFriendVitImpl(friendId, callback);
	}
	
    public synchronized void onBossDamageSettlement(int boss, int damage, boolean hunter)
    {
        logActivityChallengeGift(GameData.ACTIVITY_CHALLENGE_TYPE_WORLD_BOSS, 0, 1);
        gs.getTLogger().logBossTaskFlow(this, boss, TLog.BOSSEVENT_DAMAGE, hunter?1:0, damage);
        gs.getTLogger().reportBossMission(this, boss, true);
    }
    
	public void giveFriendVitImpl(int friendId, GiveFriendVitCallBack callback)
	{
		gs.getLoginManager().exeCommonRoleVisitor(friendId, false, new LoginManager.CommonRoleVisitor()
		{
			@Override
			public boolean visit(Role role, Role sameUserRole)
			{
				SBean.DBFriend f = role.friend.getFriend(Role.this.id);
				if (f == null)
					return false;

				f.receiveVit = 1;
				return true;
			}

			@Override
			public void onCallback(boolean success)
			{
				synchronized (Role.this)
				{
					if (success)
					{
						Role.this.friend.addToSendVitRoles(friendId);
						Role.this.logDailyTask(GameData.DAILY_TASK_ID_GIVE_FRIEND_VIT, 1);
					}
				}
				
				if(callback != null)
					callback.onCallback(success);
			}
		});
	}
	
	//接收好友赠送的体力，批量收取
	public synchronized boolean receiveFriendVit(Set<Integer> fids)
	{
		SBean.FriendGiveRewardCFGS friendGiveRewardCFGS = GameData.getInstance().getFriendGiveReward(this.friend.getVitLvl());
		if (friendGiveRewardCFGS == null)
			return false;

		int count = fids.size();
		if (fids.isEmpty() || this.friend.getDayVitTakeTimes() + count > friendGiveRewardCFGS.count)
			return false;

		List<SBean.DBFriend> friends = new ArrayList<>();
		for (int fid : fids)
		{
			SBean.DBFriend friend = this.friend.getFriend(fid);
			if (friend == null || friend.receiveVit == 0)
				return false;

			friends.add(friend);
		}

		for (SBean.DBFriend friend : friends)
			friend.receiveVit = 0;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_RECEIVE_FRIEND_VIT);
		tlogEvent.setArg(count);
		this.syncAddGameItem(GameData.getInstance().toGameItem(GameData.getInstance().getCommonCFG().friend.itemId, count), tlogEvent);
		this.friend.addVitExp(count * GameData.getInstance().getCommonCFG().friend.addExp);
		this.friend.setDayVitTakeTimes(this.friend.getDayVitTakeTimes() + count);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	//同意对方加我为好友， 成功后互相为好友
	public void agreeAddFriend(int friendId)
	{
		synchronized (this)
		{
			if (friendId == this.id || this.friend.getFriend(friendId) != null || !this.friend.isFans(friendId))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_agreeadd_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			
			if(this.friend.getCurFriendCnt() >= GameData.getInstance().getCommonCFG().friend.maxCount)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.friend_agreeadd_res(GameData.PROTOCOL_OP_FRIEND_FULL));
				return;
			}
		}

		gs.getLoginManager().exeCommonRoleVisitor(friendId, false, new LoginManager.CommonRoleVisitor()
		{
			SBean.FriendOverview overview = null;

			@Override
			public boolean visit(Role role, Role sameUserRole)
			{
				role.friend.addFans(Role.this.id);
				overview = role.getFriendOverview();
				return true;
			}

			@Override
			public void onCallback(boolean success)
			{

				synchronized (Role.this)
				{
					if (success && overview != null)
						Role.this.friend.addFriend(friendId, new SBean.DBFriend(GameData.getInstance().getCommonCFG().friend.focusDefault, GameTime.getTime(), (byte) 0), overview);
				}

				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.friend_agreeadd_res(success ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED));
			}
		});
	}

	//设置在好友面板中显示的心情
	public synchronized boolean changeRoleMsg(String msg)
	{
		if (!GameData.getInstance().checkInputStrValid(msg, GameData.getInstance().getCommonCFG().friend.heartLength, false))
			return false;

		this.friend.setPersonalMsg(msg);
		return true;
	}

	//设置在好友面板中显示的自己头像
	public synchronized boolean changeRoleHead(short headId)
	{
		SBean.FriendHeadCFGS friendHeadCFGS = GameData.getInstance().getFriendHeadCFGS(headId);
		if (friendHeadCFGS == null)
			return false;
		if (friendHeadCFGS.openType == GameData.FRIEND_TYPE_GENERAL)
		{
			if (this.level < friendHeadCFGS.arg1)
				return false;
		}
		else if (friendHeadCFGS.openType == GameData.FRIEND_TYPE_VIP)
		{
			if (this.getUseableVipLvl() < friendHeadCFGS.arg1)
				return false;
		}
		else if (friendHeadCFGS.openType == GameData.FRIEND_TYPE_HEAD_ITEM || friendHeadCFGS.openType == GameData.FRIEND_TYPE_USE_ITEM)
		{
			if (!this.itemUnlockHead.contains((int)headId))
				return false;
		}
		this.headIcon = headId;
		return true;
	}

	//获取宿敌列表
	public void getFriendEnemys()
	{
		Map<Integer, Integer> enemies = new HashMap<>();
		synchronized (this)
		{
			enemies.putAll(this.friend.friendData.enemys);
		}
		
		if(enemies.isEmpty())
		{
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.friend_enemy_res(GameData.emptyList()));
			return;
		}
		
		gs.getLoginManager().getRoleOverviews(enemies.keySet(), overviews ->
		{
			List<SBean.EnemyOverview> eovs = new ArrayList<>();
			for(SBean.RoleOverview ov: overviews.values())
			{
				Role role = gs.getLoginManager().getOnGameRole(ov.id);
				if(role == null)
				{
					eovs.add(new SBean.EnemyOverview(ov, enemies.get(ov.id), 0, 0));
				}
				else
				{
					synchronized(role)
					{
						eovs.add(new SBean.EnemyOverview(ov, enemies.get(ov.id), role.gameMapContext.getCurMapId(), role.gameMapContext.getCurMapLine()));
					}
				}
			}
			
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.friend_enemy_res(eovs));
		});
	}

	//删除宿敌
	public synchronized boolean removeFriendEnemy(int enemyId)
	{
		return this.friend.removeEnemy(enemyId);
	}
	
	public synchronized void addEnemy(int rid)
	{
		this.friend.addEnemy(rid);
	}

	//设置好友的关注度
	public synchronized boolean setFriendFocus(int friendId, int value)
	{
		if (friendId <= 0 || value == 0)
			return false;
		SBean.DBFriend friend = this.friend.getFriend(friendId);
		SBean.CommonFriendCFGS friendCFGS = GameData.getInstance().getCommonCFG().friend;
		if (friend == null || friendCFGS == null)
			return false;
		if (value > 0)
		{
			if (friend.focusValue == friendCFGS.focusUp)
				return false;
			friend.focusValue += friendCFGS.focusAdd;
			if (friend.focusValue > friendCFGS.focusUp)
				friend.focusValue = friendCFGS.focusUp;
		}
		else
		{
			if (friend.focusValue == friendCFGS.focusDown)
				return false;
			friend.focusValue -= friendCFGS.focusAdd;
			if (friend.focusValue < friendCFGS.focusDown)
				friend.focusValue = friendCFGS.focusDown;
		}
		return true;
	}

	//返回给客户端的送花记录信息
	public SBean.FlowerOverview getRoleFlowerOverview(int contribution)
	{
		return new SBean.FlowerOverview(this.getRoleOverview(), this.share.getVipLevel(), this.friend.getCharm(), contribution);
	}

	//送花，可以给任何玩家送花
	public void giveFriendFlower(int rid, int count)
	{
		synchronized (this)
		{
			if (rid <= 0 || count <= 0)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.give_flower_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			if (!this.containsEnoughGameItem(GameData.getInstance().getCommonCFG().flower.flowerId, count))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.give_flower_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}

		gs.getLoginManager().exeCommonRoleVisitor(rid, false, new LoginManager.CommonRoleVisitor()
		{
			int visitRoleId = 0;
			String visitRoleName = null;

			@Override
			public boolean visit(Role role, Role sameUserRole)
			{
				visitRoleId = role.id;
				visitRoleName = role.name;
				role.syncAddCharm(count * 2);
				role.friend.addAccecptFlowers(Role.this.id, count);
				return true;
			}

			@Override
			public void onCallback(boolean success)
			{
				if (success && visitRoleId > 0 && visitRoleName != null)
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GIVE_FRIEND_FLOWER);
					tlogEvent.setArg(rid, count);

					Role.this.syncAddCharm(count);
					Role.this.friend.addGiveFlowers(visitRoleId, count);
					if (count > 10)
					{
						Role.this.sendMsgImpl(SBean.MessageInfo.MTypeWorld, 0, createSendFlowerMessage(new SBean.SendFlowersInfo(rid, visitRoleName, count)), "");
					}
					Role.this.delGameItem(GameData.getInstance().getCommonCFG().flower.flowerId, count, tlogEvent.getGameItemRecords());
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
				}

				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.give_flower_res(success ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED));
			}
		});
	}

	public synchronized List<SBean.FlowerLog> getAcceptFlowerLog()
	{
		return this.friend.getAcceptFlowerRank();
	}

	public synchronized List<SBean.FlowerLog> getGiveFlowerLog()
	{
		return this.friend.getGiveFlowerRank();
	}

	//获取好有的接收魅力记录
	public void getAcceptFlowerList(int fid)
	{
		synchronized (this)
		{
			if (fid <= 0 || this.friend.getGiveFlower(fid) == 0)
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.get_acceptlist_res(GameData.emptyList()));
				return;
			}
		}

		gs.getLoginManager().getAcceptFlowerLog(fid, logs ->
		{
			gs.getLoginManager().getFlowerOverviews(logs, overviews ->
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.get_acceptlist_res(overviews));
			});
		});
	}

	//获取赠送魅力详细记录， 赠送魅力和被赠送魅力
	public void getFlowerOverviews()
	{
		List<SBean.FlowerLog> acceptLogs = GameData.emptyList();
		List<SBean.FlowerLog> giveLogs = GameData.emptyList();
		synchronized (this)
		{
			acceptLogs = this.getAcceptFlowerLog();
			giveLogs = this.getGiveFlowerLog();
		}

		if (acceptLogs.isEmpty() && giveLogs.isEmpty())
			gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.get_flowerlog_res(GameData.emptyList(), GameData.emptyList()));
		else
		{
			gs.getLoginManager().getGiveAndAcceptFlowerOverviews(giveLogs, acceptLogs, (giveOverviews, acceptOverviews) ->
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.get_flowerlog_res(giveOverviews, acceptOverviews));
			});
		}
	}

	////////////////////////////////////////////////////好友 end///////////////////////////////////////////////////////////
	//查询机器人的基本信息
	void queryRobotBrief(int qRid, int rank)
	{
		if (qRid >= 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.query_robot_res(null));
			return;
		}

		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.query_robot_res(GameData.getInstance().getArenaRobotBrief(qRid, rank)));
	}

	//查看玩家的好友基本信息
	void queryRoleBrief(int qRid)
	{
		gs.getLoginManager().getRoleBrief(qRid, new LoginManager.GetRoleBriefCallback()
		{
			@Override
			public void onCallback(SBean.RoleBrief brief, int teamID)
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.query_rolebrief_res(brief, teamID));
			}
		});
	}

	//获取人物特性的详细信息
	public void queryRoleFeature(int qRid)
	{
		gs.getLoginManager().getRoleFeature(qRid, new LoginManager.GetRoleFeatureCallback()
		{
			@Override
			public void onCallback(SBean.RoleFeature feature)
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.query_rolefeature_res(feature));
			}
		});
	}

	//获取玩家所有已获得的佣兵
	public void queryPetOverviews(int qRid)
	{
		gs.getLoginManager().getPetOverviews(qRid, new LoginManager.GetPetOverviewsCallback()
		{
			@Override
			public void onCallback(List<SBean.PetOverview> pets)
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.query_petoverviews_res(pets));
			}
		});
	}

	//获取玩家所有已获得的神兵
	public void queryWeaponOverviews(int qRid)
	{
		gs.getLoginManager().getWeaponOverviews(qRid, new LoginManager.GetWeaponOverviewsCallback()
		{

			@Override
			public void onCallback(List<SBean.WeaponOverview> weapons)
			{
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.query_weaponoverviews_res(weapons));
			}
		});
	}

	/////////////////////////////////////////////////////拍卖行 ////////////////////////////////////////////////////////////
	SBean.DBAuctionInfo createNewAuctionInfo()
	{
		SBean.VipCFGS vip0Cfg = GameData.getInstance().getVipCFGS(0);
		if (vip0Cfg == null)
			return new SBean.DBAuctionInfo(new TreeSet<Integer>(), 0, 0, new ArrayList<SBean.DBConsignItems>(), 0, 0);
		else
			return new SBean.DBAuctionInfo(new TreeSet<Integer>(), vip0Cfg.auctionMaxCells, 0, new ArrayList<SBean.DBConsignItems>(), 0, 0);
	}

	synchronized boolean expandAuctionCells(int times)
	{
		if (times < this.auctionInfo.expandTimes + 1)
			return false;

		SBean.VipCFGS vip0Cfg = GameData.getInstance().getVipCFGS(0);
		SBean.VipCFGS vipCfg = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vip0Cfg == null || vipCfg == null || times > (vipCfg.auctionMaxCells - vip0Cfg.auctionMaxCells))
			return false;

		int cost = 0;
		for (int i = this.auctionInfo.expandTimes + 1; i <= times; i++)
			cost += GameData.getTimesCost(GameData.getInstance().getCommonCFG().auction.expandCost, i);

		if (!this.canUseCoin(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EXPAND_AUCTION_CELLS);
		tlogEvent.setArg(times, cost);
		this.useCoin(cost, false, tlogEvent.getGameItemRecords());
		this.auctionInfo.cellSize += times - this.auctionInfo.expandTimes;
		this.auctionInfo.expandTimes = times;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	void syncAuctionCommonItems(int sessionid, int itemType, int classType, int rank, int level, int order, int page, String name)
	{
		switch (itemType)
		{
			case GameData.CLASS_TYPE_BLADE:
			case GameData.CLASS_TYPE_SWORD:
			case GameData.CLASS_TYPE_SPEAR:
			case GameData.CLASS_TYPE_ARROW:
			case GameData.CLASS_TYPE_HEAL:
			case GameData.AUCTION_ITEM_TYPE_SPIRIT:
				{
					if(classType > GameData.CLASS_TYPE_END)
					{
						gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_syncitems_res(null, 1));
						return;
					}
				}
				break;
			default:
				break;
		}
		if (page <= 0 || GameData.getInstance().getCommonCFG().auction.needLvl > this.level)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_syncitems_res(null, 1));
			return;
		}

		gs.getAuctionService().auctionItemsSyncImpl(itemType, classType, rank, level, order, page, name, new AuctionService.AuctionItemsSyncCallBack()
		{
			@Override
			public void onCallback(List<SBean.DetailConsignItems> items, int lastPage)
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_syncitems_res(items, lastPage));
			}
		});
	}

//	void syncAuctionEquips(int itemType, int classType, int rank, int level, int order, int page, String name)
//	{
//		if (itemType <= 0 || itemType > GameData.AUCTION_ITEM_TYPE_EQUIP || classType < 0 || classType > GameData.getInstance().getClassRoleCount())
//		{
//			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.auction_syncitems_res(null, 1));
//			return;
//		}
//
//		this.syncAuctionCommonItems(itemType, classType, rank, level, order, page, name);
//	}

	void syncSelfAuctionItems(int sessionid)
	{
		gs.getAuctionService().selfItemSyncImpl(this.id, new AuctionService.SelfItemsSyncCallBack()
		{
			@Override
			public void onCallback(Map<Integer, SBean.DBConsignItems> items)
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_syncselfitems_res(items, Role.this.auctionInfo.cellSize, Role.this.auctionInfo.expandTimes));
			}
		});
	}

	synchronized void putOnNormalItems(int sessionid, int id, int count, int price)
	{
		if (count <= 0 || !this.checkItemCanPutOn(id, price / count) || !this.containsEnoughGameItem(id, count) || GameData.getInstance().getBagItemAuctionType(id) <= 0)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putonitems_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		SBean.Counter counter = this.lockBagItem(id, count);
		gs.getAuctionService().putOnItemImpl(this.id, createDBConsignItems(id, count, null, price), new AuctionService.PutOnItemCallBack()
		{
			@Override
			public void onCallback(int cid)
			{
				synchronized(this)
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PUT_ON_NORMAL_ITEMS);
					tlogEvent.setArg(id, count, price);
					if (cid <= 0)
					{
						Role.this.delLockedBagItem(id, counter, true, tlogEvent.getGameItemRecords());
						gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putonitems_res(GameData.PROTOCOL_OP_FAILED));
						return;
					}
					Role.this.delLockedBagItem(id, counter, false, tlogEvent.getGameItemRecords());
					gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putonitems_res(GameData.PROTOCOL_OP_SUCCESS));
					Role.this.auctionInfo.consignments.add(cid);
					Role.this.onlineSave(GameTime.getTime());
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
					gs.getTLogger().logMarketPutOn(Role.this, id, count, price);
				}
			}
		});
	}

	synchronized void putOnEquip(int sessionid, int id, String guid, int price)
	{
		if (!this.checkItemCanPutOn(id, price) || !this.containsEquip(id, guid))
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putonequip_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		SBean.DBEquip equip = this.lockEquip(id, guid);
		gs.getAuctionService().putOnItemImpl(this.id, createDBConsignItems(id, 1, equip.kdClone(), price), new AuctionService.PutOnItemCallBack()
		{
			@Override
			public void onCallback(int cid)
			{
				synchronized(this)
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PUT_ON_EQUIP);
					tlogEvent.setArg(id, price);
					tlogEvent.setArg(guid);
					if (cid <= 0)
					{
						Role.this.delLockedEquip(equip, true, tlogEvent.getGameItemRecords());
						gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putonequip_res(GameData.PROTOCOL_OP_FAILED));
						return;
					}
					Role.this.delLockedEquip(equip, false, tlogEvent.getGameItemRecords());
					gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putonequip_res(GameData.PROTOCOL_OP_SUCCESS));
					Role.this.auctionInfo.consignments.add(cid);
					Role.this.onlineSave(GameTime.getTime());
					gs.getTLogger().logMarketPutOn(Role.this, id, 1, price);
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
				}
			}
		});
	}
	
	SBean.DBConsignItems createDBConsignItems(int itemID, int count, SBean.DBEquip equip, int price)
	{
		if(equip != null)
			equip.guid = GameData.getInstance().createEquipGuid(itemID, gs.getConfig().id);
		
		return new SBean.DBConsignItems(itemID, count, equip, price, 0, 0);
	}
	
	boolean checkItemCanPutOn(int id, int price)
	{
		if (id >= 0 || price <= 0 || price > GameData.MAX_CURRENCY_AMOUNT || !GameData.getInstance().checkBagItemCanTrade(id, price))
			return false;

		return this.auctionInfo.cellSize > this.auctionInfo.consignments.size();
	}

	void mailAuctionItem(SBean.DBConsignItems items, SysMailType type, List<Integer> additionalInfo)
	{
		List<SBean.GameItem> att = new ArrayList<SBean.GameItem>();
		att.add(GameData.getInstance().toGameItem(items));
		this.mailbox.addSysMail(type, MailBox.AUCTIONMAP_MAIL_MAX_RESERVE_TIME, "", att, additionalInfo);
	}

	synchronized int timeOutPutOffItems(int cid, SBean.DBConsignItems items)
	{
		if (!this.auctionInfo.consignments.remove(cid))
			return GameData.PROTOCOL_OP_FAILED;

		List<Integer> additionalInfo = new ArrayList<Integer>();
		additionalInfo.add(items.id);
		this.mailAuctionItem(items, MailBox.SysMailType.AuctionBack, additionalInfo);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	void putOffAuctionItems(int sessionid, int cid, int itemID, int count)
	{
		synchronized (this)
		{
			if (!this.auctionInfo.consignments.remove(cid) || !this.canAddGameItem(itemID, count))
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putoffitems_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}

		gs.getAuctionService().putOffItemsImpl(this.id, cid, new AuctionService.PutOffItemsCallBack()
		{
			@Override
			public void onCallback(int errCode, SBean.DBConsignItems offItems)
			{
				synchronized(this)
				{
					if (errCode < 0)
					{
						if (errCode == -100)
							Role.this.auctionInfo.consignments.add(cid);

						gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putoffitems_res(errCode));
					}
					else if(offItems != null)
					{
						TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PUT_OFF_AUCTION_ITEMS);
						tlogEvent.setArg(cid, itemID, count);
						SBean.GameItem gi = GameData.getInstance().toGameItem(offItems);
						Role.this.syncAddGameItem(gi, tlogEvent);
						Role.this.onlineSave(GameTime.getTime());
						gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
					}
					gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_putoffitems_res(GameData.PROTOCOL_OP_SUCCESS));
				}
			}
		});
	}

	//拍卖
	public void buyAuctionItems(int sessionid, int sellerID, int cid, SBean.DBConsignItems buyItems)
	{
		if (sellerID == this.id)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_buyitems_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}

		SBean.Counter counter;
		int lockedCredit;
		synchronized (this)
		{
			if (buyItems.price <= 0 || !this.canAddGameItem(buyItems.id, buyItems.count))
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_buyitems_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}

			if (!this.canUseDiamond(buyItems.price, true))
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_buyitems_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
			
			//购买装备，消耗固定比率商誉值
			int type = GameData.getInstance().getBagItemAuctionType(buyItems.id);
			int needCredit = (int) (GameData.getInstance().getCommonCFG().auction.costCreditTypes.contains(type) ? Math.ceil(buyItems.price * GameData.getInstance().getCommonCFG().auction.buyCreditRate) : 0);
			if(needCredit > 0 && !this.canUseCredit(needCredit))
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_buyitems_res(GameData.PROTOCOL_OP_AUCTION_LACK_CREDIT));
				return;
			}
			
			counter = this.lockDiamond(buyItems.price, true);
			lockedCredit = this.lockCredit(needCredit);
		}

		gs.getAuctionService().buyItemsImpl(sellerID, cid, buyItems.price, new AuctionService.BuyItemsCallBack()
		{
			@Override
			public void onCallback(SBean.DBConsignItems items)
			{
				synchronized(this)
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_AUCTION_ITEMS);
					Role.this.useLockedDiamond(counter, items == null, true, tlogEvent.getGameItemRecords());
					if(lockedCredit > 0)
						Role.this.useLockCredit(lockedCredit, items == null ? null : tlogEvent.getGameItemRecords());
					
					if (items == null)
					{
						gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_buyitems_res(GameData.PROTOCOL_OP_AUCTION_NOT_EXSIT));
						return;
					}
					
					tlogEvent.setArg(sellerID, cid, items.id, items.count);
					items.id = Math.abs(items.id);
					if (items.equip != null)
						items.equip.id = Math.abs(items.equip.id);

					SBean.GameItem gi = GameData.getInstance().toGameItem(items);

					Role.this.syncAddGameItem(gi, tlogEvent);

					int now = GameTime.getTime();
					items.time = now;
					items.price = -items.price;
					Role.this.addAuctionTradeLog(items);
					Role.this.onlineSave(GameTime.getTime());
					gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_buyitems_res(GameData.PROTOCOL_OP_SUCCESS));
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
					gs.getTLogger().logMarketBuy(Role.this, buyItems.id, buyItems.count, buyItems.price);
					
					Role.this.testChallengeTask(GameData.CHALLENGE_TASK_ID_SELL_OR_BUY, 0);
				}
			}
		});
	}

	synchronized boolean checkAuctionItemsCanBuy(int cid, SBean.DBConsignItems items)
	{
		if (!this.auctionInfo.consignments.remove(cid))
			return false;

		int gain = items.price;
		if(gain >= GameData.getInstance().getCommonCFG().auction.freeAmount)
			gain = (int) (gain * (1 - (GameData.getInstance().getCommonCFG().auction.taxRate - GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).taxReduction / 10000f)));
		
		if(gain > 0)
		{
			SBean.GameItem gi = GameData.getInstance().toGameItem(-GameData.COMMON_ITEM_ID_DIAMOND, gain);
			List<SBean.GameItem> att = new ArrayList<SBean.GameItem>();
			att.add(gi);

			List<Integer> additionalInfo = new ArrayList<Integer>();
			additionalInfo.add(items.id);
			additionalInfo.add(items.price);
			additionalInfo.add(items.price - gain);
			this.mailbox.addSysMail(MailBox.SysMailType.AuctionSale, MailBox.AUCTIONMAP_MAIL_MAX_RESERVE_TIME, "", att, additionalInfo);
		}
		int now = GameTime.getTime();
		items.time = now;
		this.addAuctionTradeLog(items);
		this.auctionInfo.sellItemsCnt += items.count;
		
		testChallengeTask(GameData.CHALLENGE_TASK_ID_SELL_OR_BUY, 0);
		return true;
	}

	synchronized void addAuctionTradeLog(SBean.DBConsignItems log)
	{
		this.auctionInfo.tradeLogs.add(log);
		if (this.auctionInfo.tradeLogs.size() > 50)
			this.auctionInfo.tradeLogs.subList(0, this.auctionInfo.tradeLogs.size() - 50).clear();
		
		this.auctionInfo.buyItemsCnt += log.count;
	}

	synchronized List<SBean.DBConsignItems> syncAuctionTradeLogs()
	{
		List<SBean.DBConsignItems> logs = new ArrayList<SBean.DBConsignItems>();
		logs.addAll(this.auctionInfo.tradeLogs);
		return logs;
	}
	
	void syncAuctionItemPrices(int sessionid, int itemID)
	{
		if(!GameData.getInstance().checkEntityIdValid(itemID))
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_itemprices_res(null));
		
		gs.getAuctionService().itemPricesSyncImpl(itemID, new AuctionService.ItemPricesSyncCallBack()
		{
			@Override
			public void onCallbakc(List<SBean.DBConsignItems> prices)
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.auction_itemprices_res(prices));
			}
		});
	}
	/////////////////////////////////////////////////////拍卖行 end////////////////////////////////////////////////////

	/////////////////////////////////////////////////////藏宝图///////////////////////////////////////////////////////
	private TreasureMap createTreasureMapInfo()
	{
		SBean.DBTreasure dbTreasure = new SBean.DBTreasure(new SBean.TreasureNPC(new HashMap<>(), new HashSet<>(), 0, new HashSet<>(GameData.getInstance().getTreasureBaseCFGS().bornPieces.keySet())), new SBean.TreasureMap(new SBean.MapState(0, (byte) 0, new HashMap<>()), new HashMap<>(GameData.getInstance().getTreasureBaseCFGS().bornPieces)), new HashMap<Integer, Byte>(), 0);
		return new TreasureMap(dbTreasure);
	}

	public class TreasureMap
	{
		int totalPercent;
		Map<Integer, Integer> index2Point = new HashMap<>();
		SBean.DBTreasure info;

		TreasureMap(SBean.DBTreasure info)
		{
			this.info = info;
			SBean.TreasureMapCFGS mapCfg = GameData.getInstance().getTreasureMapCFGS(this.info.mapInfo.curMap.mapID);
			if (mapCfg == null)
				return;

			//			for(int i=0; i<mapCfg.points.size(); i++)
			//				index2Point.put(i + 1, mapCfg.points.get(i));
			if (this.info.mapInfo.curMap.open == 1)
				this.resetInfoPoint(mapCfg);

			SBean.ClueTreeCFGS clueTree = GameData.getInstance().getTreasureBaseCFGS().clueTrees.get(mapCfg.clueType);
			if (clueTree == null)
				return;

			this.resetTotalPercent(clueTree);
		}

		void resetInfoPoint(SBean.TreasureMapCFGS mapCfg)
		{
			this.totalPercent = 0;
			index2Point.clear();
			for (int i = 0; i < mapCfg.points.size(); i++)
				index2Point.put(i + 1, mapCfg.points.get(i));

			SBean.TreasureBaseCFGS baseCfg = GameData.getInstance().getTreasureBaseCFGS();
			SBean.ClueTreeCFGS treeCfg = baseCfg.clueTrees.get(mapCfg.clueType);
			for (int i = 1; i <= treeCfg.clues.size(); i++)
			{
				SBean.Clue clue = GameData.getInstance().getClueCFGS(treeCfg, i);
				if (clue == null)
					continue;

				if (clue.prePoints.isEmpty() && !this.info.mapInfo.curMap.points.containsKey(i))
				{
					this.info.mapInfo.curMap.points.put(i, (byte) 0);
					//					totalPercent += clue.gain;
				}
			}
		}

		void resetCurTreasureMap(SBean.TreasureMapCFGS mapCfg)
		{
			this.info.mapInfo.curMap.open = 0;
			this.info.mapInfo.curMap.points.clear();
			if (mapCfg != null)
			{
				this.info.mapInfo.curMap.mapID = mapCfg.id;
				//				this.resetInfoPoint(mapCfg);
			}
			else
				this.info.mapInfo.curMap.mapID = 0;

			this.totalPercent = 0;
		}

		void resetTotalPercent(SBean.ClueTreeCFGS clueTree)
		{
			this.totalPercent = 0;
			this.info.mapInfo.curMap.points.entrySet().stream().filter(e -> e.getValue() == 1).forEach(e -> this.addTotalPercent(clueTree, e.getKey()));
		}

		void addTotalPercent(SBean.ClueTreeCFGS clueTree, int index)
		{
			SBean.Clue clue = GameData.getInstance().getClueCFGS(clueTree, index);
			if (clue != null)
				this.totalPercent += clue.gain;
		}
	}

	synchronized boolean searchTreasure(int pointIndex)
	{
		if (this.treasuremapInfo.info.mapInfo.curMap.mapID == 0 || this.treasuremapInfo.info.mapInfo.curMap.open == 0 || !this.treasuremapInfo.info.mapInfo.curMap.points.containsKey(pointIndex))
			return false;

		SBean.TreasureMapCFGS mapCfg = GameData.getInstance().getTreasureMapCFGS(this.treasuremapInfo.info.mapInfo.curMap.mapID);
		if (mapCfg == null)
			return false;

		SBean.ClueTreeCFGS clueTree = GameData.getInstance().getTreasureBaseCFGS().clueTrees.get(mapCfg.clueType);
		if (clueTree == null)
			return false;

		Integer pointID = this.treasuremapInfo.index2Point.get(pointIndex);
		if (pointID == null)
			return false;

		SBean.InfoPointCFGS infoCfg = GameData.getInstance().getPointCFGS(pointID);
		if (infoCfg == null)
			return false;

		if (infoCfg.type == GameData.TREASURE_INFOPOINT_KILLMONSTER)
			return false;

		if (!this.logTreasureTask(infoCfg, pointIndex))
			return false;

		this.treasuremapInfo.info.mapInfo.curMap.points.put(pointIndex, (byte) 1);

		this.treasuremapInfo.addTotalPercent(clueTree, pointIndex);
		this.checkOpenInfoPoint(clueTree);
		return true;
	}

	void checkTreasureMonster(int monsterID)
	{
		if (this.treasuremapInfo.info.mapInfo.curMap.mapID == 0 || this.treasuremapInfo.info.mapInfo.curMap.open == 0)
			return;

		SBean.TreasureMapCFGS mapCfg = GameData.getInstance().getTreasureMapCFGS(this.treasuremapInfo.info.mapInfo.curMap.mapID);
		if (mapCfg == null)
			return;

		SBean.ClueTreeCFGS clueTree = GameData.getInstance().getTreasureBaseCFGS().clueTrees.get(mapCfg.clueType);
		if (clueTree == null)
			return;

		int openIndex = 0;
		for (Map.Entry<Integer, Byte> e : this.treasuremapInfo.info.mapInfo.curMap.points.entrySet())
		{
			if (e.getValue() == 0)
			{
				int pointIndex = e.getKey();
				Integer pointID = this.treasuremapInfo.index2Point.get(pointIndex);
				if (pointID != null)
				{
					SBean.InfoPointCFGS infoCfg = GameData.getInstance().getPointCFGS(pointID);
					if (infoCfg != null && infoCfg.type == GameData.TREASURE_INFOPOINT_KILLMONSTER && infoCfg.param1 == monsterID)
					{
						if (this.logTreasureTask(infoCfg, pointIndex))
						{
							e.setValue((byte) 1);
							openIndex = pointIndex;
						}
						break;
					}
				}
			}
		}

		if (openIndex > 0)
		{
			this.treasuremapInfo.addTotalPercent(clueTree, openIndex);
			this.checkOpenInfoPoint(clueTree);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_search_res(openIndex));
		}
	}

	boolean logTreasureTask(SBean.InfoPointCFGS infoCfg, int pointIndex)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_LOG_TREASURE_TASK);
		tlogEvent.setArg(infoCfg.type, pointIndex);
		switch (infoCfg.type)
		{
		case GameData.TREASURE_INFOPOINT_KILLMONSTER:
			if (!GameData.checkRandom(infoCfg.param2))
				return false;

			break;
		case GameData.TREASURE_INFOPOINT_DIALOGUE:
			if (!GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapContext().getMapLocation(), infoCfg.param1, GameData.getInstance().getTreasureBaseCFGS().distance))
				return false;

			break;
		case GameData.TREASURE_INFOPOINT_MINERAL:
			if (!GameData.getInstance().testNearbyPosition(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), infoCfg.param1, infoCfg.param2, 0, infoCfg.param3, infoCfg.param4))
				return false;

			break;
		case GameData.TREASURE_INFOPOINT_SECRET_BOX:
			if (!GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), infoCfg.param1, GameData.getInstance().getTreasureBaseCFGS().distance))
				return false;

			List<SBean.DummyGoods> dgs = new ArrayList<>();
			if (infoCfg.param2 != 0 && infoCfg.param3 > 0)
				dgs.add(new SBean.DummyGoods(infoCfg.param2, infoCfg.param3));

			if (infoCfg.param4 != 0 && infoCfg.param5 > 0)
				dgs.add(new SBean.DummyGoods(infoCfg.param4, infoCfg.param5));

			if (!this.containsEnoughGameItems(dgs))
				return false;

			this.delGameItems(dgs, tlogEvent.getGameItemRecords());
			break;
		default:
			return false;
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	private void checkOpenInfoPoint(SBean.ClueTreeCFGS clueTree)
	{
		for (int index = 1; index <= clueTree.clues.size(); index++)
		{
			if (this.treasuremapInfo.info.mapInfo.curMap.points.containsKey(index))
				continue;

			SBean.Clue clue = clueTree.clues.get(index - 1);
			boolean open = true;
			for (int preIndex : clue.prePoints)
			{
				Byte finish = this.treasuremapInfo.info.mapInfo.curMap.points.get(preIndex);
				if (finish == null || finish == 0)
				{
					open = false;
					break;
				}
			}

			if (open)
				this.treasuremapInfo.info.mapInfo.curMap.points.put(index, (byte) 0);
		}
	}

	void dayRefreshTreasure(int nowday)
	{
		this.resetTreasureNcp();
		this.treasuremapInfo.info.npcInfo.lastRefreshDay = nowday;
	}

	synchronized void resetTreasureNcp()
	{
		for (SBean.TreasureNpcCFGS npcCfg : GameData.getInstance().getAllTreasureNpc())
		{
			SBean.NPCState npcState = this.treasuremapInfo.info.npcInfo.npcs.get(npcCfg.id);
			if (npcState == null)
			{
				npcState = new SBean.NPCState((byte) 0, new HashMap<Integer, Integer>(), 0, (byte) 0, 0);
				this.treasuremapInfo.info.npcInfo.npcs.put(npcCfg.id, npcState);
			}

			npcState.refreshTimes = 0;
			npcState.open = (byte) (this.roleProperties.getRoleFightPower() > npcCfg.needPower ? 1 : 0);
			this.resetNpcLib(npcCfg, npcState);
		}
	}

	synchronized void syncTreasureNpcInfo()
	{
		if (this.level < GameData.getInstance().getTreasureBaseCFGS().needlevel)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_syncnpcs_res(null, null));
			return;
		}
		
		for (Map.Entry<Integer, SBean.NPCState> e : this.treasuremapInfo.info.npcInfo.npcs.entrySet())
		{
			SBean.NPCState npcState = e.getValue();
			if (npcState.open == 0)
			{
				SBean.TreasureNpcCFGS npcCfg = GameData.getInstance().getTreasureNpcCFGS(e.getKey());
				if (npcCfg == null)
					continue;

				if (this.roleProperties.getRoleFightPower() >= npcCfg.needPower)
					npcState.open = 1;
			}
		}

		this.isTreasureGuide = 1;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_syncnpcs_res(this.treasuremapInfo.info.npcInfo.kdClone(), new HashMap<>(this.treasuremapInfo.info.mapInfo.pieces)));
	}

	synchronized void resetNpcLib(SBean.TreasureNpcCFGS npcCfg, SBean.NPCState npcState)
	{
		npcState.lib.clear();
		SBean.NpcFameCFGS fameCfg = GameData.getInstance().getNpcFameCFGS(npcState.fame);
		for (int i = 0; i < fameCfg.count; i++)
		{
			SBean.IntList lib = npcCfg.pieces.get(fameCfg.level - 1);
			int piece = lib.list.get(GameRandom.getRandInt(0, lib.list.size()));
			int count = GameRandom.getRandInt(fameCfg.min, fameCfg.max + 1);
			npcState.lib.put(piece, count);
		}
	}

	synchronized SBean.NPCState refreshNpcInfo(int npcID, int times)
	{
		SBean.TreasureNpcCFGS npcCfg = GameData.getInstance().getTreasureNpcCFGS(npcID);
		if (npcCfg == null)
			return null;

		SBean.NPCState npcState = this.treasuremapInfo.info.npcInfo.npcs.get(npcID);
		if (npcState == null || times != npcState.refreshTimes + 1 || times > GameData.DIAMOND_REFRESH_MAX_TIMES)
			return null;

		if (npcState.open == 0 && this.roleProperties.getRoleFightPower() < npcCfg.needPower)
			return null;

		int costDiamond = GameData.getTimesCost(GameData.getInstance().getTreasureBaseCFGS().refreshDiamond, times);
		if (!this.canUseDiamond(costDiamond, false))
			return null;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_REFRESH_TREASURE_INFO);
		tlogEvent.setArg(npcID, times, costDiamond);
		this.useDiamond(costDiamond, false, tlogEvent.getGameItemRecords());
		this.resetNpcLib(npcCfg, npcState);
		npcState.refreshTimes++;
		Role.this.logDailyTask(GameData.DAILY_TASK_ID_REFRESH_TREASURE_INFO, 1);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return npcState;
	}

	private void addTreasureNpcFame(SBean.NPCState npcState, int fame)
	{
		SBean.NpcFameCFGS fameCfg = GameData.getInstance().getNpcMaxFameCFGS();
		npcState.fame += fame;
		if (npcState.fame > fameCfg.fameFloor)
			npcState.fame = fameCfg.fameFloor;
	}

	synchronized boolean buyTreasurePieces(int npcID, int pieceID)
	{
		SBean.TreasurePieceCFGS pieceCfg = GameData.getInstance().getTreasurePieceCFGS(pieceID);
		if (pieceCfg == null)
			return false;

		SBean.NPCState npcState = this.treasuremapInfo.info.npcInfo.npcs.get(npcID);
		if (npcState == null || npcState.open == 0)
			return false;

		Integer count = npcState.lib.get(pieceID);
		if (count == null || count == 0)
			return false;

		int cost = pieceCfg.price * count;
		if (!this.canUseCoin(cost, true))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_TREASURE_PIECES);
		tlogEvent.setArg(npcID, pieceID, cost);
		this.useCoin(cost, true, tlogEvent.getGameItemRecords());
		npcState.lib.put(pieceID, 0);
		this.treasuremapInfo.info.mapInfo.pieces.compute(pieceID, (k, v) -> v == null ? count : v + count);
		this.addTreasureNpcFame(npcState, pieceCfg.addFame);
		this.treasuremapInfo.info.npcInfo.pieceLog.add(pieceID);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	synchronized void takeTreasureNpcReward(int npcID)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_TREASURE_NPC_REWARD);
		tlogEvent.setArg(npcID);
		SBean.TreasureNpcCFGS npcCfg = GameData.getInstance().getTreasureNpcCFGS(npcID);
		SBean.NPCState npcState = this.treasuremapInfo.info.npcInfo.npcs.get(npcID);

		if (npcCfg == null || npcState == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_npcreward_res(GameData.PROTOCOL_OP_FAILED, null));
			return;
		}

		SBean.NpcFameCFGS fameCfg = GameData.getInstance().getNpcFameCFGS(npcState.fame);
		if (npcState.reward >= fameCfg.level)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_npcreward_res(GameData.PROTOCOL_OP_FAILED, null));
			return;
		}

		int fixDropTblID = npcCfg.fixTblIDs.get(npcState.reward);
		Map<Integer, Integer> goods = GameData.getInstance().getMergedFixedDrop(fixDropTblID, 1);
		List<SBean.GameItem> gis = GameData.getInstance().toGameItems(goods);
		if (!this.canAddGameItems(gis))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_npcreward_res(GameData.PROTOCOL_OP_TREASURE_BAG_FULL, null));
			return;
		}

		this.syncAddGameItems(gis, tlogEvent);
		npcState.reward++;

		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_npcreward_res(GameData.PROTOCOL_OP_SUCCESS, goods));
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}

	synchronized SBean.TreasureMap syncTreasureMapInfo()
	{
		if (this.level < GameData.getInstance().getTreasureBaseCFGS().needlevel)
			return null;

		this.isTreasureGuide = 1;
		return this.treasuremapInfo.info.mapInfo.kdClone();
	}

	private boolean useTreasurePiece(int pieceID, int cost)
	{
		Integer count = this.treasuremapInfo.info.mapInfo.pieces.get(pieceID);
		if (count == null || count < cost)
			return false;

		count -= cost;
		if (count > 0)
			this.treasuremapInfo.info.mapInfo.pieces.put(pieceID, count);
		else
			this.treasuremapInfo.info.mapInfo.pieces.remove(pieceID);

		return true;
	}

	synchronized boolean makeTreasureMap(int pieceID)
	{
		if (this.treasuremapInfo.info.mapInfo.curMap.mapID > 0)
			return false;

		SBean.TreasurePieceCFGS pieceCfg = GameData.getInstance().getTreasurePieceCFGS(pieceID);
		if (pieceCfg == null)
			return false;

		SBean.TreasureMapCFGS mapCfg = GameData.getInstance().getTreasureMapCFGS(pieceCfg.relateMapID);
		if (mapCfg == null)
			return false;

		if (!this.useTreasurePiece(pieceID, pieceCfg.needCount))
			return false;

		this.treasuremapInfo.resetCurTreasureMap(mapCfg);
		return true;
	}

	synchronized SBean.MapState treasureTotalSearch()
	{
		if (this.treasuremapInfo.info.mapInfo.curMap.mapID == 0)
			return null;

		SBean.TreasureMapCFGS mapCfg = GameData.getInstance().getTreasureMapCFGS(this.treasuremapInfo.info.mapInfo.curMap.mapID);
		if (mapCfg == null)
			return null;

		int searchVit = GameData.getInstance().getTreasureBaseCFGS().searchVit;
		if (!this.canUseVit(searchVit))
			return null;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TREASURE_TOTAL_SEARCH);
		tlogEvent.setArg(searchVit);
		this.useVit(searchVit, tlogEvent.getGameItemRecords());
		this.treasuremapInfo.resetInfoPoint(mapCfg);
		this.treasuremapInfo.info.mapInfo.curMap.open = 1;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return this.treasuremapInfo.info.mapInfo.curMap;
	}

	synchronized void takeTreasureMapReward()
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_TREASURE_MAP_REWARD);
		if (this.treasuremapInfo.info.mapInfo.curMap.mapID == 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_mapreward_res(GameData.PROTOCOL_OP_FAILED, null));
			return;
		}

		SBean.TreasureMapCFGS mapCfg = GameData.getInstance().getTreasureMapCFGS(this.treasuremapInfo.info.mapInfo.curMap.mapID);
		if (mapCfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_mapreward_res(GameData.PROTOCOL_OP_FAILED, null));
			return;
		}

		int grade = GameData.getTreasureMapRewardGrade(mapCfg, this.treasuremapInfo.totalPercent);
		if (grade == 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_mapreward_res(GameData.PROTOCOL_OP_FAILED, null));
			return;
		}

		SBean.TreasureReward reward = mapCfg.rewards.get(grade - 1);
		Map<Integer, Integer> goods = GameData.getInstance().getMergedFixedDrop(reward.fixTblID, 1);
		List<SBean.GameItem> gis = GameData.getInstance().toGameItems(goods);
		if (!this.canAddGameItems(gis))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_mapreward_res(GameData.PROTOCOL_OP_TREASURE_BAG_FULL, null));
			return;
		}
		tlogEvent.setArg(grade);
		this.syncAddGameItems(gis, tlogEvent);
		if (grade == mapCfg.rewards.size() && mapCfg.medal > 0)
			this.addMedal(mapCfg.medal);

		this.treasuremapInfo.info.npcInfo.finishMaps.add(this.treasuremapInfo.info.mapInfo.curMap.mapID);
		this.treasuremapInfo.resetCurTreasureMap(null);
		
		testChallengeTask(GameData.CHALLENGE_TASK_ID_TREASURE, 0);
		
		this.logTaskScheduleData(GameData.SCHEDULE_TYPE_TREASUREMAP);
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.treasure_mapreward_res(GameData.PROTOCOL_OP_SUCCESS, goods));
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
	}

	private void addMedal(int medalID)
	{
		if (this.treasuremapInfo.info.medals.containsKey(medalID))
			return;

		this.setMedal(medalID, (byte) 0);
	}
	
	synchronized boolean quitTreasureMap()
	{
		int oldMapID = this.treasuremapInfo.info.mapInfo.curMap.mapID;
		boolean notOpen = this.treasuremapInfo.info.mapInfo.curMap.open != 1;
		if (this.treasuremapInfo.info.mapInfo.curMap.mapID == 0)
			return false;

		this.treasuremapInfo.resetCurTreasureMap(null);

		//没有探索过的藏宝图，放弃时加回碎片
		if (notOpen)
		{
			SBean.TreasureMapCFGS mapCfg = GameData.getInstance().getTreasureMapCFGS(oldMapID);
			if (mapCfg != null)
			{
				SBean.TreasurePieceCFGS pieceCfg = GameData.getInstance().getTreasurePieceCFGS(mapCfg.pieceID);
				if (pieceCfg != null)
					this.treasuremapInfo.info.mapInfo.pieces.compute(mapCfg.pieceID, (k, v) -> v == null ? pieceCfg.needCount : v + pieceCfg.needCount);
			}
		}

		return true;
	}

	synchronized boolean medalGrow(int medalID, int growType)
	{
		Byte type = this.treasuremapInfo.info.medals.get(medalID);
		if (type == null || type == growType)
			return false;

		SBean.MedalCFGS medalCfg = GameData.getInstance().getMedalCFGS(medalID);
		if (medalCfg == null)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MEDAL_GROW);
		tlogEvent.setArg(medalID, growType);
		switch (growType)
		{
		case GameData.TREASURE_MEDAL_GROW_NORMAL:
			if (!this.containsEnoughGameItems(medalCfg.normalCost))
				return false;

			this.delGameItems(medalCfg.normalCost, tlogEvent.getGameItemRecords());
			break;
		case GameData.TREASURE_MEDAL_GROW_DIAMOND:
			if (!this.canUseDiamond(medalCfg.diamondCost, false))
				return false;

			this.useDiamond(medalCfg.diamondCost, false, tlogEvent.getGameItemRecords());
			break;
		default:
			return false;
		}
		this.setMedal(medalID, (byte) 1);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	private void setMedal(int medalID, byte state)
	{
		this.treasuremapInfo.info.medals.put(medalID, state);
		this.roleProperties.onUpdateMedal(medalID, state);
		gs.getMapService().syncRoleUpdateMedal(this.gameMapContext.getCurMapId(), this.id, medalID, state);
	}

	////////////////////////////////////////////////////藏宝图 end////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////坐骑/////////////////////////////////////////////////////////////
	public class HorseData
	{
		public static final int PROP_FIX_COUNT = 4;
		public static final int PROP_FIX_VALUE = 4;
		SBean.DBHorse dbHorse;
		List<SBean.Prop> enhanceAttrs;
		int enhanceHorse;

		HorseData(SBean.DBHorse dbHorse)
		{
			this.dbHorse = dbHorse;
			this.enhanceAttrs = new ArrayList<>();
		}
		
//		void fixEnhanceAttr(SBean.HorseInfo info, List<Integer> lows, List<Integer> equals, Set<Integer> locks)
//		{
//			if(lows.size() >= PROP_FIX_COUNT)
//			{
//				int propID = lows.get(GameRandom.getRandInt(0, lows.size()));
//				Integer value = info.enhanceAttrs.get(propID);
//				if(value != null)
//					this.enhanceAttrs.put(propID, value);
//			}
//			
//			if(!equals.isEmpty() && (equals.size() + locks.size() == enhanceAttrs.size()))
//			{
//				int propID = equals.get(GameRandom.getRandInt(0, equals.size()));
//				Integer value = enhanceAttrs.get(propID);
//				if(value != null)
//					this.enhanceAttrs.put(propID, value - GameRandom.getRandInt(1, PROP_FIX_VALUE));
//			}
//		}
	}

	private void updateHorse(SBean.HorseInfo info)
	{
		this.horseData.dbHorse.horses.put(info.id, info);
		this.roleProperties.onUpdateHorse(info);

		gs.getMapService().syncRoleUpdateHorseInfo(this.gameMapContext.getCurMapId(), this.id, info);
	}

	synchronized SBean.HorseInfo tameHorse(int hid)
	{
		if (this.horseData.dbHorse.horses.containsKey(hid))
			return null;

		SBean.HorseCFGS horseCfg = GameData.getInstance().getHorseCFGS(hid);
		SBean.HorseEnHanceLvlCommonCFGS defaultLvlCfg = GameData.getInstance().getHorseDefaultEnHanceLvlCommonCFGS();

		if (horseCfg == null)
			return null;

		if (!this.containsEnoughGameItem(horseCfg.tameCost.id, horseCfg.tameCost.count))
			return null;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAME_HORSE);
		tlogEvent.setArg(hid, horseCfg.tameCost.id, horseCfg.tameCost.count);
		this.delGameItem(horseCfg.tameCost.id, horseCfg.tameCost.count, tlogEvent.getGameItemRecords());

		SBean.HorseInfo info = new SBean.HorseInfo(hid, (byte) 0, new ArrayList<>(), 0, new HashMap<Integer, Integer>(), 1, 0, new HashSet<Integer>(), horseCfg.orgShowID);
		if (horseCfg.pure != 1)
		{
			for (int i = 0; i < defaultLvlCfg.attrNum; i++)
				info.enhanceAttrs.add(new SBean.Prop(0, 0));
		}

		this.horseData.enhanceHorse = 0;
		this.updateHorse(info);

		if (this.horseData.dbHorse.horses.size() == 1)
			this.setCurUseHorse(hid);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logHorseUnlock(this, hid);
		return info;
	}

	boolean setCurUseHorse(int hid)
	{
		if (!this.horseData.dbHorse.horses.containsKey(hid))
			return false;
		
		int curRide = this.gameMapContext.getCurMapContext().getCurRideHorse();
		boolean change = curRide > 0 && curRide != hid;
		if(change)
			this.roleUnRide();
		
		this.horseData.dbHorse.inuseHorse = hid;
		this.roleProperties.onUpdateCurUseHorse(hid);
		gs.getMapService().syncRoleUpdateCurUseHorse(this.gameMapContext.getCurMapId(), this.id, hid);
		
		if(change)
			this.roleRide();
		return true;
	}

	synchronized boolean upStarHorse(int hid, int star)
	{
		SBean.HorseInfo info = this.horseData.dbHorse.horses.get(hid);
		if (info == null || star <= info.star || star != info.star + 1)
			return false;

		SBean.HorseCFGS horseCfg = GameData.getInstance().getHorseCFGS(hid);
		if (horseCfg == null || horseCfg.pure == 1)
			return false;

		SBean.HorseGrowUpCGFS growCfg = GameData.getHorseGrowUpCGFS(horseCfg, star);
		if (growCfg == null)
			return false;

		if (!this.containsEnoughGameItems(growCfg.costs))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UP_STAR_HORSE);
		tlogEvent.setArg(hid, star);
		this.delGameItems(growCfg.costs, tlogEvent.getGameItemRecords());
		info.star = (byte) star;
		// 升星1级，默认开启第一个先天骑术。
		if (growCfg.bornOpen > 0 && !this.horseData.dbHorse.allHorseSkills.containsKey(horseCfg.bornSkill))
		{
			this.horseData.dbHorse.allHorseSkills.put(horseCfg.bornSkill, 1);
			this.roleProperties.onUpdateHorseSkill(horseCfg.bornSkill, 1);
			gs.getMapService().syncRoleUpdateHorseSkill(this.gameMapContext.getCurMapId(), this.id, horseCfg.bornSkill, 1);
		}

		boolean changeShow = false;
		if (star == horseCfg.growups.size() - 1)
		{
			info.showIDs.add(horseCfg.fullStarShowID);
			info.curShowID = horseCfg.fullStarShowID;
			changeShow = true;
		}

		this.updateHorse(info);
		if (changeShow)
			gs.getMapService().syncRoleChangeHorseShow(this.gameMapContext.getCurMapId(), this.id, hid, info.curShowID);
		if (GameData.getInstance().getRollNoticeCFGS().hourseStarups.contains(star))
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_HOURSE_STARUP, this.name + "|" + hid + "|" + star);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logHorseStarUp(this, hid, star);
		return true;
	}

	private boolean addHorseEnHanceExp(SBean.HorseInfo info, int exp)
	{
		SBean.HorseEnHanceLvlCFGS cfg = GameData.getInstance().getHorseEnHanceLvlCFGS(info.id);
		if (cfg == null || info.enhanceLvl >= cfg.datas.size())
			return false;

		GameData.LevelExp lvlExp = GameData.getInstance().getAddHorseEnHanceLvlExp(info.enhanceLvl, info.enhanceExp, exp, cfg);
		boolean lvlChange = lvlExp.level > info.enhanceLvl;
		if (lvlChange)
		{
			info.enhanceLvl = lvlExp.level;
//			this.updateHorse(info);
		}
		info.enhanceExp = (int) lvlExp.exp;

		return lvlChange;
	}

	public synchronized boolean unLockEnHanceProp(int hid, int index)
	{
		SBean.HorseInfo info = this.horseData.dbHorse.horses.get(hid);
		if (info == null)
			return false;
		SBean.HorseEnHanceLvlCommonCFGS cfg = GameData.getInstance().getHorseEnHanceLvlCommonCFGS(info.enhanceLvl);
		if (cfg == null || index != info.enhanceAttrs.size() + 1 || index > cfg.attrNum)
			return false;

		SBean.DummyGoods cost = GameData.getInstance().getHorseCommonCFGS().unlockCost.get(index - 1);
		if (cost.id != 0 && !this.containsEnoughGameItem(cost.id, cost.count))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UNLOCK_HORSE_PROP);
		tlogEvent.setArg(hid, index);
		if (cost.id != 0)
			this.delGameItem(cost.id, cost.count, tlogEvent.getGameItemRecords());
		info.enhanceAttrs.add(new SBean.Prop(0, 0));
		this.horseData.enhanceAttrs.add(new SBean.Prop(0, 0));

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	synchronized List<SBean.Prop> enhanceHorse(int hid, Set<Integer> locks, int isReplace)
	{
		SBean.HorseInfo info = this.horseData.dbHorse.horses.get(hid);
		if (info == null)
			return null;

		SBean.HorseCFGS horseCfg = GameData.getInstance().getHorseCFGS(hid);
		SBean.HorseEnHanceLvlCommonCFGS lvlCommonCfg = GameData.getInstance().getHorseEnHanceLvlCommonCFGS(info.enhanceLvl);
		if (horseCfg == null || lvlCommonCfg == null || horseCfg.pure == 1)
			return null;

		int lockSize = locks.size();
		if (lockSize > horseCfg.lockCostCounts.size() || lockSize > lvlCommonCfg.maxLockNum)
			return null;

		for (Integer attr : locks)
		{
			if (attr <= 0 || attr > info.enhanceAttrs.size())
				return null;
		}

		if (!this.containsEnoughGameItems(horseCfg.enhanceCosts))
			return null;
		
		int costItem = 0;
		int costNum = 0;
		if (lockSize > 0)
			if (isReplace == 1)
			{
				costItem = horseCfg.lockCostReplaceItem;
				costNum = horseCfg.lockCostReplaceCounts.get(lockSize - 1);
			}
			else
			{
				costItem = horseCfg.lockCostItem;
				costNum = horseCfg.lockCostCounts.get(lockSize - 1);
			}
		
		if (lockSize > 0 && !this.containsEnoughGameItem(costItem, costNum))
			return null;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ENHANCE_HORSE);
		tlogEvent.setArg(hid);
		this.delGameItems(horseCfg.enhanceCosts, tlogEvent.getGameItemRecords());
		if (lockSize > 0)
			this.delGameItem(costItem, costNum, tlogEvent.getGameItemRecords());

		int addExp = horseCfg.enhanceExp;
		if (lockSize > 0)
			addExp += GameData.getTimesCost(horseCfg.lockExps, lockSize);
		this.addHorseEnHanceExp(info, addExp);
		this.createEnHanceAttrs(horseCfg, locks, info.enhanceLvl, info, lvlCommonCfg);
		info.enhanceTimes++;

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		//Attention info.enhanceLvl are setted by addHorseEnHanceExp call,if someone change addHorseEnHanceExp implemention, repaire here same time
		gs.getTLogger().logHorseEnhance(this, hid, info.enhanceLvl);
		return this.horseData.enhanceAttrs;
	}

	private void createEnHanceAttrs(SBean.HorseCFGS horseCfg, Set<Integer> locks, int level, SBean.HorseInfo info, SBean.HorseEnHanceLvlCommonCFGS lvlCommonCfg)
	{
		this.horseData.enhanceAttrs.clear();
		this.horseData.enhanceHorse = horseCfg.id;
		for (int i = 1; i <= info.enhanceAttrs.size(); i++)
		{
			SBean.HorseEnHanceAttrLineCFGS enhanceCfg = GameData.getInstance().getHorseEnHanceAttrLineCFGS(horseCfg.enHanceType, i);
			if (enhanceCfg == null)
			{
				this.horseData.enhanceAttrs.add(info.enhanceAttrs.get(i - 1).kdClone());
				continue;
			}
			
			if (locks.contains(i))
			{
				SBean.Prop prop = info.enhanceAttrs.get(i - 1).kdClone();
				if (lvlCommonCfg.canLockGrow == 1)
				{
					SBean.HorseEnHanceAttrCFGS attrCFGS = GameData.getInstance().getHorseEnHanceAttrCFGSByAttrId(enhanceCfg, prop.id);
					if (attrCFGS != null && prop.value < attrCFGS.maxNum && prop.value >= Math.ceil((attrCFGS.maxNum - attrCFGS.minNum) * 0.8) + attrCFGS.minNum)
					{
						int lockAddArg=GameData.getInstance().getHorseCommonCFGS().lockAddArg;
						int randomInt = GameRandom.getRandom().nextInt(lockAddArg);
						if (randomInt < attrCFGS.maxNum - attrCFGS.minNum)
						{
							prop.value += Math.ceil((attrCFGS.maxNum - attrCFGS.minNum) * 1.0 / lockAddArg);
						}
						if (prop.value > attrCFGS.maxNum)
						{
							prop.value = attrCFGS.maxNum;
						}
					}
				}
				this.horseData.enhanceAttrs.add(prop);
				continue;
			}

			SBean.Prop prop = GameData.getInstance().getHorseEnHanceRandomProp(enhanceCfg);
			if (prop == null)
			{
				this.horseData.enhanceAttrs.add(info.enhanceAttrs.get(i - 1).kdClone());
				continue;
			}

			this.horseData.enhanceAttrs.add(prop);
		}

	}

	synchronized boolean saveEnhanceAttrs()
	{
		if (this.horseData.enhanceHorse <= 0)
			return false;

		SBean.HorseInfo info = this.horseData.dbHorse.horses.get(this.horseData.enhanceHorse);
		if (info == null || info.enhanceAttrs.size() != this.horseData.enhanceAttrs.size())
			return false;

		info.enhanceAttrs = Stream.clone(this.horseData.enhanceAttrs);

		this.updateHorse(info);
		this.horseData.enhanceHorse = 0;
		return true;
	}

	synchronized boolean changeHorseShow(int hid, int showID)
	{
		SBean.HorseCFGS horseCfg = GameData.getInstance().getHorseCFGS(hid);
		if (horseCfg == null)
			return false;

		SBean.HorseInfo info = this.horseData.dbHorse.horses.get(hid);
		if (info == null || info.curShowID == showID)
			return false;

		if (!info.showIDs.contains(showID) && showID != horseCfg.orgShowID)
			return false;

		info.curShowID = showID;
		gs.getMapService().syncRoleChangeHorseShow(this.gameMapContext.getCurMapId(), this.id, hid, showID);
		return true;
	}

	synchronized boolean activateShow(int hid)
	{
		SBean.HorseInfo info = this.horseData.dbHorse.horses.get(hid);
		if (info == null)
			return false;

		SBean.HorseCFGS horseCfg = GameData.getInstance().getHorseCFGS(hid);
		if (horseCfg == null || horseCfg.pure == 1)
			return false;

		if (info.showIDs.contains(horseCfg.buyShowID))
			return false;

		SBean.HorseShowCFGS showCfg = GameData.getInstance().getHorseShowCFGS(horseCfg.buyShowID);
		if (showCfg == null)
			return false;

		if (!this.containsEnoughGameItem(showCfg.cost.id, showCfg.cost.count))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ACTIVATE_SHOW);
		tlogEvent.setArg(hid, showCfg.cost.id, showCfg.cost.count);
		this.delGameItem(showCfg.cost.id, showCfg.cost.count, tlogEvent.getGameItemRecords());
		info.showIDs.add(horseCfg.buyShowID);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	synchronized boolean learnHorseSkill(int skillID)
	{
		if (this.horseData.dbHorse.horses.isEmpty())
			return false;

		if (this.horseData.dbHorse.allHorseSkills.containsKey(skillID))
			return false;
		
		SBean.HorseSkillCFGS skillCfg = GameData.getInstance().getHorseSkillCFGS(skillID);
		if (skillCfg == null)
			return false;

		if (!this.containsEnoughGameItem(skillCfg.learnCost.id, skillCfg.learnCost.count))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_LEARN_HORSE_SKILL);
		tlogEvent.setArg(skillID, skillCfg.learnCost.id, skillCfg.learnCost.count);
		this.delGameItem(skillCfg.learnCost.id, skillCfg.learnCost.count, tlogEvent.getGameItemRecords());
		this.horseData.dbHorse.allHorseSkills.put(skillID, 1); // 初始解锁等级为1（此处将set改为map）
		
		this.roleProperties.onUpdateHorseSkill(skillID, 1);
		gs.getMapService().syncRoleUpdateHorseSkill(this.gameMapContext.getCurMapId(), this.id, skillID, 1);
//		// TODO 主角增加战力
//		SBean.HorseSkillUpdateDataCFGS skillIDCfg = GameData.getInstance().getHorseSkillUpdateCFGS(skillID);
//		int fightPower = skillIDCfg.data.get(0).fightPower;
		
		testChallengeTask(GameData.CHALLENGE_TASK_ID_RIDING_LEVEL, 0);
		
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logHorseSkillLearned(this, horseData.dbHorse.inuseHorse, skillID);
		return true;
	}
	
	synchronized Map<Integer, Integer> syncHorseSkillLevel()
	{
		return new HashMap<>(this.horseData.dbHorse.allHorseSkills);
	}
	
	// 骑术升级
	synchronized boolean upLevelHorseSkill(int skillID)
	{
		if (this.horseData.dbHorse.horses.isEmpty())
			return false;

		if (!this.horseData.dbHorse.allHorseSkills.containsKey(skillID))
			return false;
		int skillLevel = this.horseData.dbHorse.allHorseSkills.get(skillID);
		SBean.HorseSkillUpdateDataCFGS skillCfg = GameData.getInstance().getHorseSkillUpdateCFGS(skillID);
		if (skillCfg == null)
			return false;
		
		if (skillCfg.data.size() <= skillLevel) // 等级满了
			return false;
		SBean.HorseSkillUpdateCFGS itemCfg = skillCfg.data.get(skillLevel);
		
		if (!this.containsEnoughGameItem(itemCfg.consume1.id, itemCfg.consume1.count))
			return false;
		if (!this.containsEnoughGameItem(itemCfg.consume2.id, itemCfg.consume2.count))
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UP_LEVEL_HORSE_SKILL);
		tlogEvent.setArg(skillID, skillLevel);
		this.delGameItem(itemCfg.consume1.id, itemCfg.consume1.count, tlogEvent.getGameItemRecords());
		this.delGameItem(itemCfg.consume2.id, itemCfg.consume2.count, tlogEvent.getGameItemRecords());
		
//		// TODO 增加战力 deltFightPower 即可。
//		int lastFightPower = skillCfg.data.get(skillLevel - 1).fightPower; // skillLevel 初始为1，不会发生数组越界
//		int nextFightPower = skillCfg.data.get(skillLevel).fightPower;
//		int deltFightPower = nextFightPower - lastFightPower;
		
		this.horseData.dbHorse.allHorseSkills.put(skillID, skillLevel + 1);
		this.roleProperties.onUpdateHorseSkill(skillID, skillLevel + 1);
		gs.getMapService().syncRoleUpdateHorseSkill(this.gameMapContext.getCurMapId(), this.id, skillID, skillLevel + 1);
		
		testChallengeTask(GameData.CHALLENGE_TASK_ID_RIDING_LEVEL, 0);
		
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logHorseSkillLevelUp(this, horseData.dbHorse.inuseHorse, skillID, skillLevel + 1);
		return true;
	}

	synchronized boolean setHorseSkill(int hid, int position, int horseSkill)
	{
		SBean.HorseInfo info = this.horseData.dbHorse.horses.get(hid);
		if (info == null)
			return false;

		SBean.HorseCFGS horseCfg = GameData.getInstance().getHorseCFGS(hid);
		if (horseCfg == null || horseCfg.pure == 1)
			return false;

		SBean.HorseGrowUpCGFS growCFg = GameData.getHorseGrowUpCGFS(horseCfg, info.star);
		if (growCFg == null || position <= 0 || position > growCFg.skillCount)
			return false;

		Integer oldSKillID = info.curHorseSkills.remove(position);
		Integer oldPosition = 0;
		for (Map.Entry<Integer, Integer> e : info.curHorseSkills.entrySet())
		{
			if (e.getValue() == horseSkill)
			{
				oldPosition = e.getKey();
				break;
			}
		}

		if (oldSKillID != null && oldPosition > 0)
			info.curHorseSkills.put(oldPosition, oldSKillID);

		info.curHorseSkills.put(position, horseSkill);
		this.updateHorse(info);
		return true;
	}
	
	public synchronized boolean roleRide()
	{
		if(this.fightState || this.gameMapContext.getCurMapContext().getHp() == 0 || this.alterState.alterID > 0)
			return false;
		
		if(this.gameMapContext.getCurMapContext().getCurRideHorse() > 0 || !this.gameMapContext.getCurMapContext().canRide || this.mulRoleInfo.leader > 0)
			return false;
		
		SBean.HorseCFGS hCfg = GameData.getInstance().getHorseCFGS(this.horseData.dbHorse.inuseHorse);
		if(hCfg == null)
			return false;
		
		this.gameMapContext.getCurMapContext().setCurRideHorse(this.horseData.dbHorse.inuseHorse);
		gs.getMapService().syncRoleCurRideHorse(this.gameMapContext.getCurMapId(), this.id, this.gameMapContext.getCurMapContext().getCurRideHorse());
		if(hCfg.rideCnt > 1)
		{
			this.onSelfJoinMulHorse(this.id);
			for(int pos = 0; pos < hCfg.rideCnt - 1; pos++)
				this.mulRoleInfo.members.add(0);
		}
		return true;
	}
	
	public boolean roleUnRide()
	{
		List<Integer> members = null;
		synchronized(this)
		{
			if(this.gameMapContext.getCurMapContext().getCurRideHorse() == 0)
				return false;
			
			SBean.HorseCFGS hCfg = GameData.getInstance().getHorseCFGS(this.horseData.dbHorse.inuseHorse);
			if(hCfg == null)
				return false;
			
			this.gameMapContext.getCurMapContext().setCurRideHorse(0);
			gs.getMapService().syncRoleCurRideHorse(this.gameMapContext.getCurMapId(), this.id, this.gameMapContext.getCurMapContext().getCurRideHorse());
			
			members = new ArrayList<>(this.mulRoleInfo.members);
			if(hCfg.rideCnt > 1)
			{
				this.mulRoleInfo.leader = 0;
				this.mulRoleInfo.type = 0;
				this.mulRoleInfo.members.clear();
				this.mulHorseInvites.clear();
				this.mulHorseApplys.clear();
//				gs.getMapService().syncRoleMulHorse(this.gameMapContext.getCurMapId(), this.mulHorse.leader, null);
			}
		}
		
		for(int memberID: members)
		{
			Role member = gs.getLoginManager().getOnGameRole(memberID);
			if(member != null)
			{
				synchronized(member)
				{
					member.mulRoleInfo.leader = 0;
					member.mulRoleInfo.type = 0;
				}
			}
		}
		return true;
	}
	
	////////////////////////////////////////////////////////坐骑 end//////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////////套装 ///////////////////////////////////////////////////////////
	public synchronized boolean buySuite(int suiteId)
	{
		SBean.DBSuite suite = this.suites.get(suiteId);
		SBean.SuiteCFGS suiteCFGS = GameData.getInstance().getSuites(suiteId);
		if (suite == null || suiteCFGS == null)
			return false;
		if (suiteCFGS.parts.size() != suite.collect.size() + 1)
			return false;
		int shortOfEquipId = 0;
		for (int partId : suiteCFGS.parts)
		{
			if (!suite.collect.contains(partId))
			{
				shortOfEquipId = partId;
				break;
			}
		}
		if (!this.canUseDiamond(suiteCFGS.buyCost, true))
			return false;
		
		if (shortOfEquipId == 0 || !this.canAddGameItem(shortOfEquipId, 1))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_SUIT);
		tlogEvent.setArg(suiteId, suiteCFGS.buyCost, shortOfEquipId);
		this.useDiamond(suiteCFGS.buyCost, true, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(shortOfEquipId, 1), tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	///////////////////////////////////////////////////////时装  end/////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////龙印/////////////////////////////////////////////////////////
	public boolean sealMake(int makeType) //合成
	{
		SBean.SealOpenCFGS openCfg = GameData.getInstance().getSealBaseCFGS().open;
		if (this.level < openCfg.lvlReq || this.roleProperties.getRoleFightPower() < openCfg.powerReq || this.transformLevel < openCfg.transformReq || this.sealData.grade > 0)
			return false;

		if (makeType == GameData.SEAL_MAKE_TYPE_NORMAL)
			return sealNormalMake();
		else if (makeType == GameData.SEAL_MAKE_TYPE_DIAMOND)
			return sealDiamondMake();

		return false;
	}

	private void updateSealGrade()
	{
		this.roleProperties.onUpdateSealGrade(this.sealData.grade);
		gs.getMapService().syncRoleUpdateSealGrade(this.id, this.gameMapContext.getCurMapId(), this.sealData.grade);
	}

	public synchronized boolean sealNormalMake()
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SEAL_NORMAL_MAKE);
		if (!this.containsEnoughGameItems(GameData.getInstance().getSealBaseCFGS().normalMake))
			return false;

		this.delGameItems(GameData.getInstance().getSealBaseCFGS().normalMake, tlogEvent.getGameItemRecords());
		this.sealData.grade = 1;
		this.updateSealGrade();
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean sealDiamondMake()
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SEAL_DIAMOND_MAKE);
		if (!this.canUseDiamond(GameData.getInstance().getSealBaseCFGS().diamondMake, false))
			return false;

		tlogEvent.setArg(GameData.getInstance().getSealBaseCFGS().diamondMake);
		this.useDiamond(GameData.getInstance().getSealBaseCFGS().diamondMake, false, tlogEvent.getGameItemRecords());
		this.sealData.grade = 1;
		this.updateSealGrade();
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	private void updateSealSkills(Map<Integer, Integer> skillProps)
	{
		this.sealData.skills = skillProps;
		this.roleProperties.onUpdateSealSkill(this.sealData.skills);
		gs.getMapService().syncRoleUpdateSealSkills(this.id, this.gameMapContext.getCurMapId(), this.sealData.skills);
	}

	public synchronized boolean sealUpGrade()
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SEAL_UPGRADE);
		if (this.sealData.grade == 0 || this.sealData.grade >= GameData.getInstance().getSealMaxGrade())
			return false;

		SBean.SealGradeCFGS gradeCfg = GameData.getInstance().getSealGradeCFGS(this.sealData.grade + 1);
		if (gradeCfg == null)
			return false;

		if (!this.containsEnoughGameItems(gradeCfg.cost))
			return false;

		tlogEvent.setArg(this.sealData.grade);
		this.delGameItems(gradeCfg.cost, tlogEvent.getGameItemRecords());
		this.sealData.grade++;
		this.updateSealGrade();
		if (this.sealData.grade == GameData.getInstance().getSealBaseCFGS().skillOpenReq)
		{
			Map<Integer, Integer> skillProps = sealEnhance(true);
			this.updateSealSkills(skillProps);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.seal_enhance_res(skillProps));
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized Map<Integer, Integer> sealEnhance(boolean free)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SEAL_ENHANCE);
		tlogEvent.setArg(this.sealData.grade, this.sealData.enhanceCount);
		Map<Integer, Integer> skillProps = GameData.emptyMap();
		if (!free)
		{
			if (this.sealData.grade < GameData.getInstance().getSealBaseCFGS().skillOpenReq)
				return null;

			if (!this.containsEnoughGameItems(GameData.getInstance().getSealBaseCFGS().enhanceCost))
				return null;

			this.delGameItems(GameData.getInstance().getSealBaseCFGS().enhanceCost, tlogEvent.getGameItemRecords());
		}

		int enhanceCount = this.sealData.enhanceCount;
		this.sealData.enhanceCount++;
		List<SBean.SealEnhanceCFGS> enhances = GameData.getInstance().getSealEnhanceCFGSs(this.classType, this.BWType, enhanceCount);
		if (!enhances.isEmpty())
			skillProps = GameData.getInstance().getSealEnhanceSkillProp(enhances, enhanceCount);
		if (free)
		{
			this.updateSealSkills(skillProps);
		}
		else
		{
			this.sealData.tempSkills = skillProps;
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return skillProps;
	}
	
	public synchronized int saveSealEnhance(int isSave)
	{
		if (this.sealData.tempSkills.isEmpty())
			return GameData.PROTOCOL_OP_FAILED;
		if (isSave == 1)
			this.updateSealSkills(new HashMap<>(this.sealData.tempSkills));
		this.sealData.tempSkills.clear();
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	/////////////////////////////////////////////////////龙印  end///////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////历练系统///////////////////////////////////////////////////////////
	public class RoleExpCoin
	{
		SBean.DBExpCoinData expCoinData;
		SBean.DBRareBook rarebookData;
		SBean.DBGrasp graspData;
		SBean.DBDMGTransfer dmgTransfer;

		RoleExpCoin()
		{
		}

		RoleExpCoin initData(SBean.DBExpCoinData expCoinData, SBean.DBRareBook rarebookData, SBean.DBGrasp graspData, SBean.DBDMGTransfer dmgTransfer)
		{
			this.expCoinData = expCoinData;
			this.rarebookData = rarebookData;
			this.graspData = graspData;
			this.dmgTransfer = dmgTransfer;
			return this;
		}

		synchronized void doRefresh()
		{
			this.expCoinData.dayTakeTimes = 0;
			this.graspData.dayGraspTimes = 0;
			this.graspData.dayGraspRids.clear();
			this.graspData.dayFortune = (byte) GameData.getInstance().getGraspDayFortune();
		}

		//历练币
		public int changetoExpCoin(long exp)
		{
			SBean.ExpCoinBaseCFGS cfg = GameData.getInstance().getExpCoinBaseCFGS();
			if (Role.this.level < cfg.lvlReq)
				return 0;

			int rate = cfg.rate + Role.this.sectAuraExpCoinRateRaise;
			if (rate <= 0)
				rate = 1;

			if (this.expCoinData.curExpCoin >= cfg.volume)
			{
				this.expCoinData.outExp = (int) ((this.expCoinData.outExp + exp) > rate ? rate : (this.expCoinData.outExp + exp));
				gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.role_add_expcoin(0, 0));
				return 0;
			}

			exp += this.expCoinData.outExp;
			int value = (int) (exp / rate);
			this.expCoinData.outExp = (int) (exp % rate);
			return value;
		}

		public int addExpCoin(int value, TLogger.GameItemRecords records)
		{
			if (this.expCoinData.curExpCoin + value > GameData.getInstance().getExpCoinBaseCFGS().volume)
				value = GameData.getInstance().getExpCoinBaseCFGS().volume - this.expCoinData.curExpCoin;

			this.expCoinData.curExpCoin += value;
			records.addProduce(GameData.COMMON_ITEM_ID_EXPCOIN, value, this.expCoinData.curExpCoin);
			return value;
		}

		public boolean canAddExpCoin()
		{
			return this.expCoinData.curExpCoin < GameData.getInstance().getExpCoinBaseCFGS().volume;
		}

		public boolean canUseExpCoin(int value)
		{
			return this.expCoinData.curExpCoin >= value;
		}

		public int useExpCoin(int value, TLogger.GameItemRecords records)
		{
			int use = this.expCoinData.curExpCoin >= value ? value : this.expCoinData.curExpCoin;
			this.expCoinData.curExpCoin -= use;
			records.addConsume(GameData.COMMON_ITEM_ID_EXPCOIN, use, this.expCoinData.curExpCoin);
			return use;
		}

		//藏书
		public void addRareBooks(Map<Integer, Integer> books, TLogger.GameItemRecords records)
		{
			for (Map.Entry<Integer, Integer> e : books.entrySet())
				this.addRareBook(e.getKey(), e.getValue(), records);
		}

		public int addRareBook(int id, int count, TLogger.GameItemRecords records)
		{
			this.rarebookData.bag.compute(id, (k, v) -> v == null ? count : v + count);
			return count;
		}

		public boolean canUseRareBooks(Map<Integer, Integer> books)
		{
			for (Map.Entry<Integer, Integer> e : books.entrySet())
			{
				if (!canUseRareBook(e.getKey(), e.getValue()))
					return false;
			}

			return true;
		}

		boolean canUseRareBook(int id, int count)
		{
			if (id > 0)
				return this.rarebookData.bag.getOrDefault(id, 0) + this.rarebookData.bag.getOrDefault(-id, 0) >= count;
			else
				return this.rarebookData.bag.getOrDefault(id, 0) >= count;
		}

		public void useRareBooks(Map<Integer, Integer> books, TLogger.GameItemRecords records)
		{
			for (Map.Entry<Integer, Integer> e : books.entrySet())
				this.useRareBook(e.getKey(), e.getValue(), records);
		}

		public int useRareBook(int id, int count, TLogger.GameItemRecords records)
		{
			int rDelCount = 0;
			int fDelCount = 0;
			if (id > 0)
			{
				rDelCount = this.delRareBook(id, count);
				fDelCount = count - rDelCount;
				fDelCount = this.delRareBook(-id, fDelCount);
			}
			else
			{
				fDelCount = delRareBook(id, count);
			}
			return rDelCount + fDelCount;
		}

		public int delRareBook(int id, int count)
		{
			if (count <= 0)
				return 0;

			int total = this.rarebookData.bag.getOrDefault(id, 0);
			int use = total >= count ? count : total;

			total -= use;
			if (total > 0)
				this.rarebookData.bag.put(id, total);
			else
				this.rarebookData.bag.remove(id);

			return use;
		}

		//参悟
		synchronized Map<Integer, Integer> getGrasps()
		{
			return this.graspData.grasps.entrySet().stream().collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().lvl));
		}

		int addGraspExp(int graspID, int exp)
		{
			SBean.GraspInfo info = this.graspData.grasps.get(graspID);
			if (info == null)
				return 0;

			SBean.GraspGroupCFGS gCfg = GameData.getInstance().getGraspGroupCFGS(graspID);
			if (gCfg == null || info.lvl >= gCfg.grasps.size())
				return 0;

			GameData.LevelExp lvlExp = GameData.getInstance().getAddGraspLvlExp(info.lvl, info.exp, exp, gCfg);
			int lvlChange = lvlExp.level - info.lvl;
			if (lvlChange > 0)
			{
				info.lvl = lvlExp.level;
				Role.this.updateGraspInfo(graspID, info.lvl);
			}
			info.exp = (int) lvlExp.exp;
			this.graspData.grasps.put(graspID, info);
			return lvlChange;
		}
		
		boolean isDMGTransferOpen()
		{
			return Role.this.level >= GameData.getInstance().getExpCoinBaseCFGS().dmgTransfer.lvlReq;
		}
		
		boolean buyDMGTransfer(boolean discount)
		{
			if(!isDMGTransferOpen())
				return false;
			
			SBean.DMGTransferBuyCFGS buyCfg = GameData.getInstance().getDMGTransferBuyCFGS(dmgTransfer.buyTimes + 1);
			if(buyCfg == null)
				return false;
			
			int gainPoint = discount ? buyCfg.discountGain : buyCfg.normalGain;
			if(gainPoint == 0 || gainPoint + dmgTransfer.totalPoints > GameData.getInstance().getExpCoinBaseCFGS().dmgTransfer.pointLimit)
				return false;

			if(!Role.this.containsEnoughGameItems(discount ? buyCfg.discountCost : buyCfg.normalCost))
				return false;
			
			dmgTransfer.totalPoints += gainPoint;
			dmgTransfer.buyTimes++;
			
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRANSFER_POINT_BUY);
			tlogEvent.setArg(dmgTransfer.buyTimes, gainPoint);
			Role.this.delGameItems(discount ? buyCfg.discountCost : buyCfg.normalCost, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			return true;
		}
		
		boolean lvlUpDMGTransfer(int transferID)
		{
			if(!isDMGTransferOpen())
				return false;
			
			if(dmgTransfer.usePoints >= dmgTransfer.totalPoints)
				return false;
			
			int curLvl = dmgTransfer.levels.getOrDefault(transferID, 0);
			SBean.DMGTransferCFGS cfg = GameData.getInstance().getDMGTransferCFGS(transferID, curLvl + 1);
			if(cfg == null)
				return false;
			
			if(dmgTransfer.usePoints + cfg.pointsReq > dmgTransfer.totalPoints)
				return false;
			
			if(!Role.this.containsEnoughGameItems(cfg.costItems))
				return false;
			
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_LVLUP_TRANSFER_POINT);
			tlogEvent.setArg(transferID, curLvl + 1);
			Role.this.delGameItems(cfg.costItems, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			dmgTransfer.levels.put(transferID, curLvl + 1);
			dmgTransfer.usePoints += cfg.pointsReq;
			Role.this.roleProperties.onDMGTransferPointLvlsUpdate(new HashMap<>(dmgTransfer.levels));
			gs.getMapService().syncRoleDMGTransferPointLvlsUpdate(Role.this.gameMapContext.getCurMapId(), Role.this.id, new HashMap<>(dmgTransfer.levels));
			return true;
		}
		
		boolean resetDMGTransfer()
		{
			if(dmgTransfer.levels.isEmpty())
				return false;
			
			final List<SBean.DummyGoods> cost = GameData.getInstance().getExpCoinBaseCFGS().dmgTransfer.cost;
			if(!Role.this.containsEnoughGameItems(cost))
				return false;
			
			List<SBean.DummyGoods> returnItems = new ArrayList<>();
			for(Map.Entry<Integer, Integer> e: dmgTransfer.levels.entrySet())
			{
				SBean.DMGTransferCFGS cfg = GameData.getInstance().getDMGTransferCFGS(e.getKey(), e.getValue());
				if(cfg == null)
					continue;

				returnItems.addAll(cfg.returnItems);
			}
			
			if(!Role.this.canAddGameItems(returnItems))
				return false;
			
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TRANSFER_POINT_RESET);
			Role.this.syncAddGameItems(GameData.getInstance().toGameItems(returnItems), tlogEvent);
			Role.this.delGameItems(cost, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
			
			dmgTransfer.levels.clear();
			dmgTransfer.usePoints = 0;
			Role.this.roleProperties.onDMGTransferPointLvlsUpdate(new HashMap<>());
			gs.getMapService().syncRoleDMGTransferPointLvlsUpdate(Role.this.gameMapContext.getCurMapId(), Role.this.id, new HashMap<>());
			return true;
		}
	}

	private SBean.DBGrasp createGraspData()
	{
		SBean.DBGrasp dbGrasp = new SBean.DBGrasp((byte) GameData.getInstance().getGraspDayFortune(), (byte) 0, 0, new HashSet<>(), new HashMap<>());
		for (int gid : GameData.getInstance().getAllGraspGroups())
			dbGrasp.grasps.put(gid, new SBean.GraspInfo(1, 0));

		return dbGrasp;
	}
	
	private SBean.DBDMGTransfer createDMGTransfer()
	{
		return new SBean.DBDMGTransfer(new HashMap<>(), 0, GameData.getInstance().getExpCoinBaseCFGS().dmgTransfer.initPoint, 0);
	}
	
	//历练
	void dayRefreshExpCoinSys()
	{
		this.roleExpCoin.doRefresh();
	}

	public synchronized int expcoinSync()
	{
		if (this.level < GameData.getInstance().getExpCoinBaseCFGS().lvlReq)
			return -1;

		return this.roleExpCoin.expCoinData.dayTakeTimes;
	}

	public synchronized boolean extractExpCoin()
	{
		if (this.roleExpCoin.expCoinData.dayTakeTimes >= GameData.getInstance().getExpCoinBaseCFGS().dayTakeTimes)
			return false;

		SBean.ExpCoinExtractCFGS extractCfg = GameData.getInstance().getExpCoinBaseCFGS().extract;
		SBean.ItemCFGS itemCfg = GameData.getInstance().getItemCFG(extractCfg.output.id);
		if (itemCfg == null || !this.canUseExpCoin(itemCfg.arg1))
			return false;

		if (!this.containsEnoughGameItem(extractCfg.input.id, extractCfg.input.count))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EXTRACT_EXPCOIN);
		tlogEvent.setArg(extractCfg.input.id, extractCfg.input.count);
		this.useExpCoin(itemCfg.arg1, tlogEvent.getGameItemRecords());
		this.delGameItem(extractCfg.input.id, extractCfg.input.count, tlogEvent.getGameItemRecords());
		SBean.GameItem gi = GameData.getInstance().toGameItem(extractCfg.output.id, extractCfg.output.count);
		this.syncAddGameItem(gi, tlogEvent);
		this.roleExpCoin.expCoinData.dayTakeTimes++;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	//藏书
	public synchronized Map<Integer, Integer> rareBookSync()
	{
		if (this.level < GameData.getInstance().getExpCoinBaseCFGS().lvlReq)
			return null;

		return this.roleExpCoin.rarebookData.bag;
	}

	public synchronized boolean rareBookPush(Map<Integer, Integer> items)
	{
		if (items.isEmpty())
			return false;

		List<SBean.DummyGoods> dgs = GameData.toDummGoods(items);
		if (!this.containsEnoughGameItems(dgs))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_RARE_BOOK_PUSH);
		this.delGameItems(dgs, tlogEvent.getGameItemRecords());
		this.roleExpCoin.addRareBooks(items, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean rareBookPop(Map<Integer, Integer> books)
	{
		if (books.isEmpty())
			return false;

		if (!this.roleExpCoin.canUseRareBooks(books))
			return false;

		List<SBean.GameItem> gis = GameData.getInstance().toGameItems(books);
		if (!this.canAddGameItems(gis))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_RARE_BOOK_POP);
		this.roleExpCoin.useRareBooks(books, tlogEvent.getGameItemRecords());
		this.syncAddGameItems(gis, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean rareBookUnLock(int bookID)
	{
		int lvl = this.roleExpCoin.rarebookData.books.getOrDefault(bookID, 0);
		if (lvl != 0)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_RARE_BOOK_UNLOCK);
		if (rareBookLvlUpImpl(bookID, lvl + 1, tlogEvent.getGameItemRecords()))
		{
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			gs.getTLogger().logRareBookUnlock(this, bookID, lvl + 1);
			
			testChallengeTask(GameData.CHALLENGE_TASK_ID_RAREBOOK, 0);
			return true;
		}

		return false;
	}

	public synchronized boolean rareBookLvlUp(int bookID)
	{
		int lvl = this.roleExpCoin.rarebookData.books.getOrDefault(bookID, 0);
		if (lvl == 0)
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_RARE_BOOK_UPLVL);
		if (rareBookLvlUpImpl(bookID, lvl + 1, tlogEvent.getGameItemRecords()))
		{
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			gs.getTLogger().logRareBookLevelUp(this, bookID, lvl + 1);
			return true;
		}

		return false;
	}

	private boolean rareBookLvlUpImpl(int bookID, int lvl, TLogger.GameItemRecords records)
	{
		SBean.RareBookCFGS rbCfg = GameData.getInstance().getRareBookCFGS(bookID, lvl);
		if (rbCfg == null)
			return false;

		int addition = rbCfg.classType == this.classType ? 1 : 2;
		final List<SBean.DummyGoods> itemCosts = rbCfg.classType == this.classType ? rbCfg.itemCost : rbCfg.itemDoubleCost;
		if (!this.roleExpCoin.canUseRareBook(rbCfg.rareBookID, rbCfg.rareBookCount * addition) || !this.roleExpCoin.canUseExpCoin(rbCfg.expCoinCost * addition))
			return false;

		if(!itemCosts.isEmpty() && !this.containsEnoughGameItems(itemCosts))
			return false;

		this.roleExpCoin.useRareBook(rbCfg.rareBookID, rbCfg.rareBookCount * addition, records);
		this.roleExpCoin.useExpCoin(rbCfg.expCoinCost * addition, records);
		if (!itemCosts.isEmpty())
			this.delGameItems(itemCosts, records);
		
		this.roleExpCoin.rarebookData.books.put(bookID, lvl);
		this.roleProperties.onUpdateRareBook(bookID, lvl);
		gs.getMapService().syncRoleUpdateRareBook(this.gameMapContext.getCurMapId(), this.id, bookID, lvl);
		return true;
	}

	//参悟
	public void graspSync()
	{
		gs.getSectManager().graspGetSectMembers(this);
	}

	public synchronized void graspSync(int errorCode, List<SBean.RoleOverview> members)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.grasp_sync_res(errorCode, this.roleExpCoin.graspData.dayFortune, this.roleExpCoin.graspData.dayGraspTimes, this.roleExpCoin.graspData.lastGraspTime, members));
	}

	public void graspImpl(int graspID, int memberID)
	{
		gs.getSectManager().graspWithSectMember(graspID, memberID, this);
	}

	void updateGraspInfo(int graspID, int lvl)
	{
		this.roleProperties.onUpdateGrasp(graspID, lvl);
		gs.getMapService().syncRoleUpdateGrasp(this.gameMapContext.getCurMapId(), this.id, graspID, lvl);
	}

	public synchronized boolean graspReset()
	{
		SBean.GraspBaseCFGS gbCfg = GameData.getInstance().getExpCoinBaseCFGS().graspBase;
		if (this.roleExpCoin.graspData.dayGraspTimes >= gbCfg.dayGraspTimes)
			return false;

		if (!this.canUseDiamond(gbCfg.resetDiamond, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GRASP_RESET);
		tlogEvent.setArg(gbCfg.resetDiamond);
		this.useDiamond(gbCfg.resetDiamond, false, tlogEvent.getGameItemRecords());
		this.roleExpCoin.graspData.lastGraspTime = 0;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean buyDMGTransfer(boolean discount)
	{
		return this.roleExpCoin.buyDMGTransfer(discount);
	}
	
	public synchronized boolean lvlUpDMGTransfer(int transferID)
	{
		return this.roleExpCoin.lvlUpDMGTransfer(transferID);
	}
	
	public synchronized boolean resetDMGTransfer()
	{
		return this.roleExpCoin.resetDMGTransfer();
	}
	/////////////////////////////////////////////////////历练系统 end/////////////////////////////////////////////////////////

	/////////////////////////////////////////////////////称号系统/////////////////////////////////////////////////////////////
	public static SBean.DBRoleTitle initRoleTitle(SBean.DBRoleTitle dbRoleTitle)
	{
		int now = GameTime.getTime();
		Map<Integer, Integer> titles = new HashMap<>();
		for (Map.Entry<Integer, Integer> e : dbRoleTitle.titles.entrySet())
		{
			int endTime = e.getValue();
			if (endTime == -1 || now <= endTime)
				titles.put(e.getKey(), endTime);
		}
		
		List<SBean.DBTitleSlot> slots = new ArrayList<>(GameData.INIT_TITLESLOT_SIZE);
		for (SBean.DBTitleSlot slot : dbRoleTitle.curTimedTitles)
		{
		    if (titles.containsKey(slot.titleId))
		        slots.add(slot);
		}
		
		if (slots.size() > dbRoleTitle.slotsize)
		    slots = new ArrayList<>(slots.subList(0, dbRoleTitle.slotsize));

		return new SBean.DBRoleTitle(titles, dbRoleTitle.curPermanent, slots, dbRoleTitle.slotsize);
	}

	private void tryUpdateRoleTitles(int timeTick)
	{
		Iterator<Map.Entry<Integer, Integer>> it = this.roleTitles.titles.entrySet().iterator();
		while (it.hasNext())
		{
			Map.Entry<Integer, Integer> e = it.next();
			int endTime = e.getValue();
			if (endTime != -1 && timeTick > endTime)
			{
				this.updateRoleTitle(e.getKey(), 0);
				it.remove();
			}
		}
	}

	private SBean.DBRoleTitle createNewRoleTitle()
	{
		SBean.DBRoleTitle dbTitle =  new SBean.DBRoleTitle(new HashMap<>(), 0, new ArrayList<>(GameData.MAX_TITLESLOT_SIZE), GameData.INIT_TITLESLOT_SIZE);
		SBean.TitleCFGS titleCfg = GameData.getInstance().getTitleCFGS(GameData.getInstance().getCommonCFG().title.initTitle);
		if(titleCfg == null)
			return dbTitle;
		
		dbTitle.titles.put(titleCfg.id, titleCfg.loopTime > 0 ? titleCfg.loopTime + GameTime.getTime() : -1);
		if(titleCfg.loopTime > 0)
		{
		    dbTitle.curTimedTitles.add(new SBean.DBTitleSlot(titleCfg.type, titleCfg.id));
		}
		else
		{
			dbTitle.curPermanent = titleCfg.id;
		}
		
		return dbTitle;
	}
	
	boolean addRoleTitle(int titleID)
	{
		SBean.TitleCFGS titleCfg = GameData.getInstance().getTitleCFGS(titleID);
		if (titleCfg == null)
			return false;

		this.updateRoleTitle(titleID, titleCfg.loopTime > 0 ? titleCfg.loopTime + GameTime.getTime() : -1);
		return true;
	}

	//覆盖旧魅力称号时用
	private void delRoleTitle(int titleID)
	{
		if (this.roleTitles.titles.remove(titleID) != null)
		{
			this.roleProperties.onUpdateTitle(titleID, false);
			gs.getMapService().syncRoleUpdateTitle(this.gameMapContext.getCurMapId(), this.id, titleID, false);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_title_update(titleID, 0));

			if (this.roleTitles.curPermanent == titleID)
				this.setCurPermanentTitle(0);
		}
	}

	private void updateRoleTitle(int titleID, int endTime)
	{
		boolean notifyMap = true;
		if (endTime == -1)
		{
			if (this.roleTitles.titles.containsKey(titleID))
				 return;

			this.roleTitles.titles.put(titleID, endTime);
		}
		else if (endTime > 0)
		{
			if (this.roleTitles.titles.put(titleID, endTime) != null)
				notifyMap = false;
		}
		else if (endTime == 0) //时效称号到期
		{
			this.setCurTimedTitle(titleID, 0);
		}

		if (notifyMap)
		{
			this.roleProperties.onUpdateTitle(titleID, endTime != 0);
			gs.getMapService().syncRoleUpdateTitle(this.gameMapContext.getCurMapId(), this.id, titleID, endTime != 0);
		}

		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_title_update(titleID, endTime));
	}

	public synchronized boolean setCurPermanentTitle(int titleID)
	{
	    // remove case
	    if (titleID==0)
	    {
	        
	        //以下一个语句用来消除策划表同类型的永久和限时称号在外网已造成的错误状态
	        this.roleTitles.titles.forEach( (title, time) -> {
	            if (time < 0)
	            {
	                final int probOld = title;
	                this.roleTitles.curTimedTitles.removeIf(x -> x.titleId == probOld);
	            }
	        });
	        
	        this.roleTitles.curTimedTitles.removeIf(x -> x.titleId == roleTitles.curPermanent);
	        roleTitles.curPermanent = titleID;
	    } 
	    else   // add or replace case 
	    {   
	        if (!this.roleTitles.titles.containsKey(titleID) || this.roleTitles.titles.get(titleID).intValue() >= 0)
		        return false;
	        
			SBean.TitleCFGS cfg = GameData.getInstance().getTitleCFGS(titleID);
			if (cfg==null)
			    return false;
			
			//以下几行为策划配置了永久和非永久称号为同个类型的补救代码, 顺便清理老永久称号及其同类型限时称号
			final SBean.TitleCFGS curCfg = GameData.getInstance().getTitleCFGS(roleTitles.curPermanent);
			if (curCfg != null)
			{
			    roleTitles.curTimedTitles.removeIf( y -> y.titletype == curCfg.type);
			    roleTitles.curPermanent = 0;
			}
			
			roleTitles.curTimedTitles.removeIf( z -> z.titletype == cfg.type);
			
			if (roleTitles.curTimedTitles.size()>=roleTitles.slotsize)      // title slot full
			{
			    return false;
			}
			
			roleTitles.curTimedTitles.add(0, new SBean.DBTitleSlot(cfg.type, titleID));
			roleTitles.curPermanent = titleID;
	    }
	    
	    
		gs.getMapService().syncRoleUpdateCurTitle(this.gameMapContext.getCurMapId(), this.id, titleID, 0);
		return true;
	}
	
    public synchronized boolean unlockTitleSlot()
    {
        if (this.roleTitles.slotsize >= GameData.MAX_TITLESLOT_SIZE)
            return false;
        
        SBean.CommonTitleCFGS cfg = GameData.getInstance().getCommonCFG().title;
        if (cfg==null)
            return false;
        
        int cost = cfg.unlockCfgs.get(this.roleTitles.slotsize - 1);
        
        TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TITLE_UNLOCKSLOT);
        if (!containsEnoughGameItem(GameData.COMMON_ITEM_ID_DIAMOND, cost))
        {
            return false;
        }
        
		this.useDiamond(cost, true, tlogEvent.getGameItemRecords());
        this.roleTitles.slotsize += 1;
        gs.getTLogger().logRoleEventFlow(this, tlogEvent);
        return true;
    }

	public synchronized boolean setCurTimedTitle(int titleID, int state)
	{
		SBean.TitleCFGS cfg = GameData.getInstance().getTitleCFGS(titleID);
		if (cfg == null)
			return false;

		if (state > 0) //装备
		{
			if (!this.roleTitles.titles.containsKey(titleID))
				return false;

		    // have equiped same one
			if(this.roleTitles.curTimedTitles.stream().filter(x -> x.titleId == titleID).count()>0)
				return false;
			
			roleTitles.curTimedTitles.removeIf(y->y.titletype==cfg.type);
			
			if (this.roleTitles.curTimedTitles.size() >= GameData.getInstance().getCommonCFG().title.timedTitleCnt 
			        || this.roleTitles.curTimedTitles.size() >= this.roleTitles.slotsize)
				return false;

			this.roleTitles.curTimedTitles.add(0, new SBean.DBTitleSlot(cfg.type, cfg.id));
		}
		else
		//卸载
		{
			this.roleTitles.curTimedTitles.removeIf(x -> x.titleId == titleID);
		}
		
		gs.getMapService().syncRoleUpdateCurTitle(this.gameMapContext.getCurMapId(), this.id, state > 0 ? titleID : -titleID, cfg.type);
		return true;
	}

	/////////////////////////////////////////////////////称号系统 end/////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////指引/////////////////////////

	public void setLeadInfo(int id)
	{
		this.leadInfo.add(id);
		gs.getTLogger().logGuideDone(this, id);
	}

	public void setLeadPlot(int id, int count)
	{
		this.leadPlot.put(id, count);
	}

	////////////////////////////////////////////////////////////指引/////////////////////////

	//////////////////////////////////封测活动////////////////////////////////////////////
	public SBean.DBUserSurvey getUserSurvey()
	{
		return share.getUserSurveyUnlock();
	}

	public boolean noteUserSurvey(Role role, int seq, Set<Integer> answer)
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_USER_SURVEY);
		boolean flag = share.noteUserSurvey(role, seq, answer, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}

	public boolean takeSurveyReward()
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_USER_SURVEY);
		boolean flag = share.takeSurveyReward(this, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}

	public Set<Integer> getBetaLoginGifts()
	{
		return share.getBetaLoginGifts();
	}

	public boolean takeBetaLoginGifts()
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_LOGIN_GIFT);
		boolean flag = share.takeBetaLoginGifts(this, GameData.getOffsetDaysToNow(gs.getOpenTime()) + 1, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}

	public Set<Integer> getBetaLvlupGift()
	{
		return share.getBetaLvlupGift();
	}

	public boolean takeBetaLvlupGift(int seq)
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		if (this.level < seq)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_LEVEL_UP_GIFT, seq);
		boolean flag = share.takeBetaLvlupGift(this, seq, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}

	public SBean.DBUserData getUserInfo()
	{
		return share.getUserInfo();
	}

	public boolean modifyUserInfo(SBean.userdata_modify_req packet)
	{
		return share.modifyUserInfo(packet);
	}

	public boolean takeUserInfoGift()
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_USER_INFO);
		boolean flag = share.takeUserInfoGift(this, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}

	public Set<Integer> getLastBetaGift()
	{
		return share.getLastBetaGift();
	}

	public boolean takeLastBetaGift(int seq)
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_LAST_BETA_GIFT);
		boolean flag = share.takeLastBetaGift(this, GameTime.getDay() - GameTime.getDay(gs.getOpenTime()) + 1, seq, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}

	public Set<Integer> getOnTimeLoginGifts()
	{
		return share.getOnTimeLoginGifts();
	}

	public boolean takeOnTimeLoginGifts()
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_ON_TIME_LOGIN_GIFT);
		boolean flag = share.takeOnTimeLoginGifts(this, GameData.getOffsetDaysToNow(gs.getOpenTime()) + 1, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}
	
	public Set<Integer> getStrengthenGifts()
	{
		return share.getStrengthenGifts();
	}

	public boolean takeStrengthenGifts(int strengthenNum)
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		int curstrengthen = 0;
		for(SBean.DBEquipPart part : this.wearParts)
		{
			curstrengthen += part.eqGrowLvl;
		}
		if(curstrengthen < strengthenNum)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_STRENG_THEN_GIFT);
		boolean flag = share.takeStrengthenGifts(this, strengthenNum, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}
	
	public byte getOfficialResearchGifts()
	{
		return share.getOfficialResearchGift();
	}

	public boolean takeOfficialResearchGifts()
	{
		if (this.level < GameData.getInstance().getBetaActivity().lvlNeed)
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BETA_ACTIVITY_REWARD);
		tlogEvent.setArg(GameData.BETA_ACTIVITY_TYPE_OFFICIAL_RESEARCH);
		boolean flag = share.takeOfficialResearchGifts(this, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return flag;
	}

	//////////////////////////////////////////封测活动////////////////////////////////

	
	
	/////////////////////////////支线任务///////////////////////////////
	public boolean testCanAccessBTask(SBean.BranchTaskDataCFGS taskCfg)
	{
		if(taskCfg.startNpc > 0 && !GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapContext().getMapLocation(), taskCfg.startNpc, GameData.getInstance().getCommonCFG().task.npcRadius))
			return false;
		
		if(this.alterState.alterID > 0 && GameData.getInstance().isTrigTaskAlter(taskCfg.senceTrigIDs))
			return false;
		
		if(taskCfg.accCondBWType > 0 && taskCfg.accCondBWType != this.BWType)
			return false;
		
		switch(taskCfg.accCondType)
		{
			case GameData.BRANCH_TASK_ACCESS_TYPE_LEVEL://level
				return this.level >= taskCfg.accCondParam;
			case GameData.BRANCH_TASK_ACCESS_TYPE_POWER://power
				return this.roleProperties.getRoleFightPower() >= taskCfg.accCondParam;
			case GameData.BRANCH_TASK_ACCESS_TYPE_MAIN_TASK://finish main task of id;
				return GameData.getInstance().testMainTaskFinished(taskCfg.accCondParam, this.mainTask.id, this.BWType);
			case GameData.BRANCH_TASK_ACCESS_TYPE_BRANCH_GROUP://finish branch task group all tasks;
				SBean.DBBranchTask btask = this.branchTask.get(taskCfg.accCondParam);
				return btask != null && btask.id == 0;
			case GameData.BRANCH_TASK_ACCESS_TYPE_CLIENT://special interface
				return true;
			case 0:
				return true;
			case GameData.BRANCH_TASK_ACCESS_TYPE_LOGINDAYS:
				return this.loginDays >= taskCfg.accCondParam;
			default:
				return false;
		}
	}
	
	public synchronized boolean quitBranchTask(int groupId)
	{
		SBean.DBBranchTask btask = this.branchTask.get(groupId);
		if(btask == null || btask.id == 0 || btask.state == 0)
			return false;
		
		final SBean.BranchTaskDataCFGS taskCfg = GameData.getInstance().getBranchTaskCFG(groupId, btask.id);
		if(taskCfg == null || taskCfg.canQuit == 0)
			return false;
		
		btask.value = 0;
		btask.state = 0;
		this.setAlterState(-1);
		this.clearSceneMonster(taskCfg.senceTrigIDs);
		
		gs.getTLogger().logBranchTaskFlow(this, groupId, taskCfg.id, btask.state, TLog.TASKEVENT_CANCLE);
		
		return true;
	}
	
	public synchronized int accessBranchTask(int groupId)
	{
		SBean.DBBranchTask btask = this.branchTask.get(groupId);
		final SBean.BranchTaskDataCFGS taskCfg = GameData.getInstance().getBranchTaskCFG(groupId, btask == null ? 1 : btask.id);
		if(taskCfg == null || !this.testCanAccessBTask(taskCfg))
			return GameData.PROTOCOL_OP_FAILED;
		
		if(btask == null)
		{
			btask = new SBean.DBBranchTask(taskCfg.id, 0, 1, GameTime.getTime());
			this.branchTask.put(groupId, btask);
		}
		else
		{
			if(btask.state == 1)
				return GameData.PROTOCOL_OP_FAILED;
			
			btask.value = 0;
			btask.state = 1;
			btask.receiveTime = GameTime.getTime();
		}
		gs.getTLogger().logBranchTaskFlow(this, groupId, taskCfg.id, btask.state, TLog.TASKEVENT_TAKE);
		
		this.logBranchTask(taskCfg.taskParam.type, 0, 0, 0);
		this.sceneTrig(taskCfg.senceTrigIDs, GameData.SCENE_TRIG_EVENT_TAKE_TASK);
		this.addTaskDrop(taskCfg.taskParam);
		
		return btask.receiveTime;
	}

	public synchronized boolean takeBranchTaskReward(int groupId)
	{
		SBean.DBBranchTask btask = this.branchTask.get(groupId);
		if(btask == null || btask.state != 2)
			return false;
		
		//测试完成状态
		SBean.BranchTaskDataCFGS taskCfg = GameData.getInstance().getBranchTaskCFG(groupId, btask.id);
		if(taskCfg == null)
			return false;
		
		Collection<SBean.DummyGoods> rewardItems = GameData.getClassTypeRewards(taskCfg.reward, this.classType);
		if (!rewardItems.isEmpty() && !this.canAddGameItems(rewardItems))
			return false;
		
		if(taskCfg.endNpc > 0 && !GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapContext().getMapLocation(), taskCfg.endNpc, GameData.getInstance().getCommonCFG().task.npcRadius))
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_BRANCH_TASK_REWARD);
		tlogEvent.setArg(btask.id);
		this.syncAddGameItems(GameData.getInstance().toGameItems(rewardItems), tlogEvent);
		this.syncAddExp(taskCfg.rewardExp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_BRANCH_TASK, 0);
		
		this.clearSceneMonster(taskCfg.senceTrigIDs);
		this.sceneTrig(taskCfg.senceTrigIDs, GameData.SCENE_TRIG_EVENT_TASK_REWARD);
		this.delTaskDrop(taskCfg.taskParam);
		
		btask.id = taskCfg.nextId;
		btask.value = 0;
		btask.state = 0;
		
		gs.getTLogger().logBranchTaskFlow(this, groupId, btask.id, btask.state, TLog.TASKEVENT_START);
		
		SBean.BranchTaskDataCFGS nextCfg = GameData.getInstance().getBranchTaskCFG(groupId, taskCfg.nextId);
		if(nextCfg != null && nextCfg.startNpc <= 0)
			this.accessBranchTask(groupId);
		
		return true;
	}
	/////////////////////////////支线任务///////////////////////////////
	

	////////////////////////////////////////随从成就//////////////////////////////////////////////////////////////////////
	public static Set<Integer> getNewPetAchieves(Map<Integer, SBean.DBPet> activePets)
	{
		Set<Integer> petachives = new TreeSet<Integer>();
		Map<Integer, Map<Integer, Integer>> activitypetdata = new HashMap<>();
		for (int i = GameData.PET_ACHIEVE_START_TYPE; i <= GameData.PET_ACHIEVE_END_TYPE; i++)
			activitypetdata.put(i, new HashMap<>());
		for (int i = GameData.PET_ACHIEVE_START_TYPE; i <= GameData.PET_ACHIEVE_END_TYPE; i++)
		{
			Integer index = i;
			GameData.getInstance().getPetAchieveGroupCFGS(index).achieves.stream().forEach((item) ->
			{
				activitypetdata.get(index).put(item.cond, 0);
			});
		}
		activePets.values().stream().forEach((activepet) ->
		{
			for (int i = GameData.PET_ACHIEVE_START_TYPE; i <= GameData.PET_ACHIEVE_END_TYPE; i++)
			{
				putPetDataToMap(activepet, activitypetdata, i);
			}
		});

		for (int i = GameData.PET_ACHIEVE_START_TYPE; i <= GameData.PET_ACHIEVE_END_TYPE; i++)
		{
			Integer index = i;
			GameData.getInstance().getPetAchieveGroupCFGS(index).achieves.stream().forEach((item) ->
			{
				if (item.petCnt <= activitypetdata.get(index).get(item.cond))
					petachives.add(item.id);
			});
		}

		return petachives;
	}

	private static void putPetDataToMap(final SBean.DBPet activepet, Map<Integer, Map<Integer, Integer>> activitypetdata, int type)
	{
		Map<Integer, Integer> curtypedata = activitypetdata.get(type);
		switch (type)
		{
		case GameData.PET_ACHIEVE_TYPE_LEVEL:
			Integer curLevel = activepet.fightPet.level;
			curtypedata.forEach((level, num) ->
			{
				if (curLevel >= level)
					curtypedata.put(level, ++num);
			});
			break;
		case GameData.PET_ACHIEVE_TYPE_STAR:
			Integer curStar = activepet.fightPet.star;
			curtypedata.forEach((star, num) ->
			{
				if (curStar >= star)
					curtypedata.put(star, ++num);
			});
			break;
		case GameData.PET_ACHIEVE_TYPE_BREAKSKILL:
			curtypedata.forEach((breakthrough, num) ->
			{
				if (activepet.fightPet.breakSkills.values().size() == 4 && activepet.fightPet.breakSkills.values().stream().allMatch(breaklvl -> breaklvl >= breakthrough))
					curtypedata.put(breakthrough, ++num);
			});
			break;
		default:
			break;
		}
	}

	private void UpdatePetAchieve()
	{
		int oldpetachievenum = this.petAchieves == null ? 0 : this.petAchieves.size();
		this.petAchieves = getNewPetAchieves(this.activePets);
		int newpetachievenum = this.petAchieves.size();
		if (oldpetachievenum != newpetachievenum)
		{
			this.roleProperties.onUpdatePetAchieve(this.petAchieves);
			gs.getMapService().syncRoleUpdatePetAchieve(this.gameMapContext.getCurMapId(), this.id, this.petAchieves);
		}
	}
	////////////////////////////////////////随从成就//////////////////////////////////////////////////////////////////////
	
	
	
	
	////////////////////爬塔系统////////////////////
	public synchronized void dayRefreshTower()
	{
		this.climbTowerData.roleClimbTowerData.dayTimesBuy = 0;
		this.climbTowerData.roleClimbTowerData.dayTimesUsed = 0;
		this.climbTowerData.roleClimbTowerData.finishFloors.clear();
		this.secretAreaTaskData = new SBean.DBSecretTaskData(0, 0, 0, 0);
	}
	
	public synchronized SBean.DBClimbTower syncClimbTowerData()
	{
		SBean.ClimbTowerBaseDataCFGS baseData = GameData.getInstance().getClimbTowerBaseData();
		if(baseData.needlvl > this.level)
			return null;
		
		return this.climbTowerData.roleClimbTowerData.kdClone();
	}
	
	private boolean checkClimbTowerPetsValid(Set<Integer> pets)
	{
		if (pets.size() > GameData.PET_TYPE_TOWER_MAX_USE)
			return false;

		for (int pid : pets)
		{
			if (!this.activePets.containsKey(pid))
				return false;
		}

		return true;
	}
	
	public synchronized boolean setClimbTowerPets(Set<Integer> pets)
	{
		if (!checkClimbTowerPetsValid(pets))
			return false;

		this.climbTowerData.roleClimbTowerData.pets = pets;
		return true;
	}
	
	private int getTowerMinBestLevel()
	{
		int minLevel = Integer.MAX_VALUE;
		for (int level : this.climbTowerData.roleClimbTowerData.history.values())
		{
			if (level < minLevel)
				minLevel = level;
		}
		return minLevel == Integer.MAX_VALUE ? 0 : minLevel;
	}
	
	//爬塔同步战绩
	public Map<Integer, SBean.DBClimbTowerRecordData> getClimbTowerRecord()
	{
		Map<Integer, SBean.ClimbTowerFloorCFGS> floorCfg = GameData.getInstance().getClimbTowerFloorDatas();
		int sectId = this.getSectId();
		for (int groupId : floorCfg.keySet())
		{
			//获取对应GroupId的数据，ownData、sectData、serverData
			int bestFloor = this.climbTowerData.roleClimbTowerData.history.getOrDefault(groupId ,0);
			SBean.DBClimbTowerRecordDataCfg sectData = new SBean.DBClimbTowerRecordDataCfg(0, "", 0);
			if (sectId != 0)
			{
				sectData = gs.getSectManager().getClimbTowerData(sectId).get(groupId);
				if (sectData == null)
					sectData = new SBean.DBClimbTowerRecordDataCfg(0, "", 0);
			}
			SBean.DBClimbTowerRecordDataCfg serverData = gs.getClimbTowerManager().climbTowerData.get(groupId);
			if (serverData == null)
				serverData = new SBean.DBClimbTowerRecordDataCfg(0, "", 0);
			SBean.DBClimbTowerRecordData recordData = new SBean.DBClimbTowerRecordData(bestFloor, sectData, serverData);
			this.climbTowerData.roleClimbTowerRecordData.put(groupId, recordData);
		}
		return Stream.clone(this.climbTowerData.roleClimbTowerRecordData);
	}
	
	//购买挑战次数
	public synchronized boolean climbTowerBuyTimes(int times)
	{
		if (times != this.climbTowerData.roleClimbTowerData.dayTimesBuy + 1)
			return false;
		if (times > GameData.getInstance().getClimbTowerBaseData().needDiamond.size())
			return false;
		
		int cost = GameData.getTimesCost(GameData.getInstance().getClimbTowerBaseData().needDiamond, times);
		if (!this.canUseDiamond(cost, false))
			return false;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_CLIMB_TOWER_BUY_TIMES);
		tlogEvent.setArg(cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		this.climbTowerData.roleClimbTowerData.dayTimesBuy++;
		return true;
	}
	
	//同步声望
	public synchronized Map<Integer, SBean.DBClimbTowerFame> syncClimbTowerFame()
	{
//		SBean.DBClimbTowerFame
		return Stream.clone(this.climbTowerData.roleClimbTowerFameData);
	}
	
	//添加绝技
	private boolean takeUniqueSkill(int uniqueSkillId)
	{
		return takeUniqueSkill(uniqueSkillId, 1);
	}
	
	private boolean takeUniqueSkill(int uniqueSkillId, int skillLevel)
	{
		return takeUniqueSkillImpl(uniqueSkillId, skillLevel);
	}
	
	private boolean takeUniqueSkillImpl(int uniqueSkillId, int skillLevel)
	{
		SBean.UniqueSkillCFG uniqueSkillCfg = GameData.getInstance().getUniqueSkillCFG(uniqueSkillId);
		if (uniqueSkillCfg == null)
			return false;
		int skillId = uniqueSkillCfg.skills.get(this.classType - 1);
		if (this.uniqueSkills.contains(skillId))
			return false;
		SBean.DBSkill uniqueSkill = new SBean.DBSkill(skillId, skillLevel, 0);
		this.skills.put(skillId, uniqueSkill);
		this.uniqueSkills.add(skillId);
		gs.getMapService().syncRoleUpdateSkill(this.id, this.gameMapContext.getCurMapId(), uniqueSkill);
		this.roleProperties.onUpdateSkill(uniqueSkill, true);
		return true;
	}
	
	//声望领奖
	public synchronized boolean takeTowerFameReward(int groupId, int seq)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_TOWER_FAME_REWARD);
//		int groupId = this.climbTowerData.roleClimbTowerData.data.groupId;
		SBean.DBClimbTowerFame fameData = this.climbTowerData.roleClimbTowerFameData.get(groupId);
		if (fameData == null)
			return false;
		
		if (fameData.reward.contains(seq))
			return false;
		
		SBean.ClimbTowerFameDataCFGS fameCfg = GameData.getInstance().getClimbTowerFameDataCfg(groupId, seq);
		if (fameCfg == null)
			return false;
		if (fameCfg.canGetStunt != 0)
			takeUniqueSkill(fameCfg.canGetStunt);
		tlogEvent.setArg(groupId, seq);
		fameData.reward.add(seq);
		this.syncAddGameItems(GameData.getInstance().toGameItems(fameCfg.rewards), tlogEvent);
		return true;
	}

	//进入副本
	boolean enterClimbTowerMapCopy(int groupId, int mapId, int instanceId)
	{
		ClimbTowerMapCopyContext context = this.tryPrepareClimbTowerMapCopyContext(groupId, mapId, instanceId);
		if (context == null)
			return false;

		this.gameMapContext.startMapCopy(context);
		return true;
	}
	
	//开始战斗入口
	public synchronized boolean startClimbTowerCopy(int groupId, int floor)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity() || this.isMulRolesState())
			return false;
		int secondOfDay = GameTime.getSecondOfDay();
		int refreshTime = GameData.GAME_DAY_REFRESH_TIME * 60 * 60 + 60;//每天五点左右刷新，前后不超过一分钟，所以五点零一之后肯定已经刷新过，允许进入
		SBean.ClimbTowerBaseDataCFGS towerBaseCfg = GameData.getInstance().getClimbTowerBaseData();
		if (secondOfDay > (refreshTime - towerBaseCfg.notInTime*60) && secondOfDay <= refreshTime)
			return false;
		
		if (this.climbTowerData.roleClimbTowerData.finishFloors.contains((groupId << 16) | floor))
			return false;
		
		SBean.ClimbTowerFloorDataCFGS cfg = GameData.getInstance().getClimbTowerFloorDataCfg(groupId, floor);
		if (!canEnterClimbTowerCopy(groupId, cfg))
			return false;

		SBean.ClimbTowerMapCFGS mapCfg = GameData.getInstance().getClimbTowerMapCFGS(cfg.dungeonId);
		if (mapCfg == null)
			return false;
		int instanceId = gs.getMapService().createClimbTowerCopy(cfg.dungeonId);
		if (instanceId <= 0)
			return false;

		if (!enterClimbTowerMapCopy(groupId, cfg.dungeonId, instanceId))
			return false;

		gs.getMapService().syncMapCopyReady(cfg.dungeonId, instanceId);
		this.climbTowerFightFloor = floor;
		return true;
	}
	
	public synchronized SBean.MapSummary sweepTowerMap(int groupId, int floor)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SWEEP_TOWER_MAP);
		
		if (this.climbTowerData.roleClimbTowerData.dayTimesUsed >= GameData.getInstance().getClimbTowerBaseData().dayTimes + this.climbTowerData.roleClimbTowerData.dayTimesBuy)
			return null;
		if (this.climbTowerData.roleClimbTowerData.finishFloors.contains((groupId << 16) | floor))
			return null;
		int bestFloor = this.climbTowerData.roleClimbTowerData.history.getOrDefault(groupId, 0);
		if (bestFloor == 0)
			return null;
		float sweepParam = GameData.getInstance().getClimbTowerBaseData().sweepParam;
		int canSweepHighestFloor = (int) (sweepParam * this.climbTowerData.roleClimbTowerData.history.get(groupId) + 1);
		if (floor > canSweepHighestFloor)
			return null;
		SBean.ClimbTowerFloorDataCFGS floorCfg = GameData.getInstance().getClimbTowerFloorDataCfg(groupId, floor);
		if (floorCfg == null)
			return null;
		int mapId = floorCfg.dungeonId;
		SBean.ClimbTowerMapCFGS cfg = GameData.getInstance().getClimbTowerMapCFGS(mapId);
		Map<Integer, Integer> monsters = new TreeMap<Integer, Integer>();
		List<SBean.MapRewards> rewards = new ArrayList<SBean.MapRewards>();
		if (cfg == null || (cfg.costVit > 0 && !canUseVit(cfg.costVit)) || this.roleProperties.getRoleFightPower() < cfg.fightPower || this.level < cfg.needLevel)
			return null;
		
		SBean.CommonCFGS commonCfg = GameData.getInstance().getCommonCFG();
		//int needDiamond = commonCfg.map.lotteryCostDiamond * (cardCount - 1) * times;
		
		tlogEvent.setArg(cfg.costVit);
		this.useVit(cfg.costVit, tlogEvent.getGameItemRecords());

		tlogEvent.setArg(mapId);
		//this.useDiamond(needDiamond, false, tlogEvent.getGameItemRecords());

		GameConf.DoubleDropConfig doubleDropCfg = gs.getGameConf().getDoubleDropActivities().getFirstOpenedCofig();
		GameConf.ExtraDropConfig extraDropCfg = gs.getGameConf().getExtraDropActivities().getFirstOpenedCofig();
		SBean.DoubleDropCfg mapDoubleDropCfg = doubleDropCfg == null ? null : doubleDropCfg.getMapDoubleDropCfg();
		SBean.ExtraDropCfg mapExtraDropCfg = extraDropCfg == null ? null : extraDropCfg.getMapExtraDropCfg();
		SBean.RewardRatio rewardRatio = GameData.getMapcopyRewardRatio(mapId, doubleDropCfg);
		int exp = 0;
		Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();
		Map<Integer, Integer> cardDrop = new TreeMap<Integer, Integer>();

		// 杀怪奖励
		for (SBean.MapEntity e : cfg.allMonsters.values())
		{
			monsters.compute(e.id, (k, v) -> v == null ? e.count : v + e.count);
			SBean.DropRatio dropRatio = GameData.getMonsterDoubleDropRatio(mapId, e.id, mapDoubleDropCfg);
			SBean.ExtraDropTbl extraDrop = GameData.getMonsterExtraDropTable(mapId, e.id, mapExtraDropCfg);
			exp += (int) (e.exp * e.count * dropRatio.exp);
			for (int i = 0; i < e.count; ++i)
				drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, dropRatio.fixedDrop, dropRatio.randomDrop, extraDrop, drops);

		}
		for (SBean.MapEntity e : cfg.allTraps.values())
		{
			exp += e.exp * e.count;
			for (int i = 0; i < e.count; ++i)
				drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, 1, 1, null, drops);
		}
		// 通关奖励
		exp += (int) (cfg.rewardExp * rewardRatio.exp);
		drops = GameData.getMergedDrops(cfg.fixedDropID, 0, 0, rewardRatio.fixedDrop, 1, null, drops);
		Integer coinCount = drops.remove(GameData.COMMON_ITEM_ID_COIN);
		if (coinCount == null)
		{
			coinCount = 0;
		}
		else
		{
			this.syncAddGameItem(GameData.getInstance().toGameItem(GameData.COMMON_ITEM_ID_COIN, coinCount), tlogEvent);
		}

		// 翻盘奖励
		List<SBean.DropItemCFGS> cardDropList = GameData.getInstance().getNoDuplicateDrops(cfg.turnPlateDropID, GameData.getInstance().getCommonCFG().map.palteCount);
		if (cardDropList != null)
		{
			SBean.DummyGoods dropItem = GameData.getInstance().getNextDrop(cardDropList);
			if (dropItem != null)
				cardDrop.merge(dropItem.id, dropItem.count, (ov, nv) -> ov + nv);
		}

		this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
		this.addDropsToBagOrMailBox(mapId, drops, cardDrop);
		rewards.add(new SBean.MapRewards(exp, coinCount, GameData.toDummGoods(drops), GameData.toDummGoods(cardDrop)));
		this.climbTowerData.roleClimbTowerData.finishFloors.add((groupId << 16) | floor);
		this.climbTowerData.roleClimbTowerData.dayTimesUsed++;
		this.syncClimbTowerSecretArea();
		this.logTDScheduleData(mapId);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logClimbTowerCopyFlow(Role.this, groupId, mapId, TLog.COPYEVENT_SWEEP, true);
		return new SBean.MapSummary(monsters, rewards);
	}
	
	//随机秘境任务
	private void syncClimbTowerSecretArea()
	{
		if (this.climbTowerData.roleClimbTowerData.dayTimesUsed >= GameData.getInstance().getClimbTowerBaseData().dayTimes)
		{
			if (this.secretAreaTaskData.id == 0 && this.secretAreaTaskData.reward != 1)
			{
				List<Integer> secretTasks = GameData.getInstance().getSecretTasksWithLevel(this.level);
				if (secretTasks == null)
					return;
				int index = GameRandom.getRandom().nextInt(secretTasks.size());
				this.secretAreaTaskData = new SBean.DBSecretTaskData(secretTasks.get(index), 0, 0, GameTime.getTime());
				
				SBean.SecretAreaTaskCFGS taskCfg = GameData.getInstance().getSecretTaskCfg(this.secretAreaTaskData.id);
				if(taskCfg != null)
					this.addTaskDrop(taskCfg.taskCond);
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_secret_task(this.secretAreaTaskData.kdClone()));
			}
		}
	}
	
	public synchronized boolean enterSecretAreaMap()
	{
		if (this.climbTowerData.roleClimbTowerData.dayTimesUsed < GameData.getInstance().getClimbTowerBaseData().dayTimes 
				|| this.mulRolesLock > 0 || this.isMulRolesState())
			return false;
		
		int taskId = this.secretAreaTaskData.id;
		if (taskId == 0 || this.secretAreaTaskData.reward == 1)
			return false;
		
		SBean.SecretAreaTaskCFGS taskCfg = GameData.getInstance().getSecretTaskCfg(taskId);
		if (taskCfg == null || taskCfg.mapId == 0)
			return false;
		
		SBean.MapLocation mapLocation = GameData.getMapSpawnLocation(GameData.getInstance().getMapClusterCFGS(taskCfg.mapId));
		this.gameMapContext.changeWorld(mapLocation, this.getPriorityLine(mapLocation.mapID));
		this.gameMapContext.roleChangeMap();
		return true;
	}
	
	public synchronized boolean takeSecretReward(int id)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_SECRET_AREA_REWARD);
		
		SBean.SecretAreaTaskCFGS taskCfg = GameData.getInstance().getSecretTaskCfg(id);
		if(taskCfg==null)
			return false;
		
		SBean.MapLocation curLocation = this.gameMapContext.getCurMapContext().getMapLocation();
		if (curLocation.mapID == taskCfg.mapId)
			return false;
		
		if (!isTaskFinished(taskCfg.taskCond, this.secretAreaTaskData.value))
			return false;
		
		if (!taskCfg.rewards.isEmpty() && !this.canAddGameItems(taskCfg.rewards))
			return false;
		
		this.secretAreaTaskData.reward = 1;
		this.secretAreaTaskData.id = 0;
		tlogEvent.setArg(id);
		this.syncAddGameItems(GameData.getInstance().toGameItems(taskCfg.rewards), tlogEvent);
		this.delTaskDrop(taskCfg.taskCond);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	///////////////////爬塔系统 end/////////////////
	
	//////////////////////////随从合修任务///////////////////////////
	private void dayRefreshPetCoPracticeTask()
	{
		for (SBean.DBPet e : this.activePets.values())
		{
			e.dailyCompleteTask = 0;
			if(canTakePetTask(e)){
				getNewPetTask(e.fightPet.id);
			}
		}
	}
	
	private boolean canTakePetTask(SBean.DBPet pet)
	{
		SBean.PetLifeTaskCFGS petTaskCFGS = GameData.getInstance().getPetLifeTaskCFGS(pet.fightPet.id, pet.lifetask.id);
		if(petTaskCFGS==null)
			return false;
		return pet.fightPet.level >= GameData.getInstance().getCommonCFG().pet.coPracticeOpenLvl 
				&& pet.task.id == 0 //当前无合修任务
				&& pet.dailyCompleteTask < GameData.getInstance().getCommonCFG().pet.maxCoPracticeTaskNum 
				&& pet.lifetask.reward == 1 && petTaskCFGS.nextId == 0 //最后一个身世任务已完成
				&& pet.fightPet.coPracticeLvl < GameData.getInstance().getPetCoPracticeLevelLimit(pet.fightPet.id);
	}

	public void getNewPetTask(int petid)
	{
		SBean.DBPet pet = this.activePets.get(petid);
		if(pet == null || pet.fightPet.coPracticeLvl >= GameData.getInstance().getPetCoPracticeLevelLimit(petid))
			return;
		SBean.PetTaskCFGS petnewCFGS = GameData.getInstance().getNextPetTaskCFG(petid,pet.fightPet.coPracticeLvl);
		if (petnewCFGS == null)
		{
			pet.task.id = 0;
			pet.task.value = 0;
		}
		else
		{
			pet.task.id = petnewCFGS.id;
			pet.task.value = 0;
			
			SBean.PetTaskCFGS petTaskCFGS = GameData.getInstance().getPetTaskCFG(pet.task.id);
			if(petTaskCFGS != null)
				this.addTaskDrop(petTaskCFGS.cond);
		}
	}
	
	public synchronized int takePetTaskReward(int petId, int taskId, int isdiamond)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if(pet == null || pet.task.id != taskId || pet.fightPet.coPracticeLvl >= GameData.getInstance().getPetCoPracticeLevelLimit(petId))
			return 0;
		if (pet.dailyCompleteTask >= GameData.getInstance().getCommonCFG().pet.maxCoPracticeTaskNum)
			return 0;
		SBean.PetCFGS petCFGS = GameData.getInstance().getPetCFG(petId);
		SBean.PetTaskCFGS petTaskCFGS = GameData.getInstance().getPetTaskCFG(taskId);
		if (petCFGS == null || petTaskCFGS == null || (!isTaskFinished(petTaskCFGS.cond, pet.task.value) && isdiamond != 1))
			return 0;
		if (isdiamond == 1 && !canUseDiamond(petTaskCFGS.quickfinishdiamond, false))
			return 0;
		int coPracticeExp = pet.coPracticeExp + petTaskCFGS.friendliness;
		int petCoPracticeLvl = GameData.getInstance().getPetCoPracticeLevel(petId, coPracticeExp);
		SBean.PetTaskCFGS petNextCFGS = GameData.getInstance().getNextPetTaskCFG(petId,petCoPracticeLvl);
		if (petNextCFGS == null)
			return 0;

		this.delTaskDrop(petTaskCFGS.cond);
		pet.coPracticeExp = coPracticeExp;
		pet.dailyCompleteTask++; 
		if(pet.dailyCompleteTask >= GameData.getInstance().getCommonCFG().pet.maxCoPracticeTaskNum)
			pet.task.id = 0;
		else 
		{
			pet.task.id = petNextCFGS.id;
			this.addTaskDrop(petNextCFGS.cond);
		}
		pet.task.value = 0;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_PET_TASK_REWARD);
		tlogEvent.setArg(petId, taskId);
		if (isdiamond == 1)
			useDiamond(petTaskCFGS.quickfinishdiamond, false, tlogEvent.getGameItemRecords());
		syncAddCoin(petTaskCFGS.coinnum, false, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		if (petCoPracticeLvl > pet.fightPet.coPracticeLvl)
		{
			pet.fightPet.coPracticeLvl = petCoPracticeLvl;
			gs.getMapService().syncRoleUpdatePet(this.id, this.gameMapContext.getCurMapId(), pet.fightPet.kdClone());
			pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);
			this.roleProperties.onUpdatePetCoPractice(pet.fightPet.id, pet.fightPet.coPracticeLvl, false);
			
		}
		gs.getTLogger().logPetCoPractice(this, petId, petCoPracticeLvl);

		return pet.task.id;
	}
	////////////////////////////////////随从合修任务end////////////////////////////////////
	
	/////////////////////////////////////随从身世任务//////////////////////////////////////////

	public synchronized boolean takePetLifeTask(int petId, int taskId)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if(pet == null || pet.lifetask.id == taskId || (pet.lifetask.id != 0 && pet.lifetask.reward != 1))
			return false;
		SBean.PetCFGS petCFGS = GameData.getInstance().getPetCFG(petId);
		SBean.PetLifeTaskCFGS petTaskCFGS = GameData.getInstance().getPetLifeTaskCFGS(petId, taskId);
		if (petCFGS == null || petTaskCFGS == null || petTaskCFGS.mapCopyId != this.gameMapContext.getCurMapId() || pet.fightPet.level < GameData.getInstance().getCommonCFG().pet.coPracticeOpenLvl)
			return false;
		if (petTaskCFGS.startNpcId > 0 && !GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), petTaskCFGS.startNpcId, GameData.getInstance().getCommonCFG().task.npcRadius))
			return false;
		pet.lifetask.id = petTaskCFGS.id;
		pet.lifetask.value = 0;
		pet.lifetask.reward = 0;
		this.addTaskDrop(petTaskCFGS.cond);
		return true;
	}
	
	public synchronized boolean takePetLifeTaskReward(int petId, int taskId)
	{
		SBean.DBPet pet = this.activePets.get(petId);
		if(pet == null || pet.lifetask.id != taskId || pet.lifetask.reward == 1)
			return false;
		SBean.PetCFGS petCFGS = GameData.getInstance().getPetCFG(petId);
		SBean.PetLifeTaskCFGS petTaskCFGS = GameData.getInstance().getPetLifeTaskCFGS(petId, taskId);
		if (petCFGS == null || petTaskCFGS == null || petTaskCFGS.mapCopyId != this.gameMapContext.getCurMapId() || !isTaskFinished(petTaskCFGS.cond, pet.lifetask.value))
			return false;
		if (petTaskCFGS.endNpcId > 0 && !GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), petTaskCFGS.endNpcId, GameData.getInstance().getCommonCFG().task.npcRadius))
			return false;

		if (!petTaskCFGS.rewardItems.isEmpty() && !this.canAddGameItems(petTaskCFGS.rewardItems))
			return false;
		pet.lifetask.reward = 1;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_PET_LIFE_TASK_REWARD);
		tlogEvent.setArg(petId,taskId);
		this.syncAddGameItems(GameData.getInstance().toGameItems(petTaskCFGS.rewardItems), tlogEvent);
		this.delTaskDrop(petTaskCFGS.cond);
		
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		if(petTaskCFGS.nextId == 0)
		{
			pet.fightPet.coPracticeLvl = 1;
			getNewPetTask(petId);
			pet.fightPet.fightPower = this.roleProperties.onUpdatePet(pet);
			gs.getMapService().syncRoleUpdatePet(this.id, this.gameMapContext.getCurMapId(), pet.fightPet.kdClone());
			
			this.roleProperties.onUpdatePetCoPractice(pet.fightPet.id, pet.fightPet.coPracticeLvl, false);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_new_pet_task(petId, pet.task.id));
		}

		return true;
	}
	/////////////////////////////////////随从身世任务end//////////////////////////////////////
	
	////////////////////////////////////////帮派运镖begin////////////////////////////////////
	public synchronized SBean.DBSectDeliver initSectDeliver()
	{
		List<SBean.SectDeliverTaskInfo> data = GameData.getInstance().getSectDeliverTasks(0);
		return new SBean.DBSectDeliver(0,0,0,data,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
	}
	
	//帮派运镖同步
	public void syncSectDeliver()
	{
		gs.getSectManager().syncSectDeliver(this);
	}
	
	public synchronized void syncSectDeliverOperate(SBean.DBDeliverWishInSect info)
	{
		if (info == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_sync_res(GameData.PROTOCOL_OP_FAILED, 0, 0, GameData.emptyList(), new SBean.DBSectDeliverWishChange()));
			return;
		}
		SBean.DBSectDeliverWishChange data = new SBean.DBSectDeliverWishChange(info.exp, this.sectDeliver.tempExp, info.money, this.sectDeliver.tempMoney, info.hp, this.sectDeliver.tempHp);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_sync_res(GameData.PROTOCOL_OP_SUCCESS, this.sectDeliver.isProtect, this.sectDeliver.wishTimes, Stream.clone(this.sectDeliver.tasks), data));
	}
	
	//帮派运镖每日刷新
	public synchronized void dayRefreshSectDeliver(int lastRefreshDay, int nowday)
	{
		this.isRob = GameData.SECT_IS_NOT_ROB;
		this.sectDeliver.dayAcceptTime = 0;
		this.sectDeliver.dayRobTime = 0;
		this.sectDeliver.refreshTimes = 0;
		this.sectDeliver.tasks = GameData.getInstance().getSectDeliverTasks(this.sectDeliver.curTaskId);
		if ((nowday - 3) % 7 != (lastRefreshDay - 3) % 7)
		{
			this.sectDeliver.wishTimes = 0;
			this.sectDeliver.tempExp = 0;
			this.sectDeliver.tempHp = 0;
			this.sectDeliver.tempMoney = 0;
		}
	}

	//刷新帮派运镖的任务
	public synchronized void refreshSectDeliver()
	{
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		if(cfg == null || this.sectDeliver.refreshTimes + 1 > GameData.DIAMOND_REFRESH_MAX_TIMES)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_refresh_res(GameData.PROTOCOL_OP_FAILED, GameData.emptyList()));
			return ;
		}
		int cost = GameData.getTimesCost(cfg.refreshDiamond, this.sectDeliver.refreshTimes + 1);
		if (!this.canUseDiamond(cost, false))//优先消耗绑定元宝
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_refresh_res(GameData.SECT_DELIVER_NO_ENOUGH_DIAMOND, GameData.emptyList()));
			return ;
		}
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_REFRESH_SECT_DELIVER);
		tlogEvent.setArg(this.sectDeliver.refreshTimes, cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		List<SBean.SectDeliverTaskInfo> data = GameData.getInstance().getSectDeliverTasks(this.sectDeliver.curTaskId);
		this.sectDeliver.tasks = data;
		this.sectDeliver.refreshTimes ++;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_refresh_res(GameData.PROTOCOL_OP_SUCCESS, data));
	}
	
	//帮派运镖投保
	public synchronized void sectDeliverProtect()
	{
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		if(cfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_protect_res(GameData.PROTOCOL_OP_FAILED));
			return ;
		}
		if (!this.canUseDiamond(cfg.protectDiamond, false))//优先消耗绑定元宝
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_protect_res(GameData.SECT_DELIVER_NO_ENOUGH_DIAMOND));
			return ;
		}
		if(this.sectDeliver.isProtect != 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_protect_res(GameData.SECT_DELIVER_IS_PROTECTED));
			return ;
		}
		if(GameTime.getSecondOfDay() > cfg.protectEndTime.get(0) && GameTime.getSecondOfDay() < cfg.protectEndTime.get(1))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_protect_res(GameData.SECT_DELIVER_IS_NOT_PROTECTED_TIME));
			return ;
		}
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_DELIVER_PROTECT);
		tlogEvent.setArg(cfg.protectDiamond);
		this.useDiamond(cfg.protectDiamond, false, tlogEvent.getGameItemRecords());
		this.sectDeliver.isProtect = 1;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_protect_res(GameData.PROTOCOL_OP_SUCCESS));
	}
	
	public int beginSectDeliver(int routeId, int taskId)
	{
		return gs.getSectManager().beginSectDeliver(routeId, taskId, this);
	}
	
	//开始运镖
	public int beginSectDeliverOperate(int routeId, int taskId, SBean.DBDeliverWishInSect info)
	{
		SBean.MapLocation mapLocation = null;
		int mapID = 0;
		int configID = 0;
		int hp = 0;
		synchronized(this)
		{
			//taskId 任务ID，routeId 路线id
			SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
			if(cfg == null || this.level < cfg.roleLevelNeed || this.isRob != GameData.SECT_IS_NOT_ROB || this.sectDeliver.startTime != 0 || this.sectDeliver.dayAcceptTime >= cfg.deliverTimes || this.isMulRolesMember() || this.mulRolesLock > 0 || this.isInJoinState())
			{
				return GameData.PROTOCOL_OP_FAILED;
			}
			if( routeId < 1 || taskId < 1 || routeId > GameData.getInstance().getSectDeliverRouteMaxId() || taskId > GameData.getInstance().getSectDeliverTaskMaxId())
			{
				return GameData.PROTOCOL_OP_FAILED;
			}
			for (int i = 0; i < this.sectDeliver.tasks.size(); i++)
			{
				if (this.sectDeliver.tasks.get(i).id == taskId)
				{
					if (this.sectDeliver.tasks.get(i).flag == 1)
					{
						return GameData.PROTOCOL_OP_FAILED;
					}
					else
						break;
				}
			}
			SBean.SectDeliverTask task = GameData.getInstance().getSectDeliverTaskCfgs(taskId);
			SBean.SectDeliverRoute route = GameData.getInstance().getSectDeliverRouteCfgs(routeId);
			if( task == null || route == null || info == null)
			{
				return GameData.PROTOCOL_OP_FAILED;
			}
			if(!canUseVit(cfg.needVit))
			{
				return GameData.SECT_DELIVER_NO_ENOUGH_VIT;
			}
			if(this.gameMapContext.getCurMapContext().getHp() <= 0)
			{
				return GameData.PROTOCOL_OP_FAILED;
			}
			mapID = route.startMapId;
			int npcPoint = route.startNPC;

			if (!this.gameMapContext.isInWorldMap())
			{
				return GameData.PROTOCOL_OP_FAILED;
			}

			SBean.MapClusterCFGS mccfg = GameData.getInstance().getMapClusterCFGS(mapID);
			if (mccfg == null || !mccfg.npcs.contains(npcPoint))
			{
				return GameData.PROTOCOL_OP_FAILED;
			}

			SBean.NpcPointCFGS npcPointCFGS = GameData.getInstance().getNpcPointCfg(npcPoint);
			if (npcPointCFGS == null)
			{
				return GameData.PROTOCOL_OP_FAILED;
			}
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SECT_DELIVER_BEGIN);
			this.useVit(cfg.needVit, tlogEvent.getGameItemRecords());
			this.sectDeliver.curRouteId = routeId;
			this.sectDeliver.curTaskId = taskId;
			this.sectDeliver.vehicleId = task.vehicleId;
			this.sectDeliver.tasks.forEach(item ->
			{
				if (item.id == taskId)
					item.flag = 1;
			});
			tlogEvent.setArg(cfg.needVit);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			this.sectDeliver.startTime = GameTime.getTime();
			this.sectDeliver.historyAcceptTime += 1;
			//传送至目标NPC
			mapLocation = new SBean.MapLocation(mapID, new SBean.Location(npcPointCFGS.position, new SBean.Vector3F(1.0f, 0.0f, 0.0f)));
			configID = task.vehicleId;
			hp = info.hp;
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(mapLocation, this.leaderLine);
				this.gameMapContext.roleChangeMap();
			}
			else
				this.mulRolesChangeMap(mapLocation);
		}
		
		this.createNewCar(mapID, configID, hp, mapLocation.location);
		
		gs.getTLogger().logRoleSectDeliverFlow(this, TLog.SECT_DELIVER, TLog.SECT_ACT_START, this.sectDeliver.isProtect);
		gs.getTLogger().logSectDeliverTask(this, this.getSectId(), routeId, taskId, 1, TLog.TASKEVENT_TAKE);
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private synchronized void createNewCar(int mapID, int configID, int hp, SBean.Location location)
	{
		WorldMapContext context = this.gameMapContext.getWorldMapContext();
		int mapInstance = context.getMapInstance();
		int ownerID = this.id;
		int maxHP = (int)(context.getHpMax() * (1 + (hp / 1000.f)));
		int teamCarCnt = getTeamCarCnt();
		// 在map中创建一个镖车
		this.escortCar.createNewCar(mapID, mapInstance, ownerID, this.name, configID, maxHP, location, teamCarCnt);
		notifyTeamUpdateCarCnt();
		gs.getMapService().syncRoleUpdateCarBehavior(this.id, this.gameMapContext.getCurMapId(), (byte)1, (byte)0);
	}
	
	private int getTeamCarCnt()
	{
		if (!this.isInTeam())
			return 0;
		int teamCarCnt = 0;
		for (Integer member : this.team.members)
		{
			Role role = gs.getLoginManager().getOnGameRole(member);
			if (role != null && role.sectDeliver.startTime != 0)
				teamCarCnt++;
		}
		return teamCarCnt;
	}

	private void notifyTeamUpdateCarCnt()
	{
		if(!this.isInTeam())
			return;
		
		for (Integer member : this.team.members)
		{
			Role role = gs.getLoginManager().getOnGameRole(member);
			if (role != null && role.sectDeliver.startTime != 0)
				role.escortCar.updateTeamCarCnt(role.getTeamCarCnt());
		}
	}
	
	public int searchHelpSectDeliver()
	{
		return gs.getSectManager().sectDeliverSearchHelp(this);
	}
	
	//帮派运镖求援
	public synchronized int searchHelpSectDeliverOperate(List<Integer> list)
	{
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		if (this.sectDeliver.startTime == 0 || list == null || cfg == null)
		{
			return GameData.PROTOCOL_OP_FAILED;
		}
		if (list.size() == 0)
		{
			return GameData.SECT_DELIVER_SERARCH_NO_MEMBER;
		}
		if (GameTime.getTime() - this.sectDeliver.searchHelpTime < cfg.searchHelpTime)
		{
			return GameData.SECT_DELIVER_SERARCH_TIME_FAILED;
		}
		for(Integer i : list)
		{
			Role role = gs.getLoginManager().getOnGameRole(i);
			if(role != null)
			{
				synchronized (role)
				{
					if (role != null && i != Role.this.id)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.sect_deliver_help_push(this.id, this.name, this.gameMapContext.getCurMapContext().getMapLocation(), this.gameMapContext.getCurWorldInstanceId()));
					}
				}
			}
		}
		this.sectDeliver.searchHelpTime = GameTime.getTime();
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int onHelpSectDeliver(int roleId, SBean.MapLocation targetLocation, int line)
	{
		return gs.getSectManager().sectDeliverOnHelp(this, roleId, targetLocation, line);
	}
	
	//帮派运镖支援他人
	public int onHelpSectDeliverOperate(int roleId, SBean.MapLocation targetLocation, int line)
	{
		synchronized(this)
		{
			if(this.mulRolesLock > 0 || this.isMulRolesMember())
				return GameData.PROTOCOL_OP_FAILED;
			if(this.sectDeliver.startTime != 0)
				return GameData.PROTOCOL_OP_SECT_HELP_IS_DELIVER;
			if(!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_SECT_HELP_IS_NOT_WORLDMAP;
			if(this.gameMapContext.getCurMapContext().getHp() <= 0)
				return GameData.PROTOCOL_OP_SECT_HELP_IS_DEAD;
			
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(targetLocation, line);
				this.gameMapContext.roleChangeMap();
				return GameData.PROTOCOL_OP_SUCCESS;
				
			}
		}
		this.mulRolesChangeMap(targetLocation, line);
		return GameData.PROTOCOL_OP_SUCCESS;
		
//		this.gameMapContext.changeWorld(targetLocation, line);
//		this.gameMapContext.roleChangeMap();
//		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int cancelSectDeliver()
	{
		return gs.getSectManager().sectDeliverOnCancel(this);
	}
	
	//帮派运镖取消运镖
	public synchronized int cancelSectDeliverOperate()
	{
		
		if(this.sectDeliver.startTime == 0)
		{
			return GameData.PROTOCOL_OP_FAILED;
		}
		//remove vehicle from map
		clearSectDeliverCarInfo();

		gs.getTLogger().logRoleSectDeliverFlow(this, TLog.SECT_DELIVER, TLog.SECT_ACT_FAIL, 0);
		gs.getTLogger().logSectDeliverTask(this, getSectId(), sectDeliver.curRouteId, sectDeliver.curTaskId, 3, TLog.TASKEVENT_CANCLE);
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized void tryClearSectDeliverData()
	{
		if (this.sectDeliver.startTime <= 0)
			return;
		clearSectDeliverCarInfo();
	}

	private void clearSectDeliverCarInfo()
	{
		this.escortCar.destoryCar();
		this.sectDeliver.beRobbedTimes = 0;
		this.sectDeliver.startTime = 0;
		this.sectDeliver.dayAcceptTime ++;
		this.sectDeliver.curRouteId = 0;
		this.sectDeliver.curTaskId = 0;
		this.sectDeliver.vehicleId = 0;
		this.sectDeliver.isProtect = 0;
		gs.getMapService().syncRoleUpdateCarBehavior(this.id, this.gameMapContext.getCurMapId(), (byte)0, this.isRob);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.destory_own_car());
		notifyTeamUpdateCarCnt();
	}
	public void finishSectDeliver()
	{
		gs.getSectManager().finishSectDeliver(this);
	}
	//帮派运镖完成，领取奖励
	public synchronized boolean finishSectDeliverOperate(SBean.DBDeliverWishInSect info)
	{
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		SBean.SectDeliverTask taskcfg = GameData.getInstance().getSectDeliverTaskCfgs(this.sectDeliver.curTaskId);
		SBean.SectDeliverRoute routecfg = GameData.getInstance().getSectDeliverRouteCfgs(this.sectDeliver.curRouteId);
		if (info == null || taskcfg == null || routecfg == null || this.level < cfg.roleLevelNeed || this.sectDeliver.startTime == 0 || GameData.getInstance().getSectDeliverTaskCfgs(this.sectDeliver.curTaskId) == null || this.escortCar.ownerID == 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_finish_res(GameData.PROTOCOL_OP_FAILED, 0, 0, 0, 0, 0, 0));
			return false;
		}
		if (!GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapContext().getMapLocation(), GameData.getInstance().getNpcPointCfg(routecfg.endNPC).relatedID, cfg.stopDistance))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_finish_res(GameData.PROTOCOL_OP_FAILED, 0, 0, 0, 0, 0, 0));
			return false;
		}
		if (!GameData.getInstance().testNearbyPosition(this.gameMapContext.getCurMapContext().getMapLocation().mapID, this.gameMapContext.getCurMapContext().getMapLocation().location.position, this.escortCar.mapID, this.escortCar.location.position.x, this.escortCar.location.position.y, this.escortCar.location.position.z, cfg.stopDistance))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_finish_res(GameData.PROTOCOL_OP_FAILED, 0, 0, 0, 0, 0, 0));
			return false;
		}
		boolean timeBouns = false;
		int dayTime = GameTime.getSecondOfDay(GameTime.getTime());
		if((cfg.doubleBonusTimes.get(0) < dayTime && dayTime < cfg.doubleBonusTimes.get(1)) ||
				(cfg.doubleBonusTimes.get(2) < dayTime && dayTime < cfg.doubleBonusTimes.get(3)))
		{
			timeBouns = true;
		}
		
		int percent = GameData.getInstance().getSectDeliverRobPercent(this.sectDeliver.startTime, this.sectDeliver.beRobbedTimes, this.sectDeliver.curTaskId, this.sectDeliver.isProtect);
		int exp = (int) Math.floor(percent / 10000F * (1 + (timeBouns ? cfg.doubleBonusRate / 10000F : 0) + info.exp / 1000F) * GameData.getInstance().getSectDeliverExp(this.level, this.sectDeliver.curTaskId));
		int money = (int) Math.floor(percent / 10000F * (1 + (timeBouns ? cfg.doubleBonusRate / 10000F : 0) + info.money / 1000F) * GameData.getInstance().getSectDeliverGold(this.level, this.sectDeliver.curTaskId));
		this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_SECT_DELIVER, 0);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_FINISH_SECT_DELIVER);
		tlogEvent.setArg(percent, exp, money);
		this.syncAddCoin(money, money > 0, tlogEvent);

		gs.getTLogger().logRoleSectDeliverFlow(this, TLog.SECT_DELIVER, TLog.SECT_ACT_FINISH, 0);
		gs.getTLogger().logSectDeliverTask(this, this.getSectId(), sectDeliver.curRouteId, sectDeliver.curTaskId, 2, TLog.TASKEVENT_FINISH);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		logDailyTask(GameData.DAILY_TASK_ID_SECT_ESCORTCAR, 1);
		this.logTaskScheduleData(GameData.SCHEDULE_TYPE_SECT_ESCORTCAR);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_finish_res(GameData.PROTOCOL_OP_SUCCESS, money, exp, timeBouns ? cfg.doubleBonusRate / 100 + 100 : 100, percent / 100, info.exp / 10 + 100, info.money / 10 + 100));
		
		clearSectDeliverCarInfo();
		return true;
	}
	
	public synchronized boolean sectDeliverTimeOut()
	{
		clearSectDeliverCarInfo();
		this.mailbox.addSysMail(MailBox.SysMailType.SectDeliverFail, MailBox.SECT_DELIVER_FAIL_MAIL_MAX_RESERVE_TIME, "由于运镖期间离线时间过长，运镖失败！", new ArrayList<>(), new ArrayList<>());
		return true;
	}
	
	//帮派祝福同步
	public void syncWishSectDeliver()
	{
		gs.getSectManager().syncWishSectDeliver(this);
	}
	
	public synchronized void syncWishSectDeliverOperate(SBean.DBDeliverWishInSect info, List<SBean.DBDeliverWishListItem> rankList)
	{
		SBean.DBSectDeliverWishChange data = null;
		if(info == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_sync_wish_res(GameData.PROTOCOL_OP_FAILED, this.sectDeliver.wishTimes, null, null ));
			return ;
		}
		data = new SBean.DBSectDeliverWishChange(info.exp, this.sectDeliver.tempExp, info.money, this.sectDeliver.tempMoney, info.hp, this.sectDeliver.tempHp);
		if(rankList == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_sync_wish_res(GameData.PROTOCOL_OP_FAILED, this.sectDeliver.wishTimes, null, null));
			return ;
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_sync_wish_res(GameData.PROTOCOL_OP_SUCCESS, this.sectDeliver.wishTimes, data, rankList));
	}
	
	//帮派祝福祝福
	public void addWishSectDeliver()
	{
		gs.getSectManager().addWishSectDeliver(this);
	}
	
	public synchronized boolean addWishSectDeliverOperate(SBean.DBDeliverWishInSect info, int wishTime)
	{
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		if (cfg == null || info == null || this.sectDeliver.wishTimes + 1 > GameData.DIAMOND_REFRESH_MAX_TIMES)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_add_wish_res(GameData.PROTOCOL_OP_FAILED, null));
			return false;
		}
		if (GameData.getInstance().checkSectDeliverNearMax(info))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_add_wish_res(GameData.SECT_DELIVER_NEAR_MAX, null));
			return false;
		}
		SBean.DBSectDeliverWishChange data = GameData.getInstance().getTempWishChange(wishTime, info.exp, info.money, info.hp);
		if(data == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_add_wish_res(GameData.PROTOCOL_OP_FAILED, null));
			return false;
		}
		int cost = GameData.getTimesCost(cfg.wishDiamonds, this.sectDeliver.wishTimes + 1);
		if (!this.canUseDiamond(cost, false))//优先消耗绑定元宝
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_add_wish_res(GameData.SECT_DELIVER_NO_ENOUGH_DIAMOND, null));
			return false;
		}
		this.sectDeliver.tempExp = data.expTo;
		this.sectDeliver.tempMoney = data.moneyTo;
		this.sectDeliver.tempHp = data.hpTo;
		this.sectDeliver.wishTimes ++ ;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SAVE_WISH_SECT_DELIVER);
		tlogEvent.setArg(cost, cfg.wishGet);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.syncAddSectContribution(cfg.wishGet, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_add_wish_res(GameData.PROTOCOL_OP_SUCCESS, data));
		return true;
	}
	
	//帮派祝福保存
	public void saveWishSectDeliver()
	{
		gs.getSectManager().modefySectDeliverWish(this, this.sectDeliver.tempExp, this.sectDeliver.tempMoney, this.sectDeliver.tempHp);
	}
	
	public synchronized boolean saveWishSectDeliverOperate(boolean sectCheck)
	{
		if (!sectCheck)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_save_wish_res(GameData.PROTOCOL_OP_FAILED));
			return false;
		}
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		if(cfg == null )
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_save_wish_res(GameData.PROTOCOL_OP_FAILED));
			return false;
		}
		if(this.sectDeliver.tempExp == 0 && this.sectDeliver.tempMoney == 0 && this.sectDeliver.tempHp == 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_save_wish_res(GameData.SECT_DELIVER_NO_TEMP_WISH_DATA));
			return false;
		}
		this.sectDeliver.tempExp = 0;
		this.sectDeliver.tempMoney = 0;
		this.sectDeliver.tempHp = 0;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_save_wish_res(GameData.PROTOCOL_OP_SUCCESS));
		return true;
	}
	
	public synchronized boolean robTaskTake()
	{
		SBean.SectDeliverCFGS cfg = GameData.getInstance().getSectDeliverCfgs();
		if(cfg == null || this.level < cfg.roleLevelNeed || this.isRob != GameData.SECT_IS_NOT_ROB || this.sectDeliver.startTime != 0 || this.sectDeliver.dayRobTime >= cfg.robTimes)
			return false;
		this.isRob = GameData.SECT_IS_ROB;
		gs.getMapService().syncRoleUpdateCarBehavior(this.id, this.gameMapContext.getCurMapId(), (byte)0, this.isRob);

		gs.getTLogger().logRoleSectDeliverFlow(this, TLog.SECT_ROB, TLog.SECT_ACT_START, 0);
		gs.getTLogger().logSectRobTask(this, getSectId(), 0, 1, TLog.TASKEVENT_TAKE);
		
		return true;
	}

	public synchronized boolean robTaskCancel()
	{
		if(this.isRob == GameData.SECT_IS_NOT_ROB)
			return false;

		gs.getTLogger().logRoleSectDeliverFlow(this, TLog.SECT_ROB, TLog.SECT_ACT_FAIL, 0);
		gs.getTLogger().logSectRobTask(this, getSectId(), 0, 0, TLog.TASKEVENT_CANCLE);
		clearRobInfo();
		return true;
	}

	public synchronized void syncSectDeliverShop()
	{
		if(this.level < GameData.getInstance().getSectDeliverCfgs().roleLevelNeed)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_shopsync_res(null, this.sectDeliver.robMoney));
			return;
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_deliver_shopsync_res(this.syncShopInfo(GameData.SHOP_TYPE_SECT_DELIVER), this.sectDeliver.robMoney));
	}

	public SBean.ShopInfo refreshSectDeliverShop(int times, int isSecondType)
	{
		if(this.level < GameData.getInstance().getSectDeliverCfgs().roleLevelNeed)
			return null;
		return this.userRefreshShop(GameData.SHOP_TYPE_SECT_DELIVER, times, isSecondType);
	}

	public boolean buySectDeliverShop(int seq)
	{
		if(this.level < GameData.getInstance().getSectDeliverCfgs().roleLevelNeed)
			return false;
		return this.buyShopGoogs(GameData.SHOP_TYPE_SECT_DELIVER, seq);
	}

	public void clearSectDeliverData()
	{
		this.sectDeliver.wishTimes = 0;
		if(this.sectDeliver.startTime != 0)
			clearSectDeliverCarInfo();
		if(this.isRob != GameData.SECT_IS_NOT_ROB)
			clearRobInfo();
	}
	private void clearRobInfo()
	{
		this.isRob = GameData.SECT_IS_NOT_ROB;
		this.sectDeliver.dayRobTime ++;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_rob_flag(this.isRob));
		gs.getMapService().syncRoleUpdateCarBehavior(this.id, this.gameMapContext.getCurMapId(), (byte)0, this.isRob);
	}

	/////////////////////////////////////////帮派运镖end/////////////////////////////////////
	

	public boolean bagMerge(int itemId)
	{
		int unbindid = itemId > 0 ? -itemId : itemId;
		CellItem ubinditem = this.getBagItem(unbindid);
		if(ubinditem == null || ubinditem.getCount() <= 0)
			return false;
		int unbindcount = ubinditem.getCount();
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MERGE_BAG);
		tlogEvent.setArg(-unbindid, unbindcount);
		this.delGameItem(unbindid, unbindcount, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(-unbindid, unbindcount), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	//---------------------------------------------------------势力战----------------------------------------------------------------
	class RoleForceWar
	{
		SBean.DBRoleForceWar forcewar;
		int joinTime;
		int totalFeatLvl;
		int joinType;
		
		RoleForceWar()
		{
			
		}
		
		RoleForceWar fromDB(SBean.DBRoleForceWar warData)
		{
			this.forcewar = warData;
			
			this.totalFeatLvl = GameData.getInstance().getForceWarTotalFeatLvl(this.forcewar.totalFeats);
			return this;
		}
		
		SBean.DBRoleForceWar toDB()
		{
			return this.forcewar.kdClone();
		}
		
		void doRefresh()
		{
			this.forcewar.log.dayEnterTimes = 0;
		}
	}
	
	void dayRefreshForceWar()
	{
		this.forceWarInfo.doRefresh();
	}
	
	void checkForceWar(int timeTick)
	{
		if(this.forceWarInfo.joinTime == 0)
			return;
		
		if(timeTick - this.forceWarInfo.joinTime > GameData.getInstance().getForceWarBaseCFGS().match.timeout)
		{
			this.timeOutQuitForceWar(GameData.PROTOCOL_OP_FORCEWAR_MATCH_TIMEOUT);
			return;
		}
		
		SBean.ForceWarCFGS cfg = GameData.getInstance().getForceWarCFGS(this.forceWarInfo.joinType);
		if(cfg == null)
			return;
		int weekDay = GameTime.getWeekdayByOffset(GameTime.getTime(), GameData.GAME_DAY_REFRESH_TIME * 3600);
		if (!cfg.openDays.contains(weekDay) ||!GameData.checkInOpenTime(cfg.openStartTime, cfg.openLastTime))
		{
			this.timeOutQuitForceWar(GameData.PROTOCOL_OP_FORCEWAR_OUT_OPENTIME);
			return;
		}
	}
	
	private int testCanEnterFRoom(int forcewarType)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isMulRolesState())
			return GameData.PROTOCOL_OP_FAILED;

		int ok = checkForceWarCond(forcewarType);
		if(ok <= 0)
			return ok;

		if (this.isInRoom())
			return GameData.PROTOCOL_OP_FAILED;
		
		if(this.isInJoinState())
			return GameData.PROTOCOL_OP_FROOM_ROLE_MATCHING;
			
		if(this.forceWarInfo.forcewar.punishEndTime > GameTime.getTime())
			return GameData.PROTOCOL_OP_FROOM_ROLE_PUNISH;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private boolean isNotInFRoomOrFRoomFull()
	{
		return (this.froom.id <= 0 || this.arenaroom.members.size() >= GameData.FORCEWAR_ROOM_MAX_COUNT);
	}
	
	private boolean isInFRoomAndRoleBeInvited(int rid)
	{
		return this.froom.id > 0 && this.froomInvites.contains(rid);
	}
	
	boolean isInFRoom()
	{
		return this.froom.id > 0;
	}
	
	private boolean isFRoomLeader()
	{
		return this.froom.id > 0 && this.froom.leader == this.id;
	}
	
	private boolean isRoleInMyFRoom(int rid)
	{
		for(int memberID: this.froom.members)
		{
			if(memberID == rid)
				return true;
		}
		return false;
	}
	
	// 自己加入房间
	synchronized void onSelfJoinFRoom(SBean.FRoom room)
	{
		this.froom = room;
		this.froomInvites.clear();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.froom_sync(room));
	}
	
	void onNewMemberJoinFRoom(Role newMember)
	{
		synchronized(this)
		{
			this.froom.members.add(newMember.id);
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.froom_join(newMember.getRoleOverview()));
	}
	
	private void clearFRoom()
	{
		this.froom.id = 0;
		this.froom.leader = 0;
		this.froom.members.clear();
	}
	
	synchronized void onFRoomMemberLeave(Role member)
	{
		if (member.id == this.id)
		{
			this.clearFRoom();
		}
		else
		{
			this.froom.members.remove(Integer.valueOf(member.id));
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.froom_leave(member.id, member.name));
	}
	
	synchronized void onFRoomLeaderChange(Role newLeader)
	{
		this.froom.leader = newLeader.id;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.froom_change_leader(newLeader.id, newLeader.name));
	}
	
	// 自己或队友被踢
	synchronized void onFRoomMemberKicked(Role member)
	{
		if (member.id == this.id)
		{
			this.clearFRoom();
		}
		else
		{
			this.froom.members.remove(Integer.valueOf(member.id));
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.froom_kick(member.id, member.name));
	}
	
	int froomNewCreate(int forcewarType)
	{
		int ok = checkForceWarCond(forcewarType);
		if(ok <= 0)
			return ok;

		Set<Integer> members = new HashSet<>();
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;

			if (this.isInMulRolesActivity() || this.isInJoinState())
				return GameData.PROTOCOL_OP_FAILED;

			if (!this.isTeamLeader())
				return GameData.PROTOCOL_OP_FAILED;
			
			members.addAll(this.team.members);
		}

		Set<Role> suitMembers = new HashSet<>();
		for (int rid : members)
		{
			if (rid != this.id)
			{
				Role iRole = gs.getLoginManager().getOnGameRole(rid);
				if (iRole == null)
					return GameData.PROTOCOL_OP_FROOM_ROLE_OFFLINE;
				
				synchronized(iRole)
				{
					if(forcewarType == GameData.FORCEWAR_TYPE_BWTYPE && iRole.BWType != this.BWType)
						return GameData.PROTOCOL_OP_FROOM_ROLE_COND_FAIL;
					
					int error = iRole.testCanEnterFRoom(forcewarType);
					if (error <= 0)
						return error;
				}
				suitMembers.add(iRole);
			}
		}
		
		int roomID = gs.getForceWarRoomManager().createRoom(this, forcewarType);
		if (roomID <= 0)
			return roomID;

		suitMembers.forEach(role ->
		{
			this.froomInvites.add(role.id);
			gs.getRPCManager().sendStrPacket(role.netsid, new SBean.froom_invite_forward(this.id, this.name, roomID, forcewarType));
		});

		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	// 邀请者必须在房间，是否为队长都可以邀请，不同于队伍，被邀请者要满足势力战要求
	public int froomInvite(int invitedRoleID)
	{
		if (invitedRoleID == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role iRole = gs.getLoginManager().getOnGameRole(invitedRoleID);
		if (iRole == null)
			return GameData.PROTOCOL_OP_FROOM_ROLE_OFFLINE;
		
		int forcewarType = 0;
		synchronized (this)
		{
			if(this.isInJoinState())
				return GameData.PROTOCOL_OP_FAILED;
			
			if (!this.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;

			if (this.isNotInFRoomOrFRoomFull())
				return GameData.PROTOCOL_OP_FROOM_ROOM_FULL;
			
			forcewarType = this.froom.type;
			this.froomInvites.add(invitedRoleID);
		}

		synchronized (iRole)
		{
			int error = iRole.testCanEnterFRoom(forcewarType);
			if (error <= 0)
				return error;
		}

		gs.getRPCManager().sendStrPacket(iRole.netsid, new SBean.froom_invite_forward(this.id, this.name, this.froom.id, forcewarType));
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	// 势力战房间玩家被邀请后弹框的选择结果
	public int froomInvitedby(int inviteStartRoleID, int roomID, int accept)
	{
		if (inviteStartRoleID == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role sRole = gs.getLoginManager().getOnGameRole(inviteStartRoleID);
		if (sRole == null)
			return GameData.PROTOCOL_OP_AROOM_ROLE_OFFLINE;
		
		if (accept == 0)
		{
			gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.froom_invite_refuse(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		else if (accept == -1)
		{
			gs.getRPCManager().sendStrPacket(sRole.netsid, new SBean.froom_invite_busy(this.id, this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		
		int forcewarType = 0;
		synchronized(sRole)
		{
			if (!sRole.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;
			
			if(!sRole.isInFRoomAndRoleBeInvited(this.id))
				return GameData.PROTOCOL_OP_FAILED;
			
			if(sRole.froom.id != roomID)
				return GameData.PROTOCOL_OP_FAILED;
			
			if(sRole.isInJoinState())
				return GameData.PROTOCOL_OP_FROOM_ROLE_MATCHING;
			
			forcewarType = sRole.froom.type;
		}
		
		synchronized(this)
		{
			int error = this.testCanEnterFRoom(forcewarType);
			if (error <= 0)
				return error;
		}
		
		Role.MultipleRoles mr = new Role.MultipleRoles(sRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_FROOM_ROLE_OFFLINE;

			return gs.getForceWarRoomManager().addRoomMember(inviteStartRoleID, this);
		}
		finally
		{
			mr.unlock();
		}
	}
	
	// 房主踢人
	public int froomKick(int kickedRoleID)
	{
		if (kickedRoleID == this.id)
			return GameData.PROTOCOL_OP_FAILED;

		Role kickedRole = gs.getLoginManager().getOnGameRole(kickedRoleID);
		if (kickedRole == null)
			return GameData.PROTOCOL_OP_FAILED;

		synchronized (this)
		{
			if (!this.isFRoomLeader() || !this.isRoleInMyFRoom(kickedRoleID))
				return GameData.PROTOCOL_OP_FAILED;
		}

		Role.MultipleRoles mr = new Role.MultipleRoles(kickedRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_FROOM_ROLE_OFFLINE;

			return gs.getForceWarRoomManager().kickRoomMember(this, kickedRole) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}
	
	public int leaveFRoom()
	{
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap() || !this.isInFRoom())
				return GameData.PROTOCOL_OP_FAILED;
		}

		return gs.getForceWarRoomManager().roomMemberLeave(this) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
	}
	
	public int froomChangeLeader(int newLeaderID)
	{
		if (newLeaderID == this.id)
			return GameData.PROTOCOL_OP_FAILED;

		Role newLeaderRole = gs.getLoginManager().getOnGameRole(newLeaderID);
		if (newLeaderRole == null)
			return GameData.PROTOCOL_OP_FROOM_ROLE_OFFLINE;

		synchronized (this)
		{
			if (!this.isFRoomLeader())
				return GameData.PROTOCOL_OP_FAILED;

			if (!this.isRoleInMyFRoom(newLeaderID))
				return GameData.PROTOCOL_OP_FAILED;
		}

		Role.MultipleRoles mr = new Role.MultipleRoles(this, newLeaderRole);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_FROOM_ROLE_OFFLINE;
			return gs.getForceWarRoomManager().froomChangeLeader(this, newLeaderRole) ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
		}
		finally
		{
			mr.unlock();
		}
	}
	
	public void queryFRoomRoles()
	{
		synchronized (this)
		{
			if (!this.gameMapContext.isInWorldMap() || this.froom.id == 0)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.froom_members_overview(GameData.emptyList(), GameData.emptyMap()));
				return;
			}
		}

		gs.getForceWarRoomManager().getRoleRoomRoles(this);
	}
	
	void queryFRoomRole(int qRid)
	{
		Role role = gs.getLoginManager().getOnGameRole(qRid);
		if (role != null)
		{
			synchronized (role)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.froom_member_overview(role.getRoleOverview(), role.netsid));
			}
		}
	}
	
	void notifyFRoomMemberUpdateConnectionState(int state)
	{
		if (this.froom.id > 0)
		{
			for (int rid : this.froom.members)
			{
				if (rid != this.id)
				{
					Role role = gs.getLoginManager().getOnGameRole(rid);
					if (role != null)
					{
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.froom_member_connection(this.id, state));
					}
				}
			}
		}
	}
	
	synchronized void roleSyncForceWar()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.forcewar_sync_res(this.forceWarInfo.forcewar.log.kdClone(), this.forceWarInfo.forcewar.punishEndTime));
	}
	
	void roleJoinForceWar(int forcewarType)
	{
		synchronized(this)
		{
			if(!checkCanJoinForceWar(forcewarType))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.forcewar_join_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}
		
		if(this.froom.id == 0)
			this.singleJoinForceWar(forcewarType);
		else
			this.teamJoinForceWar();
	}
	
	synchronized void singleJoinForceWar(int forcewarType)
	{
		gs.getFightService().roleJoinForceWarImpl(this.getForceWarJoin(), forcewarType, ok -> 
		{
			if(ok > 0)
			{
				this.forceWarInfo.joinTime = GameTime.getTime();
				this.forceWarInfo.joinType = forcewarType;
			}
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.forcewar_join_res(ok));
			gs.getTLogger().logForceWarFlow(Role.this, 0, TLog.COPYEVENT_APPLY, false);
		});
	}
	
	void teamJoinForceWar()
	{
		gs.getForceWarRoomManager().teamJoin(this.id, ok ->
		{
			synchronized(this)
			{
				if(ok > 0)
				{
					this.forceWarInfo.joinTime = GameTime.getTime();
					this.forceWarInfo.joinType = this.froom.type;
				}
			}
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.forcewar_join_res(ok));
			gs.getTLogger().logForceWarFlow(Role.this, 1, TLog.COPYEVENT_APPLY, true);
		});
	}
	
	private boolean checkCanJoinForceWar(int forcewarType)
	{
		if (!this.gameMapContext.isInWorldMap() || this.isMulRolesState())
			return false;

		if (this.isInARoom() || this.isInMRoom())
			return false;
		
		if(this.isInJoinState())
			return false;
			
		if(this.forceWarInfo.forcewar.punishEndTime > GameTime.getTime())
			return false;
		
		return checkForceWarCond(forcewarType) > 0;
	}
	
	private int checkForceWarCond(int forcewarType)
	{
		if(GameTime.getDay() - GameTime.getDay(gs.getOpenTime()) < GameData.getInstance().getForceWarBaseCFGS().match.openDayLimit)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.ForceWarCFGS forcewar = GameData.getInstance().getForceWarCFGS(forcewarType);
		if(forcewar == null || this.BWType == 0 || this.level < forcewar.lvlReq)
			return GameData.PROTOCOL_OP_FROOM_ROLE_COND_FAIL;
		
		int weekDay = GameTime.getWeekdayByOffset(GameTime.getTime(), GameData.GAME_DAY_REFRESH_TIME * 3600);
		if (!forcewar.openDays.contains(weekDay) ||!GameData.checkInOpenTime(forcewar.openStartTime, forcewar.openLastTime))
			return GameData.PROTOCOL_OP_FAILED;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	synchronized void timeOutQuitForceWar(int errorCode)
	{
		this.roleQuitForceWar(ok -> 
		{
			if(ok > 0)
				this.syncRoleForceWarMatch(errorCode);
		});
	}
	
	interface ForceWarQuitCallBack
	{
		void onCallback(int ok);
	}
	
	void roleQuitForceWar(ForceWarQuitCallBack callback)
	{
		if(this.forceWarInfo.joinTime == 0)
		{
			if(callback != null)
				callback.onCallback(GameData.PROTOCOL_OP_FAILED);
			return;
		}
		
		if(this.froom.id == 0)
			this.singleQuitForceWar(callback);
		else
			this.teamQuitForceWar(callback);
	}
	
	void singleQuitForceWar(ForceWarQuitCallBack callback)
	{
		gs.getFightService().roleQuitForceWarImpl(this.id, this.BWType, this.forceWarInfo.joinType, ok ->
		{
			synchronized(this)
			{
				this.forceWarInfo.joinTime = 0;
				this.forceWarInfo.joinType = 0;
			}
			
			if(callback != null)
				callback.onCallback(ok);
		});
	}
	
	void teamQuitForceWar(ForceWarQuitCallBack callback)
	{
		gs.getForceWarRoomManager().teamQuit(this, callback);
	}
	
	synchronized void syncRoleForceWarMatch(int ok)
	{
		this.syncRoleForceWarMatchImpl(ok);
		gs.getFightService().delForceWarJoinRole(this.id);
	}
	
	synchronized void syncRoleForceWarMatchImpl(int ok)
	{
		this.forceWarInfo.joinTime = 0;
		this.forceWarInfo.joinType = 0;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.forcewar_match(ok));
	}
	//--------------------------------------------------------势力战end--------------------------------------------------------------
	
	//--------------------------------------------------------七日留存--------------------------------------------------------------
	synchronized boolean takeRemainActivityReward(int pos)
	{
		if(this.rmactivity + 1 != pos)
			return false;
		
		final SBean.RemainActivityCFGS rac = GameData.getInstance().getRemainActivityCFGS(pos);		
		if(rac == null || !checkRemainActivityConf(rac))
			return false;
		
		final Map<Integer, Integer> reward = rac.rewards.get((int)(this.classType - 1)).dummyGoods;
		if(!this.canAddGameItems(reward))
			return false;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_REMAIN_ACTIVITY_REWARD);
		tlogEvent.setArg(pos);
		List<SBean.GameItem> gi = GameData.getInstance().toGameItems(reward);
		this.syncAddGameItems(gi, tlogEvent);
		this.rmactivity = pos;
		if (this.rmactivity + 1 == GameData.getInstance().getHeirloomCFGS().remainIndex)
			this.rmactivity++;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	private boolean checkRemainActivityConf(final SBean.RemainActivityCFGS rac)
	{
		switch (rac.type)
		{
		case GameData.REMAIN_ACTIVITY_TYPE_LEVEL:
			return this.level >= rac.cond;
		case GameData.REMAIN_ACTIVITY_TYPE_LOGINDAYS:
			return this.loginDays >= rac.cond;
		default:
			return false;
		}
	}
	//------------------------------------------------------七日留存end-------------------------------------------------------------
	public void roleRename(String newName, int type)
	{
		SBean.CommonRenameCFGS renameCfg = GameData.getInstance().getCommonCFG().rename;
		int costItemID = type == GameData.ROLE_RENAME_COST_TYPE_DIAMOND ? -GameData.COMMON_ITEM_ID_DIAMOND : renameCfg.costItemID;
		int costCount = type == GameData.ROLE_RENAME_COST_TYPE_DIAMOND ? renameCfg.diamondCost : 1;
		synchronized(this)
		{
			if(!GameData.getInstance().checkInputStrValid(newName, GameData.getInstance().getCommonCFG().input.maxRoleNameLength, true))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_rename_res(GameData.PROTOCOL_OP_RENAME_INVALID));
				return;
			}
			
			if(newName.equals(this.name) || !this.containsEnoughGameItem(costItemID, costCount))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_rename_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}
		gs.getLoginManager().roleRename(this.id, this.name, newName, errCode -> 
		{
			synchronized (Role.this)
			{
				if(errCode == 0)	//success
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ROLE_RENAME);
					tlogEvent.setArg(costItemID, costCount);
					this.delGameItem(costItemID, costCount, tlogEvent.getGameItemRecords());
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
					Role.this.onlineSave(GameTime.getTime());
				}
			}
			
			if(errCode == 0)
				Role.this.onRoleNameChange(newName);
			
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_rename_res(errCode == 0 ? GameData.PROTOCOL_OP_SUCCESS : errCode));
		});
	}
	
	private void onRoleNameChange(String newName)
	{
		Set<Integer> eachFriends = new HashSet<>();
		String oldName = new String(this.name);
		synchronized(this)
		{
			this.name = newName;
			this.updateRanks();
			
			MarriageShare share = this.getSharedMarriage();
			if (share != null)
			{
				gs.getLoginManager().exeCommonRoleVisitor(this.getMarriagePartnerId(), false, new LoginManager.CommonRoleVisitor()
				{
					@Override
					public boolean visit(Role role, Role sameUserRole)
					{
						role.marriageData.partnerName = newName;
						gs.getRPCManager().sendStrPacket(role.netsid, new SBean.role_marriage_partner_name(newName));
						return true;
					}
					
					@Override
					public void onCallback(boolean success)
					{
					}
				});
			}
			
			for(int rid: this.friend.friendData.friends.keySet())
			{
				if(this.friend.friendData.fans.contains(rid))
					eachFriends.add(rid);
			}
			
		}
		
		StringBuilder content = new StringBuilder();
		content.append(oldName);
		content.append("|");
		content.append(newName);
		for(int rid: eachFriends)
		{
			gs.getLoginManager().sysSendMail(rid, MailBox.SysMailType.FriendRename, MailBox.FRIEND_RENAME_MAIL_MAX_RESERVE_TIME, content.toString(), new ArrayList<>(), new ArrayList<>());
			gs.getLogger().debug("mail role " + rid + " friend change name " + content.toString());
		}
		
		gs.getSectManager().onRoleInfoChanged(this);
		gs.getLoginManager().changeMessageBoardName(this.id, newName);
		if (this.marriageData.marriageShareId != 0)
			gs.getLoginManager().changeMarriageBespeakName(this.marriageData.marriageShareId, this.id, newName);
		gs.getMapService().syncMapRoleRename(this.gameMapContext.getCurMapId(), this.id, newName);
	}
	
	public synchronized void updateFightState(int mapID, int mapInstance, boolean fightState)
	{
		if(mapID == this.gameMapContext.getCurMapId() && mapInstance == this.gameMapContext.getCurMapInstance())
		{
			this.fightState = fightState;
			
			if(fightState)
			{
				if(this.mulRolesLock > 0)
					this.mulRolesLock++;
				else
				{
					if(this.mulRoleInfo.leader > 0)
						this.clearMulRole();
					else
						this.roleUnRide();
				}
			}
		}
	}

	public synchronized void changePetCanUsePool(byte canUsePool)
	{
		if (canUsePool == 0)
			this.petCanUsePool = false;
		else 
			this.petCanUsePool = true;
	}

	public synchronized void syncCurPetHp(int mapID, int mapInstance, int petID, SBean.Hp hpState)
	{
		this.gameMapContext.getCurMapContext().putPetHp(mapID, mapInstance, petID, hpState);
	}
	
	//--------------------------------------------留言板--------------------------------------------------------------------
	public void syncMessageBoards()
	{
		byte hasNewMsg = 0;
		if (this.messageBoardLastSyncTime < gs.getLoginManager().getMessageBoard().getConSideLastChangeTime() && gs.getLoginManager().getMessageBoard().hasConSideMsg())
			hasNewMsg = 1;
		this.messageBoardLastSyncTime = GameTime.getTime();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sync_message_board_res(gs.getLoginManager().getMessageBoard().syncMessageBoard(), hasNewMsg));
	}

	public synchronized void addOrReplaceMessageBoard(int side, int msgId, String content, int time, byte anonymous, int isrewrite)
	{
		SBean.MessageBoardCFGS msgCFGS = GameData.getInstance().getMessageBoardCFGS(side, msgId);
		SBean.MessageBoardCommonCFGS msgCommonCFGS = GameData.getInstance().getMessageBoardCommonCFGS();
		if (msgCFGS == null || msgCommonCFGS == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		if (this.level < msgCommonCFGS.openLevel)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_LEVEL_NEED));
			return;
		}
		if (!GameData.getInstance().checkInputStrValid(content, msgCFGS.maxLength, false))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_CONTENT_NOT_VALID));
			return;
		}
		if (isrewrite == 0 && !gs.getLoginManager().getMessageBoard().isMsgCanUse(side, msgId))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_USED));
			return;
		}
		if (isrewrite == 1 && gs.getLoginManager().getMessageBoard().isMsgCanUse(side, msgId))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_UN_USED));
			return;
		}
		if (!gs.getLoginManager().getMessageBoard().isTimeValid(side, msgId, time))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_TIME_INVALID));
			return;
		}
		int costnum = isrewrite == 1 ? Math.round(msgCFGS.timeCost.get(time) * msgCFGS.rewritePercent) : msgCFGS.timeCost.get(time);
		if ((msgCFGS.consumeType == GameData.GAME_ITEM_TYPE_COIN && !canUseCoin(costnum, true)) || (msgCFGS.consumeType == GameData.GAME_ITEM_TYPE_DIAMOND && !canUseDiamond(costnum, true)))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_NOT_ENOUGH_MONEY));
			return;
		}
		SBean.Counter counter = new SBean.Counter();
		if (msgCFGS.consumeType == GameData.GAME_ITEM_TYPE_COIN)
			counter = this.lockCoin(costnum, true);
		if (msgCFGS.consumeType == GameData.GAME_ITEM_TYPE_DIAMOND)
			counter = this.lockDiamond(costnum, true);
		final SBean.Counter finalcounter = counter;
		final int oldRoleId = gs.getLoginManager().getCurMsgRole(side, msgId);
		gs.getLoginManager().addOrReplaceMessageBoard(side, msgId, this, time, content, anonymous, (errCode) ->
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ADD_MESSAGE_BOARD);
			tlogEvent.setArg(-msgCFGS.consumeType, costnum);
			if (msgCFGS.consumeType == GameData.GAME_ITEM_TYPE_COIN)
				this.useLockedCoin(finalcounter, errCode <= 0, tlogEvent.getGameItemRecords());
			if (msgCFGS.consumeType == GameData.GAME_ITEM_TYPE_DIAMOND)
				this.useLockedDiamond(finalcounter, errCode <= 0, tlogEvent.getGameItemRecords());
			if (errCode > 0)
			{
				if (side == GameData.MESSAGE_BOARD_SIDE_CON)
					gs.getLoginManager().getMessageBoard().setConSideLastChangeTime(GameTime.getTime());
				gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
				gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_ADD_MESSAGE_BOARD, anonymous == 1 ? msgCommonCFGS.anonymousName : this.name);
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_SUCCESS));
				if (isrewrite == 1)
					gs.getLoginManager().sysSendMail(oldRoleId, MailBox.SysMailType.BeRewrite, MailBox.BE_REWRITE_MAIL_MAX_RESERVE_TIME, msgCommonCFGS.replaceNotice, new ArrayList<>(), new ArrayList<>());
			}
			else
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_message_board_res(GameData.PROTOCOL_OP_FAILED));
			}
		});
	}

	public synchronized void commentMessageBoard(int side, int msgid, int comment, int sendtime)
	{
		SBean.MessageBoardCommonCFGS msgCommonCFGS = GameData.getInstance().getMessageBoardCommonCFGS();
		if (msgCommonCFGS == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.comment_message_board_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		if (this.level < msgCommonCFGS.openLevel)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.comment_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_LEVEL_NEED));
			return;
		}
		if (this.messageBoardDayCommentTimes >= GameData.getInstance().getMessageBoardCommonCFGS().dayCommentTime)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.comment_message_board_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_NEED_COMMONT_TIME));
			return;
		}
		gs.getLoginManager().commontMessageBoard(side, msgid, comment, sendtime, (ok) ->
		{
			if (ok > 0)
			{
				if (side == GameData.MESSAGE_BOARD_SIDE_CON)
					gs.getLoginManager().getMessageBoard().setConSideLastChangeTime(GameTime.getTime());
				this.messageBoardDayCommentTimes++;
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.comment_message_board_res(GameData.PROTOCOL_OP_SUCCESS));
			}
			else
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.comment_message_board_res(ok));
		});

	}

	public void changeMessageBoardContent(int side, int msgId, String content, int sendtime)
	{
		SBean.MessageBoardCFGS msgCFGS = GameData.getInstance().getMessageBoardCFGS(side, msgId);
		if (msgCFGS == null){
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.change_message_board_content_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		if (!GameData.getInstance().checkInputStrValid(content, msgCFGS.maxLength, false)){
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.change_message_board_content_res(GameData.PROTOCOL_OP_MESSAGE_BOARD_CONTENT_NOT_VALID));
			return;
		}
		gs.getLoginManager().changeMessageBoardContext(side, this.id, msgId, content, sendtime, (ok) ->
		{
			if (ok > 0)
			{
				if (side == GameData.MESSAGE_BOARD_SIDE_CON)
					gs.getLoginManager().getMessageBoard().setConSideLastChangeTime(GameTime.getTime());
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.change_message_board_content_res(GameData.PROTOCOL_OP_SUCCESS));
			}
			else
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.change_message_board_content_res(ok));
		});
	}

	private void dayRefreshMessageBoard()
	{
		this.messageBoardDayCommentTimes = 0;
	}

		
	//---------------------------------------------日程表----------------------------------------------------	
		
	public SBean.DBSchedule syncSchedule()
	{
		return this.schedule.kdClone();
	}

	private void addScheduleActivity(int addactivity, int type, int mapId)
	{
		if(addactivity > 0)
		{
			int old = this.schedule.activity;
			this.schedule.activity += addactivity;
			Role.this.masterLogGraduateTaskWithoutLock(GameData.MASTER_GRADUATE_TASK_ACTIVITY, addactivity);
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ADD_ACTIVITY);
			tlogEvent.setArg(type, mapId, this.schedule.activity - old);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			// 此处的最大活跃度是指提供给帮派的最大活跃度，并不是每个人可获取的最大活跃度
			final int activityMax = GameData.getInstance().getCommonCFG().activityMax;
			int sectAddActivity = old >= activityMax ? 0 : (this.schedule.activity > activityMax ? activityMax - old: this.schedule.activity - old);
			if(sectAddActivity > 0)
			{
				gs.getLoginManager().addNormalTaskEvent(new Runnable()
				{
					@Override
					public void run()
					{
						gs.getSectManager().roleDedicateActivity(Role.this, sectAddActivity);
					}
				});
			}
		}
	}

	public synchronized void bonusSchedule(int sid)
	{
		if (canBonus(sid))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.schedule_mapreward_res(GameData.PROTOCOL_OP_SCHEDULE_CONDITION_NEED, GameData.emptyMap()));
			return;
		}

		SBean.ScheduleDropCFGS cfg = GameData.getInstance().getScheduleRewards(sid, this.level);

		if (cfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.schedule_mapreward_res(GameData.PROTOCOL_OP_FAILED, GameData.emptyMap()));
			return;
		}
		Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();
		GameData.getMergedDrops(cfg.fixedDropID, cfg.randomDropIDs, cfg.randomDropCnt, 1, 1, null, drops);

		List<SBean.GameItem> gis = GameData.getInstance().toGameItems(drops);
		if (gis.isEmpty())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.schedule_mapreward_res(GameData.PROTOCOL_OP_FAILED, GameData.emptyMap()));
			return;
		}
		if (!this.canAddGameItems(gis))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.schedule_mapreward_res(GameData.PROTOCOL_OP_SCHEDULE_BAG_FULL, GameData.emptyMap()));
			return;
		}
		this.schedule.rewards.add(sid);

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_SCHEDULE_REWARD);
		tlogEvent.setArg(sid);
		this.syncAddGameItems(gis, tlogEvent);

		gs.getTLogger().logScheduleTaskFlow(this, sid);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.schedule_mapreward_res(GameData.PROTOCOL_OP_SUCCESS, drops));
	}

	public synchronized void logTaskScheduleData(int type)
	{
		int taskNum = this.schedule.task2num.merge(getScheduleKey(type, 0), 1, (ov, nv) -> ov + nv);
		SBean.ScheduleDataCFGS scheduleData = GameData.getInstance().getScheduleData(type);
		if (scheduleData == null || taskNum > scheduleData.num)
			return;
		addScheduleActivity(scheduleData.activity, type, 0);
	}

	public void logMapScheduleData(int mapId, int oldEnterTimes, int enterTimes)
	{
		SBean.ScheduleDataCFGS scheduleData = GameData.getInstance().getScheduleDatabyMapId(0, mapId);
		if (scheduleData == null || oldEnterTimes > scheduleData.num || scheduleData.type < 1 || scheduleData.type > 4)
			return;
		int taskNum = this.schedule.task2num.merge(getScheduleKey(scheduleData.type, mapId), enterTimes, (ov, nv) -> ov + nv);
		addScheduleActivity(scheduleData.activity * (taskNum > scheduleData.num ? scheduleData.num - oldEnterTimes : enterTimes), scheduleData.type, mapId);
	}

	public void logExchangeScheduleData(int npcId)
	{
		int taskNum = this.schedule.task2num.merge(getScheduleKey(GameData.SCHEDULE_TYPE_EXCHANGE, npcId), 1, (ov, nv) -> ov + nv);
		SBean.ScheduleDataCFGS scheduleData = GameData.getInstance().getScheduleDatabyMapId(GameData.SCHEDULE_TYPE_EXCHANGE, npcId);
		if (scheduleData == null || taskNum > scheduleData.num || scheduleData.type != GameData.SCHEDULE_TYPE_EXCHANGE)
			return;
		addScheduleActivity(scheduleData.activity, GameData.SCHEDULE_TYPE_EXCHANGE, npcId);
	}

	public void logNpcMapScheduleData(int groupId)
	{
		int taskNum = this.schedule.task2num.merge(getScheduleKey(GameData.SCHEDULE_TYPE_NPC_MAP, groupId), 1, (ov, nv) -> ov + nv);
		SBean.ScheduleDataCFGS scheduleData = GameData.getInstance().getScheduleDatabyMapId(GameData.SCHEDULE_TYPE_NPC_MAP, groupId);
		if (scheduleData == null || taskNum > scheduleData.num || scheduleData.type != GameData.SCHEDULE_TYPE_NPC_MAP)
			return;
		addScheduleActivity(scheduleData.activity, GameData.SCHEDULE_TYPE_NPC_MAP, groupId);
	}
	
	private void logTDScheduleData(int mapID)
	{
		int taskNum = this.schedule.task2num.merge(getScheduleKey(GameData.SCHEDULE_TYPE_TOWER_DEFENCE, mapID), 1, (ov, nv) -> ov + nv);
		SBean.ScheduleDataCFGS scheduleData = GameData.getInstance().getScheduleDatabyMapId(GameData.SCHEDULE_TYPE_TOWER_DEFENCE, mapID);
		if (scheduleData == null || taskNum > scheduleData.num || scheduleData.type != GameData.SCHEDULE_TYPE_TOWER_DEFENCE)
			return;
		addScheduleActivity(scheduleData.activity, GameData.SCHEDULE_TYPE_TOWER_DEFENCE, mapID);
	}
	
	private int getScheduleKey(int type, int mapId)
	{
		return type << 16 | mapId;
	}

	private void dayRefreshSchedule()
	{
		this.schedule.task2num.clear();
		this.schedule.rewards.clear();
		this.schedule.activity = 0;
	}

	public SBean.DBSchedule initScheduleData()
	{
		return new SBean.DBSchedule(0, new HashMap<Integer, Integer>(), new HashSet<Integer>(), 0, 0);
	}

	private boolean canBonus(int sid)
	{
		int activity = GameData.getInstance().getScheduleActivity(sid);
		return activity < 0 || activity > this.schedule.activity || this.schedule.rewards.contains(sid);
	}

	public void tryLogBossScheduleData()
	{
		if (this.schedule.task2num.getOrDefault(getScheduleKey(GameData.SCHEDULE_TYPE_KILL_MAPBOSS, 0), 0) == 0)
		{
			this.logTaskScheduleData(GameData.SCHEDULE_TYPE_KILL_MAPBOSS);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_touch_boss());
		}
	}

//-------------------------------------------------------------------------多人骑乘---------------------------------------------------------------------------------------------
	private boolean testRoleNearBy(Role role, int distance)
	{
		return this.gameMapContext.getCurMapId() == role.gameMapContext.getCurMapId() && 
				this.gameMapContext.getCurMapInstance() == role.gameMapContext.getCurMapInstance() &&
						GameData.testNearByPosition(this.gameMapContext.getCurMapPosition(), role.gameMapContext.getCurMapPosition(), distance);
	}
	
	synchronized int isMulHorseFull()
	{
		if(this.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
			return -1;
		
		for(int index = 0; index < this.mulRoleInfo.members.size(); index++)
		{
			if(this.mulRoleInfo.members.get(index) == 0)
				return index;
		}
		
		return -1;
	}
	
	synchronized boolean isMulRolesEmpty()
	{
		for(int rid: this.mulRoleInfo.members)
		{
			if(rid > 0)
				return false;
		}
		
		return true;
	}
	
	synchronized boolean isMulRolesState()
	{
		return !this.isMulRolesEmpty() || this.isMulRolesMember() || this.mulRolesLock != 0;
	}
	
	synchronized boolean isMulRolesMember()
	{
		return this.mulRoleInfo.leader > 0 && this.mulRoleInfo.leader != this.id; 
	}
	
	synchronized void mulHorseAddMember(int pos, int memberID)
	{
		this.mulRoleInfo.members.set(pos, memberID);
		if(this.isMulHorseFull() < 0)
		{
			this.mulHorseApplys.clear();
			this.mulHorseInvites.clear();
		}
		gs.getMapService().syncRoleUpdateMulHorse(this.gameMapContext.getCurMapId(), this.mulRoleInfo.leader, pos, memberID);
	}
	
	synchronized boolean mulHorseDelMember(int memberID)
	{
		if(this.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
			return false;
		
		for(int index = 0; index < this.mulRoleInfo.members.size(); index++)
		{
			if(this.mulRoleInfo.members.get(index) == memberID)
			{
				this.mulRoleInfo.members.set(index, 0);
				gs.getMapService().syncRoleUpdateMulHorse(this.gameMapContext.getCurMapId(), this.mulRoleInfo.leader, index, 0);
				return true;
			}
		}
		
		return false;
	}
	
	synchronized void onSelfJoinMulHorse(int leaderID)
	{
		this.mulRoleInfo.leader = leaderID;
		this.mulRoleInfo.type = GameData.MULROLE_TYPE_HORSE;
		this.mulRoleInfo.members.clear();
		this.mulHorseApplys.clear();
	}
	
	void onSelfLeaveMulHorse()
	{
		Role leader = gs.getLoginManager().getOnGameRole(this.mulRoleInfo.leader);
		if(leader != null)
		{
			leader.mulHorseDelMember(this.id);
		}
		
		synchronized(this)
		{
			this.mulRoleInfo.leader = 0;
			this.mulRoleInfo.type = 0;
		}
	}
	
	private boolean isInRoom()
	{
		return this.isInARoom() || this.isInMRoom() || this.isInFRoom();
	}
	
	synchronized boolean isInMulRolesActivity()
	{
		return this.isInRoom() || this.isInJoinState();
	}
	
	synchronized boolean isInJoinState()
	{
		return this.superarenaState > 0 || this.forceWarInfo.joinTime > 0;
	}
	
	//邀请别人上多人骑乘
	public int mulHorseInvite(int rid)
	{
		if(rid == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role iRole = gs.getLoginManager().getOnGameRole(rid);
		if(iRole == null)
			return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;
		
		synchronized(iRole)
		{
			if(iRole.isInMulRolesActivity() || iRole.escortCar.getCarID() > 0 || iRole.alterState.alterID > 0)
				return GameData.PROTOCOL_OP_MULHORSE_BUSY;
			
			if(iRole.isMulRolesState() || iRole.gameMapContext.getCurMapContext().getCurRideHorse() > 0)
				return GameData.PROTOCOL_OP_MULHORSE_OTHER_RIDE;
			
			if(iRole.fightState)
				return GameData.PROTOCOL_OP_MULHORSE_IN_FIGHT;
		}
		
		synchronized(this)
		{
			if(this.isInMulRolesActivity())
				return GameData.PROTOCOL_OP_FAILED; 
			
			if(this.id != this.mulRoleInfo.leader || this.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
				return GameData.PROTOCOL_OP_MULHORSE_SELF_UNRIDE;
			
			if(this.isMulHorseFull() < 0)
				return GameData.PROTOCOL_OP_MULHORSE_SELF_FULL;
			
			if(!this.testRoleNearBy(iRole, GameData.getInstance().getHorseCommonCFGS().inviteDistance))
				return GameData.PROTOCOL_OP_MULHORSE_TOO_FAR;
		}
		
		Role.MultipleRoles mr = new Role.MultipleRoles(iRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;
			
			synchronized(this)
			{
				this.mulHorseInvites.put(iRole.id, GameTime.getTime() + 300);	//TODO 300 get cfg
				gs.getRPCManager().sendStrPacket(iRole.netsid, new SBean.mulhorse_invite_forward(this.id, this.name));
			}
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		finally
		{
			mr.unlock();
		}
	}
	
	//多人骑乘邀请处理
	/**
	 * @param leaderID
	 * @param accept
	 * @return
	 */
	public int mulHorseInviteHandle(int leaderID, int accept)
	{
		try
		{
			if(leaderID == this.id)
				return GameData.PROTOCOL_OP_FAILED;
	
			synchronized(this)
			{
				if(this.isInMulRolesActivity() || this.escortCar.getCarID() > 0 || this.alterState.alterID > 0)
					return GameData.PROTOCOL_OP_FAILED;
				
				if(this.isMulRolesState() || this.gameMapContext.getCurMapContext().getCurRideHorse() > 0)
					return GameData.PROTOCOL_OP_MULHORSE_SELF_RIDE;
				
				this.mulRolesLock++;
			}
			
			Role leader = gs.getLoginManager().getOnGameRole(leaderID);
			if(leader == null)
				return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;

			synchronized(leader)
			{
				Integer timeout = leader.mulHorseInvites.remove(this.id);
				if(timeout == null)
					return GameData.PROTOCOL_OP_MULHORSE_INVALID;

				if(GameTime.getTime() > timeout)
					return GameData.PROTOCOL_OP_MULHORSE_TIME_OUT;
				
				if(accept <= 0)
				{
					gs.getRPCManager().sendStrPacket(leader.netsid, new SBean.mulhorse_invite_result(this.id, this.name, accept));
					return GameData.PROTOCOL_OP_SUCCESS;
				}
			}
			
			Role.MultipleRoles mr = new Role.MultipleRoles(leader, this);
			try
			{
				mr.lock();
				if (mr.isClosed())
					return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;
				
				synchronized(leader)
				{
					if(leader.isInMulRolesActivity())
						return GameData.PROTOCOL_OP_MULHORSE_BUSY;
					
					if(leaderID != leader.mulRoleInfo.leader || leader.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
						return GameData.PROTOCOL_OP_MULHORSE_OTHER_UNRIDE;

					int pos = leader.isMulHorseFull();
					if(pos < 0)
						return GameData.PROTOCOL_OP_MULHORSE_OTHER_FULL;
					
					if(!testRoleNearBy(leader, GameData.getInstance().getHorseCommonCFGS().inviteDistance))
						return GameData.PROTOCOL_OP_MULHORSE_TOO_FAR;
					
					if(leader.mulRolesLock > 0)
						return GameData.PROTOCOL_OP_MULHORSE_BUSY;
					
					leader.mulHorseAddMember(pos, this.id);
				}
				
				this.onSelfJoinMulHorse(leader.id);
				gs.getRPCManager().sendStrPacket(leader.netsid, new SBean.mulhorse_join(this.id, this.name));
				return GameData.PROTOCOL_OP_SUCCESS;
			}
			finally
			{
				mr.unlock();
			}
		}
		finally
		{
			this.mulRolesLock--;
			if(this.mulRolesLock > 0)		//延时下马
				this.onSelfLeaveMulHorse();
			
			this.mulRolesLock = 0;
		}
	}

	//自己申请加入多人骑乘
	public int mulHorseApply(int leaderID) 
	{
		if(leaderID == this.id)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role leader = gs.getLoginManager().getOnGameRole(leaderID);
		if(leader == null)
			return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;
		
		synchronized(this)
		{
			if(this.isMulRolesState() || this.gameMapContext.getCurMapContext().getCurRideHorse() > 0)
				return GameData.PROTOCOL_OP_MULHORSE_SELF_RIDE;
			
			if(this.isInMulRolesActivity() || this.escortCar.getCarID() > 0 || this.alterState.alterID > 0)
				return GameData.PROTOCOL_OP_FAILED;
		}
		
		Role.MultipleRoles mr = new Role.MultipleRoles(leader, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;
			
			synchronized(leader)
			{
				if(leader.isInMulRolesActivity())
					return GameData.PROTOCOL_OP_MULHORSE_BUSY;
				
				if(leader.mulRoleInfo.leader != leaderID || leader.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
					return GameData.PROTOCOL_OP_MULHORSE_OTHER_UNRIDE;
				
				if(leader.isMulHorseFull() < 0)
					return GameData.PROTOCOL_OP_MULHORSE_OTHER_FULL;
				
				if(!testRoleNearBy(leader, GameData.getInstance().getHorseCommonCFGS().inviteDistance))
					return GameData.PROTOCOL_OP_MULHORSE_TOO_FAR;
				
				leader.mulHorseApplys.put(this.id, GameTime.getTime() + 300);	//TODO 300 get cfg
				gs.getRPCManager().sendStrPacket(leader.netsid, new SBean.mulhorse_apply_forward(this.id, this.name));
			}
			
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		finally
		{
			mr.unlock();
		}
	}
	
	//多人骑乘申请处理
	public int mulHorseApplyHandle(int applyID, int accept)
	{
		try
		{
			if(applyID == this.id)
				return GameData.PROTOCOL_OP_FAILED;
			
			Role applyer = gs.getLoginManager().getOnGameRole(applyID);
			if(applyer == null)
				return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;
			
			int pos = -1;
			synchronized(this)
			{
				this.mulRolesLock++;
				Integer timeout = this.mulHorseApplys.remove(applyID); 
				if(timeout == null)
					return GameData.PROTOCOL_OP_FAILED;
				
				if(GameTime.getTime() > timeout)
					return GameData.PROTOCOL_OP_MULHORSE_TIME_OUT;
				
				if(accept <= 0)
				{
					gs.getRPCManager().sendStrPacket(applyer.netsid, new SBean.mulhorse_apply_result(this.id, this.name, accept));
					return GameData.PROTOCOL_OP_SUCCESS;
				}
				
				if(this.isInMulRolesActivity())
					return GameData.PROTOCOL_OP_FAILED;
				
				if(this.mulRoleInfo.leader != this.id || this.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
					return GameData.PROTOCOL_OP_MULHORSE_SELF_UNRIDE;
				
				pos = this.isMulHorseFull();
				if(this.isMulHorseFull() < 0)
					return GameData.PROTOCOL_OP_MULHORSE_SELF_FULL;
			}
			
			Role.MultipleRoles mr = new Role.MultipleRoles(applyer, this);
			try
			{
				mr.lock();
				if (mr.isClosed())
					return GameData.PROTOCOL_OP_MULHORSE_OFFLINE;
				
				synchronized(applyer)
				{
					if(applyer.isMulRolesState() || applyer.gameMapContext.getCurMapContext().getCurRideHorse() > 0)
						return GameData.PROTOCOL_OP_MULHORSE_OTHER_RIDE;
					
					if(!testRoleNearBy(applyer, GameData.getInstance().getHorseCommonCFGS().inviteDistance))
						return GameData.PROTOCOL_OP_MULHORSE_TOO_FAR;
					
					if(applyer.mulRolesLock > 0 || applyer.isInMulRolesActivity() || applyer.escortCar.getCarID() > 0 || applyer.alterState.alterID > 0)
						return GameData.PROTOCOL_OP_MULHORSE_BUSY;
					
					applyer.onSelfJoinMulHorse(this.id);
				}
				
				synchronized(this)
				{
					this.mulHorseAddMember(pos, applyer.id);
				}
				
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.mulhorse_join(applyer.id, applyer.name));
				return GameData.PROTOCOL_OP_SUCCESS;
			}
			finally
			{
				mr.unlock();
			}
		}
		finally
		{
			this.mulRolesLock--;
			if(this.mulRolesLock > 0)		//延时下马
				this.roleUnRide();
//				this.mulHorseDissolve();
			
			this.mulRolesLock = 0;
		}
		
	}
	
	int mulHorseLeave()
	{
		int leaderID = this.mulRoleInfo.leader;
		synchronized(this)
		{
			if(leaderID == 0 || leaderID == this.id || this.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
				return GameData.PROTOCOL_OP_FAILED;
			
			this.mulRoleInfo.leader = 0;
			this.mulRoleInfo.type = 0;
		}
			
		Role leader = gs.getLoginManager().getOnGameRole(leaderID);
		if(leader == null)
			return GameData.PROTOCOL_OP_MULHORSE_SELF_UNRIDE;
		leader.mulHorseDelMember(this.id);
		
		gs.getRPCManager().sendStrPacket(leader.netsid, new SBean.mulhorse_leave(this.id, this.name));
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	int mulHorseKick(int memberID)
	{
		synchronized(this)
		{
			if(this.mulRoleInfo.leader != this.id || this.mulRoleInfo.type != GameData.MULROLE_TYPE_HORSE)
				return GameData.PROTOCOL_OP_FAILED;
			
			if(!this.mulHorseDelMember(memberID))
				return GameData.PROTOCOL_OP_FAILED;
		}
		
		Role member = gs.getLoginManager().getOnGameRole(memberID);
		if(member == null)
			return GameData.PROTOCOL_OP_MULHORSE_OTHER_UNRIDE;
		
		synchronized(member)
		{
			member.mulRoleInfo.leader = 0;
			member.mulRoleInfo.type = 0;
		}
		
		gs.getRPCManager().sendStrPacket(member.netsid, new SBean.mulhorse_kick(this.id, this.name));
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private void clearMulRole()
	{
		if(this.mulRoleInfo.leader == 0)
			return;
		
		if(this.mulRoleInfo.leader == this.id)
		{
			switch (this.mulRoleInfo.type)
			{
			case GameData.MULROLE_TYPE_HORSE:
				this.roleUnRide();
				break;
			case GameData.MULROLE_TYPE_STAYWITH:
				this.staywithLeave();
				break;
			default:
				break;
			}
		}
		else
		{
			switch (this.mulRoleInfo.type)
			{
			case GameData.MULROLE_TYPE_HORSE:
				this.mulHorseLeave();
				break;
			case GameData.MULROLE_TYPE_STAYWITH:
				this.staywithLeave();
				break;
			default:
				break;
			}
		}
	}
	
	private void checkMulHorseTimeOut(int timeTick)
	{
		
	}
//-------------------------------------------------------------------------多人骑乘---------------------------------------------------------------------------------------------
	
//-------------------------------------------------------------------------相依相偎---------------------------------------------------------------------------------------------
	int staywithInvite(int rid)
	{
		if(this.id == rid)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role iRole = gs.getLoginManager().getOnGameRole(rid);
		if(iRole == null)
			return GameData.PROTOCOL_OP_STAYWITH_OFFLINE;
		
		synchronized(this)
		{
			if(this.gender == iRole.gender)
				return GameData.PROTOCOL_OP_FAILED;
			
			if(iRole.isInMulRolesActivity() || iRole.escortCar.getCarID() > 0 || iRole.alterState.alterID > 0)
				return GameData.PROTOCOL_OP_STAYWITH_BUSY;
			
			if(iRole.isMulRolesState())
				return GameData.PROTOCOL_OP_STAYWITH_OTHER_MULSTATE;
			
			if(iRole.fightState)
				return GameData.PROTOCOL_OP_STAYWITH_IN_FIGHT;
		}
		
		synchronized(this)
		{
			if(this.isInMulRolesActivity() || this.escortCar.getCarID() > 0 || this.alterState.alterID > 0)
				return GameData.PROTOCOL_OP_FAILED;
			
			if(this.isMulRolesState())
				return GameData.PROTOCOL_OP_STAYWITH_SELF_MULSTATE;
			
			if(!this.testRoleNearBy(iRole, 1000))
				return GameData.PROTOCOL_OP_STAYWITH_BUSY;
		}
		
		Role.MultipleRoles mr = new Role.MultipleRoles(iRole, this);
		try
		{
			mr.lock();
			if (mr.isClosed())
				return GameData.PROTOCOL_OP_STAYWITH_OFFLINE;
			
			synchronized(this)
			{
				this.staywithInvites.put(iRole.id, GameTime.getTime() + 300);	//TODO 300 get cfg
				gs.getRPCManager().sendStrPacket(iRole.netsid, new SBean.staywith_invite_forward(this.id, this.name));
			}
			
			return GameData.PROTOCOL_OP_SUCCESS;
		}
		finally
		{
			mr.unlock();
		}
	}
	
	public int staywithInviteHandle(int inviterID, int accept)
	{
		try
		{
			if(inviterID == this.id)
				return GameData.PROTOCOL_OP_FAILED;
			
			synchronized(this)
			{
				if(this.isInMulRolesActivity() || this.escortCar.getCarID() > 0 || this.alterState.alterID > 0)
					return GameData.PROTOCOL_OP_FAILED;
				
				if(this.isMulRolesState())
					return GameData.PROTOCOL_OP_STAYWITH_SELF_MULSTATE;
				
				this.mulRolesLock++;
			}
			
			Role inviter = gs.getLoginManager().getOnGameRole(inviterID);
			if(inviter == null)
				return GameData.PROTOCOL_OP_STAYWITH_OFFLINE;
			
			if(this.gender == inviter.gender)
				return GameData.PROTOCOL_OP_FAILED;
			
			synchronized(inviter)
			{
				Integer timeout = inviter.staywithInvites.remove(this.id);
				if(timeout == null)
					return GameData.PROTOCOL_OP_STAYWITH_INVALID;
				
				if(GameTime.getTime() > timeout)
					return GameData.PROTOCOL_OP_STAYWITH_TIME_OUT;
				
				if(accept <= 0)
				{
					gs.getRPCManager().sendStrPacket(inviter.netsid, new SBean.staywith_invite_result(this.id, this.name, accept));
					return GameData.PROTOCOL_OP_SUCCESS;
				}
			}
			
			Role.MultipleRoles mr = new Role.MultipleRoles(inviter, this);
			try
			{
				mr.lock();
				if (mr.isClosed())
					return GameData.PROTOCOL_OP_STAYWITH_OFFLINE;
				
				synchronized(inviter)
				{
					if(inviter.isInMulRolesActivity())
						return GameData.PROTOCOL_OP_STAYWITH_BUSY;
					
					if(inviter.isMulRolesState())
						return GameData.PROTOCOL_OP_STAYWITH_OTHER_MULSTATE;
					
					if(!testRoleNearBy(inviter, 1000))
						return GameData.PROTOCOL_OP_STAYWITH_TOO_FAR;
				}
				
				this.staywithUnRideHorse();
				inviter.staywithUnRideHorse();
				
				this.createStayWith(inviter.id);
				inviter.createStayWith(this.id);
				gs.getRPCManager().sendStrPacket(inviter.netsid, new SBean.staywith_join(this.id, this.name));
				return GameData.PROTOCOL_OP_SUCCESS;
			}
			finally
			{
				mr.unlock();
			}
		}
		finally
		{
			this.mulRolesLock--;
			if(this.mulRolesLock > 0)		//延时离开相依相偎
				this.staywithLeave();
			
			this.mulRolesLock = 0;
		}
	}
	
	private synchronized void staywithUnRideHorse()
	{
		if(this.gender == GameData.ROLE_GENDER_MAN)
			return;
		
		if(this.gameMapContext.getCurMapContext().getCurRideHorse() > 0)
			this.roleUnRide();
	}
	
	public SBean.MasterMember getMasterInfoWithLock()
	{
		synchronized( this )
		{
			return new SBean.MasterMember(this.getRoleOverviewWithoutLock()
					, masterIsOnline(), master.point);
		}
	}
	
	private synchronized void createStayWith(int memberID)
	{
		this.mulRoleInfo.members.clear();
		this.mulRoleInfo.type = GameData.MULROLE_TYPE_STAYWITH;
		if(this.gender == GameData.ROLE_GENDER_MAN)
		{
			this.mulRoleInfo.leader = this.id;
			this.mulRoleInfo.members.add(memberID);
			this.staywithInvites.clear();
			gs.getMapService().syncRoleUpdateStayWith(this.gameMapContext.getCurMapId(), this.id, this.mulRoleInfo.kdClone());
		}
		else
		{
			this.mulRoleInfo.leader = memberID;
		}
	}
	
	int staywithLeave()
	{
		Set<Integer> members = new HashSet<>();
		Role leader = gs.getLoginManager().getOnGameRole(this.mulRoleInfo.leader);
		if(leader != null)
		{
			synchronized(leader)
			{
				members = new HashSet<>(leader.mulRoleInfo.members);
				leader.mulRoleInfo.leader = 0;
				leader.mulRoleInfo.type = 0;
				leader.mulRoleInfo.members.clear();
				
				gs.getMapService().syncRoleUpdateStayWith(leader.gameMapContext.getCurMapId(), leader.id, leader.mulRoleInfo.kdClone());
				gs.getRPCManager().sendStrPacket(leader.netsid, new SBean.staywith_dissolve());
			}
		}
		
		for(int memberID: members)
		{
			Role member = gs.getLoginManager().getOnGameRole(memberID);
			if(member != null)
			{
				synchronized(member)
				{
					member.mulRoleInfo.leader = 0;
					member.mulRoleInfo.type = 0;
					member.mulRoleInfo.members.clear();
					gs.getRPCManager().sendStrPacket(member.netsid, new SBean.staywith_dissolve());
				}
			}
		}
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
//-------------------------------------------------------------------------相依相偎---------------------------------------------------------------------------------------------
	

	public int changeSectPushApplication(byte ok)
	{
		return gs.getSectManager().changeSectPushApplication(this, ok);
	}

	public int saveGuideMapcopy(int step)
	{
		this.guidestep = step;
		if (step == 0)
			this.gameMapContext.enterGameWorld();
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	//////////////////////////////////////////////////////////////内甲系统////////////////////////////////////////////////////

	private SBean.DBArmor initArmor()
	{
		SBean.DBArmor armor = new SBean.DBArmor(0, new ArrayList<>(), new HashMap<>(), 0, 0);
		for (int i = 0; i < GameData.getInstance().getArmorTypeSize(); i++)
		{
			armor.allArmors.add(new SBean.ArmorData(i + 1, (byte) 0, 1, 0, 0, 1, 0, new HashMap<>(), getInitSoltGroup(i + 1), 0));
		}
		return armor;
	}
	
	private List<SBean.SoltData> getInitSoltGroup(int armorType)
	{
		SBean.ArmorSlotGroupCFGS cfg = GameData.getInstance().getSoltGroupCFGS(armorType);
		List<SBean.SoltData> slotGroupDatas = new ArrayList<>();
		SBean.SoltData slotGroup = null;
		for(int i=0;i<cfg.armorSlots.size();i++){
			slotGroup = new SBean.SoltData(cfg.armorSlots.get(i).defaultOpen,new ArrayList<>());
			for(int j=0;j<cfg.armorSlots.get(i).slotNum;j++)
				slotGroup.solts.add(0);
			slotGroupDatas.add(slotGroup);
		}
		return slotGroupDatas;
	}

	public synchronized int armorUpRank(int type, int nextRank)
	{
		if (type <= 0 || type > this.armor.allArmors.size())
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		SBean.ArmorData theArmor = this.armor.allArmors.get(type - 1);
		if (theArmor.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		if (nextRank != theArmor.rank + 1)
			return GameData.PROTOCOL_OP_FAILED;
		if(nextRank>GameData.getInstance().getArmorRankSize(type))
			return GameData.PROTOCOL_OP_ARMOR_RANK_MAX;
		SBean.ArmorRankCFGS cfg = GameData.getInstance().getArmorRankCFGS(type, theArmor.rank);
		if(cfg == null)
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ARMOR_UPRANK);
		tlogEvent.setArg(type, nextRank);
		this.delGameItems(cfg.rankUpConsume, tlogEvent.getGameItemRecords());
		int rankUpResult = 0;
		if (GameData.getInstance().tryArmorUpRank(this.forceWarInfo.forcewar.totalFeats, theArmor))
		{
			theArmor.rank = nextRank;
			theArmor.wishPoint = 0;
			theArmor.curUpRankTime = 0;
			rankUpResult = GameData.ARMOR_RANK_UP_SUCCESS;
			if (type == this.armor.curArmor)
			{
				this.roleProperties.onUpdateArmorRank(nextRank);
				gs.getMapService().syncRoleUpdateArmorRank(this.gameMapContext.getCurMapId(), this.id, nextRank);
			}
		}
		else
		{
			theArmor.wishPoint += cfg.addWishPointEveryTime;
			theArmor.curUpRankTime ++;
			rankUpResult = GameData.ARMOR_RANK_UP_FAIL;
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		testChallengeTask(GameData.CHALLENGE_TASK_ID_ANY_ARMORRANK, 0);
		return rankUpResult;
	}

	public synchronized int armorAddTalent(int type, int talentId)
	{
		if (type <= 0 || type > this.armor.allArmors.size())
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		SBean.ArmorData theArmor = this.armor.allArmors.get(type - 1);
		if (theArmor.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		SBean.ArmorLevelCFGS levelCFGS = GameData.getInstance().getArmorLevelCFGS(theArmor.id, theArmor.level);
		if (levelCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.ArmorTalentCFGS talentCFGS = GameData.getInstance().getArmorTalentCFGS(theArmor.id, talentId);
		if (talentCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (theArmor.useTalentPoint >= levelCFGS.talentPoint)
			return GameData.PROTOCOL_OP_ARMOR_NO_TALENT_POINT_VALID;
		if (theArmor.useTalentPoint < talentCFGS.needTalentPoint)
			return GameData.PROTOCOL_OP_ARMOR_NEED_TALENT_POINT;
		if (talentCFGS.preTalentId != 0 && (!theArmor.talentPoint.containsKey(talentCFGS.preTalentId) || talentCFGS.preTalentPoint > theArmor.talentPoint.get(talentCFGS.preTalentId)))
			return GameData.PROTOCOL_OP_ARMOR_NEED_PRE_TALENT;
		if (theArmor.talentPoint.containsKey(talentId) && theArmor.talentPoint.get(talentId) >= talentCFGS.maxTalentPoint)
			return GameData.PROTOCOL_OP_ARMOR_TALENT_MAX_LEVEL;
		theArmor.talentPoint.merge(talentId, 1, (ov, nv) -> ov + nv);
		theArmor.useTalentPoint++;
		if (type == this.armor.curArmor)
		{
			this.roleProperties.onUpdateArmorTalent(new HashMap<>(theArmor.talentPoint));
			gs.getMapService().syncRoleUpdateArmorTalentPoint(this.gameMapContext.getCurMapId(), this.id, new HashMap<>(theArmor.talentPoint));
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int unlockArmorType(int type)
	{
		SBean.ArmorTypeCFGS cfg = GameData.getInstance().getArmorTypeCFGS(type);
		if (cfg == null)
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		if (this.level < cfg.unLockLevel || this.roleProperties.totalRolePower < cfg.unLockPower || this.forceWarInfo.forcewar.totalFeats < cfg.unLockFeat)
			return GameData.PROTOCOL_OP_ARMOR_NEED_UNLOCK_CONDITION;
		if (this.armor.allArmors.get(type - 1).unlocked == GameData.ARMOR_UNLOCK_STATUS_UNLOCK)
			return GameData.PROTOCOL_OP_ARMOR_AREADY_UNLOCK;
		if (!this.containsEnoughGameItems(cfg.unLockItems))
			return GameData.PROTOCOL_OP_ARMOR_NOT_ENOUGH_ITEM;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UNLOCK_ARMOR_TYPE);
		tlogEvent.setArg(type);
		this.delGameItems(cfg.unLockItems, tlogEvent.getGameItemRecords());
		this.armor.allArmors.get(type - 1).unlocked = GameData.ARMOR_UNLOCK_STATUS_UNLOCK;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getTLogger().logArmorDevelopFlow(this, TLog.ARMOR_UNLOCK, type, 1);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int armorChange(int type)
	{
		if (type <= 0 || type > this.armor.allArmors.size())
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		if (this.armor.allArmors.get(type - 1).unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		int oldType = this.armor.curArmor;
		this.armor.curArmor = type;
		
		this.roleProperties.onChangeCurArmor(getArmorFightData(this.armor.allArmors.get(type - 1)));
		gs.getMapService().syncRoleChangeArmor(this.gameMapContext.getCurMapId(), this.id, getArmorFightData(this.armor.allArmors.get(type - 1)));
		gs.getTLogger().logArmorDevelopFlow(this, TLog.ARMOR_EQUIP, oldType, type);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public static SBean.ArmorFightData getArmorFightData(List<SBean.ArmorData> armors, int type)
	{
		if (type <= 0 || type > armors.size())
			return null;
		
		return getArmorFightData(armors.get(type - 1));
	}
	
	public static SBean.ArmorFightData getArmorFightData(SBean.ArmorData armor)
	{
		return new SBean.ArmorFightData(armor.id, armor.level, armor.rank, Stream.clone(armor.soltGroupData), new HashMap<>(armor.talentPoint));
	}
	
	public synchronized int armorLevelUp(int type, Map<Integer, Integer> items)
	{
		int expsum = 0;
		SBean.ArmorTypeCFGS cfg = GameData.getInstance().getArmorTypeCFGS(type);
		if (cfg == null)
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		SBean.ArmorData theArmor = this.armor.allArmors.get(type - 1);
		if (theArmor.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		List<SBean.DummyGoods> useItems = GameData.toDummGoods(items);
		if (!this.containsEnoughGameItems(useItems))
			return GameData.PROTOCOL_OP_ARMOR_NOT_ENOUGH_ITEM;
		for (SBean.DummyGoods item : useItems)
		{
			if (item.count == 0)
				continue;
			CellItem bi = this.bag.getCellItem(item.id);
			if (bi == null)
				return GameData.PROTOCOL_OP_FAILED;
			CellItem.Useable useable = bi.getUseable();
			if (useable == null || !useable.canUse(this.getUseableVipLvl(), this.level, item.count))
				return GameData.PROTOCOL_OP_FAILED;
			CellItem.ArmorExpItem expAdder = useable.useAsArmorExpItem();
			if (expAdder == null)
				return GameData.PROTOCOL_OP_FAILED;
			expsum += expAdder.getExp() * item.count;
		}
		int oldlevel = theArmor.level;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ARMOR_LEVEL_UP);
		tlogEvent.setArg(type);
		this.delGameItems(useItems, tlogEvent.getGameItemRecords());
		this.armor.allArmors.get(type - 1).exp += expsum;
		GameData.getInstance().updateArmorLevel(theArmor);
		if (type == this.armor.curArmor && theArmor.level != oldlevel)
		{
			this.roleProperties.onUpdateArmorLevel(theArmor.level);
			gs.getMapService().syncRoleUpdateArmorLevel(this.gameMapContext.getCurMapId(), this.id, theArmor.level);
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		
		testChallengeTask(GameData.CHALLENGE_TASK_ID_ANY_ARMORLEVEL, 0);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int pushRuneToRuneBag(Map<Integer, Integer> runes)
	{
		List<SBean.DummyGoods> pushRunes = GameData.toDummGoods(runes);
		if (pushRunes.stream().anyMatch(rune -> !GameData.getInstance().isRune(rune.id) || rune.count < 0))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.containsEnoughGameItems(pushRunes))
			return GameData.PROTOCOL_OP_ARMOR_NOT_ENOUGH_ITEM;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PUSH_RUNE_TO_RUNE_BAG);
		this.delGameItems(pushRunes, tlogEvent.getGameItemRecords());
		pushRunes.stream().forEach(rune -> this.armor.runeBag.merge(rune.id, rune.count, (ov, nv) -> ov + nv));
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int popRuneToBag(Map<Integer, Integer> runes)
	{
		List<SBean.GameItem> popRunes = GameData.getInstance().toGameItems(runes);
		if (popRunes.stream().anyMatch(rune -> !GameData.getInstance().isRune(rune.id) || rune.count < 0))
			return GameData.PROTOCOL_OP_FAILED;
		if (popRunes.stream().anyMatch(rune -> this.armor.runeBag.getOrDefault(rune.id, 0) < rune.count))
			return GameData.PROTOCOL_OP_ARMOR_NOT_ENOUGH_RUNE;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_POP_RUNE_TO_BAG);
		popRunes.stream().forEach(rune -> this.armor.runeBag.merge(rune.id, rune.count, (ov, nv) -> ov - nv == 0 ? null : ov - nv));
		this.syncAddGameItems(popRunes, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int resetTalentPoint(int type)
	{
		if (type <= 0 || type > this.armor.allArmors.size())
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		SBean.ArmorData theArmor = this.armor.allArmors.get(type - 1);
		if (theArmor.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		if (theArmor.useTalentPoint == 0)
			return GameData.PROTOCOL_OP_ARMOR_NOT_USE_TALENT_POINT;
		SBean.DummyGoods useitem = GameData.getInstance().getCurResetUseItem(this.armor.curResetTalentTimes);
		if (!this.containsEnoughGameItem(useitem.id, useitem.count))
			return GameData.PROTOCOL_OP_ARMOR_NOT_ENOUGH_ITEM;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ARMOR_RESET_TALENT);
		this.delGameItem(useitem.id, useitem.count, tlogEvent.getGameItemRecords());
		this.armor.curResetTalentTimes++;
		theArmor.talentPoint.clear();
		theArmor.useTalentPoint = 0;
		if (type == this.armor.curArmor)
		{
			this.roleProperties.onUpdateArmorTalent(new HashMap<>(theArmor.talentPoint));
			gs.getMapService().syncRoleUpdateArmorTalentPoint(this.gameMapContext.getCurMapId(), this.id, new HashMap<>(theArmor.talentPoint));
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int unlockSoltGroup(int type, int soltGroupIndex)
	{
		if (type <= 0 || type > this.armor.allArmors.size())
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		SBean.ArmorData theArmor = this.armor.allArmors.get(type - 1);
		if (theArmor.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		SBean.ArmorSlotCFGS cfg = GameData.getInstance().getArmorSlotCFGS(type, soltGroupIndex);
		if (this.level < cfg.unlockLevel || this.roleProperties.totalRolePower < cfg.unLockPower || this.forceWarInfo.forcewar.totalFeats < cfg.unLockFeat)
			return GameData.PROTOCOL_OP_ARMOR_NEED_UNLOCK_CONDITION;
		if (soltGroupIndex <= 0 || soltGroupIndex > theArmor.soltGroupData.size())
			return GameData.PROTOCOL_OP_ARMOR_SLOT_GROUP_INDEX_INVALID;
		if (theArmor.soltGroupData.get(soltGroupIndex - 1).unlocked == GameData.ARMOR_UNLOCK_STATUS_UNLOCK)
			return GameData.PROTOCOL_OP_ARMOR_SLOT_AREADY_UNLOCK;
		if (!this.containsEnoughGameItems(cfg.unLockItems))
			return GameData.PROTOCOL_OP_ARMOR_NOT_ENOUGH_ITEM;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SOLT_GROUP_UNLOCK);
		tlogEvent.setArg(type);
		this.delGameItems(cfg.unLockItems, tlogEvent.getGameItemRecords());
		theArmor.soltGroupData.get(soltGroupIndex - 1).unlocked = GameData.ARMOR_UNLOCK_STATUS_UNLOCK;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int soltAddRune(int type, int soltGroupIndex, int soltIndex, int runeId)
	{
		if (type <= 0 || type > this.armor.allArmors.size())
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		SBean.ArmorData theArmor = this.armor.allArmors.get(type - 1);
		if (theArmor.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		if (soltGroupIndex <= 0 || soltGroupIndex > theArmor.soltGroupData.size())
			return GameData.PROTOCOL_OP_ARMOR_SLOT_GROUP_INDEX_INVALID;
		SBean.SoltData slotGroup = theArmor.soltGroupData.get(soltGroupIndex - 1);
		if (slotGroup.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_SLOT_NOT_UNLOCK;
		if (soltIndex <= 0 || soltIndex > slotGroup.solts.size())
			return GameData.PROTOCOL_OP_ARMOR_SLOT_INDEX_INVALID;
		SBean.RuneCFGS runeCFGS = GameData.getInstance().getRuneCFGS(runeId);
		if (runeId != 0 && runeCFGS == null)
			return GameData.PROTOCOL_OP_ARMOR_RUNE_ID_INVALID;
		for (int i = 0; i < slotGroup.solts.size(); i++)
		{
			if (runeId != 0 && soltIndex - 1 != i && slotGroup.solts.get(i) != 0 && (slotGroup.solts.get(i) == runeId || slotGroup.solts.get(i) == -runeId || runeCFGS.mutexRunes.contains(slotGroup.solts.get(i) > 0 ? slotGroup.solts.get(i) : - slotGroup.solts.get(i))))
				return GameData.PROTOCOL_OP_ARMOR_RUNE_HAS_MUTEX;
		}
		if (slotGroup.solts.get(soltIndex - 1) != 0)
		{
			runeBagChange(slotGroup.solts.get(soltIndex - 1), 1);
		}
		if (runeId != 0)
			runeBagChange(runeId, -1);
		slotGroup.solts.set(soltIndex - 1, runeId);
		if (type == this.armor.curArmor)
		{
			this.roleProperties.onUpdateArmorRune(soltGroupIndex, new ArrayList<>(theArmor.soltGroupData.get(soltGroupIndex - 1).solts));
			gs.getMapService().syncRoleUpdateArmorRune(this.gameMapContext.getCurMapId(), this.id, soltGroupIndex, new ArrayList<>(theArmor.soltGroupData.get(soltGroupIndex - 1).solts));
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int soltUseLang(int type, int soltGroupIndex, int langId)
	{

		if (type <= 0 || type > this.armor.allArmors.size())
			return GameData.PROTOCOL_OP_ARMOR_TYPE_INVALID;
		SBean.ArmorData theArmor = this.armor.allArmors.get(type - 1);
		if (theArmor.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_NOT_UNLOCK;
		if (soltGroupIndex <= 0 || soltGroupIndex > theArmor.soltGroupData.size())
			return GameData.PROTOCOL_OP_ARMOR_SLOT_GROUP_INDEX_INVALID;
		SBean.SoltData slotGroup = theArmor.soltGroupData.get(soltGroupIndex - 1);
		if (slotGroup.unlocked == GameData.ARMOR_UNLOCK_STATUS_LOCKED)
			return GameData.PROTOCOL_OP_ARMOR_SLOT_NOT_UNLOCK;
		SBean.RuneLangCFGS langCFGS = GameData.getInstance().getRuneLangCFGS(langId);
		if (langCFGS == null)
			return GameData.PROTOCOL_OP_ARMOR_LANG_ID_UNVALID;
		if (!langCFGS.runes.stream().allMatch(langrune -> containRune(slotGroup.solts ,langrune) || containRune(this.armor.runeBag.keySet() ,langrune)))
			return GameData.PROTOCOL_OP_ARMOR_RUNE_NOT_ENOUGH;
		for (int slotitem : slotGroup.solts)
		{
			if (slotitem != 0)
			{
				runeBagChange(slotitem, 1);
			}
		}	
		for (int i = 0; i < langCFGS.runes.size(); i++)
		{
			int langrune = langCFGS.runes.get(i);
			if (this.armor.runeBag.containsKey(-langrune))
			{
				runeBagChange(-langrune, -1);
				slotGroup.solts.set(i, -langrune);
			}
			else
			{
				runeBagChange(langrune, -1);
				slotGroup.solts.set(i, langrune);
			}
		}
		if (type == this.armor.curArmor)
		{
			this.roleProperties.onUpdateArmorRune(soltGroupIndex,  new ArrayList<>(theArmor.soltGroupData.get(soltGroupIndex - 1).solts));
			gs.getMapService().syncRoleUpdateArmorRune(this.gameMapContext.getCurMapId(), this.id, soltGroupIndex, new ArrayList<>(theArmor.soltGroupData.get(soltGroupIndex - 1).solts));
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public void runeBagChange(int runeId, int changeNum)
	{
		this.armor.runeBag.merge(runeId, changeNum, (ov, nv) -> ov + nv <= 0 ? null : ov + nv);
	}

	public boolean containRune(Collection<Integer> runes, int rune)
	{
		return runes.stream().anyMatch(runesItem -> (runesItem > 0 ? runesItem : -runesItem) == rune);
	}
	
	public synchronized void runeWish(Map<Integer, Integer> runes)
	{
		SBean.ArmorCommonCFGS commonCFGS = GameData.getInstance().getArmorCommonCFGS();
		int allnum = 0;
		int wishPoint = 0;
		boolean isbind = false;
		for (Entry<Integer, Integer> num : runes.entrySet())
		{
			if (!GameData.getInstance().isRune(num.getKey()))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rune_wish_res(GameData.PROTOCOL_OP_ARMOR_RUNE_ID_INVALID, new ArrayList<>()));
				return;
			}
			if (this.armor.runeBag.getOrDefault(num.getKey(), 0) < num.getValue())
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rune_wish_res(GameData.PROTOCOL_OP_ARMOR_RUNE_NOT_ENOUGH, new ArrayList<>()));
				return;
			}
			if (num.getKey() > 0)
				isbind = true;
			allnum += num.getValue();
			wishPoint += GameData.getInstance().getRuneCFGS(num.getKey()).transmigratePoint;
		}
		if (allnum < commonCFGS.minWishRuneNum || allnum > commonCFGS.maxWishRuneNum)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rune_wish_res(GameData.PROTOCOL_OP_ARMOR_WISH_NUM_INVALID, new ArrayList<>()));
			return;
		}
		if (!containsEnoughGameItem(commonCFGS.wishUseItem, commonCFGS.wishUseItemNum))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rune_wish_res(GameData.PROTOCOL_OP_ARMOR_NOT_ENOUGH_ITEM, new ArrayList<>()));
			return;
		}
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_RUNE_WISH);
		this.delGameItem(commonCFGS.wishUseItem, commonCFGS.wishUseItemNum, tlogEvent.getGameItemRecords());
		List<SBean.DummyGoods> dropMap = GameData.getInstance().getRuneWishDrops(wishPoint);
		for (Entry<Integer, Integer> use : runes.entrySet())
		{
			runeBagChange(use.getKey(), -use.getValue());
		}
		for (SBean.DummyGoods drop : dropMap)
		{
			if (!isbind)
				drop.id = -drop.id;
			runeBagChange(drop.id, drop.count);
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.rune_wish_res(GameData.PROTOCOL_OP_SUCCESS, dropMap));
	}

	private void dayRefreshArmor(int nowday)
	{
		if ((nowday - 3) % 7 == 0)
		{
			this.armor.curResetTalentTimes = 0;
		}
	}

	//////////////////////////////////////////帮派邀请/////////////////////////////////////////////////////
	public int inviteRoleInSect(int roleId)
	{
		if (this.sectData.data.sectBrief.sectID == 0)
			return GameData.PROTOCOL_OP_SECT_NOT_JOIN;
		Role invitedRole = gs.getLoginManager().getOnGameRole(roleId);
		if (invitedRole == null)
			return GameData.PROTOCOL_OP_SECT_BEINVITE_ROLE_NOT_ONGAME;
		int sectId = this.getSectId();
		if (sectId <= 0)
			return GameData.PROTOCOL_OP_SECT_NOT_EXIST;
		synchronized (invitedRole)
		{
			if (invitedRole.getSectId() != 0)
				return GameData.PROTOCOL_OP_SECT_ALREADY_JOIN;
			int canjoin = invitedRole.testCanJoinSect();
			if (canjoin != GameData.PROTOCOL_OP_SUCCESS)
				return canjoin;
			gs.getRPCManager().sendStrPacket(invitedRole.netsid, new SBean.role_sect_invite(this.id, this.name, this.getSectName()));
		}
		synchronized (this)
		{
			this.sectInvites.add(roleId);
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int responseSectInvite(int inviteId, byte res)
	{
		Role inviteRole = gs.getLoginManager().getOnGameRole(inviteId);
		if (inviteRole == null || !inviteRole.sectInvites.contains(this.id))
			return GameData.PROTOCOL_OP_SECT_INVITE_IS_INVALID;
		synchronized (inviteRole)
		{
			inviteRole.sectInvites.remove(this.id);
		}
		switch (res)
		{
		case GameData.SECT_INVITE_RESPONSE_TYPE_ACCEPT:
			return gs.getSectManager().acceptSectInvite(inviteRole, this);
		case GameData.SECT_INVITE_RESPONSE_TYPE_REFUSE:
			gs.getRPCManager().sendStrPacket(inviteRole.netsid, new SBean.role_refuse_sect_invite(this.name));
			return GameData.PROTOCOL_OP_SUCCESS;
		case GameData.SECT_INVITE_RESPONSE_TYPE_BUSY:
			gs.getRPCManager().sendStrPacket(inviteRole.netsid, new SBean.sect_invite_busy(this.name));
			return GameData.PROTOCOL_OP_FAILED;
		default:
			return GameData.PROTOCOL_OP_FAILED;
		}
	}
	
	///////////////////////////////////////个人仓库//////////////////////////////////////////////////////////////////////
	public int putInWarehouse(int id, int count, int target, String equip)
	{
		if (target == GameData.WAREHOUSE_TYPE_PRIVATE)
			return putInPrivateWarehouse(id, count, equip);
		else
			return putInMarriageWarehouse(id, count, equip);
	}
	
	public int takeOutWarehouse(int id, int count, int target, String equip)
	{
		if (target == GameData.WAREHOUSE_TYPE_PRIVATE)
			return takeOutPrivateWarehouse(id, count, equip);
		else
			return takeOutMarriageWarehouse(id, count, equip);
	}
	
	public boolean expandWarehouse(int times, int target)
	{
		if (target == GameData.WAREHOUSE_TYPE_PRIVATE)
			return expandPrivateWarehouse(times);
		else
			return expandPublicWarehouse(times);
	}
	
	public SBean.DBItemCells syncPublicWarehouse()
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return null;
		return marriage.getWarehouseShare();
	}
	
	public SBean.DBItemCells syncPrivateWarehouse()
	{
		return this.warehouse.toDB();
	}
	
	public synchronized boolean expandPrivateWarehouse(int times)
	{
		if (this.warehouse.getExpandTimes() + 1 != times)
			return false;
		if (times > GameData.getInstance().getCommonCFG().warehouse.priavetExpandSize)
			return false;
		int cost = GameData.getTimesCost(GameData.getInstance().getCommonCFG().warehouse.priavetExpandCost, times);
		if (!this.canUseDiamond(cost, false))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EXBAND_WAREHOUSE);
		tlogEvent.setArg(times, cost);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.warehouse.expand(GameData.getInstance().getCommonCFG().warehouse.expandCells);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}

	public synchronized boolean expandPublicWarehouse(int times)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return false;
		SBean.MarriageGradeCFGS gradeCFGS = GameData.getInstance().getMarriageGradeCFGS(marriage.getMarriageType());
		if (gradeCFGS == null)
			return false;
		if (gradeCFGS.publicWarehouseOpen == 0)
			return false;
		if (times > GameData.getInstance().getCommonCFG().warehouse.publicExpandSize)
			return false;
		int cost = GameData.getTimesCost(GameData.getInstance().getCommonCFG().warehouse.publicExpandCost, times);
		if (!this.canUseDiamond(cost, false))
			return false;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_EXBAND_WAREHOUSE);
		tlogEvent.setArg(times, cost);
		boolean result = marriage.tryExpandWarehouse(times);
		if (result)
		{
			this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		return result;
	}
	
	public synchronized int putInPrivateWarehouse(int id, int count, String guid)
	{
		SBean.GameItem gameitem = null;
		if (!guid.equals("0"))
		{
			CellItem bi = this.getBagItem(id);
			if (bi != null)
			{
				CellItem.Wearable wearable = bi.getWearable();
				if (wearable != null)
					gameitem = GameData.toGameItem(wearable.getEquipData(guid));
			}
		}
		else
			gameitem = GameData.getInstance().toGameItem(id, count);
		if (gameitem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.containsEnoughGameItem(id, count))
			return GameData.PROTOCOL_OP_WAREHOUSE_BAG_ITEM_NOT_ENOUGH;
		if (!this.warehouse.canPutIn(id, count))
			return GameData.PROTOCOL_OP_WAREHOUSE_CELL_NOT_ENOUGH;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WAREHOUSE_SAVE);
		if(!guid.equals("0"))
			this.delEquip(id, guid, tlogEvent.getGameItemRecords());
		else
			this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		this.warehouse.putIn(gameitem);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int takeOutPrivateWarehouse(int id, int count, String guid)
	{
		SBean.GameItem gameitem = null;
		if (!guid.equals("0"))
		{
			CellItem bi = this.warehouse.getCellItem(id);
			if (bi != null)
			{
				CellItem.Wearable wearable = bi.getWearable();
				if (wearable != null)
					gameitem = GameData.toGameItem(wearable.getEquipData(guid).kdClone());
			}
		}
		else
			gameitem = GameData.getInstance().toGameItem(id, count);
		if (gameitem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.warehouse.containsEnough(id, count))
			return GameData.PROTOCOL_OP_WAREHOUSE_ITEM_NOT_ENOUGH;
		if (!this.canAddGameItem(id, count))
			return GameData.PROTOCOL_OP_WAREHOUSE_BAG_CELL_NOT_ENOUGH;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WAREHOUSE_TAKE);
		this.syncAddGameItem(gameitem, tlogEvent);
		if (!guid.equals("0"))
			this.warehouse.del(id, guid);
		else
			this.warehouse.del(id, count);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int putInMarriageWarehouse(int id, int count, String guid)
	{
		if (id > 0)
			return GameData.PROTOCOL_OP_WAREHOUSE_BIND_ITEM;
		SBean.GameItem gameitem = null;
		if (!guid.equals("0"))
		{
			CellItem bi = this.getBagItem(id);
			if (bi != null)
			{
				CellItem.Wearable wearable = bi.getWearable();
				if (wearable != null)
					gameitem = GameData.toGameItem(wearable.getEquipData(guid));
			}
		}
		else
			gameitem = GameData.getInstance().toGameItem(id, count);
		if (gameitem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.containsEnoughGameItem(id, count))
			return GameData.PROTOCOL_OP_WAREHOUSE_BAG_ITEM_NOT_ENOUGH;
		
		MarriageShare marriage = this.getSharedMarriage();
		if(marriage == null)
			return GameData.PROTOCOL_OP_WAREHOUSE_ALREADY_DIVORCE;
		
		if (!marriage.tryWarehousePutIn(gameitem))
			return GameData.PROTOCOL_OP_WAREHOUSE_CELL_NOT_ENOUGH;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WAREHOUSE_SAVE);
		if(!guid.equals("0"))
			this.delEquip(id, guid, tlogEvent.getGameItemRecords());
		else
			this.delGameItem(id, count, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int takeOutMarriageWarehouse(int id, int count, String guid)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.GameItem gameitem = null;
		if (!guid.equals("0"))
		{
			CellItem bi = marriage.getCollection().getCellItem(id);
			if (bi != null)
			{
				CellItem.Wearable wearable = bi.getWearable();
				if (wearable != null)
					gameitem = GameData.toGameItem(wearable.getEquipData(guid));
			}
		}
		else
			gameitem = GameData.getInstance().toGameItem(id, count);
		if (gameitem == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItem(id, count))
			return GameData.PROTOCOL_OP_WAREHOUSE_BAG_CELL_NOT_ENOUGH;
		if (!this.getSharedMarriage().tryWarehouseDel(id, count, guid))
			return GameData.PROTOCOL_OP_WAREHOUSE_ITEM_NOT_ENOUGH;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WAREHOUSE_TAKE);
		this.syncAddGameItem(gameitem, tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public RpcRes<String> tryPropose(int grade)
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		SBean.MarriageGradeCFGS gradeCFGS = GameData.getInstance().getMarriageGradeCFGS(grade);
		int now = GameTime.getTime();
		if (cfg == null || gradeCFGS == null || !isInTeam() || !isTeamLeader())
			return new RpcRes<String>(GameData.PROTOCOL_OP_FAILED);
		
		if(this.team.id <= 0 || this.team.members.size() != 2)
			return new RpcRes<String>(GameData.PROTOCOL_OP_FAILED);
		
		int partnerID = 0;
		for(int rid: this.team.members)
		{
			if(rid != this.id)
			{
				partnerID = rid;
				break;
			}
		}
		
		Role partner = gs.getLoginManager().getOnGameRole(partnerID);
		if (partner == null || this.gender == partner.gender)
			return new RpcRes<String>(GameData.PROTOCOL_OP_FAILED);
		
		int myResult = this.testCanMarriage(partner.id);
		if (myResult <= 0)
			return new RpcRes<String>(myResult, this.name);
		int partnerResult = partner.testCanMarriage(this.id);
		if (partnerResult <= 0)
			return new RpcRes<String>(partnerResult, partner.name);

		if (!this.canUseCoin(gradeCFGS.coinCost, true) || !this.canUseDiamond(gradeCFGS.diamondCost, true) || !this.containsEnoughGameItem(gradeCFGS.itemCost.id, gradeCFGS.itemCost.count))
			return new RpcRes<String>(GameData.PROTOCOL_OP_MARRIAGE_ITEM_NEED, null);
		synchronized (this)
		{
			this.propose.grade = grade;
		}
		partner.pushPropose(grade);
		gs.getTLogger().logMarriageFlow(this, partner, 0, TLog.MARRIAGE_REQUEST, 0);
		return new RpcRes<String>(GameData.PROTOCOL_OP_SUCCESS);
	}
	
	private synchronized boolean testInBespeakLine(SBean.DBMarriageBespeak bespeak)
	{
		return bespeak.line == this.gameMapContext.getCurMapInstance();
	}
	
	private synchronized int testCanMarriage(int partnerId)
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		if (this.marriageData.divorceTime + cfg.divorceCD > GameTime.getTime())
			return GameData.PROTOCOL_OP_MARRIAGE_IN_DIVORCE_CD;
		if (this.level < cfg.levelNeed)
			return GameData.PROTOCOL_OP_MARRIAGE_LEVEL_NEED;
		if (this.marriageData.marriageShareId != 0)
			return GameData.PROTOCOL_OP_MARRIAGE_SINGEL_NEED;
		if (!this.friend.friendData.friends.containsKey(partnerId))
			return GameData.PROTOCOL_OP_MARRIAGE_MAKE_FRIEND_NEED;
		if (this.pkValue > cfg.pkPointLess)
			return GameData.PROTOCOL_OP_MARRIAGE_PK_POINT_NEED;
		if (this.friend.friendData.charm < cfg.friendPointNeed)
			return GameData.PROTOCOL_OP_MARRIAGE_FRIEND_POINT_NEED;
		if (!this.testNearByNPC(cfg.marriageNpcId))
			return GameData.PROTOCOL_OP_MARRIAGE_TOO_FAR_TO_NPC;
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public void pushPropose(int grade)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_push(grade));
	}
	
	public void pushProposeResponse(byte response)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_propose_response(response));
	}
	
	public void proposeResponse(int grade, byte response)
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		SBean.MarriageGradeCFGS gradeCFGS = GameData.getInstance().getMarriageGradeCFGS(grade);
		if (cfg == null || gradeCFGS == null || !isInTeam())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		Role partner = gs.getLoginManager().getOnGameRole(this.team.leader);
		if (partner == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		if (partner.propose.grade != grade)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_MARRIAGE_PROPOSE_INVALID));
			return;
		}
		if (!partner.canUseCoin(gradeCFGS.coinCost, true) || !partner.canUseDiamond(gradeCFGS.diamondCost, true) || !partner.containsEnoughGameItem(gradeCFGS.itemCost.id, gradeCFGS.itemCost.count))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_MARRIAGE_ITEM_NEED));
			return;
		}
		partner.propose.grade = 0;
		if (response == GameData.MARRIAGE_RESPONSE_FAILED)
		{
			partner.pushProposeResponse(response);
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_SUCCESS));
			gs.getTLogger().logMarriageFlow(this, partner, 0, TLog.MARRIAGE_RESPONSE, response);
			return;
		}
		else if (response == GameData.MARRIAGE_RESPONSE_SUCCESS)
		{
			if (!partner.canUseCoin(gradeCFGS.coinCost, true) || !partner.canUseDiamond(gradeCFGS.diamondCost, true) || !partner.containsEnoughGameItem(gradeCFGS.itemCost.id, gradeCFGS.itemCost.count))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_MARRIAGE_ITEM_NEED));
				return;
			}
			gs.getLoginManager().initMarriageShare(grade, this, partner, (marriageshare) ->
			{
				if (marriageshare != null)
				{
					SBean.DBMarriageTask mrtTask = marriageshare.getTask().kdClone();
					Map<Integer, Integer> skills = marriageshare.getMarriageSkillMap();
					List<SBean.GameItem> marriageDress = new ArrayList<>();
					if (gradeCFGS.dressId > 0)
						marriageDress.add(GameData.getInstance().toGameItem(gradeCFGS.dressId, 1));
					int now = GameTime.getTime();
					synchronized (partner)
					{
						partner.marriageData.marriageShareId = marriageshare.getId();
						partner.marriageData.partnerName = this.name;
						partner.tryUnlockWarehouse();
						TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MARRIAGE);
						partner.useCoin(gradeCFGS.coinCost, true, tlogEvent.getGameItemRecords());
						partner.useDiamond(gradeCFGS.diamondCost, true, tlogEvent.getGameItemRecords());
						partner.delBagItem(gradeCFGS.itemCost.id, gradeCFGS.itemCost.count, tlogEvent.getGameItemRecords());
						if (gradeCFGS.dressId > 0)
							partner.mailbox.addSysMail(SysMailType.Marriage, MailBox.MARRIAGE_MAIL_MAX_RESERVE_TIME, this.name, marriageDress, GameData.emptyList());
						gs.getTLogger().logRoleEventFlow(this, tlogEvent);
						gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrgtask(mrtTask));
						gs.getMapService().syncRoleUpdateMarriageSkillInfo(partner.id, partner.gameMapContext.getCurMapId(), skills, partner.getMarriagePartnerId());
						partner.onMarriageLvlChange(1);
						partner.doSave(now);
					}
					synchronized (this)
					{
						this.marriageData.marriageShareId = marriageshare.getId();
						this.marriageData.partnerName = partner.name;
						this.tryUnlockWarehouse();
						if (gradeCFGS.dressId > 0)
							this.mailbox.addSysMail(SysMailType.Marriage, MailBox.MARRIAGE_MAIL_MAX_RESERVE_TIME, partner.name, marriageDress, GameData.emptyList());
						gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_mrgtask(mrtTask));
						gs.getMapService().syncRoleUpdateMarriageSkillInfo(this.id, this.gameMapContext.getCurMapId(), skills, this.getMarriagePartnerId());
						this.onMarriageLvlChange(1);
						this.doSave(now);
					}
					if (gradeCFGS.rollNoticeDisplay == 1)
						gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_MARRIAGE, this.name + "|" + partner.name);
					partner.pushProposeResponse(response);
					gs.getLoginManager().sendRoleMarriageFlash(marriageshare.getMarriageType(), this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance());
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_SUCCESS));
					gs.getTLogger().logMarriageFlow(this, partner, marriageshare.getId(), TLog.MARRIAGE_RESPONSE, response);
					return;
				}
				else
				{
					gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_MARRIAGE_SAVE_FAILD));
					return;
				}
			});
			return;
		}
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.propose_response_res(GameData.PROTOCOL_OP_FAILED));
	}
	
	private boolean tryUnlockWarehouse()
	{
		if (this.warehouse.getCellSize() != 0)
			return false;
		this.warehouse = new ItemCellCollection(GameData.getInstance().getCommonCFG().warehouse.privateDefaultSize, 0);
		return true;
	}
	
	public synchronized int unlockWarehouse()
	{
		SBean.CommonWarehouseCFGS cfg = GameData.getInstance().getCommonCFG().warehouse;
		if (this.warehouse.getCellSize() != 0 || this.level < cfg.unlockLevel || !this.canUseDiamond(cfg.privateUnlockPrice, true))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UNLOCK_PRIVATE_WAREHOUSE);
		useDiamond(cfg.privateUnlockPrice, true, tlogEvent.getGameItemRecords());
		tryUnlockWarehouse();
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public void syncMapMarriageSkills(boolean isDivoce)
	{
		MarriageShare marriageshare = this.getSharedMarriage();
		if (!isDivoce && marriageshare == null)
			return;
		gs.getMapService().syncRoleUpdateMarriageSkillInfo(this.id, this.gameMapContext.getCurMapId(), marriageshare == null ? GameData.emptyMap() : marriageshare.getMarriageSkillMap(), getMarriagePartnerId());
	}
	
	public int getMarriagePartnerId()
	{
		MarriageShare marriageshare = this.getSharedMarriage();
		if (marriageshare == null)
			return 0;
		return this.id == marriageshare.getManId() ? marriageshare.getLadyId() : marriageshare.getManId();
	}

	public void getMarriageOverview()
	{
		final MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.marriage_sync_res(null, 0));
			return;
		}
		gs.getLoginManager().getRoleOverview(marriage.getManId() == this.id ? marriage.getLadyId() : marriage.getManId(), (overview) ->
		{
			if (overview != null)
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.marriage_sync_res(new SBean.MarriageShareOverView(marriage.getMarriageType(), marriage.getMarriageExp(), marriage.getMarriageLevel(), marriage.getMarriageSkill(), marriage.getMarriageTime(), marriage.getMarriageStep(), overview), this.marriageData.lastTransformTime));
			else
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.marriage_sync_res(null, 0));
		});
	}

	public boolean gmStartMarriageParade()
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null || cfg == null)
			return false;
		if (this.team.id <= 0 || this.team.members.size() != 2)
			return false;
		int partnerID = 0;
		for (int rid : this.team.members)
		{
			if (rid != this.id)
			{
				partnerID = rid;
				break;
			}
		}
		Role partner = gs.getLoginManager().getOnGameRole(partnerID);
		if (partner == null || (partnerID != marriage.getManId() && partnerID != marriage.getLadyId()))
			return false;
		if (!GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), cfg.marriageNpcId, GameData.getInstance().getCommonCFG().task.npcRadius) || !GameData.getInstance().testNearbyNPC(partner.gameMapContext.getCurMapId(), partner.gameMapContext.getCurMapPosition(), cfg.marriageNpcId, GameData.getInstance().getCommonCFG().task.npcRadius))
			return false;
		
		MultipleRoles mr = new Role.MultipleRoles(this, partner);
		try
		{
			mr.lock();
			if(mr.isClosed())
				return false;
			
			synchronized(this)
			{
				if(this.isMulRolesState())
					return false;
			}
			
			synchronized(partner)
			{
				if(partner.isMulRolesState())
					return false;
			}
		}
		finally
		{
			mr.unlock();
		}
		
		gs.getMapService().syncRoleStartMarriageParade(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance(), cfg.carId, this.getRoleOverview(), partner.getRoleOverview());
		return true;
	}
	
	public int startMarriageParade()
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null || cfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.team.id <= 0 || this.team.members.size() != 2)
			return GameData.PROTOCOL_OP_FAILED;
		int partnerID = 0;
		for (int rid : this.team.members)
		{
			if (rid != this.id)
			{
				partnerID = rid;
				break;
			}
		}
		Role partner = gs.getLoginManager().getOnGameRole(partnerID);
		if (partner == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (partnerID != marriage.getManId() && partnerID != marriage.getLadyId())
			return GameData.PROTOCOL_OP_MARRIAGE_NOT_PARTNER;
		if (!this.testNearByNPC(cfg.marriageNpcId) || !partner.testNearByNPC(cfg.marriageNpcId))
			return GameData.PROTOCOL_OP_MARRIAGE_TOO_FAR_TO_NPC;
		int now = GameTime.getTime();
		SBean.DBMarriageBespeak mybespeak = gs.getLoginManager().getMarriageBespeak().getMarriageBespeakByRoleId(marriage.getId());
		int bespeakCheck = GameData.getInstance().testInBespeak(mybespeak, now);
		if (bespeakCheck <= 0)
			return bespeakCheck;
		if (!testInBespeakLine(mybespeak))
			return GameData.PROTOCOL_OP_MARRIAGE_NO_BESPEAK_LINE;
		int result = marriage.startMarriageParade(GameData.getInstance().getMarriageEndTime(now));
		if (result <= 0)
			return result;
		
		MultipleRoles mr = new Role.MultipleRoles(this, partner);
		try
		{
			mr.lock();
			if(mr.isClosed())
				return GameData.PROTOCOL_OP_MARRIAGE_PARTNER_NOT_ONLINE;
			
			synchronized(this)
			{
				if(this.isMulRolesState())
					return GameData.PROTOCOL_OP_FAILED;
			}
			
			synchronized(partner)
			{
				if(partner.isMulRolesState())
					return GameData.PROTOCOL_OP_MARRIAGE_IN_MULROLESTATE;
			}
		}
		finally
		{
			mr.unlock();
		}
		
		gs.getMapService().syncRoleStartMarriageParade(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance(), cfg.carId, this.getRoleOverview(), partner.getRoleOverview());
		partner.syncMarriageStep();
		gs.getTLogger().logMarriageFlow(this, partner, marriage.getId(), TLog.MARRIAGE_WALK, 1);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private void syncMarriageStep()
	{
		MarriageShare marriage = getSharedMarriage();
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_marriage_step(marriage == null ? -1 : marriage.getMarriageStep()));
	}

	public synchronized boolean testNearByNPC(int npcId)
	{
		return GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), npcId, GameData.getInstance().getCommonCFG().task.npcRadius);
	}

	public synchronized boolean gmStartMarriageBanquet(int banquet)
	{
		SBean.MarriageBanquetCFGS cfg = GameData.getInstance().getMarriageBanquetCFGS(banquet);
		if(cfg == null)
			return false;
		
		gs.getMapService().syncRoleStartMarriageBanquet(this.id, this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance(), banquet);
		return true;
	}
	
	public int startMarriageBanquet()
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null || cfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		int now = GameTime.getTime();
		SBean.DBMarriageBespeak mybespeak = gs.getLoginManager().getMarriageBespeak().getMarriageBespeakByRoleId(marriage.getId());
		int bespeakCheck = GameData.getInstance().testInBespeak(mybespeak, now);
		if (bespeakCheck <= 0)
			return bespeakCheck;
		if (!testInBespeakLine(mybespeak))
			return GameData.PROTOCOL_OP_MARRIAGE_NO_BESPEAK_LINE;
		int result = marriage.startMarriageBanquet();
		if (result <= 0)
			return result;
		//TODO 添加开启结婚宴席
		gs.getMapService().syncRoleStartMarriageBanquet(this.id, this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapInstance(), cfg.banquetType);
		Role partner = gs.getLoginManager().getOnGameRole(getMarriagePartnerId());
		if (partner != null)
		{
			partner.syncMarriageStep();
			gs.getTLogger().logMarriageFlow(this, partner, marriage.getId(), TLog.MARRIAGE_BANQUET, 1);
		}
		else
		{
			gs.getTLogger().logMarriageFlow(this, this, marriage.getId(), TLog.MARRIAGE_BANQUET, 0);
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private void updateMarriageLevel()
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return;
		
		this.marriageLevel = marriage.getMarriageLevel();
		this.roleProperties.onMarriageLevelChange(this.marriageLevel);
	}
	
	private void syncMarriageInfo()
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return;
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.login_marriage_info(marriage.getMarriageLevel(), marriage.getMarriageSkill(), marriage.getMarriageTime(), marriage.getMarriageType(), marriage.getMarriageStep(), marriage.getManId() != this.id ? marriage.getManId() : marriage.getLadyId()));
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_mrgtask(marriage.getTask().kdClone()));
		marriage.updateMinLevel(this.level);
	}

	public void tryDivorce()
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null || cfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.divorce_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		if (!marriage.getCollection().isEmpty())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.divorce_res(GameData.PROTOCOL_OP_MARRIAGE_PUBLIC_IS_NOT_EMPTY));
			return;
		}
		SBean.Counter lockcounter;
		synchronized (this)
		{
			if (!this.containsEnoughGameItem(cfg.divorceCostId, cfg.divorceCost))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.divorce_res(GameData.PROTOCOL_OP_MARRIAGE_ITEM_NEED));
				return;
			}
			lockcounter = this.lockBagItem(cfg.divorceCostId, cfg.divorceCost);
		}
		int partnerId = getMarriagePartnerId();
		int now = GameTime.getTime();
		gs.getLoginManager().delMarriageShare(marriage.getId(), partnerId, new LoginManager.DelMarriageTransCallback()
		{
			@Override
			public void onCallback(int errcode)
			{
				TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_DIVORCE);
				boolean error = errcode <= 0;
				synchronized (Role.this)
				{
					Role.this.delLockedBagItem(cfg.divorceCostId, lockcounter, error, tlogEvent.getGameItemRecords());
					if (!error)
					{
						Role.this.divoceUpdateRole();
						Role.this.syncMapMarriageSkills(true);
						Role.this.onMarriageLvlChange(0);
						Role.this.doSave(now);
					}
				}
				if (error)
				{
					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.divorce_res(GameData.PROTOCOL_OP_FAILED));
					return;
				}
				else
				{
					Role partner = gs.getLoginManager().getOnGameRole(partnerId);
					if (partner != null)
					{
						synchronized (partner)
						{
							partner.syncMapMarriageSkills(true);
							partner.onMarriageLvlChange(0);
						}
						gs.getTLogger().logMarriageFlow(Role.this, partner, marriage.getId(), TLog.MARRIAGE_DIVORCE, 1);
					}
					else
					{
						gs.getTLogger().logMarriageFlow(Role.this, Role.this, marriage.getId(), TLog.MARRIAGE_DIVORCE, 0);
					}
					gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
					gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.divorce_res(GameData.PROTOCOL_OP_SUCCESS));
					return;
				}
			}
		});
	}

	public synchronized int exchangeItemByNpc(int npcId, int exchangeId)
	{
		SBean.NpcCFGS npcCFGS = GameData.getInstance().getNpcCFGS(npcId);
		SBean.ExchangeCFGS exchangeCFGS = GameData.getInstance().getExchangeCFGS(exchangeId);
		if (npcCFGS == null || exchangeCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (!npcCFGS.functionArg.contains(exchangeId))
			return GameData.PROTOCOL_OP_EXCHANGE_NPC_CAN_NOT_OFFER;
		if (exchangeCFGS.dayTimes != -1 && exchangeTimes.getOrDefault(exchangeId, 0) > exchangeCFGS.dayTimes)
			return GameData.PROTOCOL_OP_EXCHANGE_NEED_TIMES;
		if (!this.containsEnoughGameItems(exchangeCFGS.itemCost))
			return GameData.PROTOCOL_OP_EXCHANGE_ITEM_NEED;
		if (!this.canAddGameItems(exchangeCFGS.itemGet))
			return GameData.PROTOCOL_OP_EXCHANGE_BAG_NEED;
		if (!GameData.getInstance().testNearbyNPC(this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapPosition(), npcId, GameData.getInstance().getCommonCFG().task.npcRadius))
			return GameData.PROTOCOL_OP_EXCHANGE_FAR_FROM_NPC;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ITEM_EXCHANGE);
		this.delGameItems(exchangeCFGS.itemCost, tlogEvent.getGameItemRecords());
		this.syncAddGameItems(GameData.getInstance().toGameItems(exchangeCFGS.itemGet), tlogEvent);
		this.exchangeTimes.merge(exchangeId, 1, (ov, nv) -> ov + nv);
		logExchangeScheduleData(npcId);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int marriageSkillLevelUp(int skillId, int levelupTimes)
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null || cfg == null || !marriage.getMarriageSkill().containsKey(skillId) || levelupTimes <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canUseCoin(cfg.skillUseCoin * levelupTimes, true))
			return GameData.PROTOCOL_OP_MARRIAGE_ITEM_NEED;
		int oldLevel = getSharedMarriage().getMarriageSkill(skillId).skillLevel;
		int result = marriage.skillLevelUp(skillId, levelupTimes);
		if (result <= 0)
			return result;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MARRIAGE_SKILL_LEVEL_UP);

		synchronized (this)
		{
			this.useCoin(cfg.skillUseCoin * levelupTimes, true, tlogEvent.getGameItemRecords());
		}
		int newLevel = getSharedMarriage().getMarriageSkill(skillId).skillLevel;
		if (newLevel > oldLevel)
		{
			this.onMarriageSkillLevelUp(skillId, newLevel);
			Role partner = gs.getLoginManager().getOnGameRole(this.id == marriage.getManId() ? marriage.getLadyId() : marriage.getManId());
			if (partner != null)
				partner.onMarriageSkillLevelUp(skillId, newLevel);
		}
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private synchronized void onMarriageSkillLevelUp(int skillId, int newLevel)
	{
		gs.getMapService().syncRoleUpdateMarriageSkillLevel(this.id, this.gameMapContext.getCurMapId(), skillId, newLevel);
	}
	
	public int transformToMarriage()
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null || cfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		int now = GameTime.getTime();
		if (this.marriageData.lastTransformTime + cfg.transmitCD > now)
			return GameData.PROTOCOL_OP_MARRIAGE_TRANSMIT_IN_CD;
		
		Role role = gs.getLoginManager().getOnGameRole(marriage.getManId() == this.id ? marriage.getLadyId() : marriage.getManId());
		if(role==null)
			return GameData.PROTOCOL_OP_MARRIAGE_PARTNER_NOT_ONLINE;
		
		SBean.MapLocation targetLocation = null;
		int line = 0;
		synchronized (role)
		{
			if(!role.gameMapContext.isInWorldMap())
				return GameData.PROTOCOL_OP_FAILED;
			
			targetLocation = role.gameMapContext.getWorldMapContext().getMapLocation().kdClone();
			line = role.gameMapContext.getCurWorldInstanceId();
		}
		int transfromres = 0;
		synchronized (this)
		{
			if(this.isMulRolesMember() || this.mulRolesLock > 0)
				return GameData.PROTOCOL_OP_MARRIAGE_IN_MULROLESTATE;
		}
		
		transfromres = this.transformToRolePosition(targetLocation, line);
		if (transfromres <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		this.marriageData.lastTransformTime = now;
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private Role getTeamMrgPartner(MarriageShare marriage)
	{
		for(int memberID: this.team.members)
		{
			if(memberID != marriage.getParterId(this.id))
				continue;
			
			return gs.getLoginManager().getOnGameRole(memberID);
		}
		return null;
	}
	
	int openMrgSeriesTask()
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role partner = null;
		synchronized(this)
		{
			if(this.team.leader == 0)
				return GameData.PROTOCOL_OP_MRGTASK_NO_TEAM;
			
			if(this.team.members.size() != 2)
				return GameData.PROTOCOL_OP_MRGTASK_TEAM_CNT;
			
			if(this.team.leader != this.id)
				return GameData.PROTOCOL_OP_FAILED;
			
			boolean parterInTeam = false;
			int partnerID = this.getMarriagePartnerId();
			for(int mid: this.team.members)
			{
				if(partnerID == mid)
				{
					parterInTeam = true;
					break;
				}
			}
			
			if(!parterInTeam)
				return GameData.PROTOCOL_OP_FAILED;
			
			partner = gs.getLoginManager().getOnGameRole(partnerID);
			if(partner == null)
				return GameData.PROTOCOL_OP_FAILED;
		}
		
		int ok = marriage.openSeriesTask(this, partner);
		if(ok > 0)
		{
			this.updateMrgSeriesTaskDrop(Role::addTaskDrop);
			partner.updateMrgSeriesTaskDrop(Role::addTaskDrop);
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrgseriestask_open(1));
		}
		
		return ok;
	}
	
	int takeMrgSeriesTask(int taskID)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role partner = null;
		synchronized(this)
		{
			if(this.team.leader == 0)
				return GameData.PROTOCOL_OP_MRGTASK_NO_TEAM;
			
			if(this.team.leader != this.id)
				return GameData.PROTOCOL_OP_FAILED;
			
			partner = getTeamMrgPartner(marriage);
			if(partner == null)
				return GameData.PROTOCOL_OP_FAILED;
		}
		
		int ok = marriage.takeSeriesTask(this, partner, taskID);
		if(ok > 0)
		{
			this.updateMrgSeriesTaskDrop(Role::addTaskDrop);
			partner.updateMrgSeriesTaskDrop(Role::addTaskDrop);
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrgseriestask_take(marriage.getTask().series.receiveTime));
		}
		
		return ok;
	}
	
	int takeMrgSeriesTaskReward(int taskID)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role partner = null;
		synchronized(this)
		{
			if(this.team.leader == 0)
				return GameData.PROTOCOL_OP_MRGTASK_NO_TEAM;
			
			if(this.team.leader != this.id)
				return GameData.PROTOCOL_OP_FAILED;
			
			partner = getTeamMrgPartner(marriage);
			if(partner == null)
				return GameData.PROTOCOL_OP_FAILED;
		}
		
		int ok = marriage.takeSeriesTaskReward(this, partner, taskID);
		if(ok > 0)
		{
			this.updateMrgSeriesTaskDrop(Role::delTaskDrop);
			partner.updateMrgSeriesTaskDrop(Role::delTaskDrop);
			
			this.logTaskScheduleData(GameData.SCHEDULE_TYPE_MARRIAGE_TASK);
			partner.logTaskScheduleData(GameData.SCHEDULE_TYPE_MARRIAGE_TASK);
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrgseriestask_reward(marriage.getTask().series.receiveTime));
		}
		return ok;
	}
	
	private void onMarriageLvlChange(int newLevel)
	{
		this.marriageLevel = newLevel;
		this.roleProperties.onMarriageLevelChange(newLevel);
		gs.getMapService().syncRoleMarriageLevelChange(this.gameMapContext.getCurMapId(), this.id, newLevel);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_marriage_level(newLevel));
	}
	
	public void addMrgSeriesTaskReward(SBean.MrgSeriesTaskCFGS taskCfg, int group, int taskID, int marriageLevel)
	{
		gs.getLoginManager().addNormalTaskEvent(() -> {
			synchronized(this)
			{
				if(taskCfg.expFactor > 0)
				{
					int exp = (int) (taskCfg.expFactor * GameData.getInstance().getMrgTaskLevelBaseExp(this.level));
					this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_MARRIAGE_TASK, GameData.MARRIAGE_OFFLINEEXP_TYPE_SERIES);
				}
				
				if(!taskCfg.rewards.isEmpty())
				{
					if(this.canAddGameItems(taskCfg.rewards))
					{
						TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_MRGSERIES_TASK_REWARD);
						tlogEvent.setArg(group, taskID);
						this.syncAddGameItems(GameData.getInstance().toGameItems(taskCfg.rewards), tlogEvent);
						gs.getTLogger().logRoleEventFlow(this, tlogEvent);
					}
					else
					{
						this.addTaskRewardToMailBox(GameData.TASK_CATEGORY_MRG_SERIES, group, taskID, GameData.getInstance().toGameItems(taskCfg.rewards));
					}
				}
				
				if(marriageLevel > 0)
					this.onMarriageLvlChange(marriageLevel);
			}
		});
	}
	
	public int openMrgLoopTask()
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role partner = null;
		synchronized(this)
		{
			if(this.team.leader == 0)
				return GameData.PROTOCOL_OP_MRGTASK_NO_TEAM;

			if(this.team.members.size() != 2)
				return GameData.PROTOCOL_OP_MRGTASK_TEAM_CNT;
		
			if(this.team.leader != this.id)
				return GameData.PROTOCOL_OP_FAILED;

			boolean parterInTeam = false;
			int partnerID = this.getMarriagePartnerId();
			for(int mid: this.team.members)
			{
				if(partnerID == mid)
				{
					parterInTeam = true;
					break;
				}
			}
			
			if(!parterInTeam)
				return GameData.PROTOCOL_OP_FAILED;
			
			partner = gs.getLoginManager().getOnGameRole(partnerID);
			if(partner == null)
				return GameData.PROTOCOL_OP_FAILED;
		}
		
		int ok = marriage.openLoopTask(this, partner);
		if(ok > 0)
		{
			this.updateMrgLoogTaskDrop(Role::addTaskDrop);
			partner.updateMrgLoogTaskDrop(Role::addTaskDrop);
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrglooptask_open(1));
		}
		
		return ok;
	}
	
	public int takeMrgLoopTask(int taskID)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		Role partner = null;
		synchronized(this)
		{
			if(this.team.leader == 0)
				return GameData.PROTOCOL_OP_MRGTASK_NO_TEAM;
			
			if(this.team.leader != this.id)
				return GameData.PROTOCOL_OP_FAILED;
			
			partner = getTeamMrgPartner(marriage);
			if(partner == null)
				return GameData.PROTOCOL_OP_FAILED;
		}
		
		int ok = marriage.takeLoopTask(this, partner, taskID);
		if(ok > 0)
		{
			this.updateMrgLoogTaskDrop(Role::addTaskDrop);
			partner.updateMrgLoogTaskDrop(Role::addTaskDrop);
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrglooptask_take(marriage.getTask().loop.receiveTime));
		}
		
		return ok;
	}
	
	interface TakeMrgLoopTaskRewardTaskCallBack
	{
		void onCallBack(int ok, int taskID);
	}
	
	public void takeMrgLoopTaskReward(int taskID, TakeMrgLoopTaskRewardTaskCallBack callback)
	{
		MarriageShare marriage = getSharedMarriage();
		if (marriage == null)
		{
			if(callback != null)
				callback.onCallBack(GameData.PROTOCOL_OP_FAILED, taskID);
			return;
		}
		
		Role partner = null;
		synchronized(this)
		{
			if(this.team.leader == 0)
			{
				if(callback != null)
					callback.onCallBack(GameData.PROTOCOL_OP_MRGTASK_NO_TEAM, taskID);
				return;
			}
			
			if(this.team.leader != this.id)
			{
				if(callback != null)
					callback.onCallBack(GameData.PROTOCOL_OP_FAILED, taskID);
				return;
			}
			
			partner = getTeamMrgPartner(marriage);
			if(partner == null)
			{
				if(callback != null)
					callback.onCallBack(GameData.PROTOCOL_OP_FAILED, taskID);
				return;
			}
		}
		
		int ok = marriage.takeLoopTaskReward(this, partner, taskID);
		if(ok > 0)
		{
			this.updateMrgLoogTaskDrop(Role::delTaskDrop);
			partner.updateMrgLoogTaskDrop(Role::delTaskDrop);
			
			this.logTaskScheduleData(GameData.SCHEDULE_TYPE_MARRIAGE_TASK);
			partner.logTaskScheduleData(GameData.SCHEDULE_TYPE_MARRIAGE_TASK);
			gs.getRPCManager().sendStrPacket(partner.netsid, new SBean.role_mrglooptask_reward(marriage.getTask().loop.id, marriage.getTask().loop.receiveTime));
		}
		
		if(callback != null)
			callback.onCallBack(ok, marriage.getTask().loop.id);
	}
	
	public void addMrgLoopTaskReward(SBean.MrgLoopTaskCFGS taskCfg, int taskID, int marriageLevel)
	{
		gs.getLoginManager().addNormalTaskEvent(() -> {
			synchronized(this)
			{
				if(taskCfg.expFactor > 0)
				{
					int exp = (int) (taskCfg.expFactor * GameData.getInstance().getMrgTaskLevelBaseExp(this.level));
					this.syncAddExp(exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_MARRIAGE_TASK, GameData.MARRIAGE_OFFLINEEXP_TYPE_LOOP);
				}
				
				if(!taskCfg.rewards.isEmpty())
				{
					if(this.canAddGameItems(taskCfg.rewards))
					{
						TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_MRGSERIES_TASK_REWARD);
						tlogEvent.setArg(taskID);
						this.syncAddGameItems(GameData.getInstance().toGameItems(taskCfg.rewards), tlogEvent);
						gs.getTLogger().logRoleEventFlow(this, tlogEvent);
					}
					else
					{
						this.addTaskRewardToMailBox(GameData.TASK_CATEGORY_MRG_LOOP, 0, taskID, GameData.getInstance().toGameItems(taskCfg.rewards));
					}
				}
				
				if(marriageLevel > 0)
					this.onMarriageLvlChange(marriageLevel);
			}
		});
	}
	
	void dayRefreshMarriage()
	{
		this.marriageData.dayTakeBanquetTimes = 0;
		this.marriageData.dayTakeWeddingBoxTimes = 0;
	}
	
	public void dayRefreshExchange()
	{
		this.exchangeTimes.clear();
	}
	
	public synchronized int saveSkillPreset(int index, String name, List<Integer> skills, int diySkill, int uniqueSkill)
	{
		int result = checkSkillPreset(index, name, skills, diySkill, uniqueSkill);
		if (result <= 0)
			return result;
		if (this.skillPreset.size() < index)
			this.skillPreset.add(new SBean.DBSkillPreset(name, skills, diySkill, uniqueSkill));
		else
			this.skillPreset.set(index - 1, new SBean.DBSkillPreset(name, skills, diySkill, uniqueSkill));
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int saveAllSkillPreset(List<SBean.DBSkillPreset> skills)
	{
		if (skills.size() > GameData.getInstance().getCommonCFG().skill.skillPresetMaxSize)
			return GameData.PROTOCOL_OP_SKILL_PRESET_MAX_SIZE;
		for (int i = 1; i <= skills.size(); i++)
		{
			SBean.DBSkillPreset preset = skills.get(i - 1);
			int result = checkSkillPreset(i, preset.skillPresetName, preset.skillPreset, preset.diySkill, preset.uniqueSkill);
			if (result <= 0)
				return result;
		}
		this.skillPreset = new ArrayList<>(skills);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private int checkSkillPreset(int index, String name, List<Integer> skills, int diySkill, int uniqueSkill)
	{
		if (skills.size() != 4)
			return GameData.PROTOCOL_OP_FAILED;
		if (index > GameData.getInstance().getCommonCFG().skill.skillPresetMaxSize || index <= 0)
			return GameData.PROTOCOL_OP_SKILL_PRESET_MAX_SIZE;
		if ((uniqueSkill != 0 && !this.skills.containsKey(uniqueSkill)) || skills.stream().anyMatch(skillId -> !this.skills.containsKey(skillId)))
			return GameData.PROTOCOL_OP_SKILL_PRESET_DO_NOT_HAVE;
		if (diySkill != 0 && !this.diySkillData.diySkills.stream().anyMatch(diyskill -> diyskill.id == diySkill))
			return GameData.PROTOCOL_OP_SKILL_PRESET_DO_NOT_HAVE;
		if (!GameData.getInstance().checkInputStrValid(name, GameData.getInstance().getCommonCFG().input.maxSkillPresetNameLength, true))
			return GameData.PROTOCOL_OP_SKILL_PRESET_NAME_INVALID;
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int saveSpiritsPreset(int index, String name, List<Integer> skills)
	{
		if (index > GameData.getInstance().getCommonCFG().skill.spiritsPresetMaxSize || index <= 0)
			return GameData.PROTOCOL_OP_SKILL_PRESET_MAX_SIZE;
		if (skills.stream().anyMatch(skillId -> !this.spirits.containsKey(skillId)))
			return GameData.PROTOCOL_OP_SKILL_PRESET_DO_NOT_HAVE;
		if (!GameData.getInstance().checkInputStrValid(name, GameData.getInstance().getCommonCFG().input.maxSkillPresetNameLength, true))
			return GameData.PROTOCOL_OP_SKILL_PRESET_NAME_INVALID;
		if (this.spiritsPreset.size() < index)
			this.spiritsPreset.add(new SBean.DBSpiritsPreset(name, skills));
		else
			this.spiritsPreset.set(index - 1, new SBean.DBSpiritsPreset(name, skills));
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int deleteSkillPreset(int index)
	{
		if (index > this.skillPreset.size() || index <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		this.skillPreset.remove(index - 1);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int deleteSpiritsPreset(int index)
	{
		if (index > this.spiritsPreset.size() || index <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		this.spiritsPreset.remove(index - 1);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int changeSkillPreset(int index)
	{
		if (index > this.skillPreset.size() || index <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBSkillPreset preset = this.skillPreset.get(index - 1);
		this.curSkills = new ArrayList<>(preset.skillPreset);
		this.diySkillSelectUse(preset.diySkill);
		this.setCurUniqueSkill(preset.uniqueSkill);
		gs.getMapService().syncRoleUpdateCurSkills(this.id, this.gameMapContext.getCurMapId(), this.curSkills);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int changeSpiritsPreset(int index)
	{
		if (index > this.spiritsPreset.size() || index <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		this.curSpirits = new HashSet<Integer>(this.spiritsPreset.get(index - 1).spiritsPreset);
		this.roleProperties.onUpdateCurSpirit(this.curSpirits);
		gs.getMapService().syncRoleUpdateCurSpirit(this.id, this.gameMapContext.getCurMapId(), this.curSpirits);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private int transformToRolePosition(SBean.MapLocation location, int line)
	{
		synchronized(this)
		{
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(location, line);
				this.gameMapContext.roleChangeMap();
				return GameData.PROTOCOL_OP_SUCCESS;
				
			}
		}
		this.mulRolesChangeMap(location, line);
		return GameData.PROTOCOL_OP_SUCCESS;
//		if(this.gameMapContext.getCurMapId() == location.mapID && this.gameMapContext.getCurMapInstance() == line)
//		{
//			this.gameMapContext.resetLocation(location.location);
//		}
//		else
//		{
//			this.gameMapContext.changeWorld(location, line);
//		}
//		
//		this.gameMapContext.roleChangeMap();
//		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private boolean transformToActivityEntity(SBean.ActivityEntity activityEntity)
	{
		if (activityEntity == null)
			return false;
		SBean.MapLocation mapLocation = null;
		if (activityEntity.entityType == GameData.ACTIVITY_ENTITY_TYPE_WORLDBOSS)
			mapLocation = GameData.getInstance().getWorldBossMapLocation(activityEntity.id, activityEntity.seq);
		if (activityEntity.entityType == GameData.ACTIVITY_ENTITY_TYPE_LITTLEBOSS)
			mapLocation = GameData.getInstance().getSuperMonsterMapLocation(activityEntity.id, activityEntity.seq);
		if (activityEntity.entityType == GameData.ACTIVITY_ENTITY_TYPE_BOX)
			mapLocation = GameData.getInstance().getMineralMapLocation(activityEntity.id, activityEntity.seq);
		if (mapLocation == null)
			return false;
		
		if(mapLocation.mapID == this.gameMapContext.getCurMapId() && (activityEntity.mapLine) == this.gameMapContext.getCurMapInstance())
		{
			this.gameMapContext.resetLocation(mapLocation.location.kdClone());
		}
		else
		{
			this.gameMapContext.changeWorld(mapLocation.kdClone(), activityEntity.mapLine);
		}
		
		this.gameMapContext.roleChangeMap();
		return true;
	}

	public void syncSectGroupMapCopyData()
	{
		SBean.SyncGroupMapBean groupMapData =  gs.getSectManager().getSectGroupMapCopyData(this);
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_group_map_sync_res(groupMapData.sectGroupMapInfo, groupMapData.sectMemberLevel));
	}

	public void syncSectGroupMapEnd(int mapId, int finishTime, int progress, int rank)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_group_map_end(mapId, finishTime, progress, rank));
	}

	public synchronized int weaponSkillLevelUp(int weaponId, int skillIndex, int level)
	{
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(weaponId);
		if (weaponCFGS == null || skillIndex <= 0 || skillIndex > weaponCFGS.skills.size())
			return GameData.PROTOCOL_OP_FAILED;
		SBean.WeaponSkillLevelUpGroupCFGS weaponSkillCFGS = weaponCFGS.skillLevelUpCost.get(skillIndex - 1);
		SBean.DBWeapon operWeapon = this.weapons.get(weaponId);
		int curLevel = operWeapon.skills.get(skillIndex - 1);
		if (weaponSkillCFGS == null || level <= curLevel || level > weaponSkillCFGS.costGroup.size())
			return GameData.PROTOCOL_OP_FAILED;
		SBean.WeaponSkillLevelUpCFGS costCFGS = weaponSkillCFGS.costGroup.get(curLevel - 1);
		if (costCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (operWeapon.level < costCFGS.weaponLevelNeed)
			return GameData.PROTOCOL_OP_WEAPON_SKILL_LEVEL_NEED;
		if (!this.containsEnoughGameItems(GameData.toDummGoods(costCFGS.costs.get(level).dummyGoods)))
			return GameData.PROTOCOL_OP_WEAPON_SKILL_ITEM_NEED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WEAPON_SKILL_LEVEL_UP);
		tlogEvent.setArg(weaponId, skillIndex, level);
		this.delGameItems(GameData.toDummGoods(costCFGS.costs.get(level).dummyGoods), tlogEvent.getGameItemRecords());
		operWeapon.skills.set(skillIndex - 1, level);
		gs.getMapService().syncRoleUpdateWeaponSkills(this.id, this.gameMapContext.getCurMapId(), weaponId, operWeapon.skills);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int weaponTalentLevelUp(int weaponId, int talentIndex)
	{
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(weaponId);
		if (weaponCFGS == null || talentIndex <= 0 || talentIndex > weaponCFGS.talents.size())
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBWeapon operWeapon = this.weapons.get(weaponId);
		int curLevel = operWeapon.talent.get(talentIndex - 1);
		int allTalentPoint = 0;
		for (int point : operWeapon.talent)
		{
			allTalentPoint += point;
		}
		if (operWeapon.canUseTalentPoint <= 0)
			return GameData.PROTOCOL_OP_WEAPON_TALENT_POINT_NEED;
		if (allTalentPoint < weaponCFGS.talents.get(talentIndex - 1).preTalentPoint)
			return GameData.PROTOCOL_OP_WEAPON_TALENT_PRE_POINT_NEED;
		if (curLevel >= weaponCFGS.talents.get(talentIndex - 1).maxUsePoint)
			return GameData.PROTOCOL_OP_WEAPON_TALENT_EARLY_MAX_LEVEL;

		operWeapon.canUseTalentPoint--;
		operWeapon.talent.set(talentIndex - 1, curLevel + 1);
		gs.getMapService().syncRoleUpdateWeaponTalents(this.id, this.gameMapContext.getCurMapId(), weaponId, operWeapon.talent);
		 
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int weaponGetTalentPoint(int weaponId)
	{
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(weaponId);
		if (weaponCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBWeapon operWeapon = this.weapons.get(weaponId);
		int allTalentPoint = 0;
		for (int point : operWeapon.talent)
		{
			allTalentPoint += point;
		}
		allTalentPoint += operWeapon.canUseTalentPoint;
		if(allTalentPoint >=weaponCFGS.talentLevelUpCost.size())
			return GameData.PROTOCOL_OP_WEAPON_TALENT_POINT_MAX;
		SBean.MutiDummyGoods cost = weaponCFGS.talentLevelUpCost.get(allTalentPoint);
		if(!this.containsEnoughGameItems(GameData.toDummGoods(cost.dummyGoods)))
			return GameData.PROTOCOL_OP_WEAPON_TALENT_POINT_BUY_NEED_ITEMS;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WEAPON_TALENT_POINT_BUY);
		tlogEvent.setArg(weaponId, allTalentPoint);
		this.delGameItems(GameData.toDummGoods(cost.dummyGoods), tlogEvent.getGameItemRecords());
		operWeapon.canUseTalentPoint++;

		gs.getTLogger().logWeaponTalentPoint(this, weaponId, allTalentPoint);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);

		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int weaponResetTalentPoint(int weaponId)
	{
		SBean.WeaponCFGS weaponCFGS = GameData.getInstance().getWeaponCFGS(weaponId);
		if (weaponCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.DBWeapon operWeapon = this.weapons.get(weaponId);
		int allTalentPoint = 0;
		for (int point : operWeapon.talent)
		{
			allTalentPoint += point;
		}
		allTalentPoint += operWeapon.canUseTalentPoint;
		int costId = GameData.getInstance().getWeaponTalentCommonCFGS().resetPointItemId;
		int costNum = GameData.getInstance().getWeaponTalentCommonCFGS().resetPointItemNum;
		if (!this.containsEnoughGameItem(costId, costNum))
			return GameData.PROTOCOL_OP_WEAPON_TALENT_POINT_BUY_NEED_ITEMS;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_WEAPON_TALENT_POINT_RESET);
		tlogEvent.setArg(weaponId);
		this.delGameItem(costId, costNum, tlogEvent.getGameItemRecords());
		operWeapon.canUseTalentPoint = allTalentPoint;
		for (int i = 0; i < operWeapon.talent.size(); i++)
		{
			operWeapon.talent.set(i, 0);
		}
		gs.getMapService().syncRoleUpdateWeaponTalents(this.id, this.gameMapContext.getCurMapId(), weaponId, operWeapon.talent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);

		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private void tryReceiveMissVit(int timeTick)
	{
		SBean.VipCFGS vipCFGS = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipCFGS.canGetMissVit == 1)
		{
			SBean.VipMissVitGetCFGS vipMissVitGetCFGS = GameData.getInstance().getCommonCFG().vipMissVitGet;
			int lastVitTime = GameData.getInstance().getLastVitTaskTime(timeTick);
			gs.getLogger().debug("try send miss vit to role " + this.id);
			for (int i = 0; i < 3; i++ )
			{
				int dailyVitId = GameData.DAILY_TASK_ID_RECEIVE_VIT_1 + i;
				SBean.DailyTaskCFGS cfg = GameData.getInstance().getDailyActivity(dailyVitId);
				if (!this.dailyVit.reward.contains(dailyVitId) && GameTime.getSecondOfDay(timeTick) > cfg.rewardEndTime)
				{
					if (GameTime.getSecondOfDay(lastVitTime) == cfg.rewardEndTime)
					{
						List<Integer> addition = new ArrayList<>();
						Map<Integer, Integer> items = new HashMap<>();
						addition.add(lastVitTime);
						int count = (int) ((cfg.rewards.get(0).count / vipMissVitGetCFGS.itemOfferVit) * (1 + getSpecialCardTakeVitAddtion()));
						items.put(vipMissVitGetCFGS.itemId, count);
						addition.add(i + 1);
						mailbox.addSysMail(MailBox.SysMailType.VipMissVitGet, MailBox.VIP_MISS_VIT_GET_MAIL_MAX_RESERVE_TIME, "", GameData.getInstance().toGameItems(items), addition);
						this.dailyVit.lastReceiveVitTime = lastVitTime;
						if (GameTime.getDay(lastVitTime) == GameTime.getDay(timeTick))
							this.dailyVit.reward.add(GameData.DAILY_TASK_ID_RECEIVE_VIT_1 + i);
						gs.getLogger().debug("send miss vit to role " + this.id + " success! vit index is " + i);
					}
				}
			}
		}
		this.dailyVit.lastReceiveVitTime = GameData.getInstance().getLastVitTaskTime(timeTick);
	}

	private void tryReceiveVipMissVitOnlogin(int timeTick)
	{
		SBean.VipCFGS vipCFGS = GameData.getInstance().getVipCFGS(this.getUseableVipLvl());
		if (vipCFGS.canGetMissVit == 1)
		{
			SBean.VipMissVitGetCFGS vipMissVitGetCFGS = GameData.getInstance().getCommonCFG().vipMissVitGet;
			int nexttime = this.dailyVit.lastReceiveVitTime;
			if (nexttime == 0)
				return;
			int firstday = GameTime.getDay(nexttime);
			int firstDayTime = GameTime.getDayStartTime(GameTime.getDay(nexttime));
			int lastVitTime = GameData.getInstance().getLastVitTaskTime(timeTick);
			int day = GameTime.getDay(timeTick);
			gs.getLogger().debug("try send miss vit to role " + this.id + " on login, today is " + day);
			List<Integer> endTimes = new ArrayList<>();
			endTimes.add(GameData.getInstance().getDailyActivity(GameData.DAILY_TASK_ID_RECEIVE_VIT_1).rewardEndTime);
			endTimes.add(GameData.getInstance().getDailyActivity(GameData.DAILY_TASK_ID_RECEIVE_VIT_2).rewardEndTime);
			endTimes.add(GameData.getInstance().getDailyActivity(GameData.DAILY_TASK_ID_RECEIVE_VIT_3).rewardEndTime);
			int curIndex = 0;
			for (int i = 0; i < 3; i++)
			{
				if (GameTime.getDayTime(day, endTimes.get(i)) <= lastVitTime)
					this.dailyVit.reward.add(GameData.DAILY_TASK_ID_RECEIVE_VIT_1 + i);
				if (endTimes.get(i) == GameTime.getSecondOfDay(nexttime))
				{
					curIndex = i;
					break;
				}
			}
			for (int i = 0; i < vipMissVitGetCFGS.getMaxTimes; i++)
			{
				curIndex++;
				nexttime = firstDayTime + GameTime.getDayTimeSpan() * (curIndex / 3) + endTimes.get(curIndex % 3);
				if (nexttime > lastVitTime)
					break;
				List<Integer> addition = new ArrayList<>();
				Map<Integer, Integer> items = new HashMap<>();
				addition.add(nexttime);
				items.put(vipMissVitGetCFGS.itemId, GameData.getInstance().getDailyActivity(GameData.DAILY_TASK_ID_RECEIVE_VIT_1 + (curIndex % 3)).rewards.get(0).count / vipMissVitGetCFGS.itemOfferVit);
				addition.add(curIndex % 3 + 1);
				this.mailbox.addSysMail(MailBox.SysMailType.VipMissVitGet, MailBox.VIP_MISS_VIT_GET_MAIL_MAX_RESERVE_TIME, "", GameData.getInstance().toGameItems(items), addition);
				gs.getLogger().debug("login send miss vit to role " + this.id + " success!day is " + (firstday + (curIndex / 3)) + ", vit index is " + (curIndex % 3));
			}
			this.dailyVit.lastReceiveVitTime = lastVitTime;
		}
		else
		{
			this.dailyVit.lastReceiveVitTime = GameData.getInstance().getLastVitTaskTime(timeTick);
		}
	}
	
	public int sendItemToRole(int itemId, int num, int roleId)
	{
		if (itemId > 0)
			return GameData.PROTOCOL_OP_GIFT_CAN_NOT_SEND;
		
		if (num <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		
		CellItem ci = this.getBagItem(itemId);
		if(ci == null || ci.getCount() < num)
			return GameData.PROTOCOL_OP_FAILED;
		
		CellItem.Useable useable = ci.getUseable();
		if(useable == null || !useable.canGift())
			return GameData.PROTOCOL_OP_FAILED;
		
		Role friend = gs.getLoginManager().getOnGameRole(roleId);
		if (friend==null)
			return GameData.PROTOCOL_OP_GIFT_FRIEND_NOT_ONLINE;
		SBean.Counter lockItems;
		if (!this.containsEnoughGameItem(itemId, num))
			return GameData.PROTOCOL_OP_GIFT_ITEM_NEED;
		synchronized (this)
		{
			lockItems = this.lockBagItem(itemId, num);
		}
		boolean receiveResult = friend.receiveFriendGifts(itemId, num);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SEND_GIFT);
		synchronized (this)
		{
			this.delLockedBagItem(itemId, lockItems, !receiveResult, tlogEvent.getGameItemRecords());
			if (receiveResult)
			{
				gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			}
		}
		return receiveResult ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_GIFT_FRIEND_BAG_FULL;
	}
	
	private synchronized boolean receiveFriendGifts(int itemId, int num)
	{
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_GET_GIFT);
		if (!canAddGameItem(itemId, num))
			return false;
		this.syncAddGameItem(GameData.getInstance().toGameItem(Math.abs(itemId), num), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return true;
	}
	
	//---------------------------------------------------任务触发怪-------------------------------------------------------------
	public class TrigSpawnPoint
	{
		Set<Integer> spawns;
		
		TrigSpawnPoint()
		{
			spawns = new HashSet<>();
		}
		
		void addSpawnPoint(int pointID)
		{
			this.spawns.add(pointID);
		}
		
		void delSpawnPoint(int pointID)
		{
			this.spawns.remove(pointID);
		}
		
		boolean isEmpty()
		{
			return this.spawns.isEmpty();
		}
		
		Collection<Integer> getPoints()
		{
			return this.spawns;
		}
	}
	
	private void initTrigSpawnPoint()
	{
		if(this.mainTask.state > 0)
		{
			SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(this.mainTask.id);
			if(mainCFGS != null)
				this.setTrigSpawnPoint(mainCFGS.cond, mainCFGS.senceTrigIDs);
		}
		
		for(Map.Entry<Integer, SBean.DBBranchTask> e: this.branchTask.entrySet())
		{
			int groupID = e.getKey();
			SBean.DBBranchTask bt = e.getValue();
			if(bt.state > 0 && bt.id > 0)
			{
				final SBean.BranchTaskDataCFGS btCfg = GameData.getInstance().getBranchTaskCFG(groupID, bt.id);
				if(btCfg != null)
					this.setTrigSpawnPoint(btCfg.taskParam, btCfg.senceTrigIDs);
			}
		}
	}
	
	private void setTrigSpawnPoint(SBean.TaskCondCFGS cond, List<Integer> trigIDs)
	{
		if(cond.type != GameData.TASK_TYPE_KILL)
			return; 
		
		for(int tid: trigIDs)
		{
			SBean.SceneTrigCFGS stc = GameData.getInstance().getSceneTrigCFGS(tid);
			if(stc == null || stc.trigEvent != GameData.SCENE_TRIG_EVENT_TAKE_TASK || stc.trigBehavior != GameData.SCENE_TRIG_BEHAVIOR_SPAWN_MONSTER)
				continue;
			
			SBean.SceneSpawnPointCFGS pointCfg = GameData.getInstance().getSceneSpawnPointCFGS(stc.param1);
			if(pointCfg != null)
				this.addTrigSpawnPoint(pointCfg);
		}
	}
	
	private void addTrigSpawnPoint(int pointID)
	{
		SBean.SceneSpawnPointCFGS pointCfg = GameData.getInstance().getSceneSpawnPointCFGS(pointID);
		if(pointCfg != null)
			this.addTrigSpawnPoint(pointCfg);
	}
	
	private void addTrigSpawnPoint(SBean.SceneSpawnPointCFGS pointCfg)
	{
		TrigSpawnPoint tsm = this.trigSpawnPoints.get(pointCfg.mapID);
		if(tsm == null)
		{
			tsm = new TrigSpawnPoint();
			this.trigSpawnPoints.put(pointCfg.mapID, tsm);
		}
		tsm.addSpawnPoint(pointCfg.id);
	}
	
	private void delTrigSpawnPoint(SBean.SceneSpawnPointCFGS pointCfg)
	{
		TrigSpawnPoint tsm = this.trigSpawnPoints.get(pointCfg.mapID);
		if(tsm == null)
			return;
		
		tsm.delSpawnPoint(pointCfg.id);
		if(tsm.isEmpty())
		{
			this.trigSpawnPoints.remove(pointCfg.mapID);
		}
	}
	
	synchronized void trigSceneMonsterAfterEnterMap(int mapID)
	{
		TrigSpawnPoint tsm = this.trigSpawnPoints.get(mapID);
		if(tsm == null)
			return;
		
		for(int pointID: tsm.getPoints())
		{
			this.sceneTrigSpawnMonster(pointID);
		}
	}

	public synchronized int petSkillLevelUp(int petId, int skillIndex, int level)
	{
		SBean.PetCFGS petCFGS = GameData.getInstance().getPetCFG(petId);
		if (petCFGS == null || skillIndex <= 0 || skillIndex > petCFGS.skills.size())
			return GameData.PROTOCOL_OP_FAILED;
		SBean.PetSkillLevelUpGroupCFGS petSkillCFGS = petCFGS.petSkill.get(skillIndex - 1);
		SBean.DBPet operPet = this.activePets.get(petId);
		int curLevel = operPet.fightPet.skill.get(skillIndex - 1);
		if (petSkillCFGS == null || level <= curLevel || level > petSkillCFGS.costGroup.size())
			return GameData.PROTOCOL_OP_FAILED;
		SBean.PetSkillLevelUpCFGS costCFGS = petSkillCFGS.costGroup.get(curLevel - 1);
		if (costCFGS == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (operPet.fightPet.level < costCFGS.petLevelNeed)
			return GameData.PROTOCOL_OP_PET_SKILL_LEVEL_NEED;
		if (!this.containsEnoughGameItems(GameData.toDummGoods(costCFGS.costs.get(level).dummyGoods)))
			return GameData.PROTOCOL_OP_PET_SKILL_ITEM_NEED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_PET_SKILL_LEVEL_UP);
		tlogEvent.setArg(petId, skillIndex, level);
		this.delGameItems(GameData.toDummGoods(costCFGS.costs.get(level).dummyGoods), tlogEvent.getGameItemRecords());
		operPet.fightPet.skill.set(skillIndex - 1, level);
		gs.getMapService().syncRoleUpdatePetSkills(this.id, this.gameMapContext.getCurMapId(), petId, operPet.fightPet.skill);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	//---------------------------------------------------任务掉落-------------------------------------------------------------
	private void initTaskDrop()
	{
		this.initMainTakDrop();
		this.initBranchTaskDrop();
		this.initWeaponTaskDrop();
		this.initPetTaskDrop();
		this.initSectTaskDrop();
		this.initPetLifeTaskDrop();
		this.initSecretArenaTaskDrop();
		this.updateMrgSeriesTaskDrop(Role::addTaskDrop);
		this.updateMrgLoogTaskDrop(Role::addTaskDrop);
	}
	
	private void initMainTakDrop()
	{
		if(this.mainTask.state > 0)
		{
			SBean.MainTaskCFGS mainCFGS = GameData.getInstance().getMainTaskCFG(this.mainTask.id);
			if(mainCFGS != null)
				this.addTaskDrop(mainCFGS.cond);
		}
	}
	
	private void initBranchTaskDrop()
	{
		for(Map.Entry<Integer, SBean.DBBranchTask> e: this.branchTask.entrySet())
		{
			int groupID = e.getKey();
			SBean.DBBranchTask bt = e.getValue();
			if(bt.state > 0 && bt.id > 0)
			{
				final SBean.BranchTaskDataCFGS btCfg = GameData.getInstance().getBranchTaskCFG(groupID, bt.id);
				if(btCfg != null)
					this.addTaskDrop(btCfg.taskParam);
			}
		}
	}
	
	private void initWeaponTaskDrop()
	{
		if(this.weaponTask.type != 0 && this.weaponTask.dayLoopCount >= GameData.getInstance().getCommonCFG().weaponTask.dayLoopCount)
			return;
		
		SBean.WeaponTaskCFGS weaponCFGS = GameData.getInstance().getWeaponTaskCFG(this.weaponTask.type, id);
		if (weaponCFGS != null)
		{
			for (int index = 0; index < weaponCFGS.conds.size(); index++)
			{
				SBean.TaskCondCFGS cond = weaponCFGS.conds.get(index);
				this.addTaskDrop(cond);
			}
		}
	}
	
	private void initPetTaskDrop()
	{
		for (SBean.DBPet e : this.activePets.values())
		{
			SBean.PetTaskCFGS cfg = GameData.getInstance().getPetTaskCFG(e.task.id);
			if(cfg != null)
				this.addTaskDrop(cfg.cond);
		}
	}
	
	private void initSectTaskDrop()
	{
		SBean.SectReceivedTask sectTask = this.sectData.task.curTask;
		if (sectTask == null)
			return;

		SBean.SectTaskCFGS sectTaskCFGS = GameData.getInstance().getSectTaskCFG(sectTask.task.taskId);
		if (sectTaskCFGS != null)
			this.addTaskDrop(sectTaskCFGS.cond);
	}
	
	private void initPetLifeTaskDrop()
	{
		for(SBean.DBPet pet: this.activePets.values())
		{
			SBean.PetLifeTaskCFGS cfg = GameData.getInstance().getPetLifeTaskCFGS(pet.fightPet.id, pet.lifetask.id);
			if(cfg != null)
				this.addTaskDrop(cfg.cond);
		}
	}
	
	private void initSecretArenaTaskDrop()
	{
		if (this.secretAreaTaskData == null || this.secretAreaTaskData.id == 0)
			return;
		SBean.SecretAreaTaskCFGS taskCfg = GameData.getInstance().getSecretTaskCfg(this.secretAreaTaskData.id);
		if (taskCfg != null)
			this.addTaskDrop(taskCfg.taskCond);
	}
	
	interface UpdateTaskDrop
	{
		void updateTaskDrop(Role role, SBean.TaskCondCFGS cond);
	}
	
	private void updateMrgSeriesTaskDrop(UpdateTaskDrop func)
	{
		MarriageShare marriage = getSharedMarriage();
		if(marriage == null)
			return;
		
		synchronized(marriage)
		{
			if(marriage.getTask().open == 0 || marriage.getTask().series.state == 0)
				return;
			
			SBean.MrgSeriesTaskGroupCFGS groupCfg = GameData.getInstance().getMrgSeriesTaskGroupCFGS(marriage.getTask().series.group);
			if(groupCfg == null)
				return;
			
			SBean.MrgSeriesTaskCFGS taskCfg = GameData.getMrgSeriesTaskCFGS(groupCfg, marriage.getTask().series.id);
			if(taskCfg != null)
				func.updateTaskDrop(this, taskCfg.cond);
		}
	}
	
	private void updateMrgLoogTaskDrop(UpdateTaskDrop func)
	{
		MarriageShare marriage = getSharedMarriage();
		if(marriage == null)
			return;
		
		synchronized(marriage)
		{
			if(marriage.getTask().open == 0 || marriage.getTask().loop.state == 0)
				return;
			
			SBean.MrgLoopTaskCFGS taskCfg = GameData.getInstance().getMrgLoopTaskCFGS(marriage.getTask().loop.id);
			if(taskCfg != null)
				func.updateTaskDrop(this, taskCfg.cond);
		}
	}
	
	private void addTaskDrop(SBean.TaskCondCFGS cond)
	{
		if(cond.type != GameData.TASK_TYPE_SUBMIT_ITEM || cond.param4 == 0)
			return;
		
		this.taskDrops.put(cond.param4, cond.param5);
		gs.getMapService().syncRoleTaskDrop(this.gameMapContext.getCurMapId(), this.id, new HashMap<>(this.taskDrops));
	}
	
	private int getTotalAchievement()
    {
	    return achPoints.entrySet().stream().mapToInt(x->x.getValue()).sum();
    }

	private void delTaskDrop(SBean.TaskCondCFGS cond)
	{
		if(cond.type != GameData.TASK_TYPE_SUBMIT_ITEM || cond.param4 == 0)
			return;
		
		this.taskDrops.remove(cond.param4);
		gs.getMapService().syncRoleTaskDrop(this.gameMapContext.getCurMapId(), this.id, new HashMap<>(this.taskDrops));
	}
	
	synchronized void syncMapTaskDrop()
	{
		if(this.taskDrops.isEmpty())
			return;
		
		gs.getMapService().syncRoleTaskDrop(this.gameMapContext.getCurMapId(), this.id, new HashMap<>(this.taskDrops));
	}
	//----------------------------------------------------------------------------------------------------------------
	
	//-------------------------------------------------传家宝-----------------------------------------------------------
	public synchronized int heirloomWipe(int colorSeq)
	{
		SBean.HeirloomCFGS heirloomCFGS = GameData.getInstance().getHeirloomCFGS();
		final SBean.RemainActivityCFGS rac = GameData.getInstance().getRemainActivityCFGS(heirloomCFGS.remainIndex);
		if (colorSeq <= 0 || colorSeq > heirloomCFGS.wipePerfectIn.size())
			return GameData.PROTOCOL_OP_FAILED;
		if (rac == null || !checkRemainActivityConf(rac))
			return GameData.PROTOCOL_OP_HEIRLOOM_CONDITION_NEED;
		if (this.heirloomData.perfectDegree >= heirloomCFGS.maxPerfect)
			return GameData.PROTOCOL_OP_HEIRLOOM_PERFECT_MAX;
		if (this.heirloomData.dayWipeTimes >= heirloomCFGS.dayMaxWipeTimes)
			return GameData.PROTOCOL_OP_HEIRLOOM_WIPE_TIME_NEED;
		int oldPerfect = this.heirloomData.isOpen == 0 ? 0 : this.heirloomData.perfectDegree;
		int wipePerfect = 0;
		if (this.heirloomData.isOpen == 0)
		{
			wipePerfect = heirloomCFGS.wipePerfectIn.get(colorSeq - 1);
		}
		else
		{
			wipePerfect = heirloomCFGS.wipePerfectOut.get(colorSeq - 1);
		}
		this.heirloomData.perfectDegree += wipePerfect;
		if (this.heirloomData.perfectDegree >= heirloomCFGS.maxPerfect)
			this.heirloomData.perfectDegree = heirloomCFGS.maxPerfect;
		this.heirloomData.dayWipeTimes ++;
		if (this.heirloomData.isOpen == 1 && heirloomCFGS.properties.stream().anyMatch(item -> item.perfectDegree > oldPerfect && item.perfectDegree <= this.heirloomData.perfectDegree))
		{
			this.roleProperties.onUpdatePerfectDegree(this.heirloomData.perfectDegree);
			gs.getMapService().syncRoleUpdatePerfectDegree(this.id, this.gameMapContext.getCurMapId(), this.heirloomData.perfectDegree);
		}
		return wipePerfect;
	}
	
	public synchronized int heirloomTakeOut()
	{
		if (this.heirloomData.isOpen != 0)
			return GameData.PROTOCOL_OP_HEIRLOOM_IS_OPEN;
		if (this.heirloomData.perfectDegree < GameData.getInstance().getHeirloomCFGS().takeoutPerfect)
			return GameData.PROTOCOL_OP_HEIRLOOM_PERFECT_NEED;
		this.heirloomData.isOpen = 1;
		this.heirloomData.display = 1;
		this.roleProperties.onUpdatePerfectDegree(this.heirloomData.perfectDegree);
		gs.getMapService().syncRoleUpdateHeirloomDisplay(this.id, this.gameMapContext.getCurMapId(), this.heirloomData.display);
		gs.getMapService().syncRoleUpdatePerfectDegree(this.id, this.gameMapContext.getCurMapId(), this.heirloomData.perfectDegree);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int heirloomDisplay(int display)
	{
		if (this.heirloomData.isOpen != 1)
			return GameData.PROTOCOL_OP_FAILED;
		this.heirloomData.display = (byte) display;
		gs.getMapService().syncRoleUpdateHeirloomDisplay(this.id, this.gameMapContext.getCurMapId(), this.heirloomData.display);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public int setSectQQGroup(String qqgroup)
	{
		return gs.getSectManager().setQQGroup(this, qqgroup);
	}
	
	public SBean.GambleShopInfo syncFeatGambleShopInfo()
	{
		if (this.BWType == GameData.BWTYPE_NONE)
			return null;
		int shoptype = 0;
		if (this.BWType == GameData.BWTYPE_WHITE)
			shoptype = GameData.GAMBLE_SHOP_TYPE_JUSTICE;
		if (this.BWType == GameData.BWTYPE_BLACK)
			shoptype = GameData.GAMBLE_SHOP_TYPE_EVIL;
		return this.syncGambleShopInfo(shoptype);
	}

	public SBean.GambleShopInfo userRefreshFeatGambleShop(int times)
	{
		if (this.BWType == 0)
			return null;
		int shoptype = 0;
		if (this.BWType == GameData.BWTYPE_WHITE)
			shoptype = GameData.GAMBLE_SHOP_TYPE_JUSTICE;
		if (this.BWType == GameData.BWTYPE_BLACK)
			shoptype = GameData.GAMBLE_SHOP_TYPE_EVIL;
		return this.userRefreshGambleShop(shoptype, times);
	}

	public List<SBean.DummyGoods> buyFeatGambleShopGoogs(int seq)
	{
		if (this.BWType == 0)
			return null;
		int shoptype = 0;
		if (this.BWType == GameData.BWTYPE_WHITE)
			shoptype = GameData.GAMBLE_SHOP_TYPE_JUSTICE;
		if (this.BWType == GameData.BWTYPE_BLACK)
			shoptype = GameData.GAMBLE_SHOP_TYPE_EVIL;
		return this.buyGambleShopGoods(shoptype, seq);
	}
	//----------------------------------------------------------------------------------------------------------------
	public synchronized void updateSpeedUpLvl(int speedUpLvl)
	{
		this.speedUpLvl = speedUpLvl;
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.speedup_level(speedUpLvl));
	}
	//----------------------------------------------------------------------------------------------------------------
	
	//-----------------------------------------------------结婚预约------------------------------------------------------
	public synchronized void addMarriageBespeak(int line, int bespeakIndex)
	{
		SBean.MarriageBaseCFGS cfg = GameData.getInstance().getMarriageBaseCFGS();
		SBean.MarriageBespeakTimeCFGS bespeakcfg = GameData.getInstance().getMarriageBespeakCFGS(bespeakIndex);
		SBean.WorldMapCFGS mapcfg = GameData.getInstance().getWorldMapCFGS(cfg.mapId);
		if (mapcfg == null || line <= 0 || (mapcfg.worldNum != 0 && line > mapcfg.worldNum))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_marriage_bespeak_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		MarriageShare marriage = this.getSharedMarriage();
		if (marriage == null || bespeakcfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_marriage_bespeak_res(GameData.PROTOCOL_OP_MARRIAGE_NO_MARRIAGE));
			return;
		}	
		if (!gs.getLoginManager().getMarriageBespeak().testCanBespeak(marriage.getId(), line, bespeakIndex))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_marriage_bespeak_res(GameData.PROTOCOL_OP_MARRIAGE_BESPEAK_INVALID));
			return;
		}
		if (!GameData.getInstance().testTimeCanBespeak(bespeakIndex))
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_marriage_bespeak_res(GameData.PROTOCOL_OP_MARRIAGE_TIME_IS_TOO_LATE));
			return;
		}
		boolean isman = this.id == marriage.getManId();
		gs.getLoginManager().getRoleOverview(this.getMarriagePartnerId(), partner -> 
		{
			if (partner == null)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.add_marriage_bespeak_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}	
			gs.getLoginManager().getMarriageBespeak().addMarriageBespeak(new SBean.DBMarriageBespeak(line, bespeakIndex, marriage.getId(), marriage.getManId(), marriage.getLadyId(), isman ? this.name : partner.name, isman ? partner.name : this.name, GameTime.getDay()), new MarriageBespeak.AddMarriageBespeakCallback()
			{
				@Override
				public void onCallback(int msgId)
				{
					if (msgId > 0)
					{

						TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MARRIAGE_BESPEAK);
						tlogEvent.setArg(bespeakIndex);
						Role.this.delGameItem(bespeakcfg.costId, bespeakcfg.costNum, tlogEvent.getGameItemRecords());
						gs.getTLogger().logRoleEventFlow(Role.this, tlogEvent);
						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.add_marriage_bespeak_res(GameData.PROTOCOL_OP_SUCCESS));
						Role partnerRole = gs.getLoginManager().getOnGameRole(partner.id);
						if (partnerRole != null)
							gs.getRPCManager().sendStrPacket(partnerRole.netsid, new SBean.role_marriage_bespeak_time(bespeakIndex));
					}
					else
					{
						gs.getRPCManager().sendStrPacket(Role.this.netsid, new SBean.add_marriage_bespeak_res(GameData.PROTOCOL_OP_FAILED));
					}
				}
			});
		});
	}
		
	public List<SBean.DBMarriageBespeak> syncMarriageBespeak()
	{
		return gs.getLoginManager().getMarriageBespeak().syncMarriageBespeak();
	}
	
	public synchronized int quickBuyBaseDummyGoods(int baseId, int num)
	{
		SBean.BaseDummyItemCFGS baseCFGS = GameData.getInstance().getBaseCFG(baseId);
		if (baseCFGS == null || baseCFGS.quickBuyCostItem == 0)
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.containsEnoughGameItem(baseCFGS.quickBuyCostItem, baseCFGS.quickBuyCostNum * num))
			return GameData.PROTOCOL_OP_FAILED;

		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_BASE_DUMMY_GOODS);
		tlogEvent.setArg(baseId, num);
		this.delGameItem(baseCFGS.quickBuyCostItem, baseCFGS.quickBuyCostNum * num, tlogEvent.getGameItemRecords());
		this.syncAddGameItem(GameData.getInstance().toGameItem(baseId, baseCFGS.quickBuyGetNum * num), tlogEvent);

		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public void pushHistoryBroadcast(SBean.DBSectHistory historyDetial)
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sect_history_broadcast(historyDetial));
	}
	
	public synchronized RpcRes<SBean.MapRewards> activityLastQuickFinish(int mapId, int seq)
	{
		SBean.ActivityMapCFGS mapCFGS = GameData.getInstance().getActivityMapCFGS(mapId);
		if (mapCFGS == null)
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_FAILED);
		SBean.ActivityLastCFGS lastCFGS = GameData.getInstance().getActivityLastCFGS(mapCFGS.groupId);
		if (lastCFGS == null)
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_FAILED);
		if (seq != this.activityLast.dayBuyTimes.getOrDefault(mapCFGS.groupId, 0) + 1)
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_ACTIVITY_LAST_SEQ_ERROR);
		if (this.activityLast.lastTimes.getOrDefault(mapCFGS.groupId, 0) <= 0)
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_ACTIVITY_LAST_TIMES_NEED);
		if (!this.activityMapGroupLogs.containsKey(mapCFGS.groupId))
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_ACTIVITY_LAST_MAP_CONDITION_NEED);
		SBean.DBActivityMapGroupLog log = this.activityMapGroupLogs.get(mapCFGS.groupId);
		if (!log.records.containsKey(mapId) || (mapCFGS.groupId != GameData.ACTIVITY_MAP_TYPE_EXP && mapCFGS.groupId != GameData.ACTIVITY_MAP_TYPE_COIN && log.records.getOrDefault(mapId, 0) < 10000))
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_ACTIVITY_LAST_MAP_CONDITION_NEED);
		int cost = GameData.getTimesCost(lastCFGS.cost, seq);
		if (!this.canUseDiamond(cost, false))
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_ACTIVITY_LAST_ITEM_NEED);
		SBean.MapRewards reward = getSweepMapReward(mapCFGS, log.records.getOrDefault(mapId, 0), lastCFGS.arg1);
		if (reward == null)
			return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_FAILED);
		this.activityLast.dayBuyTimes.merge(mapCFGS.groupId, 1, (ov, nv) -> ov + nv);
		this.activityLast.lastTimes.merge(mapCFGS.groupId, 0, (ov, nv) -> ov - 1 <= 0 ? null : ov - 1);
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ACTIVITY_LAST_QUICK_FINISH);
		tlogEvent.setArg(mapCFGS.groupId, seq);
		this.useDiamond(cost, false, tlogEvent.getGameItemRecords());
		this.syncAddExp(reward.exp, GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
		this.syncAddCoin(reward.coin, false, tlogEvent);
		this.syncAddGameItems(GameData.getInstance().toGameItems(reward.cardRewards), tlogEvent);
		this.syncAddGameItems(GameData.getInstance().toGameItems(reward.normalRewards), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return new RpcRes<SBean.MapRewards>(GameData.PROTOCOL_OP_SUCCESS, reward);
	}
	
	private SBean.MapRewards getSweepMapReward(SBean.ActivityMapCFGS cfg, int lastRecord, int arg1)
	{
		int minexp = Integer.MAX_VALUE;
		int exp = 0;
		Map<Integer, Integer> drops = new TreeMap<Integer, Integer>();
		Map<Integer, Integer> cardDrop = new TreeMap<Integer, Integer>();

		if (cfg.groupId == 2)
		{
			int monstercount = 0;
			SBean.MapClusterCFGS map = GameData.getInstance().getMapClusterCFGS(cfg.id);
			for (int areaid : map.spawnAreas)
			{
				SBean.SpawnAreaCFGS area = GameData.getInstance().getSpawnArea(areaid);
				if (area == null)
					continue;
				for (int pointid : area.spawnPoint)
				{
					SBean.SpawnPointCFGS point = GameData.getInstance().getSpawnPoint(pointid);
					if (point == null)
						continue;
					SBean.MonsterCFGS monsterCFG = GameData.getInstance().getMonsterCFGS(point.monsterID);
					SBean.MapEntity e = cfg.allMonsters.get(point.monsterID);
					if (monsterCFG == null || e == null)
						continue;
					for (int monsterNum : point.spawnNum)
					{
						int countNum = monsterNum <= lastRecord - monstercount ? monsterNum : lastRecord - monstercount;
						SBean.DropRatio dropRatio = GameData.getMonsterDoubleDropRatio(cfg.id, e.id, null);
						exp += (int) (e.exp * countNum * dropRatio.exp);
						for (int i = 0; i < countNum; ++i)
						{
							drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, dropRatio.fixedDrop, dropRatio.randomDrop, null, drops);
							for (SBean.PercentDropCFGS percentDrop : monsterCFG.percentDrop.values())
								drops = GameData.getMergedDrops(0, percentDrop.randomDropId, percentDrop.randomDropTimes, dropRatio.fixedDrop, dropRatio.randomDrop, null, drops);
						}
						monstercount += countNum;
						if (monstercount >= lastRecord)
							break;
					}
					if (monstercount >= lastRecord)
						break;
				}
				if (monstercount >= lastRecord)
					break;
			}
		}
		else
		{
			for (SBean.MapEntity e : cfg.allMonsters.values())
			{
				SBean.DropRatio dropRatio = GameData.getMonsterDoubleDropRatio(cfg.id, e.id, null);
				if (minexp > e.exp)
					minexp = e.exp;
				exp += (int) (e.exp * e.count * dropRatio.exp);
				for (int i = 0; i < e.count; ++i)
					drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, dropRatio.fixedDrop, dropRatio.randomDrop, null, drops);
			}
			for (SBean.MapEntity e : cfg.allTraps.values())
			{
				exp += e.exp * e.count;
				for (int i = 0; i < e.count; ++i)
					drops = GameData.getMergedDrops(e.fixedDropTblId, e.randomDropTblIds.get(this.classType - 1), e.randomDropCount, 1, 1, null, drops);
			}
			if (cfg.groupId == GameData.ACTIVITY_MAP_TYPE_EXP)
				exp = (int) (minexp * lastRecord * (arg1 / 10000.0));
		}
		// 通关奖励
		exp += (int) (cfg.rewardExp);
		drops = GameData.getMergedDrops(cfg.fixedDropID, 0, 0, 1, 1, null, drops);
		Integer coinCount = drops.remove(GameData.COMMON_ITEM_ID_COIN);
		if (coinCount == null)
		{
			coinCount = 0;
		}
		
		if (cfg.groupId == GameData.ACTIVITY_MAP_TYPE_COIN)
		{
			coinCount = (int) (coinCount * (arg1 / 10000.0));
		}

		// 翻牌奖励
		List<SBean.DropItemCFGS> cardDropList = GameData.getInstance().getNoDuplicateDrops(cfg.turnPlateDropID, GameData.getInstance().getCommonCFG().map.palteCount);
		if (cardDropList != null)
		{
			SBean.DummyGoods dropItem = GameData.getInstance().getNextDrop(cardDropList);
			if (dropItem != null)
				cardDrop.merge(dropItem.id, dropItem.count, (ov, nv) -> ov + nv);
		}
		return new SBean.MapRewards(exp, coinCount, GameData.toDummGoods(drops), GameData.toDummGoods(cardDrop));
	}

	public Set<Integer> SyncDailyVit()
	{
		return new HashSet<>(this.dailyVit.reward);
	}

	//------------------------------------------------------------------------------------
	void syncSteleInfo()
	{
		gs.getSteleManager().syncSteleInfo(this);
	}
	
	synchronized SBean.DBRoleStele tryRefreshStele(boolean clear)
	{
		if(this.stele.index != 0)
		{
			if(clear)
			{
				this.stele.index = 0;
				this.stele.allFinish = 0;
			}
		}
		
		return this.stele.kdClone();
	}
	
	synchronized void dayRefreshStele()
	{
		this.stele.index = 0;
		this.stele.allFinish = 0;
		this.stele.card = 0;
	}
	
	synchronized boolean canJoinStele()
	{
		return this.level >= GameData.getInstance().getSteleCFGS().base.lvlReq && this.stele.index == 0;
	}
	
	synchronized int joinSteleSuccess()
	{
		this.stele.index = 1;
		this.stele.allFinish = 0;
		this.stele.receiveTime = GameTime.getTime();
		return this.stele.receiveTime; 
	}
	
	int joinStele()
	{
        int result = gs.getSteleManager().roleJoinStele(this);
        if (result>0)
        {
            gs.getTLogger().logSteleActivityFlow(this, TLog.STELE_JOIN_EVENT);
        }
		return result;
	}
	
	void syncSteleRank()
	{
		gs.getSteleManager().syncSteleRank(this);
	}
	
	synchronized void mineSteleSuccess(int steleType, int mineID)
	{
		if(this.stele.index <= 0 || this.stele.allFinish == 1)
			return;
		
		SBean.SteleMineralTypeCFGS typeCfg = GameData.getInstance().getSteleMineralTypeCFGS(steleType);
		if(typeCfg == null)
			return;
		
		SBean.SteleMineralCFGS mCfg = GameData.getSteleMineralCFGS(typeCfg, this.stele.index);
		if(mCfg == null || mCfg.mineralID != mineID)
			return;
		
		if(this.stele.index < typeCfg.minerals.size())
		{
			this.stele.index++;
		}
		else if(this.stele.index == typeCfg.minerals.size())
		{
			this.stele.allFinish = (byte)1;
		}
		
		if(this.stele.joinReward == 0)
		{
			final List<SBean.GameItem> att = GameData.getInstance().toGameItems(GameData.getInstance().getSteleCFGS().joinRewards);
			List<Integer> addinfo = new ArrayList<>();
			addinfo.add(0);
			int sendTime = GameTime.getDayTime(GameData.getInstance().getSteleCFGS().base.startTime + GameData.getInstance().getSteleCFGS().base.lastTime);
			mailbox.addDelaySysMail(MailBox.SysMailType.SteleReward, sendTime, MailBox.STELE_REWARD_MAIL_MAX_RESERVE_TIME, "", att, addinfo);
			gs.getLogger().debug("send role " + this.id + " stele join delay mail reward at " + GameTime.getTimeStampStr(sendTime));
			this.stele.joinReward = 1;
		}
		
		this.stele.receiveTime = GameTime.getTime();
		this.logTaskScheduleData(GameData.SCHEDULE_TYPE_STELE);
	}
	
	synchronized int tryMineStele(int steleType, final List<Integer> remainTimes, int mineID)
	{
		if(this.stele.index <= 0 || this.stele.index > remainTimes.size())
			return GameData.PROTOCOL_OP_STELE_NOT_JOIN;
		
		if(this.stele.allFinish == 1)
			return GameData.PROTOCOL_OP_STELE_ALL_FINISH;
		
		SBean.SteleMineralTypeCFGS typeCfg = GameData.getInstance().getSteleMineralTypeCFGS(steleType);
		if(typeCfg == null || remainTimes.isEmpty())
			return GameData.PROTOCOL_OP_STELE_NOT_OPEN;
		
		if(remainTimes.get(this.stele.index - 1) <= 0)
			return GameData.PROTOCOL_OP_STELE_NO_TIMES;

		SBean.SteleMineralCFGS mCfg = GameData.getSteleMineralCFGS(typeCfg, this.stele.index);
		if(mCfg == null || mCfg.mineralID != mineID)
			return GameData.PROTOCOL_OP_STELE_NO_FIT;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	synchronized int addSteleCards(int addCards, int addType)
	{
		if(this.stele.index <= 0 || this.stele.card >= GameData.getInstance().getSteleCFGS().base.maxCards)
			return -1;
		
		this.stele.card += addCards;
		if(this.stele.card > GameData.getInstance().getSteleCFGS().base.maxCards)
			this.stele.card = GameData.getInstance().getSteleCFGS().base.maxCards;
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_stele_card(this.stele.card));
		return this.stele.card;
	}
	
	public boolean teleportStele(int steleType, int index)
	{
		if(steleType <= 0 || index <= 0)
			return false;
		
		SBean.MapLocation mapLocation = null;
		synchronized(this)
		{
			if (!this.gameMapContext.isInWorldMap() || this.mulRolesLock > 0 || this.isMulRolesMember())
				return false;
			
			int itemID = GameData.getInstance().getCommonCFG().activity.transItemID;
			boolean freeTrans = GameData.getInstance().getVipCFGS(this.getUseableVipLvl()).freeTransfrom == 1;
			if (!freeTrans && !this.containsEnoughGameItem(itemID, 1))
				return false;
			
			SBean.SteleMineralTypeCFGS typeCfg = GameData.getInstance().getSteleMineralTypeCFGS(steleType);
			if(typeCfg == null)
				return false;
			
			SBean.SteleMineralCFGS mCfg = GameData.getSteleMineralCFGS(typeCfg, index);
			if(mCfg == null)
				return false;
			
			mapLocation = new SBean.MapLocation(mCfg.mapLocation.mapID, GameData.createRandomLocation(200, (float)Math.PI / 2.f, mCfg.mapLocation.location.position, mCfg.mapLocation.location.rotation));
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TELEPORT_STELE);
			tlogEvent.setArg(itemID, steleType, index);
			if (!freeTrans)
				this.delGameItem(itemID, 1, tlogEvent.getGameItemRecords());
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
			if(this.isMulRolesEmpty())
			{
				this.gameMapContext.changeWorld(mapLocation, this.getPriorityLine(mapLocation.mapID));
				this.gameMapContext.roleChangeMap();
				return true;
			}
		}
		
		this.mulRolesChangeMap(mapLocation);
		return true;
	}
	//------------------------------------------------------------------------------------
	public synchronized int checkCanEnterJusticeMap()
	{
		SBean.JusticeMapCFGS cfgs = GameData.getInstance().getJusticeMapCFGS();
		if (cfgs == null)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.MapLocation curNpc = GameData.getInstance().getJusticeNpcPoint(gs.getJusticeManager().getCurIndex());
		if (curNpc == null)
			return GameData.PROTOCOL_OP_JUSTICE_NOT_IN_TIME;
//		if (this.gameMapContext.getCurMapId() != curNpc.mapID || !GameData.testNearByPosition(this.gameMapContext.getCurMapPosition(), curNpc.location.position, cfgs.chatDistance))
//			return GameData.PROTOCOL_OP_JUSTICE_MEMBER_FAR_FROM_NPC;
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	//------------------------------------------------------------------------------------
	class DemonHoleInfo
	{
		SBean.RoleDemonHoleLog demonHole;
		int curDemonHoleFloor;				
		int curDemonHoleGrade;				
		int lastDemonHoleAddExpTime;
		
		int expAddInterval = -1;
		float expAddPercent;
		
		DemonHoleInfo(SBean.RoleDemonHoleLog demonHole)
		{
			this.demonHole = demonHole;
			this.curDemonHoleFloor = 0;
			this.curDemonHoleGrade = 0;
			this.lastDemonHoleAddExpTime = 0;
		}
		
		SBean.RoleDemonHoleLog toDB()
		{
			return this.demonHole.kdClone();
		}
		
		void enterDemonHole(SBean.DemonHoleMapCFGS mapCfg)
		{
			this.expAddInterval = mapCfg.addExpInterval;
			this.expAddPercent = mapCfg.addExpPercent;
		}
		
		void leaveDemonHole()
		{
			this.expAddInterval = -1;
			this.expAddPercent = 0;
		}
		
		void tryAddExp(int timeTick)
		{
			int baseExp = GameData.getInstance().getDemonHoleLevelExp(Role.this.level);
		}
		
		void dayRefresh()
		{
			this.demonHole.dayEnterTimes = 0;
		}
	}
	
	private void dayRefreshDemonHole()
	{
		this.demonHoleInfo.dayRefresh();
	}
	
	synchronized void syncDemonHole()
	{
		if(this.level < GameData.getInstance().getDemonHoleBaseCFGS().lvlReq)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_sync_res(GameData.PROTOCOL_OP_DEMON_HOLE_LEVELREQ, this.demonHoleInfo.demonHole.dayEnterTimes));
			return;
		}
		
		gs.getFightService().syncRoleDemonHoleImpl(this.id, (curFloor, grade) ->
		{
			synchronized(this)
			{
				if(grade > 0)
					this.demonHoleInfo.curDemonHoleGrade = grade;
				else
					this.demonHoleInfo.demonHole.addExp = 0;
					
				this.demonHoleInfo.curDemonHoleFloor = curFloor;
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_sync_res(curFloor, this.demonHoleInfo.demonHole.dayEnterTimes));
			}
		});
	}
	
	synchronized void joinDemonHole()
	{
		if(!this.gameMapContext.isInWorldMap())
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_join_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		
		int error = testCanJoinDemonHole();
		if(error <= 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_join_res(error));
			return;
		}
		
		gs.getFightService().roleJoinDemonHoleReqImpl(this.getRoleOverviewWithoutLock(), grade ->
		{
			synchronized(this)
			{
				if(grade > 0)
					this.demonHoleInfo.curDemonHoleGrade = grade;
				
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_join_res(grade > 0 ? GameData.PROTOCOL_OP_SUCCESS : grade));
			}
		});
	}
	
	private int testDemonHoleBase()
	{
		if(this.isInMulRolesActivity() || this.isMulRolesState())
			return GameData.PROTOCOL_OP_FAILED;
		
		if(!GameData.getInstance().checkDemonHoleInOpenTime(GameTime.getTime()))
			return GameData.PROTOCOL_OP_DEMON_HOLE_NOT_IN_OPENTIME;
		
		if(this.level < GameData.getInstance().getDemonHoleBaseCFGS().lvlReq)
			return GameData.PROTOCOL_OP_DEMON_HOLE_LEVELREQ;
		
		if(this.transformLevel < GameData.getInstance().getDemonHoleBaseCFGS().transformLvlReq)
			return GameData.PROTOCOL_OP_DEMON_HOLE_TLEVELREQ;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private int testCanJoinDemonHole()
	{
		int ok = testDemonHoleBase();
		if(ok <= 0)
			return ok;
		
//		if(this.curDemonHoleGrade == 0 && this.demonHole.dayEnterTimes >= GameData.getInstance().getDemonHoleBaseCFGS().dayEnterTimes)
//			return GameData.PROTOCOL_OP_DEMON_HOLE_NO_TIMES;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	synchronized void changeDemonHoleFloor(int toFloor)
	{
		int error = testCanChangeDemonHoleFloor(toFloor);
		if(error <= 0)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_changefloor_res(error));
			return;
		}

		MapCopyContext context = this.gameMapContext.getMapCopyContext();
		if(context == null || context.getMapType() != GameData.MAP_TYPE_MAPCOPY_DEMON_HOLE)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_changefloor_res(GameData.PROTOCOL_OP_FAILED));
			return;
		}
		
		SBean.DemonHoleMapCFGS mapCfg = GameData.getInstance().getDemonHoleMapCFGSByFloor(this.demonHoleInfo.curDemonHoleGrade, toFloor);
		if(mapCfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_changefloor_res(GameData.PROTOCOL_OP_DEMON_HOLE_OUT_FLOOR));
			return;
		}
		
		if(toFloor > this.demonHoleInfo.curDemonHoleFloor)
		{
			if(!this.containsEnoughGameItem(GameData.getInstance().getDemonHoleBaseCFGS().enterCostItem, mapCfg.enterCostCnt))
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_changefloor_res(GameData.PROTOCOL_OP_FAILED));
				return;
			}
		}
		final SBean.Counter lockItems = toFloor <= this.demonHoleInfo.curDemonHoleFloor ? null : this.lockBagItem(GameData.getInstance().getDemonHoleBaseCFGS().enterCostItem, mapCfg.enterCostCnt);
		gs.getFightService().roleChangeDemonFloorReqImpl(this.getRoleOverview(), toFloor, ok ->
		{
			synchronized(this)
			{
				if(lockItems != null)
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UP_DEMON_FLOOR);
					this.delLockedBagItem(GameData.getInstance().getDemonHoleBaseCFGS().enterCostItem, lockItems, ok <= 0 , tlogEvent.getGameItemRecords());
					if(ok > 0)
						gs.getTLogger().logRoleEventFlow(this, tlogEvent);
				}
				
				if(ok > 0)
				{
					context.endMapCopy();
					gs.getFightService().roleEnterDemonHoleFloor(this.getRoleOverviewWithoutLock(), toFloor);
				}
			}
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_changefloor_res(ok));
		});
	}
	
	private int testCanChangeDemonHoleFloor(int toFloor)
	{
		int ok = testDemonHoleBase();
		if(ok <= 0)
			return ok;
		
		if(this.demonHoleInfo.curDemonHoleGrade <= 0)
			return GameData.PROTOCOL_OP_DEMON_HOLE_NOT_JOIN;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	synchronized void queryDemonHoleBattle()
	{
		if(this.gameMapContext.getCurMapContext().getMapType() != GameData.MAP_TYPE_MAPCOPY_DEMON_HOLE)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_battle_res(GameData.emptyList(), GameData.emptyList(), GameData.PROTOCOL_OP_FAILED));
			return;
		}
		
		gs.getFightService().roleDemonHoleBattleReqImpl(this.id, (curFloor, total) -> 
		{
			synchronized(this)
			{
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.demonhole_battle_res(curFloor, total, this.demonHoleInfo.demonHole.addExp));
			}
		});
	}
	
	private void tryAddDemonHoleExp(int timeTick)
	{
		if(this.demonHoleInfo.expAddInterval < 0 || this.state == ROLE_STATE_STANDBY)
			this.demonHoleInfo.lastDemonHoleAddExpTime = 0;
		
		if(this.demonHoleInfo.lastDemonHoleAddExpTime == 0)
			this.demonHoleInfo.lastDemonHoleAddExpTime = timeTick;
		
		if(timeTick - this.demonHoleInfo.lastDemonHoleAddExpTime > this.demonHoleInfo.expAddInterval)
		{
			if(this.demonHoleInfo.expAddPercent > 0)
			{
				int baseExp = GameData.getInstance().getDemonHoleLevelExp(this.level);
				int addExp = (int) this.syncAddExp((int)(baseExp * this.demonHoleInfo.expAddPercent), GameData.OFFLINE_EXP_DISTRIBUTE_TYPE_OTHER, 0);
				this.demonHoleInfo.demonHole.addExp += addExp;
			}
			
			this.demonHoleInfo.lastDemonHoleAddExpTime = timeTick;
		}
	}
	
	private boolean onEnterDemonHole(int mapID, int floor)
	{
		SBean.DemonHoleMapCFGS mapCfg = GameData.getInstance().getDemonHoleMapCFGS(mapID);
		if(mapCfg == null)
			return false;
		
		this.demonHoleInfo.enterDemonHole(mapCfg);
		
		if(this.demonHoleInfo.curDemonHoleFloor == 0)
		{
			this.demonHoleInfo.demonHole.dayEnterTimes++;
			this.demonHoleInfo.demonHole.lastJoinTime = GameTime.getTime();
		}
		
		boolean firstEnter = false; 
		this.demonHoleInfo.curDemonHoleFloor = floor;
		if(!this.demonHoleInfo.demonHole.enterFloors.contains(floor))
		{
			firstEnter = true;
			this.demonHoleInfo.demonHole.enterFloors.add(floor);
			if(!mapCfg.rewards.isEmpty())
			{
				List<SBean.GameItem> gis = GameData.getInstance().toGameItems(mapCfg.rewards);
				if(this.canAddGameItems(mapCfg.rewards))
				{
					TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_ENTER_DEMONHOLE_FLOOR);
					this.syncAddGameItems(gis, tlogEvent);
					tlogEvent.setArg(mapID, floor);
					gs.getTLogger().logRoleEventFlow(this, tlogEvent);
				}
				else
				{
					this.addDropsToMailBox(mapID, gis);		//TODO mail type
				}
			}
		}
		
		return firstEnter;
	}
	
	public void addEmergencyKill(int size, int monsterID)
	{
		MapContext curcontext=this.gameMapContext.getCurMapContext();
		if (curcontext instanceof EmergencyMapCopyContext)
		{
			EmergencyMapCopyContext emc = EmergencyMapCopyContext.class.cast(curcontext);
			SBean.EmergencyCFGS cfgs = GameData.getInstance().getEmergencyCFGS();
			SBean.MonsterCFGS monsterCFGS = GameData.getInstance().getMonsterCFGS(monsterID);
			if (monsterCFGS == null)
				return;
			int prestige = GameData.getInstance().getEmergencyBasePrestige(emc.activityId, monsterCFGS.bossType - GameData.MONSTER_BOSSTYPE_EMERGENCY_NORMAL);
			if (size > 1)
				prestige = prestige / size * (cfgs.prestigeTeamRatio / 10000);
			if (prestige > 0)
			{
				gs.getEmergencyManager().tryUpdateRank(getRoleOverviewWithoutLock(), prestige);
				gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sync_prestige_num(gs.getEmergencyManager().getRolePrestige(this.id)));
				this.logTaskScheduleData(GameData.SCHEDULE_TYPE_EMERGENCY);
			}
		}
	}

	public void syncEmergencyRank()
	{
		gs.getEmergencyManager().syncEmergencyRank(this);
	}

	public synchronized SBean.DBLucklyStar syncLucklyStarInfo()
	{
		return this.lucklyStar.kdClone();
	}

	public int sendLucklyStarToRole(int roleId)
	{
		Role tar = gs.getLoginManager().getOnGameRole(roleId);
		if (tar == null)
			return GameData.PROTOCOL_OP_LUCKLYSTAR_TAR_OFFLINE;

		SBean.LucklyStarCFGS cfgs = GameData.getInstance().getLucklyStarCFGS();
		boolean sameClassType = this.classType == tar.classType;
		List<SBean.DummyGoods> rewardClone = new ArrayList<>();
		synchronized(this)
		{
			if (this.level < cfgs.levelNeed)
				return GameData.PROTOCOL_OP_LUCKLYSTAR_LEVEL_NEED;
			
			if (this.lucklyStar.lastGiftTimes <= 0)
				return GameData.PROTOCOL_OP_LUCKLYSTAR_NO_TIME_LEFT;
			
			List<SBean.DummyGoods> reward = GameData.getInstance().getLucklyStarLevelReward(this.level);
			if (reward.isEmpty())
				return GameData.PROTOCOL_OP_FAILED;
			
			if(sameClassType)
			{
				for(SBean.DummyGoods good : reward)
					rewardClone.add(new SBean.DummyGoods(good.id, good.count * cfgs.sameProReward));
			}
			else
			{
				rewardClone = reward;
			}
			
			if (!this.canAddGameItems(rewardClone))
				return GameData.PROTOCOL_OP_LUCKLYSTAR_BAG_FULL;
		}
		
		int recvResult = tar.recvLucklyStar(this.name);
		if (recvResult <= 0)
			return recvResult;
		
		synchronized (this)
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_SEND_LUCKLY_STAR);
			this.lucklyStar.lastGiftTimes --;
			this.syncAddGameItems(GameData.getInstance().toGameItems(rewardClone), tlogEvent);
			tlogEvent.setArg(this.level, tar.classType);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		return sameClassType ?  cfgs.sameProReward : GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int recvLucklyStar(String roleName)
	{
		SBean.LucklyStarCFGS cfgs = GameData.getInstance().getLucklyStarCFGS();
		if (this.level < cfgs.levelNeed)
			return GameData.PROTOCOL_OP_LUCKLYSTAR_TAR_LEVEL_NEED;
		if (this.lucklyStar.dayRecvTimes > 0)
			return GameData.PROTOCOL_OP_LUCKLYSTAR_TAR_ALREADY_RECV;
		this.lucklyStar.dayRecvTimes++;
		this.lucklyStar.lastGiftTimes = 1;
		this.lucklyStar.sendTime = GameData.getDayByRefreshTimeOffset(GameTime.getTime());
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.recv_lucnlystar_by_role(roleName));
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	//-----------------------------------------------------约战NPC----------------------------------------------------
	private boolean testFightNpc()
	{
		if (!this.gameMapContext.isInWorldMap())
			return false;
		
		if(this.fightNpc.curIndex == -1 || this.fightNpc.coolTime > GameTime.getTime())
			return false;
		
		SBean.FightNpcCFGS fnCfg = GameData.getInstance().getFightNpcCFGS(this.fightNpc.group, this.fightNpc.curIndex);
		if(fnCfg == null || !checkCanFightNpc(fnCfg.trigConds))
			return false;
		
		return true;
	}
	
	public synchronized int startFightNpcMapCopy()
	{
		if (!this.gameMapContext.isInWorldMap() || this.isInMulRolesActivity() || this.isMulRolesState())
			return GameData.PROTOCOL_OP_FAILED;
		
		if(this.fightNpc.state == 1)
			return GameData.PROTOCOL_OP_FIGHT_NPC_ALREADY_WIN;
		
		if(this.fightNpc.curIndex == -1)
			return GameData.PROTOCOL_OP_FIGHT_NPC_ALL_FINISH;
		
		if(this.fightNpc.coolTime > GameTime.getTime())
			return GameData.PROTOCOL_OP_FIGHT_NPC_COOL_TIME;
		
		SBean.FightNpcCFGS fnCfg = GameData.getInstance().getFightNpcCFGS(this.fightNpc.group, this.fightNpc.curIndex);
		if(fnCfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		if(!checkCanFightNpc(fnCfg.openConds))
			return GameData.PROTOCOL_OP_FIGHT_NPC_COND_REQ;
		
		int instanceID = gs.getMapService().createFightNpcMapCopy(fnCfg.mapID);
		if(instanceID <= 0)
			return GameData.PROTOCOL_OP_FAILED;
		
		if(!enterFightNpcMapCopy(fnCfg.mapID, instanceID))
			return GameData.PROTOCOL_OP_FAILED;
		
		gs.getMapService().syncMapCopyReady(fnCfg.mapID, instanceID);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private boolean checkCanFightNpc(List<SBean.FightNpcCondCFGS> conds)
	{
		for(SBean.FightNpcCondCFGS c: conds)
		{
			switch (c.type)
			{
			case GameData.FIGHT_NPC_COND_TYPE_LEVEL:
				return this.level >= c.param;
			case GameData.FIGHT_NPC_COND_TYPE_POWER:
				return this.roleProperties.getRoleFightPower() >= c.param;
			case GameData.FIGHT_NPC_COND_TYPE_SPIRIT_LVL_SUM:
				return this.getSpiritLevelSum() >= c.param;
			case GameData.FIGHT_NPC_COND_TYPE_WEAPON_STAR_SUM:
				return this.getWeaponStarSum() >= c.param;
			default:
				break;
			}
		}
		return true;
	}
	
	public synchronized int takeFightNpcReward()
	{
		if(this.fightNpc.state != 1)
			return GameData.PROTOCOL_OP_FIGHT_NPC_NOT_WIN;
		
		SBean.FightNpcCFGS curCfg = GameData.getInstance().getFightNpcCFGS(this.fightNpc.group, this.fightNpc.curIndex);
		if(curCfg == null)
			return GameData.PROTOCOL_OP_FAILED;

		Collection<SBean.DummyGoods> reward = GameData.getClassTypeRewards(curCfg.rewards, this.classType);
		if(!reward.isEmpty())
		{
			if(!this.canAddGameItems(reward))
				return GameData.PROTOCOL_OP_FIGHT_NPC_BAG_FULL;
			
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_FIGHT_NPC_REWARD);
			this.syncAddGameItems(GameData.getInstance().toGameItems(reward), tlogEvent);
			tlogEvent.setArg(this.fightNpc.group, this.fightNpc.curIndex);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		
		this.fightNpc.state = 0;
		SBean.FightNpcCFGS nextCfg = GameData.getInstance().getFightNpcCFGS(this.fightNpc.group, this.fightNpc.curIndex + 1);
		if(nextCfg == null)
			this.fightNpc.curIndex = -1;
		else
			this.fightNpc.curIndex++;
		
		this.fightNpc.coolTime = GameTime.getTime() + curCfg.coolTime;
		return this.fightNpc.coolTime; 
	}
	
	private SBean.DBFightNpc initFightNpc()
	{
		return new SBean.DBFightNpc(GameData.getInstance().randFightNpcGroup(), 1, (byte)0, 0, 0);
	}

	public int syncPacketReward()
	{
		return this.packetReward + 1;
	}

	public int takePacketReward(int index)
	{
		if (index <= this.packetReward)
			return GameData.PROTOCOL_OP_FAILED;
		SBean.CommonPacketRewardCFGS prCfgs = GameData.getInstance().getCommonCFG().packetReward;
		if (index <= 0 || index > prCfgs.levelNeeds.size())
			return GameData.PROTOCOL_OP_FAILED;
		if (this.level < prCfgs.levelNeeds.get(index - 1))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.canAddGameItem(prCfgs.rewards.get(index - 1).id, prCfgs.rewards.get(index - 1).count))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_PACKET_REWARD);
		tlogEvent.setArg(index);
		this.syncAddGameItem(GameData.getInstance().toGameItem(prCfgs.rewards.get(index - 1).id, prCfgs.rewards.get(index - 1).count), tlogEvent);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public void syncEmergencyInfos()
	{
		gs.getEmergencyManager().syncEmergencyInfos(this.netsid);
	}

	public void syncAllFlags()
	{
		gs.getFlagManager().syncAllFlags(this.netsid);
	}

	public synchronized int buyWizardPetTime(int petId)
	{
		SBean.WizardPetCFGS wpCfgs = GameData.getInstance().getWizardPetCFGSs(petId);
		if (wpCfgs == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (this.offlineWizard.wizardEndTimes.getOrDefault(petId, 0) == -1)
			return GameData.PROTOCOL_OP_FAILED;
		if (!wpCfgs.channels.isEmpty() && !wpCfgs.channels.contains(this.getChannel()))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.containsEnoughGameItem(wpCfgs.buyCostId, wpCfgs.buyCostNum))
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_BUY_WIZARD_PET_TIME);
		tlogEvent.setArg(petId);
		this.delGameItem(wpCfgs.buyCostId, wpCfgs.buyCostNum, tlogEvent.getGameItemRecords());
		int now = GameTime.getTime();
		this.offlineWizard.wizardEndTimes.merge(petId, now + wpCfgs.buyTime, (ov, nv) -> ov > now ? ov + wpCfgs.buyTime : nv);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	public synchronized int setCurWizardPet(int petId)
	{
		int now = GameTime.getTime();
		if (this.offlineWizard.curWizard == petId)
			return GameData.PROTOCOL_OP_FAILED;
		int endTime = this.offlineWizard.wizardEndTimes.getOrDefault(petId, 0);
		if (endTime >= 0 && endTime < now)
			return GameData.PROTOCOL_OP_FAILED;
		this.offlineWizard.curWizard = petId;
		gs.getMapService().syncRoleWizardPet(this.gameMapContext.getCurMapId(), this.id, petId);
		return GameData.PROTOCOL_OP_SUCCESS;
	}

	private void tryRefreshWizardPet()
	{
		int now = GameTime.getTime();
		int curWizardEndTime = this.offlineWizard.wizardEndTimes.getOrDefault(this.offlineWizard.curWizard, 0);
		if (curWizardEndTime >= 0 && curWizardEndTime < now)
		{
			this.offlineWizard.curWizard = 1;
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.role_cur_wizard_pet(1));
			gs.getMapService().syncRoleWizardPet(this.gameMapContext.getCurMapId(), this.id, 1);
		}
	}

	public synchronized Set<Integer> getUnlockHeads()
	{
		return new HashSet<>(this.itemUnlockHead);
	}

	public void divoceUpdateRole()
	{
		marriageData.marriageShareId = 0;
		marriageData.divorceTime = GameTime.getTime();
		marriageData.partnerName = "";
	}
	
	public synchronized int npcTransfrom(int transfromId)
	{
		SBean.NpcTransfromFuncCFGS cfg = GameData.getInstance().getNpcTransfromFuncCFGS(transfromId);
		if (cfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		if (cfg.cost.id > 0 && !this.containsEnoughGameItem(cfg.cost.id, cfg.cost.count))
			return GameData.PROTOCOL_OP_FAILED;
		if (!testNearByAnyNpc(cfg.npcs))
			return GameData.PROTOCOL_OP_FAILED;
		if (!GameData.testCanNpcTransfrom(cfg, this))
			return GameData.PROTOCOL_OP_FAILED;
		if(!this.gameMapContext.isInWorldMap())
			return GameData.PROTOCOL_OP_FAILED;
		if(this.transformToRolePosition(new SBean.MapLocation(cfg.mapId, new SBean.Location(cfg.position, new SBean.Vector3F(1.0f, 0.0f, 0.0f))), cfg.line) < 0)
			return GameData.PROTOCOL_OP_FAILED;
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_NPC_TRANSFROM);
		tlogEvent.setArg(transfromId);
		if (cfg.cost.id > 0)
			this.delGameItem(cfg.cost.id, cfg.cost.count, tlogEvent.getGameItemRecords());
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private boolean testNearByAnyNpc(Collection<Integer> npcs)
	{
		boolean nearNpc = false;
		for (int npc : npcs)
		{
			if (this.testNearByNPC(npc))
			{
				nearNpc = true;
				break;
			}
		}
		return nearNpc;
	}
	
	//--------------------------------------------------宠物、神兵评价------------------------------------------------------------
	private void dayRefreshSocialComment()
	{
		for(SBean.DBRoleSocialComment sc: this.roleSocialComment.values())
		{
			sc.daySends = 0;
			sc.dayLikes = 0;
			sc.dayDislikes = 0;
		}
	}
	
	public synchronized void sendSocialComment(int sessionid, int serverID, String serverName, int themeType, int themeID, String comment)
	{
		int errorCode = canSendSocialComment(serverID, serverName, themeType, themeID, comment);
		if(errorCode <= 0)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_send_res(errorCode));
			return;
		}
		
		gs.getExchangeService().roleSendSocialComment(serverID, serverName, this.id, this.name, themeType, themeID, comment, commentID ->
		{
			synchronized(this)
			{
				if(commentID > 0)
				{
					this.roleSocialComment.merge(themeType, new SBean.DBRoleSocialComment(1, 0, 0), (ov, nv) -> 
					{
						ov.daySends++;
						return ov;
					});
				}
			}
			
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_send_res(commentID));
		});
	}
	
	private int canSendSocialComment(int serverID, String serverName, int themeType, int themeID, String comment)
	{
		switch (themeType)
		{
		case GameData.SOCIAL_COMMENT_THEME_PET:
			if(!this.activePets.containsKey(themeID))
				return GameData.PROTOCOL_OP_SOCIAL_COMMENT_NO_THEME;
			break;
		case GameData.SOCIAL_COMMENT_THEME_WEAPON:
			if(!this.weapons.containsKey(themeID))
				return GameData.PROTOCOL_OP_SOCIAL_COMMENT_NO_THEME;
			break;
		default:
			return GameData.PROTOCOL_OP_SOCIAL_COMMENT_TYPE_INVALID;
		}
		
		SBean.DBRoleSocialComment log = this.roleSocialComment.get(themeType);
		if(log != null && log.daySends >= GameData.getInstance().getCommonCFG().socialComment.daySendTimes)
			return GameData.PROTOCOL_OP_SOCIAL_COMMENT_NO_TIMES;
		
		if(this.level < GameData.getInstance().getCommonCFG().socialComment.lvlReq)
			return GameData.PROTOCOL_OP_SOCIAL_COMMENT_LVL_REQ;
		
		int zoneId = GameData.getRawZoneIdFromGSId(serverID);
		if(!gs.getConfig().zones.contains(zoneId))
			return GameData.PROTOCOL_OP_SOCIAL_COMMENT_SERVERID_INVALID;
		
		comment = comment.replaceAll("\n", "");
		comment = comment.replaceAll("\r", "");
		if(!GameData.getInstance().checkInputStrValid(comment, GameData.getInstance().getCommonCFG().socialComment.maxWords, true))
			return GameData.PROTOCOL_OP_SOCIAL_COMMENT_INVALID;
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized void syncPageSocialComment(int sessionid, int themeType, int themeID, int tag, int pageNo, int len)
	{
		if(!checkSocialThemeValid(themeType, themeID))
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_pageinfo_res(GameData.emptyList()));
			return;
		}
		
		switch (tag)
		{
			case GameData.SOCIAL_COMMENT_TAG_LAST:
			case GameData.SOCIAL_COMMENT_TAG_LIKE:
			case GameData.SOCIAL_COMMENT_TAG_DISLIKE:
				break;
			default:
			{
				gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_pageinfo_res(GameData.emptyList()));
				return;
			}
		}
		
		gs.getExchangeService().syncPageComment(themeType, themeID, tag, pageNo, len, lst -> 
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_pageinfo_res(lst));
		});
	}
	
	private boolean checkSocialThemeValid(int themeType, int themeID)
	{
		switch (themeType)
		{
		case GameData.SOCIAL_COMMENT_THEME_PET:
			return GameData.getInstance().getPetCFG(themeID) != null;
		case GameData.SOCIAL_COMMENT_THEME_WEAPON:
			return GameData.getInstance().getWeaponCFGS(themeID) != null;
		default:
			return false;
		}
	}
	
	private int checkLikeOrDislike(int serverID, int themeType, int themeID, int commentID)
	{
		int zoneId = GameData.getRawZoneIdFromGSId(serverID);
		if(!gs.getConfig().zones.contains(zoneId))
			return GameData.PROTOCOL_OP_SOCIAL_COMMENT_SERVERID_INVALID;
		
		if(!checkSocialThemeValid(themeType, themeID))
			return GameData.PROTOCOL_OP_SOCIAL_COMMENT_NO_THEME;
		
		return commentID > 0 ? GameData.PROTOCOL_OP_SUCCESS : GameData.PROTOCOL_OP_FAILED;
	}
	
	public synchronized void likeSocialComment(int sessionid, int serverID, String serverName, int themeType, int themeID, int commentID)
	{
		int errorCode = checkLikeOrDislike(serverID, themeType, themeID, commentID);
		if(errorCode <= 0)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_like_res(errorCode));
			return;
		}
		
		SBean.DBRoleSocialComment log = this.roleSocialComment.getOrDefault(themeType, new SBean.DBRoleSocialComment(0, 0, 0));
		if(log.dayLikes >= GameData.getInstance().getCommonCFG().socialComment.dayLikeTimes)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_like_res(GameData.PROTOCOL_OP_SOCIAL_COMMENT_NO_TIMES));
			return;
		}
		
		gs.getExchangeService().roleLikeComment(serverID, serverName, this.id, this.name, themeType, themeID, commentID, ok ->
		{
			synchronized(this)
			{
				if(ok > 0)
				{
					log.dayLikes++;
					this.roleSocialComment.put(themeType, log);
				}
			}
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_like_res(ok));
		});
	}
	
	public synchronized void dislikeSocialComment(int sessionid, int serverID, String serverName, int themeType, int themeID, int commentID)
	{
		int errorCode = checkLikeOrDislike(serverID, themeType, themeID, commentID);
		if(errorCode <= 0)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_dislike_res(errorCode));
			return;
		}
		
		SBean.DBRoleSocialComment log = this.roleSocialComment.getOrDefault(themeType, new SBean.DBRoleSocialComment(0, 0, 0));
		if(log.dayDislikes >= GameData.getInstance().getCommonCFG().socialComment.dayDislikeTimes)
		{
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_dislike_res(GameData.PROTOCOL_OP_SOCIAL_COMMENT_NO_TIMES));
			return;
		}
		
		gs.getExchangeService().roleDislikeComment(serverID, serverName, this.id, this.name, themeType, themeID, commentID, ok -> 
		{
			synchronized(this)
			{
				if(ok > 0)
				{
					log.dayDislikes++;
					this.roleSocialComment.put(themeType, log);
				}
			}
			gs.getRPCManager().sendStrPacket(sessionid, new SBean.socialmsg_dislike_res(ok));
		});
	}
	
	//--------------------------------------------------传世装备打造------------------------------------------------------------
	class LegendMake
	{
		SBean.DBEquip curMakeEquip;
		List<Integer> curLegends;
		
		int lastMakeTime;
		int makeCount;
		
		LegendMake(SBean.DBEquip curMakeEquip, List<Integer> curLegends)
		{
			this.curMakeEquip = curMakeEquip;
			this.curLegends = curLegends;
			
			this.lastMakeTime = 0;
			this.makeCount = 0;
		}
		
		SBean.DBLegendMake toDB()
		{
			return new SBean.DBLegendMake(curMakeEquip.kdClone(), new ArrayList<>(curLegends), 0);
		}
		
		boolean canMake()
		{
			return curMakeEquip.guid.equals("") && curLegends.isEmpty();
		}
		
		List<Integer> make(SBean.DBEquip equip, int partID)
		{
			equip.id = equip.id > 0 ? equip.id : -equip.id;
			this.curMakeEquip = equip;
			this.curLegends = GameData.getInstance().createEquipLegend(partID);
			updateMakeTime(equip.id);
			return curLegends;
		}
		
		void updateMakeTime(int equipID)
		{
			int now = GameTime.getTime();
			if(now - lastMakeTime <= GameData.getInstance().getLegendMakeCFGS().rollNoticeInterval)
				makeCount++;
			else
				makeCount = 1;

			lastMakeTime = now;
			gs.getLogger().debug("role " + Role.this.name + " make legend equip " + equipID + " make count " + makeCount);
			gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_LEGEND_MAKE, Role.this.name + "|" + makeCount + "|" + equipID);
		}
		
		SBean.DBEquip save()
		{
			if(curMakeEquip.guid.equals("") || curLegends.isEmpty())
				return null;
			
			SBean.DBEquip equip = curMakeEquip.kdClone();
			equip.legends = new ArrayList<>(curLegends);
			equip.durability = GameData.getInstance().getCommonCFG().equip.initDurability;
			clear();
			return equip;
		}
		
		SBean.DBEquip quit()
		{
			if(curMakeEquip.guid.equals(""))
				return null;
			
			SBean.DBEquip equip = curMakeEquip.kdClone();
			clear();
			return equip;
		}
		
		void clear()
		{
			curMakeEquip.guid = "";
			curMakeEquip.id = 0;
			curMakeEquip.addValues.clear();
			curMakeEquip.durability = 0;
			curMakeEquip.refine.clear();
			curMakeEquip.legends.clear();
			
			curLegends.clear();
		}
	}
	
	public synchronized void syncLegendMake()
	{
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.legend_sync_res(this.legendMake.curMakeEquip.kdClone(), new ArrayList<>(this.legendMake.curLegends)));
	}
	
	public synchronized List<Integer> doLegendMake(int equipID, String guid, int costItemID)
	{
		if(!this.legendMake.canMake())
			return null;
		
		CellItem ci = this.getBagItem(equipID);
		if (ci == null || !ci.contains(guid))
			return null;
		
		CellItem.Wearable wearable = ci.getWearable();
		if(wearable == null || wearable.getRank() < GameData.EQUIP_RANK_PURPLE)
			return null;
		
		SBean.DBEquip equip = wearable.getEquipData(guid);
		if(equip == null)
			return null;
		
		Set<Integer> costItems = GameData.getInstance().getLegendMakeCostItems(wearable.getRank(), wearable.getWearPartID(), wearable.getLvlReq());
		if(costItems == null || !costItems.contains(costItemID > 0 ? costItemID : -costItemID))
			return null;
		
		if(!this.containsEnoughGameItem(costItemID, 1))
			return null;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MAKE_LEGEND_COST);
		tlogEvent.setArg(equipID, costItemID, 1);
		this.delGameItem(costItemID, 1, tlogEvent.getGameItemRecords());
		this.delEquip(equipID, guid, tlogEvent.getGameItemRecords());
		return new ArrayList<>(this.legendMake.make(equip, wearable.getWearPartID()));
	}
	
	public synchronized int legendMakeSave()
	{
		SBean.DBEquip equip = this.legendMake.save();
		if(equip == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.GameItem gi = GameData.toGameItem(equip);
		if(this.canAddGameItem(equip.id, 1))
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MAKE_LEGEND_SAVE);
			tlogEvent.setArg(equip.id);
			this.syncAddGameItem(gi, tlogEvent);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		else
		{
			List<SBean.GameItem> gis = new ArrayList<>();
			gis.add(gi);
			mailbox.addSysMail(SysMailType.LegendMake, MailBox.TEMP_MAIL_MAX_RESERVE_TIME, "", gis, new ArrayList<>());
		}
		
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized int legendMakeQuit()
	{
		SBean.DBEquip equip = this.legendMake.quit();
		if(equip == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.GameItem gi = GameData.toGameItem(equip);
		if(this.canAddGameItem(equip.id, 1))
		{
			TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_MAKE_LEGEND_QUIT);
			tlogEvent.setArg(equip.id);
			this.syncAddGameItem(gi, tlogEvent);
			gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		}
		else
		{
			List<SBean.GameItem> gis = new ArrayList<>();
			gis.add(gi);
			mailbox.addSysMail(SysMailType.LegendMake, MailBox.TEMP_MAIL_MAX_RESERVE_TIME, "", gis, new ArrayList<>());
		}
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	//--------------------------------------------------特权卡------------------------------------------------------------
	public synchronized void syncSpecialCard(int cardType)
	{
		SBean.PayCFGS payCfg = GameData.getInstance().getChannelPayCFG();
		if(payCfg == null)
		{
			gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sync_special_card_res(0, null));
			return;
		}
		
		gs.getRPCManager().sendStrPacket(this.netsid, new SBean.sync_special_card_res(payCfg.id, GameData.getSpecailCardPayInfo(payCfg, cardType)));
	}
	
	public synchronized int takeSpecialCardReward(int cardType)
	{
		SBean.DBSpecialCardData card = getSpecialCardData(cardType);
		if(card == null || GameTime.getTime() > card.cardEndTime || card.reward != 0)
			return GameData.PROTOCOL_OP_FAILED;
		
		SBean.SpecialCardCFGS cardCfg = GameData.getInstance().getSpecialCardCFGS(cardType);
		if(cardCfg == null)
			return GameData.PROTOCOL_OP_FAILED;
		
		if(!this.canAddGameItems(cardCfg.dayReward))
			return GameData.PROTOCOL_OP_FAILED;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_TAKE_SPECIAL_CARD_REWARD);
		tlogEvent.setArg(cardType);
		this.syncAddGameItems(GameData.getInstance().toGameItems(cardCfg.dayReward), tlogEvent);
		card.reward = 1;
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	private void tryUpdateSpecialCard(int timeTick)
	{
		boolean update = tryUpdateSpecialCardImpl(timeTick);
		if(update)
		{
			this.roleProperties.onUpdateSpecialCardAttrs(getSpecialCardAttrs(this.specialCards));
			gs.getMapService().updateRoleSpecialCardAttr(this.gameMapContext.getCurMapId(), this.id, getSpecialCardAttrs(this.specialCards));
		}
	}
	
	private boolean tryUpdateSpecialCardImpl(int timeTick)
	{
		boolean update = false;
		int now = GameTime.getTime();
		for(int cardType = 1; cardType <= specialCards.size(); cardType++)
		{
			byte effect = (byte) (specialCards.get(cardType - 1).cardEndTime > now ? 1 : 0);
			if(effect != this.specialCardsState.getOrDefault(cardType, (byte)0))
				update = true;
			
			this.specialCardsState.put(cardType, effect);
		}
		return update;
	}
	
	public static Map<Integer, Integer> getSpecialCardAttrs(List<SBean.DBSpecialCardData> specialCards)
	{
		int now = GameTime.getTime();
		Map<Integer, Integer> attrs = new HashMap<>();
		for(int cardType = 1; cardType <= specialCards.size(); cardType++)
		{
			if(now > specialCards.get(cardType - 1).cardEndTime)
				continue;
			
			SBean.SpecialCardCFGS cfg = GameData.getInstance().getSpecialCardCFGS(cardType);
			if(cfg == null)
				continue;
			
			for(SBean.AttrCFGS a: cfg.attrs)
			{
				int value = attrs.getOrDefault(a.id, 0);
				if(a.value > value)
					attrs.put(a.id, a.value);
			}
		}
		return attrs;
	}
	
	private int getSpecialCardOfflineTimeAddtion()
	{
		int addtion = 0;
		int now = GameTime.getTime();
		for(int cardType = 1; cardType <= this.specialCards.size(); cardType++)
		{
			if(now > this.specialCards.get(cardType - 1).cardEndTime)
				continue;
			
			SBean.SpecialCardCFGS cfg = GameData.getInstance().getSpecialCardCFGS(cardType);
			if(cfg == null)
				continue;
			
			addtion = cfg.offlineAddtion > addtion ? cfg.offlineAddtion : addtion;
		}
		return addtion;
	}
	
	private float getSpecialCardTakeVitAddtion()
	{
		float addtion = 0;
		int now = GameTime.getTime();
		for(int cardType = 1; cardType <= this.specialCards.size(); cardType++)
		{
			if(now > this.specialCards.get(cardType - 1).cardEndTime)
				continue;
			
			SBean.SpecialCardCFGS cfg = GameData.getInstance().getSpecialCardCFGS(cardType);
			if(cfg == null)
				continue;
			
			addtion = cfg.takeVitAddtion > addtion ? cfg.takeVitAddtion : addtion;
		}
		return addtion;
	}
	
	public int logShareGift()
	{
		Role.this.logDailyTask(GameData.DAILY_TASK_ID_SHARE_GIFT, 1);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	public synchronized RpcRes<SBean.DummyGoods> joinNpcPray(int prayId, int dropId)
	{
		SBean.NpcPrayCFGS prayCfg = GameData.getInstance().getNpcPrayCFGS(prayId);
		SBean.PrayDropCFGS dropCfg = GameData.getInstance().getPrayDropCFGS(dropId);
		if(prayCfg == null || dropCfg == null || !prayCfg.prayDrops.contains(dropId))
			return new RpcRes<SBean.DummyGoods>(GameData.PROTOCOL_OP_FAILED);

		int now = GameTime.getTime();
		if(now < prayCfg.startTime || now > prayCfg.endTime)
			return new RpcRes<SBean.DummyGoods>(GameData.PROTOCOL_OP_FAILED);

		if(this.bag.getCanUseSize() < GameData.getInstance().getCommonCFG().bagSizeNeed.prayNeeds || this.dayNpcPrayTimes.getOrDefault(prayId, 0) >= prayCfg.dayJoinTime)
			return new RpcRes<SBean.DummyGoods>(GameData.PROTOCOL_OP_FAILED);
		
		if(!this.containsEnoughGameItems(prayCfg.costs))
			return new RpcRes<SBean.DummyGoods>(GameData.PROTOCOL_OP_FAILED);
		
		Map<Integer, Integer> drops = GameData.getInstance().getMergedRandomDrop(dropCfg.randomDropId, 1, 1);
		
		if(drops.size() != 1 || !this.canAddGameItems(drops))
			return new RpcRes<SBean.DummyGoods>(GameData.PROTOCOL_OP_FAILED);
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_JOIN_NPC_PRAY);
		tlogEvent.setArg(prayId, dropId);
		this.delGameItems(prayCfg.costs, tlogEvent.getGameItemRecords());
		SBean.GameItem gi = GameData.getInstance().toGameItems(drops).get(0);
		this.syncAddGameItem(gi, tlogEvent);
		this.dayNpcPrayTimes.merge(prayId, 1, (ov, nv) -> ov + nv);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return new RpcRes<SBean.DummyGoods>(new SBean.DummyGoods(gi.id, gi.count));
	}
	
	//-----------------------------------------------------------红名惩罚(红名天雷)
	private void updateRedNamePunish()
	{
		int punishVal = GameData.getInstance().getCommonCFG().pk.punishReq;
		if(this.pkValue < punishVal)
		{
			this.redNamePunish.nextPunishTime = 0;
			this.redNamePunish.punishEffectTime = 0;
		}
		else if(this.redNamePunish.nextPunishTime == 0)
		{
			int interval = GameData.getInstance().getCommonCFG().pk.punishInterval;
			int now = GameTime.getTime();
			this.redNamePunish.nextPunishTime = now + interval;
			this.redNamePunish.punishEffectTime = now + GameRandom.getRandInt(0, interval);
			gs.getLogger().debug("red name punish effect time " + GameTime.getTimeStampStr(this.redNamePunish.punishEffectTime) + " next calc time " + GameTime.getTimeStampStr(this.redNamePunish.nextPunishTime));
		}
	}
	
	private void checkRedNamePunish(int timeTick)
	{
		if(!this.gameMapContext.isInWorldMap() || this.gameMapContext.getCurMapContext().getHp() == 0 || !this.gameMapContext.isMapRoleReady())
			return;
		
		tryEffectRedNamPunish(timeTick);
		tryReCalcRedNamePunish(timeTick);
	}
	
	private void tryEffectRedNamPunish(int timeTick)
	{
		if(this.redNamePunish.punishEffectTime == 0 || timeTick < this.redNamePunish.punishEffectTime)
			return;
		
		this.pkValue -= GameData.getInstance().getCommonCFG().pk.punishReduceValue;
		if(this.pkValue <= 0)
		{
			this.pkValue = 0;
			this.pkValueTime = 0;
		}
		
		gs.getLoginManager().roleAddRollNotice(GameData.ROLLNOTICE_TYPE_REDNAME_PUNISH, this.name);
		gs.getLogger().debug("roll notice role " + this.name + " execute red name punish, current pkValue " + this.pkValue);
		gs.getMapService().roleRedNamePunish(this.gameMapContext.getCurMapId(), this.id);
		gs.getMapService().syncRoleUpdatePKInfo(this.id, this.gameMapContext.getCurMapId(), this.gameMapContext.getCurMapContext().getPKMode(), this.pkValue);
		this.redNamePunish.punishEffectTime = 0;
		this.updateRedNamePunish();
	}
	
	private void tryReCalcRedNamePunish(int timeTick)
	{
		if(this.redNamePunish.nextPunishTime == 0 || timeTick < this.redNamePunish.nextPunishTime)
			return;
		
		this.redNamePunish.nextPunishTime = 0;
		this.updateRedNamePunish();
	}
	
	public synchronized int unlockHeadIcon(int headId)
	{
		SBean.FriendHeadCFGS friendHeadCFGS = GameData.getInstance().getFriendHeadCFGS(headId);
		if (friendHeadCFGS == null || friendHeadCFGS.openType != GameData.FRIEND_TYPE_USE_ITEM || this.itemUnlockHead.contains(headId))
			return GameData.PROTOCOL_OP_FAILED;
		if (!this.containsEnoughGameItem(friendHeadCFGS.arg1, friendHeadCFGS.arg2))
			return GameData.PROTOCOL_OP_FAILED;
		
		TLogger.TLogEvent tlogEvent = gs.getTLogger().createNewEvent(TLog.AT_UNLOCK_ROLE_HEAD);
		tlogEvent.setArg(headId);
		this.delGameItem(friendHeadCFGS.arg1, friendHeadCFGS.arg2, tlogEvent.getGameItemRecords());
		this.itemUnlockHead.add(headId);
		gs.getTLogger().logRoleEventFlow(this, tlogEvent);
		return GameData.PROTOCOL_OP_SUCCESS;
	}
	
	final GameServer gs;
	Lock lock = new ReentrantLock();
	boolean closed;

	int netsid;
	int loginnetsid;
	int randTick;
	int randQuarterTick;

	SBean.UserLoginInfo loginInfo;
	TLogger.DCRole dcRole;

	int disconnectTime;
	int lastSaveTime;

	int state;

	Ban ban;
	RoleShare share;

	MailBox mailbox;
	int lastSyncRollNoticeTime;
	final int id;
	// 注册登录信息
	SBean.DBRegister register;
	String name;
	int createTime;
	int lastLoginTime;
	int lastLogoutTime;
	int lastOnlineTime;//只用于盯周期写db时
	int totalOnlineTime;

	short headIcon;
	byte gender;
	byte face;
	byte hair;

	byte classType;
	byte transformLevel;
	byte BWType; // 正1、邪2

	GameMapContext gameMapContext;

	int lastDayRefresh;
	int loginDays;

	int level;
	long exp;
	int lastLevelUpTime;
	long expVolume;
	

	int lastUseHpTime;
	int lastSpawnReviveTime;
	int lastDiamondReviveTime;		//上一次原地复活时间
	int diamondReviveTimes;			//原地复活累计次数
	int hpPool;
	int lastUseHpPoolTime;
	int vit;
	int vitRevertTime;

	int pkValue;
	int pkValueTime;
	int historyHighestPower;

	int totalPayPoint;
	Map<Integer, Integer> payLevelTimes;
	Map<Integer, Integer> payRewardTimes;
	int diamondF;
	int diamondR;
	int coinF;
	int coinR;
	int credit;

	int diamondFUseTotal;
	int diamondRUseTotal;
	int coinFUseTotal;
	int coinRUseTotal;
	int creditUseTotal;
	
	int historyMaxGemLevel;
	int historyMaxGemNum;

	int equipEnergy;
	int gemEnergy;
	int bookInspiration;

	int dayBuyCoinTimes;
	int dayBuyVitTimes;
	int dayUseVit;
	Map<Integer, Integer> dayUseItemsTimes;

	List<SBean.DBSpecialCardData> specialCards;
	Map<Integer, Byte> specialCardsState = new HashMap<>();
	SBean.DBTempVIP tempVIP;
	Set<Integer> vipRewards;
	
	ItemCellCollection bag;

	List<SBean.DBEquipPart> wearParts;
	Map<Integer, SBean.DBWearEquip> wearEquips;
	Map<Integer, SBean.DBSuite> suites;
	Map<Integer, Integer> logWearEquips;
	SBean.DBSealData sealData; 				//龙印信息
	LegendMake legendMake;					//传世装备打造

	Map<Integer, SBean.DBSkill> skills;				//包含绝技
	List<Integer> curSkills;
	int curUniqueSkill;								//当前的绝技
	Set<Integer> uniqueSkills = new HashSet<>();	//不存盘	
	
	
	Map<Integer, SBean.DBSpirit> spirits;
	Set<Integer> curSpirits;

	Map<Integer, SBean.DBBuff> buffs;

	SBean.DBWeaponTask weaponTask;
	Map<Integer, SBean.DBWeapon> weapons;
	int curWeapon;
	WeaponUSkill weaponUSkill;
	
//	List<SBean.DBPetData> allPets;
	Map<Integer, SBean.DBPet> activePets;
	Set<Integer> worldMapPets;
	Set<Integer> privateMapPets;
	Set<Integer> sectMapPets;
	Set<Integer> activityMapPets;
	PetSpiritInfo petSpirit;
	
	Set<Integer> petAchieves;			//随从成就不存盘
	
	SBean.DBMainTask mainTask;
	SBean.DBAlterState alterState;

	Map<Integer, SBean.DBNormalMapCopyLog> normalMapCopyLogs;
	Map<Integer, SBean.DBActivityMapGroupLog> activityMapGroupLogs;
	SBean.DBRoleTowerDefence towerDefence;

	SBean.DBCheckInLog checkinLog;

	//activity相关logs
	Map<Integer, SBean.DBRoleMallLog> mallBuyLogs;
	Map<Integer, SBean.DBRoleConsumeGiftLog> consumeGiftLogs;
	Map<Integer, SBean.DBRoleUpgradeGiftLog> upgradeGiftLogs;
	Map<Integer, SBean.DBRoleInvestmentFundLog> investmentFundLogs;
	Map<Integer, SBean.DBRoleGrowthFundLog> growthFundLogs;
	Map<Integer, SBean.DBRoleExchangeGiftLog> exchangeGiftLogs;
	Map<Integer, SBean.DBRoleLoginGiftLog> loginGiftLogs;
	Map<Integer, SBean.DBRoleGroupBuyLog> groupBuyLogs;
	Map<Integer, SBean.DBRoleFlashSaleLog> flashSaleLogs;
	Map<Integer, SBean.DBRoleActivityChallengeGiftLog> activityChallengeGiftLogs;
	Map<Integer, SBean.DBRoleLuckyRollerLog> luckyRollerLogs;
	Map<Integer, SBean.DBRoleUpgradePurchaseLog> upgradePurchaseLogs;
	Map<Integer, SBean.DBRoleGiftPackageLog> giftPackageLogs;
	Map<Integer, SBean.DBRoleOneArmBanditLog> oneArmBanditLogs;
	
	//充值相关activity logs
	Map<Integer, SBean.DBRoleFirstPayGiftLog> firstPayGiftLogs;
	Map<Integer, SBean.DBRolePayGiftLog> payGiftLogs;
	Map<Integer, SBean.DBRoleDirectPurchaseLog> directPurchaseLogs;
	Map<Integer, SBean.DBRoleLastPayGiftLog> lastPayGiftLogs;
	Map<Integer, SBean.DBRoleDailyPayGiftLog> dailyPayGiftLogs;
	
	Map<Integer, SBean.DBShop> shops;
	Map<Integer, SBean.DBGambleShop> gambleShops;

	Map<Integer, SBean.DBDailyTask> dailyTasks;
	Map<Integer, SBean.DBChallengeTask> challengeTasks;
	Map<Integer, Integer> achPoints;
	SBean.DBFame fame;
	SBean.DBDailyOnlineGift dailyOnlineGift;
	int dailyOnlineLastRecordTime;
	SBean.DBOfflineExp offlineExp;
	Map<Integer, SBean.DBQuizGift> quizGift;
	SBean.DBLuckyWheel luckyWheel; // 幸运大转盘
	List<Integer> luckyWheelSelectPos;
	
	int daySnatchRedEnvelopes;
	int dayGetRedEnvelopesEmptyGift;

	SBean.DBRoleSectData sectData;
	
	Map<Integer, Integer> sectAuras;
	int sectAuraExpCoinRateRaise;
	int lastSectChatTime;
	int lastMRoomInviteChatTime;
	int lastSectInviteChatTime;
	int lastJusticeInviteChatTime;
	int showWebLink;

	SBean.DBRoleDiySkillData diySkillData;
	ItemCellCollection warehouse;
	SBean.DBRoleMarriageData marriageData;
	Map<Integer, Integer> exchangeTimes;
	List<SBean.DBSkillPreset> skillPreset;
	List<SBean.DBSpiritsPreset> spiritsPreset;
	SBean.DBDailyVitData dailyVit;
	Map<Integer, Integer> lifeUse;
	Map<Integer, Integer> itemGetProp;
	SBean.DBInsightData insightData;
	SBean.DBRevengeData revengeData;
	SBean.DBHeirloom heirloomData;
	SBean.DBOfflineWizard offlineWizard;
	int marriageLevel;
	SBean.DBActivityLastData activityLast; //活动补做次数
	SBean.DBRoleStele stele;
	int dayJusticeJoinTime;//正义之心参与次数
	TreeMap<Integer, Integer> levelUpTimeMap;
	
	DemonHoleInfo demonHoleInfo;
	SBean.DBLucklyStar lucklyStar;
	SBean.DBFightNpc fightNpc;
	int packetReward;
	Set<Integer> itemUnlockHead;
	Map<Integer, SBean.DBRoleSocialComment> roleSocialComment;
	
	SBean.DBRedNamePunish redNamePunish;
	Map<Integer, Integer> dayNpcPrayTimes;
	Map<Integer, Integer> dayNpcCpoyTimes;

	// 不存盘数据
	Set<Integer> teamInvites;
	Set<Integer> teamApplys;
	SBean.Team team;
	int leaderLine;
	int lastTeamChatTime;
	int lastFightChatTime;
	int lastAllServerChatTime;
	Set<Integer> roomInvites;
	SBean.MRoom room;
	Set<Integer> aroomInvites;
	SBean.ARoom arenaroom;
	SBean.FRoom froom;
	Set<Integer> froomInvites;
	int nextLeaveWrongPosTime; //下次能脱离卡死时间
	int nextTransToBossTime; //下次能传送到boss位置时间
	private int speedUpLvl;
	private EquipLegend equipLegend;
	
	int superarenaState; 		//0:没有参加  1：单人匹配 2：组队匹配
	int superarenaJoinTime; 	//开始匹配时间
	int superarenaJoinType;		//参加的会武类型
	int superarenaJoinGrade;
	
	Map<Integer, Integer> petLastUsePool; //随从最后使用血池时间
	boolean petCanUsePool;
	
	private boolean fightState;
	Map<Integer, Integer> mulHorseInvites;
	Map<Integer, Integer> mulHorseApplys;
	SBean.MulRoleInfo mulRoleInfo;
	private byte mulRolesLock;
	Map<Integer, Integer> staywithInvites;
	Map<Integer, TrigSpawnPoint> trigSpawnPoints;	//<mapID, TrigSpawnPoint>
	Map<Integer, Integer> taskDrops;

	List<SBean.MessageInfo> msgs;
	int lastPrivateChatTime;

	RoleArena arenaInfo;
	RoleFriend friend;

	SBean.DBAuctionInfo auctionInfo; //拍卖行
	HorseData horseData; //坐骑
	TreasureMap treasuremapInfo; //藏宝图
	RoleExpCoin roleExpCoin; //历练系统
	SBean.DBRoleFashion fashionEquip; 	//时装
	Map<Integer, Integer> showFashionTypes;		//显示的时装类型
	SBean.DBRoleTitle roleTitles; //称号系统

	Set<Integer> leadInfo; //指引信息
	Map<Integer, Integer> leadPlot; //强制剧情信息
	byte isTreasureGuide;	//藏宝图是否开启过引导
	
	Map<Integer, SBean.DBBranchTask> branchTask;//支线任务
	RoleClimbTower climbTowerData;//爬塔数据
	List<Integer> towerCards;
	int climbTowerFightFloor;
	SBean.DBSecretTaskData secretAreaTaskData;
	SBean.DBSectDeliver sectDeliver;
	RoleEscortCar escortCar;
	SBean.DBProduceData produce; // 生产系统
	byte isRob;
	
	RoleForceWar forceWarInfo;
	int rmactivity;				//七日留存
	int messageBoardDayCommentTimes;
	int messageBoardLastSyncTime;
	int guidestep;

	SBean.DBSchedule schedule;//日程表
	SBean.DBArmor armor;//内甲
	
	Set<Integer> sectInvites;
	SBean.ProposeData propose;
	
	SuperGM superGM = new SuperGM();
	
	SBean.DBFusionData fusionData;
	DBMaster master;
	Map<Integer, SBean.DBRolePayRankLog> payRankLogs;
	/////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////
	//最后初始化的内存任务
	RoleProperties roleProperties;

	public static void main(String[] args)
	{
	}
}
